# This file is automatically generated by the rmf-codegen project.
#
# The Python code generator is maintained by Lab Digital. If you want to
# contribute to this project then please do not edit this file directly
# but send a pull request to the Lab Digital fork of rmf-codegen at
# https://github.com/labd/rmf-codegen

import datetime
import enum
import typing

from ._abstract import _BaseType

if typing.TYPE_CHECKING:
    from . import Amount
    from .common import PaymentAction

__all__ = [
    "CancelPaymentAction",
    "CapturePaymentAction",
    "Payment",
    "RefundPaymentAction",
]


class CapturePaymentAction(_BaseType):
    """Requests to [capture](/payments-lifecycle#payment-capture) the given amount from the customer. Checkout will request the PSP to proceed with the financial process to capture the amount."""

    #: Amount to be captured. It must be less than or equal to the [authorized](/payments-lifecycle#authorization) amount.
    amount: "Amount"

    def __init__(self, *, amount: "Amount"):
        self.amount = amount

        super().__init__(action="capturePayment")

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CapturePaymentAction":
        from ._schemas.payments import CapturePaymentActionSchema

        return CapturePaymentActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.payments import CapturePaymentActionSchema

        return CapturePaymentActionSchema().dump(self)


class RefundPaymentAction(_BaseType):
    """Requests to [refund](/payments-lifecycle#refund) the given amount to the customer. Checkout will request the PSP to proceed with the financial process to refund the amount."""

    #: Amount to be refunded. It must be less than or equal to the [captured](/payments-lifecycle#payment-capture) amount.
    amount: typing.Optional["Amount"]

    def __init__(self, *, amount: typing.Optional["Amount"] = None):
        self.amount = amount

        super().__init__(action="refundPayment")

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "RefundPaymentAction":
        from ._schemas.payments import RefundPaymentActionSchema

        return RefundPaymentActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.payments import RefundPaymentActionSchema

        return RefundPaymentActionSchema().dump(self)


class CancelPaymentAction(_BaseType):
    """Requests to [cancel the authorization](/payments-lifecycle#authorization-cancellation) for a Payment. Checkout will cancel the [Payment](/../api/projects/payments#payment) and will request the PSP to proceed with the financial process to cancel the authorization.

    You cannot request to cancel the authorization for a Payment that has already been [captured](/payments-lifecycle#payment-capture).

    """

    def __init__(self):

        super().__init__(action="cancelPayment")

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CancelPaymentAction":
        from ._schemas.payments import CancelPaymentActionSchema

        return CancelPaymentActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.payments import CancelPaymentActionSchema

        return CancelPaymentActionSchema().dump(self)


class Payment(_BaseType):
    #: Action to execute for the given Payment.
    actions: typing.List["PaymentAction"]

    def __init__(self, *, actions: typing.List["PaymentAction"]):
        self.actions = actions

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "Payment":
        from ._schemas.payments import PaymentSchema

        return PaymentSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.payments import PaymentSchema

        return PaymentSchema().dump(self)
