# This file is automatically generated by the rmf-codegen project.
#
# The Python code generator is maintained by Lab Digital. If you want to
# contribute to this project then please do not edit this file directly
# but send a pull request to the Lab Digital fork of rmf-codegen at
# https://github.com/labd/rmf-codegen

import datetime
import enum
import typing

from ._abstract import _BaseType

__all__ = [
    "AdyenBadConfig",
    "AdyenInitError",
    "AdyenTimeout",
    "ApplicationDeactivated",
    "ApplicationNotFound",
    "BadInputData",
    "CartEmptiedDuringCheckout",
    "CartEmpty",
    "CartNotFound",
    "CartWithExistingPayment",
    "CheckoutCancelled",
    "CheckoutCompleted",
    "CheckoutLoaded",
    "CheckoutStarted",
    "DeprecatedFields",
    "InitTimeout",
    "InvalidToken",
    "NoPaymentMethods",
    "NoShippingMethods",
    "OrderCreated",
    "OrderCreationError",
    "ProjectIsDeactivated",
    "ResponseMessage",
    "ShippingAddressMissing",
    "UnallowedOrigin",
    "UnavailableLocale",
]


class ResponseMessage(_BaseType):
    #: The message code for the event.
    code: str
    #: A string with the following pattern `{level}:{entity}:{subtype}` where `{level}` can be `info`, `warn`, or `error`.
    #: This field allows filtering messages from a more generic to a more specific type. Messages for different events can be of the same `type`.
    type: str
    #: A human-readable description of the event.
    message: str
    #: An object containing additional data about the event.
    payload: typing.Optional[object]

    def __init__(
        self,
        *,
        code: str,
        type: str,
        message: str,
        payload: typing.Optional[object] = None
    ):
        self.code = code
        self.type = type
        self.message = message
        self.payload = payload

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ResponseMessage":
        if data["code"] == "adyen_bad_config":
            from ._schemas.responses import AdyenBadConfigSchema

            return AdyenBadConfigSchema().load(data)
        if data["code"] == "adyen_init_error":
            from ._schemas.responses import AdyenInitErrorSchema

            return AdyenInitErrorSchema().load(data)
        if data["code"] == "adyen_timeout":
            from ._schemas.responses import AdyenTimeoutSchema

            return AdyenTimeoutSchema().load(data)
        if data["code"] == "application_disabled":
            from ._schemas.responses import ApplicationDeactivatedSchema

            return ApplicationDeactivatedSchema().load(data)
        if data["code"] == "application_not_found":
            from ._schemas.responses import ApplicationNotFoundSchema

            return ApplicationNotFoundSchema().load(data)
        if data["code"] == "cart_emptied_during_checkout":
            from ._schemas.responses import CartEmptiedDuringCheckoutSchema

            return CartEmptiedDuringCheckoutSchema().load(data)
        if data["code"] == "cart_empty":
            from ._schemas.responses import CartEmptySchema

            return CartEmptySchema().load(data)
        if data["code"] == "cart_not_found":
            from ._schemas.responses import CartNotFoundSchema

            return CartNotFoundSchema().load(data)
        if data["code"] == "checkout_cancelled":
            from ._schemas.responses import CheckoutCancelledSchema

            return CheckoutCancelledSchema().load(data)
        if data["code"] == "checkout_completed":
            from ._schemas.responses import CheckoutCompletedSchema

            return CheckoutCompletedSchema().load(data)
        if data["code"] == "checkout_loaded":
            from ._schemas.responses import CheckoutLoadedSchema

            return CheckoutLoadedSchema().load(data)
        if data["code"] == "checkout_started":
            from ._schemas.responses import CheckoutStartedSchema

            return CheckoutStartedSchema().load(data)
        if data["code"] == "init_timeout":
            from ._schemas.responses import InitTimeoutSchema

            return InitTimeoutSchema().load(data)
        if data["code"] == "invalid_fields":
            from ._schemas.responses import BadInputDataSchema

            return BadInputDataSchema().load(data)
        if data["code"] == "invalid_token":
            from ._schemas.responses import InvalidTokenSchema

            return InvalidTokenSchema().load(data)
        if data["code"] == "no_payment_methods":
            from ._schemas.responses import NoPaymentMethodsSchema

            return NoPaymentMethodsSchema().load(data)
        if data["code"] == "no_shipping_methods":
            from ._schemas.responses import NoShippingMethodsSchema

            return NoShippingMethodsSchema().load(data)
        if data["code"] == "order_created":
            from ._schemas.responses import OrderCreatedSchema

            return OrderCreatedSchema().load(data)
        if data["code"] == "project_deactivated":
            from ._schemas.responses import ProjectIsDeactivatedSchema

            return ProjectIsDeactivatedSchema().load(data)
        if data["code"] == "shipping_address_missing":
            from ._schemas.responses import ShippingAddressMissingSchema

            return ShippingAddressMissingSchema().load(data)
        if data["code"] == "unallowed_origin":
            from ._schemas.responses import UnallowedOriginSchema

            return UnallowedOriginSchema().load(data)
        if data["code"] == "unavailable_locale":
            from ._schemas.responses import UnavailableLocaleSchema

            return UnavailableLocaleSchema().load(data)
        if data["code"] == "deprecated_fields":
            from ._schemas.responses import DeprecatedFieldsSchema

            return DeprecatedFieldsSchema().load(data)
        if data["code"] == "order_creation_error":
            from ._schemas.responses import OrderCreationErrorSchema

            return OrderCreationErrorSchema().load(data)
        if data["code"] == "cart_with_exisiting_payment":
            from ._schemas.responses import CartWithExistingPaymentSchema

            return CartWithExistingPaymentSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import ResponseMessageSchema

        return ResponseMessageSchema().dump(self)


class AdyenBadConfig(ResponseMessage):
    """Generated when the configuration to initialize the [Adyen payment connector](/configuring-adyen) contains at least one invalid field."""

    def __init__(
        self, *, type: str, message: str, payload: typing.Optional[object] = None
    ):

        super().__init__(
            type=type, message=message, payload=payload, code="adyen_bad_config"
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "AdyenBadConfig":
        from ._schemas.responses import AdyenBadConfigSchema

        return AdyenBadConfigSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import AdyenBadConfigSchema

        return AdyenBadConfigSchema().dump(self)


class AdyenInitError(ResponseMessage):
    """Generated when the [Adyen payment connector](/configuring-adyen) cannot be initialized."""

    def __init__(
        self, *, type: str, message: str, payload: typing.Optional[object] = None
    ):

        super().__init__(
            type=type, message=message, payload=payload, code="adyen_init_error"
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "AdyenInitError":
        from ._schemas.responses import AdyenInitErrorSchema

        return AdyenInitErrorSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import AdyenInitErrorSchema

        return AdyenInitErrorSchema().dump(self)


class AdyenTimeout(ResponseMessage):
    """Generated when a timeout error occurs while initializing the [Adyen payment connector](/configuring-adyen)."""

    def __init__(
        self, *, type: str, message: str, payload: typing.Optional[object] = None
    ):

        super().__init__(
            type=type, message=message, payload=payload, code="adyen_timeout"
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "AdyenTimeout":
        from ._schemas.responses import AdyenTimeoutSchema

        return AdyenTimeoutSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import AdyenTimeoutSchema

        return AdyenTimeoutSchema().dump(self)


class ApplicationDeactivated(ResponseMessage):
    """Generated when the requested [application](/configuring-checkout#applications) is deactivated. Activate the application in the Merchant Center to continue."""

    def __init__(
        self, *, type: str, message: str, payload: typing.Optional[object] = None
    ):

        super().__init__(
            type=type, message=message, payload=payload, code="application_disabled"
        )

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ApplicationDeactivated":
        from ._schemas.responses import ApplicationDeactivatedSchema

        return ApplicationDeactivatedSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import ApplicationDeactivatedSchema

        return ApplicationDeactivatedSchema().dump(self)


class ApplicationNotFound(ResponseMessage):
    """Generated when the requested [application](/configuring-checkout#applications) is not found. The application may have been deleted or its configuration is incorrect."""

    def __init__(
        self, *, type: str, message: str, payload: typing.Optional[object] = None
    ):

        super().__init__(
            type=type, message=message, payload=payload, code="application_not_found"
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ApplicationNotFound":
        from ._schemas.responses import ApplicationNotFoundSchema

        return ApplicationNotFoundSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import ApplicationNotFoundSchema

        return ApplicationNotFoundSchema().dump(self)


class CartEmptiedDuringCheckout(ResponseMessage):
    """Generated when the [Cart](/../api/projects/carts) was emptied during the checkout process. It is not possible to recover from this, the customer must restart the checkout process."""

    def __init__(
        self, *, type: str, message: str, payload: typing.Optional[object] = None
    ):

        super().__init__(
            type=type,
            message=message,
            payload=payload,
            code="cart_emptied_during_checkout",
        )

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartEmptiedDuringCheckout":
        from ._schemas.responses import CartEmptiedDuringCheckoutSchema

        return CartEmptiedDuringCheckoutSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import CartEmptiedDuringCheckoutSchema

        return CartEmptiedDuringCheckoutSchema().dump(self)


class CartEmpty(ResponseMessage):
    """Generated when the [Cart](/../api/projects/carts) for the current checkout is empty. The Cart must contain at least one [Line Item](/../api/carts-orders-overview#line-items)."""

    def __init__(
        self, *, type: str, message: str, payload: typing.Optional[object] = None
    ):

        super().__init__(type=type, message=message, payload=payload, code="cart_empty")

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CartEmpty":
        from ._schemas.responses import CartEmptySchema

        return CartEmptySchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import CartEmptySchema

        return CartEmptySchema().dump(self)


class CartNotFound(ResponseMessage):
    """Generated when the [Cart](/../api/projects/carts) is not found. To start the checkout process, a valid Cart with at least one [Line Item](/../api/carts-orders-overview#line-items) is required."""

    def __init__(
        self, *, type: str, message: str, payload: typing.Optional[object] = None
    ):

        super().__init__(
            type=type, message=message, payload=payload, code="cart_not_found"
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CartNotFound":
        from ._schemas.responses import CartNotFoundSchema

        return CartNotFoundSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import CartNotFoundSchema

        return CartNotFoundSchema().dump(self)


class CheckoutCancelled(ResponseMessage):
    """Generated when the customer cancels the checkout process."""

    def __init__(
        self, *, type: str, message: str, payload: typing.Optional[object] = None
    ):

        super().__init__(
            type=type, message=message, payload=payload, code="checkout_cancelled"
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CheckoutCancelled":
        from ._schemas.responses import CheckoutCancelledSchema

        return CheckoutCancelledSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import CheckoutCancelledSchema

        return CheckoutCancelledSchema().dump(self)


class CheckoutCompleted(ResponseMessage):
    """Generated when the customer completes the checkout process."""

    def __init__(
        self, *, type: str, message: str, payload: typing.Optional[object] = None
    ):

        super().__init__(
            type=type, message=message, payload=payload, code="checkout_completed"
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CheckoutCompleted":
        from ._schemas.responses import CheckoutCompletedSchema

        return CheckoutCompletedSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import CheckoutCompletedSchema

        return CheckoutCompletedSchema().dump(self)


class CheckoutLoaded(ResponseMessage):
    """Generated when Checkout has been loaded successfully and is waiting for the configuration parameters passed in the `checkoutConfig` [object](/sdk)."""

    def __init__(
        self, *, type: str, message: str, payload: typing.Optional[object] = None
    ):

        super().__init__(
            type=type, message=message, payload=payload, code="checkout_loaded"
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CheckoutLoaded":
        from ._schemas.responses import CheckoutLoadedSchema

        return CheckoutLoadedSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import CheckoutLoadedSchema

        return CheckoutLoadedSchema().dump(self)


class CheckoutStarted(ResponseMessage):
    """Generated when the configuration parameters are passed successfully through the `checkoutConfig` [object](/sdk) and the checkout process starts."""

    def __init__(
        self, *, type: str, message: str, payload: typing.Optional[object] = None
    ):

        super().__init__(
            type=type, message=message, payload=payload, code="checkout_started"
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CheckoutStarted":
        from ._schemas.responses import CheckoutStartedSchema

        return CheckoutStartedSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import CheckoutStartedSchema

        return CheckoutStartedSchema().dump(self)


class InitTimeout(ResponseMessage):
    """Generated when Checkout has not received the configuration parameters passed through the `checkoutConfig` [object](/sdk) on time."""

    def __init__(
        self, *, type: str, message: str, payload: typing.Optional[object] = None
    ):

        super().__init__(
            type=type, message=message, payload=payload, code="init_timeout"
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "InitTimeout":
        from ._schemas.responses import InitTimeoutSchema

        return InitTimeoutSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import InitTimeoutSchema

        return InitTimeoutSchema().dump(self)


class BadInputData(ResponseMessage):
    """Generated when the `checkoutConfig` [object](/sdk) contains one or more invalid fields."""

    def __init__(
        self, *, type: str, message: str, payload: typing.Optional[object] = None
    ):

        super().__init__(
            type=type, message=message, payload=payload, code="invalid_fields"
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "BadInputData":
        from ._schemas.responses import BadInputDataSchema

        return BadInputDataSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import BadInputDataSchema

        return BadInputDataSchema().dump(self)


class InvalidToken(ResponseMessage):
    """Generated when the `accessToken` is invalid."""

    def __init__(
        self, *, type: str, message: str, payload: typing.Optional[object] = None
    ):

        super().__init__(
            type=type, message=message, payload=payload, code="invalid_token"
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "InvalidToken":
        from ._schemas.responses import InvalidTokenSchema

        return InvalidTokenSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import InvalidTokenSchema

        return InvalidTokenSchema().dump(self)


class NoPaymentMethods(ResponseMessage):
    """Generated when no payment method is set up for an [application](/configuring-checkout#applications). Add at least one **Payment method** to the application in the Merchant Center."""

    def __init__(
        self, *, type: str, message: str, payload: typing.Optional[object] = None
    ):

        super().__init__(
            type=type, message=message, payload=payload, code="no_payment_methods"
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "NoPaymentMethods":
        from ._schemas.responses import NoPaymentMethodsSchema

        return NoPaymentMethodsSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import NoPaymentMethodsSchema

        return NoPaymentMethodsSchema().dump(self)


class NoShippingMethods(ResponseMessage):
    """Generated when no [Shipping Method](/../api/projects/shippingMethods) is available for the shipping address of the [Cart](/../api/projects/carts). This may indicate an incomplete configuration."""

    def __init__(
        self, *, type: str, message: str, payload: typing.Optional[object] = None
    ):

        super().__init__(
            type=type, message=message, payload=payload, code="no_shipping_methods"
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "NoShippingMethods":
        from ._schemas.responses import NoShippingMethodsSchema

        return NoShippingMethodsSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import NoShippingMethodsSchema

        return NoShippingMethodsSchema().dump(self)


class OrderCreated(ResponseMessage):
    """Generated when an [Order](/../api/projects/orders) is created after a successful checkout process."""

    def __init__(
        self, *, type: str, message: str, payload: typing.Optional[object] = None
    ):

        super().__init__(
            type=type, message=message, payload=payload, code="order_created"
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "OrderCreated":
        from ._schemas.responses import OrderCreatedSchema

        return OrderCreatedSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import OrderCreatedSchema

        return OrderCreatedSchema().dump(self)


class ProjectIsDeactivated(ResponseMessage):
    """Generated when the commercetools Checkout [`projectKey`](/sdk) is deactivated and cannot be initialized. Contact support via the [Support Portal](https://commercetools.atlassian.net/servicedesk/customer/portal/30)."""

    def __init__(
        self, *, type: str, message: str, payload: typing.Optional[object] = None
    ):

        super().__init__(
            type=type, message=message, payload=payload, code="project_deactivated"
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ProjectIsDeactivated":
        from ._schemas.responses import ProjectIsDeactivatedSchema

        return ProjectIsDeactivatedSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import ProjectIsDeactivatedSchema

        return ProjectIsDeactivatedSchema().dump(self)


class ShippingAddressMissing(ResponseMessage):
    """Generated when the checkout is initialised with [`skipShipping` set to `true`](/installing-checkout#placeholder-values). You must populate the `shippingAddress` field of the Cart with at least the shipping country."""

    def __init__(
        self, *, type: str, message: str, payload: typing.Optional[object] = None
    ):

        super().__init__(
            type=type, message=message, payload=payload, code="shipping_address_missing"
        )

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ShippingAddressMissing":
        from ._schemas.responses import ShippingAddressMissingSchema

        return ShippingAddressMissingSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import ShippingAddressMissingSchema

        return ShippingAddressMissingSchema().dump(self)


class UnallowedOrigin(ResponseMessage):
    """Generated when Checkout cannot be initialized because the URL that is trying to initialize it is not in the list of the allowed URLs for the [application](/configuring-checkout#applications). Add the URL to the **Origin URLs** list in your application settings in the Merchant Center."""

    def __init__(
        self, *, type: str, message: str, payload: typing.Optional[object] = None
    ):

        super().__init__(
            type=type, message=message, payload=payload, code="unallowed_origin"
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "UnallowedOrigin":
        from ._schemas.responses import UnallowedOriginSchema

        return UnallowedOriginSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import UnallowedOriginSchema

        return UnallowedOriginSchema().dump(self)


class UnavailableLocale(ResponseMessage):
    """Generated when the provided `locale` is not [available for localization](/installing-checkout#locales). The localization falls back to English."""

    def __init__(
        self, *, type: str, message: str, payload: typing.Optional[object] = None
    ):

        super().__init__(
            type=type, message=message, payload=payload, code="unavailable_locale"
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "UnavailableLocale":
        from ._schemas.responses import UnavailableLocaleSchema

        return UnavailableLocaleSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import UnavailableLocaleSchema

        return UnavailableLocaleSchema().dump(self)


class DeprecatedFields(ResponseMessage):
    """Generated when the `checkoutConfig` [object](/sdk) contains one or more deprecated fields."""

    def __init__(
        self, *, type: str, message: str, payload: typing.Optional[object] = None
    ):

        super().__init__(
            type=type, message=message, payload=payload, code="deprecated_fields"
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "DeprecatedFields":
        from ._schemas.responses import DeprecatedFieldsSchema

        return DeprecatedFieldsSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import DeprecatedFieldsSchema

        return DeprecatedFieldsSchema().dump(self)


class OrderCreationError(ResponseMessage):
    """Generated when an [Order](/../api/projects/orders) that references an approved [Payment](/../api/projects/payments) cannot be created."""

    def __init__(
        self, *, type: str, message: str, payload: typing.Optional[object] = None
    ):

        super().__init__(
            type=type, message=message, payload=payload, code="order_creation_error"
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "OrderCreationError":
        from ._schemas.responses import OrderCreationErrorSchema

        return OrderCreationErrorSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import OrderCreationErrorSchema

        return OrderCreationErrorSchema().dump(self)


class CartWithExistingPayment(ResponseMessage):
    """Generated when trying to add a [Payment](/../api/projects/payments) to a [Cart](/../api/projects/carts) that already references an approved Payment."""

    def __init__(
        self, *, type: str, message: str, payload: typing.Optional[object] = None
    ):

        super().__init__(
            type=type,
            message=message,
            payload=payload,
            code="cart_with_exisiting_payment",
        )

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartWithExistingPayment":
        from ._schemas.responses import CartWithExistingPaymentSchema

        return CartWithExistingPaymentSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.responses import CartWithExistingPaymentSchema

        return CartWithExistingPaymentSchema().dump(self)
