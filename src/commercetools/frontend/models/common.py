# This file is automatically generated by the rmf-codegen project.
#
# The Python code generator is maintained by Lab Digital. If you want to
# contribute to this project then please do not edit this file directly
# but send a pull request to the Lab Digital fork of rmf-codegen at
# https://github.com/labd/rmf-codegen

import datetime
import enum
import typing

from ._abstract import _BaseType

__all__ = [
    "BuildMetadata",
    "BuildUpload",
    "BuildUploadResult",
    "DataSourceConfiguration",
    "DataSourceResponse",
    "DataSources",
    "Environment",
    "Error",
    "Footer",
    "Head",
    "LayoutElement",
    "LayoutElementConfiguration",
    "Main",
    "Page",
    "PageDataResponse",
    "PageFolder",
    "PagePreviewContext",
    "PagePreviewDataResponse",
    "PathConfiguration",
    "ProjectContext",
    "RedirectResponse",
    "Sections",
    "Tastic",
    "TasticConfiguration",
    "ViewData",
]


class DataSourceConfiguration(_BaseType):
    data_source_id: str
    type: str
    name: str
    configuration: typing.Any

    def __init__(
        self, *, data_source_id: str, type: str, name: str, configuration: typing.Any
    ):
        self.data_source_id = data_source_id
        self.type = type
        self.name = name
        self.configuration = configuration

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "DataSourceConfiguration":
        from ._schemas.common import DataSourceConfigurationSchema

        return DataSourceConfigurationSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import DataSourceConfigurationSchema

        return DataSourceConfigurationSchema().dump(self)


class DataSourceResponse(_BaseType):
    data_source_payload: object
    preview_payload: object

    def __init__(self, *, data_source_payload: object, preview_payload: object):
        self.data_source_payload = data_source_payload
        self.preview_payload = preview_payload

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "DataSourceResponse":
        from ._schemas.common import DataSourceResponseSchema

        return DataSourceResponseSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import DataSourceResponseSchema

        return DataSourceResponseSchema().dump(self)


class DataSources(typing.Dict[str, typing.Any]):
    pass


class Environment(enum.Enum):
    PRODUCTION = "production"
    DEVELOPMENT = "development"


class Error(_BaseType):
    ok: bool
    message: str

    def __init__(self, *, ok: bool, message: str):
        self.ok = ok
        self.message = message

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "Error":
        from ._schemas.common import ErrorSchema

        return ErrorSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import ErrorSchema

        return ErrorSchema().dump(self)


class Footer(_BaseType):
    layout_elements: typing.List["LayoutElement"]

    def __init__(self, *, layout_elements: typing.List["LayoutElement"]):
        self.layout_elements = layout_elements

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "Footer":
        from ._schemas.common import FooterSchema

        return FooterSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import FooterSchema

        return FooterSchema().dump(self)


class Head(_BaseType):
    layout_elements: typing.List["LayoutElement"]

    def __init__(self, *, layout_elements: typing.List["LayoutElement"]):
        self.layout_elements = layout_elements

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "Head":
        from ._schemas.common import HeadSchema

        return HeadSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import HeadSchema

        return HeadSchema().dump(self)


class LayoutElement(_BaseType):
    layout_element_id: str
    configuration: "LayoutElementConfiguration"
    tastics: typing.List["Tastic"]

    def __init__(
        self,
        *,
        layout_element_id: str,
        configuration: "LayoutElementConfiguration",
        tastics: typing.List["Tastic"]
    ):
        self.layout_element_id = layout_element_id
        self.configuration = configuration
        self.tastics = tastics

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "LayoutElement":
        from ._schemas.common import LayoutElementSchema

        return LayoutElementSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import LayoutElementSchema

        return LayoutElementSchema().dump(self)


class LayoutElementConfiguration(_BaseType):
    size: float
    mobile: bool
    tablet: bool
    desktop: bool

    def __init__(self, *, size: float, mobile: bool, tablet: bool, desktop: bool):
        self.size = size
        self.mobile = mobile
        self.tablet = tablet
        self.desktop = desktop

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "LayoutElementConfiguration":
        from ._schemas.common import LayoutElementConfigurationSchema

        return LayoutElementConfigurationSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import LayoutElementConfigurationSchema

        return LayoutElementConfigurationSchema().dump(self)


class Main(_BaseType):
    layout_elements: typing.List["LayoutElement"]

    def __init__(self, *, layout_elements: typing.List["LayoutElement"]):
        self.layout_elements = layout_elements

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "Main":
        from ._schemas.common import MainSchema

        return MainSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import MainSchema

        return MainSchema().dump(self)


class Page(_BaseType):
    """Page represents the structure and data of the published page displayed through commercetools Frontend."""

    page_id: str
    sections: "Sections"
    state: str

    def __init__(self, *, page_id: str, sections: "Sections", state: str):
        self.page_id = page_id
        self.sections = sections
        self.state = state

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "Page":
        from ._schemas.common import PageSchema

        return PageSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import PageSchema

        return PageSchema().dump(self)


class PageDataResponse(_BaseType):
    page_folder: "PageFolder"
    #: Page represents the structure and data of the published page displayed through commercetools Frontend.
    page: "Page"
    data: "ViewData"

    def __init__(self, *, page_folder: "PageFolder", page: "Page", data: "ViewData"):
        self.page_folder = page_folder
        self.page = page
        self.data = data

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "PageDataResponse":
        from ._schemas.common import PageDataResponseSchema

        return PageDataResponseSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import PageDataResponseSchema

        return PageDataResponseSchema().dump(self)


class PageFolder(_BaseType):
    page_folder_id: str
    is_dynamic: bool
    page_folder_type: str
    configuration: typing.Any
    data_source_configurations: typing.List["DataSourceConfiguration"]
    name: typing.Optional[str]
    ancestor_ids_materialized_path: str
    depth: float
    sort: float

    def __init__(
        self,
        *,
        page_folder_id: str,
        is_dynamic: bool,
        page_folder_type: str,
        configuration: typing.Any,
        data_source_configurations: typing.List["DataSourceConfiguration"],
        name: typing.Optional[str] = None,
        ancestor_ids_materialized_path: str,
        depth: float,
        sort: float
    ):
        self.page_folder_id = page_folder_id
        self.is_dynamic = is_dynamic
        self.page_folder_type = page_folder_type
        self.configuration = configuration
        self.data_source_configurations = data_source_configurations
        self.name = name
        self.ancestor_ids_materialized_path = ancestor_ids_materialized_path
        self.depth = depth
        self.sort = sort

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "PageFolder":
        from ._schemas.common import PageFolderSchema

        return PageFolderSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import PageFolderSchema

        return PageFolderSchema().dump(self)


class PagePreviewContext(_BaseType):
    customer_name: str

    def __init__(self, *, customer_name: str):
        self.customer_name = customer_name

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "PagePreviewContext":
        from ._schemas.common import PagePreviewContextSchema

        return PagePreviewContextSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import PagePreviewContextSchema

        return PagePreviewContextSchema().dump(self)


class PagePreviewDataResponse(PageDataResponse):
    preview_id: str
    preview_context: "PagePreviewContext"

    def __init__(
        self,
        *,
        page_folder: "PageFolder",
        page: "Page",
        data: "ViewData",
        preview_id: str,
        preview_context: "PagePreviewContext"
    ):
        self.preview_id = preview_id
        self.preview_context = preview_context

        super().__init__(page_folder=page_folder, page=page, data=data)

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "PagePreviewDataResponse":
        from ._schemas.common import PagePreviewDataResponseSchema

        return PagePreviewDataResponseSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import PagePreviewDataResponseSchema

        return PagePreviewDataResponseSchema().dump(self)


class PathConfiguration(_BaseType):
    path: str
    path_translations: typing.List["str"]

    def __init__(self, *, path: str, path_translations: typing.List["str"]):
        self.path = path
        self.path_translations = path_translations

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "PathConfiguration":
        from ._schemas.common import PathConfigurationSchema

        return PathConfigurationSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import PathConfigurationSchema

        return PathConfigurationSchema().dump(self)


class ProjectContext(_BaseType):
    #: Indicates whether the project is intended as production or development environment.
    environment: "Environment"
    #: Locales that can be used in the project.
    locales: typing.List["str"]
    #: Locale used by default in the project.
    default_locale: str

    def __init__(
        self,
        *,
        environment: "Environment",
        locales: typing.List["str"],
        default_locale: str
    ):
        self.environment = environment
        self.locales = locales
        self.default_locale = default_locale

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ProjectContext":
        from ._schemas.common import ProjectContextSchema

        return ProjectContextSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import ProjectContextSchema

        return ProjectContextSchema().dump(self)


class RedirectResponse(_BaseType):
    status_code: float
    reason: str
    target_type: str
    target: str

    def __init__(
        self, *, status_code: float, reason: str, target_type: str, target: str
    ):
        self.status_code = status_code
        self.reason = reason
        self.target_type = target_type
        self.target = target

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "RedirectResponse":
        from ._schemas.common import RedirectResponseSchema

        return RedirectResponseSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import RedirectResponseSchema

        return RedirectResponseSchema().dump(self)


class Sections(_BaseType):
    head: "Head"
    main: "Main"
    footer: "Footer"

    def __init__(self, *, head: "Head", main: "Main", footer: "Footer"):
        self.head = head
        self.main = main
        self.footer = footer

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "Sections":
        from ._schemas.common import SectionsSchema

        return SectionsSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import SectionsSchema

        return SectionsSchema().dump(self)


class Tastic(_BaseType):
    tastic_id: str
    tastic_type: str
    configuration: "TasticConfiguration"

    def __init__(
        self, *, tastic_id: str, tastic_type: str, configuration: "TasticConfiguration"
    ):
        self.tastic_id = tastic_id
        self.tastic_type = tastic_type
        self.configuration = configuration

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "Tastic":
        from ._schemas.common import TasticSchema

        return TasticSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import TasticSchema

        return TasticSchema().dump(self)


class TasticConfiguration(_BaseType):
    desktop: bool
    mobile: bool
    tablet: bool

    def __init__(self, *, desktop: bool, mobile: bool, tablet: bool):
        self.desktop = desktop
        self.mobile = mobile
        self.tablet = tablet

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "TasticConfiguration":
        from ._schemas.common import TasticConfigurationSchema

        return TasticConfigurationSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import TasticConfigurationSchema

        return TasticConfigurationSchema().dump(self)


class ViewData(_BaseType):
    #: Data sources configured for the page folder and referenced in the page. They are indexed by data source identifier.
    data_sources: "DataSources"

    def __init__(self, *, data_sources: "DataSources"):
        self.data_sources = data_sources

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ViewData":
        from ._schemas.common import ViewDataSchema

        return ViewDataSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import ViewDataSchema

        return ViewDataSchema().dump(self)


class BuildUpload(_BaseType):
    #: Metadata about the build.
    metadata: "BuildMetadata"
    #: Javascript bundle containing all code of the backend extensions.
    extension: typing.BinaryIO
    #: Map for the build file. When provided, exceptions will be logged with readable stack traces.
    extension_map: typing.Optional[typing.BinaryIO]

    def __init__(
        self,
        *,
        metadata: "BuildMetadata",
        extension: typing.BinaryIO,
        extension_map: typing.Optional[typing.BinaryIO] = None
    ):
        self.metadata = metadata
        self.extension = extension
        self.extension_map = extension_map

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "BuildUpload":
        from ._schemas.common import BuildUploadSchema

        return BuildUploadSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import BuildUploadSchema

        return BuildUploadSchema().dump(self)


class BuildMetadata(_BaseType):
    #: Name of the Git branch to deploy.
    branch: str
    #: Full commit ID hash of the current HEAD.
    revision: str
    #: Current time represented in the format `YYYY.MM.DD.HH.mm`. This value should be unique and sortable.
    version_number: str
    #: Node.js version for the [Extension runner](/../frontend-getting-started/development-concepts#extension-runner).
    node_js_version: typing.Optional[int]
    #: If `true`, the build is marked as successful and [displayed in the Studio](/../frontend-studio/using-deployment-in-the-studio).
    build_successful: bool
    #: Date and time of the build in the [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339) format. For example, `2023-11-21T08:14:31.830Z`.
    build_time: str
    #: Build duration in seconds.
    build_duration: int
    #: CI execution logs.
    build_log: str
    #: If `true`, the build is automatically deployed to the staging environment, if `buildSuccessful` is `true`.
    deploy: typing.Optional[bool]

    def __init__(
        self,
        *,
        branch: str,
        revision: str,
        version_number: str,
        node_js_version: typing.Optional[int] = None,
        build_successful: bool,
        build_time: str,
        build_duration: int,
        build_log: str,
        deploy: typing.Optional[bool] = None
    ):
        self.branch = branch
        self.revision = revision
        self.version_number = version_number
        self.node_js_version = node_js_version
        self.build_successful = build_successful
        self.build_time = build_time
        self.build_duration = build_duration
        self.build_log = build_log
        self.deploy = deploy

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "BuildMetadata":
        from ._schemas.common import BuildMetadataSchema

        return BuildMetadataSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import BuildMetadataSchema

        return BuildMetadataSchema().dump(self)


class BuildUploadResult(_BaseType):
    #: Status of the build.
    status: str
    #: Description of the upload result.
    message: str

    def __init__(self, *, status: str, message: str):
        self.status = status
        self.message = message

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "BuildUploadResult":
        from ._schemas.common import BuildUploadResultSchema

        return BuildUploadResultSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import BuildUploadResultSchema

        return BuildUploadResultSchema().dump(self)
