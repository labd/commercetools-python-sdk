# This file is automatically generated by the rmf-codegen project.
#
# The Python code generator is maintained by Lab Digital. If you want to
# contribute to this project then please do not edit this file directly
# but send a pull request to the Lab Digital fork of rmf-codegen at
# https://github.com/labd/rmf-codegen

import datetime
import enum
import typing

from ._abstract import _BaseType
from .common import ImportResource

if typing.TYPE_CHECKING:
    from .common import (
        ChannelKeyReference,
        CustomerGroupKeyReference,
        DiscountedPrice,
        PriceTier,
        TypedMoney,
    )
    from .customfields import Custom

__all__ = ["StandalonePriceImport"]


class StandalonePriceImport(ImportResource):
    """The data representation for a Standalone Price to be imported that is persisted as a [Standalone Price](/../api/projects/standalone-prices#standaloneprice) in the Project."""

    #: Identifies the ProductVariant to which this Standalone Price is associated. This value is not validated to exist in Product Variants.
    sku: str
    #: Sets the money value of this Price.
    value: "TypedMoney"
    #: Sets the country for which this Price is valid.
    country: typing.Optional[str]
    #: Sets the CustomerGroup for which this Price is valid.
    customer_group: typing.Optional["CustomerGroupKeyReference"]
    #: Sets the product distribution Channel for which this Price is valid
    channel: typing.Optional["ChannelKeyReference"]
    #: Sets the date from which the Price is valid.
    valid_from: typing.Optional[datetime.datetime]
    #: Sets the date until the Price is valid.
    valid_until: typing.Optional[datetime.datetime]
    #: Sets price tiers.
    tiers: typing.Optional[typing.List["PriceTier"]]
    #: Sets a discounted price for this Price that is different from the base price with value.
    discounted: typing.Optional["DiscountedPrice"]
    #: Custom Fields for the StandalonePrice.
    custom: typing.Optional["Custom"]

    def __init__(
        self,
        *,
        key: str,
        sku: str,
        value: "TypedMoney",
        country: typing.Optional[str] = None,
        customer_group: typing.Optional["CustomerGroupKeyReference"] = None,
        channel: typing.Optional["ChannelKeyReference"] = None,
        valid_from: typing.Optional[datetime.datetime] = None,
        valid_until: typing.Optional[datetime.datetime] = None,
        tiers: typing.Optional[typing.List["PriceTier"]] = None,
        discounted: typing.Optional["DiscountedPrice"] = None,
        custom: typing.Optional["Custom"] = None
    ):
        self.sku = sku
        self.value = value
        self.country = country
        self.customer_group = customer_group
        self.channel = channel
        self.valid_from = valid_from
        self.valid_until = valid_until
        self.tiers = tiers
        self.discounted = discounted
        self.custom = custom

        super().__init__(key=key)

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "StandalonePriceImport":
        from ._schemas.standalone_prices import StandalonePriceImportSchema

        return StandalonePriceImportSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.standalone_prices import StandalonePriceImportSchema

        return StandalonePriceImportSchema().dump(self)
