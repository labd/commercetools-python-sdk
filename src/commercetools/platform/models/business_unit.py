# This file is automatically generated by the rmf-codegen project.
#
# The Python code generator is maintained by Lab Digital. If you want to
# contribute to this project then please do not edit this file directly
# but send a pull request to the Lab Digital fork of rmf-codegen at
# https://github.com/labd/rmf-codegen

import datetime
import enum
import typing

from ._abstract import _BaseType
from .common import (
    BaseResource,
    KeyReference,
    Reference,
    ReferenceTypeId,
    ResourceIdentifier,
)

if typing.TYPE_CHECKING:
    from .associate_role import (
        AssociateRoleKeyReference,
        AssociateRoleResourceIdentifier,
    )
    from .common import Address, BaseAddress, CreatedBy, LastModifiedBy, ReferenceTypeId
    from .customer import CustomerReference, CustomerResourceIdentifier
    from .store import StoreKeyReference, StoreResourceIdentifier
    from .type import (
        CustomFields,
        CustomFieldsDraft,
        FieldContainer,
        TypeResourceIdentifier,
    )

__all__ = [
    "Associate",
    "AssociateDraft",
    "AssociateRoleAssignment",
    "AssociateRoleAssignmentDraft",
    "AssociateRoleDeprecated",
    "AssociateRoleInheritanceMode",
    "BusinessUnit",
    "BusinessUnitAddAddressAction",
    "BusinessUnitAddAssociateAction",
    "BusinessUnitAddBillingAddressIdAction",
    "BusinessUnitAddShippingAddressIdAction",
    "BusinessUnitAddStoreAction",
    "BusinessUnitAssociateMode",
    "BusinessUnitChangeAddressAction",
    "BusinessUnitChangeAssociateAction",
    "BusinessUnitChangeAssociateModeAction",
    "BusinessUnitChangeNameAction",
    "BusinessUnitChangeParentUnitAction",
    "BusinessUnitChangeStatusAction",
    "BusinessUnitDraft",
    "BusinessUnitKeyReference",
    "BusinessUnitPagedQueryResponse",
    "BusinessUnitReference",
    "BusinessUnitRemoveAddressAction",
    "BusinessUnitRemoveAssociateAction",
    "BusinessUnitRemoveBillingAddressIdAction",
    "BusinessUnitRemoveShippingAddressIdAction",
    "BusinessUnitRemoveStoreAction",
    "BusinessUnitResourceIdentifier",
    "BusinessUnitSetAddressCustomFieldAction",
    "BusinessUnitSetAddressCustomTypeAction",
    "BusinessUnitSetAssociatesAction",
    "BusinessUnitSetContactEmailAction",
    "BusinessUnitSetCustomFieldAction",
    "BusinessUnitSetCustomTypeAction",
    "BusinessUnitSetDefaultBillingAddressAction",
    "BusinessUnitSetDefaultShippingAddressAction",
    "BusinessUnitSetStoreModeAction",
    "BusinessUnitSetStoresAction",
    "BusinessUnitStatus",
    "BusinessUnitStoreMode",
    "BusinessUnitType",
    "BusinessUnitUpdate",
    "BusinessUnitUpdateAction",
    "Company",
    "CompanyDraft",
    "Division",
    "DivisionDraft",
    "InheritedAssociate",
    "InheritedAssociateRoleAssignment",
]


class Associate(_BaseType):
    #: Roles assigned to the Associate within a Business Unit.
    associate_role_assignments: typing.List["AssociateRoleAssignment"]
    #: Deprecated type. Use `associateRoleAssignment` instead.
    roles: typing.List["AssociateRoleDeprecated"]
    #: The [Customer](ctp:api:type:Customer) that acts as an Associate in the Business Unit.
    customer: "CustomerReference"

    def __init__(
        self,
        *,
        associate_role_assignments: typing.List["AssociateRoleAssignment"],
        roles: typing.List["AssociateRoleDeprecated"],
        customer: "CustomerReference"
    ):
        self.associate_role_assignments = associate_role_assignments
        self.roles = roles
        self.customer = customer

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "Associate":
        from ._schemas.business_unit import AssociateSchema

        return AssociateSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.business_unit import AssociateSchema

        return AssociateSchema().dump(self)


class AssociateDraft(_BaseType):
    #: Roles assigned to the Associate within a Business Unit.
    associate_role_assignments: typing.Optional[
        typing.List["AssociateRoleAssignmentDraft"]
    ]
    #: Deprecated type. Use `associateRoleAssignment` instead.
    roles: typing.Optional[typing.List["AssociateRoleDeprecated"]]
    #: The [Customer](ctp:api:type:Customer) to be part of the Business Unit.
    customer: "CustomerResourceIdentifier"

    def __init__(
        self,
        *,
        associate_role_assignments: typing.Optional[
            typing.List["AssociateRoleAssignmentDraft"]
        ] = None,
        roles: typing.Optional[typing.List["AssociateRoleDeprecated"]] = None,
        customer: "CustomerResourceIdentifier"
    ):
        self.associate_role_assignments = associate_role_assignments
        self.roles = roles
        self.customer = customer

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "AssociateDraft":
        from ._schemas.business_unit import AssociateDraftSchema

        return AssociateDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.business_unit import AssociateDraftSchema

        return AssociateDraftSchema().dump(self)


class AssociateRoleAssignment(_BaseType):
    #: Role the Associate holds within a Business Unit.
    associate_role: "AssociateRoleKeyReference"
    #: Determines whether the AssociateRoleAssignment can be inherited by child Business Units.
    inheritance: "AssociateRoleInheritanceMode"

    def __init__(
        self,
        *,
        associate_role: "AssociateRoleKeyReference",
        inheritance: "AssociateRoleInheritanceMode"
    ):
        self.associate_role = associate_role
        self.inheritance = inheritance

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "AssociateRoleAssignment":
        from ._schemas.business_unit import AssociateRoleAssignmentSchema

        return AssociateRoleAssignmentSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.business_unit import AssociateRoleAssignmentSchema

        return AssociateRoleAssignmentSchema().dump(self)


class AssociateRoleAssignmentDraft(_BaseType):
    #: Role the Associate holds within a Business Unit.
    associate_role: "AssociateRoleResourceIdentifier"
    #: Determines whether the AssociateRoleAssignment can be inherited by child Business Units.
    inheritance: typing.Optional["AssociateRoleInheritanceMode"]

    def __init__(
        self,
        *,
        associate_role: "AssociateRoleResourceIdentifier",
        inheritance: typing.Optional["AssociateRoleInheritanceMode"] = None
    ):
        self.associate_role = associate_role
        self.inheritance = inheritance

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "AssociateRoleAssignmentDraft":
        from ._schemas.business_unit import AssociateRoleAssignmentDraftSchema

        return AssociateRoleAssignmentDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.business_unit import AssociateRoleAssignmentDraftSchema

        return AssociateRoleAssignmentDraftSchema().dump(self)


class AssociateRoleDeprecated(enum.Enum):
    """Roles defining how an [Associate](ctp:api:type:Associate) can interact with a Business Unit."""

    ADMIN = "Admin"
    BUYER = "Buyer"


class AssociateRoleInheritanceMode(enum.Enum):
    """Determines whether an [AssociateRoleAssignment](ctp:api:type:AssociateRoleAssignment) can be inherited by child Business Units."""

    ENABLED = "Enabled"
    DISABLED = "Disabled"


class BusinessUnit(BaseResource):
    """Generic type to model the fields that all types of Business Units have in common."""

    #: Present on resources updated after 1 February 2019 except for [events not tracked](/../api/client-logging#events-tracked).
    last_modified_by: typing.Optional["LastModifiedBy"]
    #: Present on resources created after 1 February 2019 except for [events not tracked](/../api/client-logging#events-tracked).
    created_by: typing.Optional["CreatedBy"]
    #: User-defined unique identifier of the Business Unit.
    key: str
    #: Indicates whether the Business Unit can be edited and used in [Orders](/../api/projects/orders).
    status: "BusinessUnitStatus"
    #: References to [Stores](ctp:api:type:Store) the Business Unit is associated with. Only present when `storeMode` is `Explicit`.
    #:
    #: If the Business Unit has Stores defined, then all of its [Carts](ctp:api:type:Cart), [Orders](ctp:api:type:Order), [Quotes](ctp:api:type:Quote), or [Quote Requests](ctp:api:type:QuoteRequest) must belong to one of the Business Unit's Stores.
    #:
    #: If the Business Unit has no Stores, then all of its [Carts](ctp:api:type:Cart), [Orders](ctp:api:type:Order), [Quotes](ctp:api:type:Quote), or [Quote Requests](ctp:api:type:QuoteRequest) must not belong to any Store.
    stores: typing.Optional[typing.List["StoreKeyReference"]]
    #: Defines whether the Stores of the Business Unit are set directly on the Business Unit or are inherited from a parent.
    store_mode: "BusinessUnitStoreMode"
    #: Type of the Business Unit indicating its position in a hierarchy.
    unit_type: "BusinessUnitType"
    #: Name of the Business Unit.
    name: str
    #: Email address of the Business Unit.
    contact_email: typing.Optional[str]
    #: Custom Fields for the Business Unit.
    custom: typing.Optional["CustomFields"]
    #: Addresses used by the Business Unit.
    addresses: typing.List["Address"]
    #: Unique identifiers of addresses used as shipping addresses.
    shipping_address_ids: typing.Optional[typing.List["str"]]
    #: Unique identifier of the address used as the default shipping address.
    default_shipping_address_id: typing.Optional[str]
    #: Unique identifiers of addresses used as billing addresses.
    billing_address_ids: typing.Optional[typing.List["str"]]
    #: Unique identifier of the address used as the default billing address.
    default_billing_address_id: typing.Optional[str]
    #: Set to `Explicit` to prevent the Business Unit inheriting Associates from a parent, set to `ExplicitAndFromParent` to enable inheritance.
    associate_mode: "BusinessUnitAssociateMode"
    #: Associates that are part of the Business Unit in specific [roles](ctp:api:type:AssociateRole).
    associates: typing.List["Associate"]
    #: Associates that are inherited from a parent Business Unit. This value of this field is [eventually consistent](/../api/general-concepts#eventual-consistency) and is only present when the `associateMode` is set to `ExplicitAndFromParent`.
    inherited_associates: typing.Optional[typing.List["InheritedAssociate"]]
    #: Parent unit of the Business Unit. Only present when the `unitType` is `Division`.
    parent_unit: typing.Optional["BusinessUnitKeyReference"]
    #: Top-level unit of the Business Unit. The top-level unit is of `unitType` `Company`.
    top_level_unit: "BusinessUnitKeyReference"

    def __init__(
        self,
        *,
        id: str,
        version: int,
        created_at: datetime.datetime,
        last_modified_at: datetime.datetime,
        last_modified_by: typing.Optional["LastModifiedBy"] = None,
        created_by: typing.Optional["CreatedBy"] = None,
        key: str,
        status: "BusinessUnitStatus",
        stores: typing.Optional[typing.List["StoreKeyReference"]] = None,
        store_mode: "BusinessUnitStoreMode",
        unit_type: "BusinessUnitType",
        name: str,
        contact_email: typing.Optional[str] = None,
        custom: typing.Optional["CustomFields"] = None,
        addresses: typing.List["Address"],
        shipping_address_ids: typing.Optional[typing.List["str"]] = None,
        default_shipping_address_id: typing.Optional[str] = None,
        billing_address_ids: typing.Optional[typing.List["str"]] = None,
        default_billing_address_id: typing.Optional[str] = None,
        associate_mode: "BusinessUnitAssociateMode",
        associates: typing.List["Associate"],
        inherited_associates: typing.Optional[typing.List["InheritedAssociate"]] = None,
        parent_unit: typing.Optional["BusinessUnitKeyReference"] = None,
        top_level_unit: "BusinessUnitKeyReference"
    ):
        self.last_modified_by = last_modified_by
        self.created_by = created_by
        self.key = key
        self.status = status
        self.stores = stores
        self.store_mode = store_mode
        self.unit_type = unit_type
        self.name = name
        self.contact_email = contact_email
        self.custom = custom
        self.addresses = addresses
        self.shipping_address_ids = shipping_address_ids
        self.default_shipping_address_id = default_shipping_address_id
        self.billing_address_ids = billing_address_ids
        self.default_billing_address_id = default_billing_address_id
        self.associate_mode = associate_mode
        self.associates = associates
        self.inherited_associates = inherited_associates
        self.parent_unit = parent_unit
        self.top_level_unit = top_level_unit

        super().__init__(
            id=id,
            version=version,
            created_at=created_at,
            last_modified_at=last_modified_at,
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "BusinessUnit":
        if data["unitType"] == "Company":
            from ._schemas.business_unit import CompanySchema

            return CompanySchema().load(data)
        if data["unitType"] == "Division":
            from ._schemas.business_unit import DivisionSchema

            return DivisionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.business_unit import BusinessUnitSchema

        return BusinessUnitSchema().dump(self)


class BusinessUnitAssociateMode(enum.Enum):
    """Determines whether a Business Unit can inherit Associates from a parent."""

    EXPLICIT = "Explicit"
    EXPLICIT_AND_FROM_PARENT = "ExplicitAndFromParent"


class BusinessUnitDraft(_BaseType):
    """Generic draft type to model those fields all Business Units have in common. The additional fields required for creating a [Company](ctp:api:type:Company) or [Division](ctp:api:type:Division) are represented on [CompanyDraft](ctp:api:type:CompanyDraft) and [DivisionDraft](ctp:api:type:DivisionDraft)."""

    #: User-defined unique identifier for the Business Unit.
    key: str
    #: Indicates whether the Business Unit can be edited and used in [Orders](/../api/projects/orders).
    status: typing.Optional["BusinessUnitStatus"]
    #: Sets the [Stores](ctp:api:type:Store) the Business Unit is associated with. Can only be set when `storeMode` is `Explicit`.
    #: Defaults to empty for [Companies](ctp:api:type:BusinessUnitType) and not set for [Divisions](ctp:api:type:BusinessUnitType).
    #:
    #: If the Business Unit has Stores defined, then all of its [Carts](ctp:api:type:Cart), [Orders](ctp:api:type:Order), [Quotes](ctp:api:type:Quote), or [Quote Requests](ctp:api:type:QuoteRequest) must belong to one of the Business Unit's Stores.
    #:
    #: If the Business Unit has no Stores, then all of its [Carts](ctp:api:type:Cart), [Orders](ctp:api:type:Order), [Quotes](ctp:api:type:Quote), or [Quote Requests](ctp:api:type:QuoteRequest) must not belong to any Store.
    stores: typing.Optional[typing.List["StoreResourceIdentifier"]]
    #: Defines whether the Stores of the Business Unit are set directly on the Business Unit or are inherited from a parent.
    #: `storeMode` is always `Explicit` for [Companies](ctp:api:type:BusinessUnitType) and defaults to `FromParent` for [Divisions](ctp:api:type:BusinessUnitType).
    store_mode: typing.Optional["BusinessUnitStoreMode"]
    #: Type of the Business Unit indicating its position in a hierarchy.
    unit_type: "BusinessUnitType"
    #: Name of the Business Unit.
    name: str
    #: Email address of the Business Unit.
    contact_email: typing.Optional[str]
    #: Determines whether the Business Unit can inherit Associates from a parent.
    #: Always `Explicit` for [Companies](ctp:api:type:BusinessUnitType) and defaults to `ExplicitAndFromParent` for [Divisions](ctp:api:type:BusinessUnitType).
    associate_mode: typing.Optional["BusinessUnitAssociateMode"]
    #: List of members that are part of the Business Unit in specific [roles](ctp:api:type:AssociateRole).
    associates: typing.Optional[typing.List["AssociateDraft"]]
    #: Addresses used by the Business Unit.
    addresses: typing.Optional[typing.List["BaseAddress"]]
    #: Indexes of entries in `addresses` to set as shipping addresses.
    #: The `shippingAddressIds` of the [Customer](ctp:api:type:Customer) will be replaced by these addresses.
    shipping_addresses: typing.Optional[typing.List["int"]]
    #: Index of the entry in `addresses` to set as the default shipping address.
    default_shipping_address: typing.Optional[int]
    #: Indexes of entries in `addresses` to set as billing addresses.
    #: The `billingAddressIds` of the [Customer](ctp:api:type:Customer) will be replaced by these addresses.
    billing_addresses: typing.Optional[typing.List["int"]]
    #: Index of the entry in `addresses` to set as the default billing address.
    default_billing_address: typing.Optional[int]
    #: Custom Fields for the Business Unit.
    custom: typing.Optional["CustomFieldsDraft"]

    def __init__(
        self,
        *,
        key: str,
        status: typing.Optional["BusinessUnitStatus"] = None,
        stores: typing.Optional[typing.List["StoreResourceIdentifier"]] = None,
        store_mode: typing.Optional["BusinessUnitStoreMode"] = None,
        unit_type: "BusinessUnitType",
        name: str,
        contact_email: typing.Optional[str] = None,
        associate_mode: typing.Optional["BusinessUnitAssociateMode"] = None,
        associates: typing.Optional[typing.List["AssociateDraft"]] = None,
        addresses: typing.Optional[typing.List["BaseAddress"]] = None,
        shipping_addresses: typing.Optional[typing.List["int"]] = None,
        default_shipping_address: typing.Optional[int] = None,
        billing_addresses: typing.Optional[typing.List["int"]] = None,
        default_billing_address: typing.Optional[int] = None,
        custom: typing.Optional["CustomFieldsDraft"] = None
    ):
        self.key = key
        self.status = status
        self.stores = stores
        self.store_mode = store_mode
        self.unit_type = unit_type
        self.name = name
        self.contact_email = contact_email
        self.associate_mode = associate_mode
        self.associates = associates
        self.addresses = addresses
        self.shipping_addresses = shipping_addresses
        self.default_shipping_address = default_shipping_address
        self.billing_addresses = billing_addresses
        self.default_billing_address = default_billing_address
        self.custom = custom

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "BusinessUnitDraft":
        if data["unitType"] == "Company":
            from ._schemas.business_unit import CompanyDraftSchema

            return CompanyDraftSchema().load(data)
        if data["unitType"] == "Division":
            from ._schemas.business_unit import DivisionDraftSchema

            return DivisionDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.business_unit import BusinessUnitDraftSchema

        return BusinessUnitDraftSchema().dump(self)


class BusinessUnitKeyReference(KeyReference):
    """[Reference](/../api/types#reference) to a [BusinessUnit](ctp:api:type:BusinessUnit) by its key."""

    def __init__(self, *, key: str):
        super().__init__(key=key, type_id=ReferenceTypeId.BUSINESS_UNIT)

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "BusinessUnitKeyReference":
        from ._schemas.business_unit import BusinessUnitKeyReferenceSchema

        return BusinessUnitKeyReferenceSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.business_unit import BusinessUnitKeyReferenceSchema

        return BusinessUnitKeyReferenceSchema().dump(self)


class BusinessUnitPagedQueryResponse(_BaseType):
    """[PagedQueryResult](/../api/general-concepts#pagedqueryresult) with results containing an array of [BusinessUnit](ctp:api:type:BusinessUnit)."""

    #: Number of requested [results](/../api/general-concepts#limit).
    limit: int
    #: Number of elements [skipped](/../api/general-concepts#offset).
    offset: int
    #: Actual number of results returned.
    count: int
    #: Total number of results matching the query.
    #: This number is an estimation that is not [strongly consistent](/../api/general-concepts#strong-consistency).
    #: This field is returned by default.
    #: For improved performance, calculating this field can be deactivated by using the query parameter `withTotal=false`.
    #: When the results are filtered with a [Query Predicate](/../api/predicates/query), `total` is subject to a [limit](/../api/limits#queries).
    total: typing.Optional[int]
    #: [BusinessUnits](ctp:api:type:BusinessUnit) matching the query.
    results: typing.List["BusinessUnit"]

    def __init__(
        self,
        *,
        limit: int,
        offset: int,
        count: int,
        total: typing.Optional[int] = None,
        results: typing.List["BusinessUnit"]
    ):
        self.limit = limit
        self.offset = offset
        self.count = count
        self.total = total
        self.results = results

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "BusinessUnitPagedQueryResponse":
        from ._schemas.business_unit import BusinessUnitPagedQueryResponseSchema

        return BusinessUnitPagedQueryResponseSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.business_unit import BusinessUnitPagedQueryResponseSchema

        return BusinessUnitPagedQueryResponseSchema().dump(self)


class BusinessUnitReference(Reference):
    """[Reference](/../api/types#reference) to a [BusinessUnit](ctp:api:type:BusinessUnit)."""

    #: Contains the representation of the expanded BusinessUnit. Only present in responses to requests with [Reference Expansion](/../api/general-concepts#reference-expansion) for BusinessUnit.
    obj: typing.Optional["BusinessUnit"]

    def __init__(self, *, id: str, obj: typing.Optional["BusinessUnit"] = None):
        self.obj = obj

        super().__init__(id=id, type_id=ReferenceTypeId.BUSINESS_UNIT)

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "BusinessUnitReference":
        from ._schemas.business_unit import BusinessUnitReferenceSchema

        return BusinessUnitReferenceSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.business_unit import BusinessUnitReferenceSchema

        return BusinessUnitReferenceSchema().dump(self)


class BusinessUnitResourceIdentifier(ResourceIdentifier):
    """[ResourceIdentifier](/../api/types#resourceidentifier) to a [BusinessUnit](ctp:api:type:BusinessUnit)."""

    def __init__(
        self, *, id: typing.Optional[str] = None, key: typing.Optional[str] = None
    ):
        super().__init__(id=id, key=key, type_id=ReferenceTypeId.BUSINESS_UNIT)

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "BusinessUnitResourceIdentifier":
        from ._schemas.business_unit import BusinessUnitResourceIdentifierSchema

        return BusinessUnitResourceIdentifierSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.business_unit import BusinessUnitResourceIdentifierSchema

        return BusinessUnitResourceIdentifierSchema().dump(self)


class BusinessUnitStatus(enum.Enum):
    """Indicates whether the Business Unit can be edited and used in [Carts](ctp:api:type:Cart), [Orders](ctp:api:type:Order), [Quote Requests](ctp:api:type:QuoteRequest), or [Quotes](ctp:api:type:Quote)."""

    ACTIVE = "Active"
    INACTIVE = "Inactive"


class BusinessUnitStoreMode(enum.Enum):
    """Defines whether the Stores of the Business Unit are set directly on the Business Unit or are inherited from its parent unit."""

    EXPLICIT = "Explicit"
    FROM_PARENT = "FromParent"


class BusinessUnitType(enum.Enum):
    """The type of the Business Unit indicating its position in a hierarchy."""

    COMPANY = "Company"
    DIVISION = "Division"


class BusinessUnitUpdate(_BaseType):
    #: Expected version of the BusinessUnit on which the changes should be applied.
    #: If the expected version does not match the actual version, a [409 Conflict](/../api/errors#409-conflict) error will be returned.
    version: int
    #: Update actions to be performed on the BusinessUnit.
    actions: typing.List["BusinessUnitUpdateAction"]

    def __init__(
        self, *, version: int, actions: typing.List["BusinessUnitUpdateAction"]
    ):
        self.version = version
        self.actions = actions

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "BusinessUnitUpdate":
        from ._schemas.business_unit import BusinessUnitUpdateSchema

        return BusinessUnitUpdateSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.business_unit import BusinessUnitUpdateSchema

        return BusinessUnitUpdateSchema().dump(self)


class BusinessUnitUpdateAction(_BaseType):
    action: str

    def __init__(self, *, action: str):
        self.action = action

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "BusinessUnitUpdateAction":
        if data["action"] == "addAddress":
            from ._schemas.business_unit import BusinessUnitAddAddressActionSchema

            return BusinessUnitAddAddressActionSchema().load(data)
        if data["action"] == "addAssociate":
            from ._schemas.business_unit import BusinessUnitAddAssociateActionSchema

            return BusinessUnitAddAssociateActionSchema().load(data)
        if data["action"] == "addBillingAddressId":
            from ._schemas.business_unit import (
                BusinessUnitAddBillingAddressIdActionSchema,
            )

            return BusinessUnitAddBillingAddressIdActionSchema().load(data)
        if data["action"] == "addShippingAddressId":
            from ._schemas.business_unit import (
                BusinessUnitAddShippingAddressIdActionSchema,
            )

            return BusinessUnitAddShippingAddressIdActionSchema().load(data)
        if data["action"] == "addStore":
            from ._schemas.business_unit import BusinessUnitAddStoreActionSchema

            return BusinessUnitAddStoreActionSchema().load(data)
        if data["action"] == "changeAddress":
            from ._schemas.business_unit import BusinessUnitChangeAddressActionSchema

            return BusinessUnitChangeAddressActionSchema().load(data)
        if data["action"] == "changeAssociate":
            from ._schemas.business_unit import BusinessUnitChangeAssociateActionSchema

            return BusinessUnitChangeAssociateActionSchema().load(data)
        if data["action"] == "changeAssociateMode":
            from ._schemas.business_unit import (
                BusinessUnitChangeAssociateModeActionSchema,
            )

            return BusinessUnitChangeAssociateModeActionSchema().load(data)
        if data["action"] == "changeName":
            from ._schemas.business_unit import BusinessUnitChangeNameActionSchema

            return BusinessUnitChangeNameActionSchema().load(data)
        if data["action"] == "changeParentUnit":
            from ._schemas.business_unit import BusinessUnitChangeParentUnitActionSchema

            return BusinessUnitChangeParentUnitActionSchema().load(data)
        if data["action"] == "changeStatus":
            from ._schemas.business_unit import BusinessUnitChangeStatusActionSchema

            return BusinessUnitChangeStatusActionSchema().load(data)
        if data["action"] == "removeAddress":
            from ._schemas.business_unit import BusinessUnitRemoveAddressActionSchema

            return BusinessUnitRemoveAddressActionSchema().load(data)
        if data["action"] == "removeAssociate":
            from ._schemas.business_unit import BusinessUnitRemoveAssociateActionSchema

            return BusinessUnitRemoveAssociateActionSchema().load(data)
        if data["action"] == "removeBillingAddressId":
            from ._schemas.business_unit import (
                BusinessUnitRemoveBillingAddressIdActionSchema,
            )

            return BusinessUnitRemoveBillingAddressIdActionSchema().load(data)
        if data["action"] == "removeShippingAddressId":
            from ._schemas.business_unit import (
                BusinessUnitRemoveShippingAddressIdActionSchema,
            )

            return BusinessUnitRemoveShippingAddressIdActionSchema().load(data)
        if data["action"] == "removeStore":
            from ._schemas.business_unit import BusinessUnitRemoveStoreActionSchema

            return BusinessUnitRemoveStoreActionSchema().load(data)
        if data["action"] == "setAddressCustomField":
            from ._schemas.business_unit import (
                BusinessUnitSetAddressCustomFieldActionSchema,
            )

            return BusinessUnitSetAddressCustomFieldActionSchema().load(data)
        if data["action"] == "setAddressCustomType":
            from ._schemas.business_unit import (
                BusinessUnitSetAddressCustomTypeActionSchema,
            )

            return BusinessUnitSetAddressCustomTypeActionSchema().load(data)
        if data["action"] == "setAssociates":
            from ._schemas.business_unit import BusinessUnitSetAssociatesActionSchema

            return BusinessUnitSetAssociatesActionSchema().load(data)
        if data["action"] == "setContactEmail":
            from ._schemas.business_unit import BusinessUnitSetContactEmailActionSchema

            return BusinessUnitSetContactEmailActionSchema().load(data)
        if data["action"] == "setCustomField":
            from ._schemas.business_unit import BusinessUnitSetCustomFieldActionSchema

            return BusinessUnitSetCustomFieldActionSchema().load(data)
        if data["action"] == "setCustomType":
            from ._schemas.business_unit import BusinessUnitSetCustomTypeActionSchema

            return BusinessUnitSetCustomTypeActionSchema().load(data)
        if data["action"] == "setDefaultBillingAddress":
            from ._schemas.business_unit import (
                BusinessUnitSetDefaultBillingAddressActionSchema,
            )

            return BusinessUnitSetDefaultBillingAddressActionSchema().load(data)
        if data["action"] == "setDefaultShippingAddress":
            from ._schemas.business_unit import (
                BusinessUnitSetDefaultShippingAddressActionSchema,
            )

            return BusinessUnitSetDefaultShippingAddressActionSchema().load(data)
        if data["action"] == "setStoreMode":
            from ._schemas.business_unit import BusinessUnitSetStoreModeActionSchema

            return BusinessUnitSetStoreModeActionSchema().load(data)
        if data["action"] == "setStores":
            from ._schemas.business_unit import BusinessUnitSetStoresActionSchema

            return BusinessUnitSetStoresActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.business_unit import BusinessUnitUpdateActionSchema

        return BusinessUnitUpdateActionSchema().dump(self)


class Company(BusinessUnit):
    """Business Unit type to represent the top level of a business.
    Contains specific fields and values that differentiate a Company from the generic [BusinessUnit](ctp:api:type:BusinessUnit).

    """

    def __init__(
        self,
        *,
        id: str,
        version: int,
        created_at: datetime.datetime,
        last_modified_at: datetime.datetime,
        last_modified_by: typing.Optional["LastModifiedBy"] = None,
        created_by: typing.Optional["CreatedBy"] = None,
        key: str,
        status: "BusinessUnitStatus",
        stores: typing.Optional[typing.List["StoreKeyReference"]] = None,
        store_mode: "BusinessUnitStoreMode",
        name: str,
        contact_email: typing.Optional[str] = None,
        custom: typing.Optional["CustomFields"] = None,
        addresses: typing.List["Address"],
        shipping_address_ids: typing.Optional[typing.List["str"]] = None,
        default_shipping_address_id: typing.Optional[str] = None,
        billing_address_ids: typing.Optional[typing.List["str"]] = None,
        default_billing_address_id: typing.Optional[str] = None,
        associate_mode: "BusinessUnitAssociateMode",
        associates: typing.List["Associate"],
        inherited_associates: typing.Optional[typing.List["InheritedAssociate"]] = None,
        parent_unit: typing.Optional["BusinessUnitKeyReference"] = None,
        top_level_unit: "BusinessUnitKeyReference"
    ):
        super().__init__(
            id=id,
            version=version,
            created_at=created_at,
            last_modified_at=last_modified_at,
            last_modified_by=last_modified_by,
            created_by=created_by,
            key=key,
            status=status,
            stores=stores,
            store_mode=store_mode,
            name=name,
            contact_email=contact_email,
            custom=custom,
            addresses=addresses,
            shipping_address_ids=shipping_address_ids,
            default_shipping_address_id=default_shipping_address_id,
            billing_address_ids=billing_address_ids,
            default_billing_address_id=default_billing_address_id,
            associate_mode=associate_mode,
            associates=associates,
            inherited_associates=inherited_associates,
            parent_unit=parent_unit,
            top_level_unit=top_level_unit,
            unit_type=BusinessUnitType.COMPANY,
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "Company":
        from ._schemas.business_unit import CompanySchema

        return CompanySchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.business_unit import CompanySchema

        return CompanySchema().dump(self)


class CompanyDraft(BusinessUnitDraft):
    """Draft type to represent the top level of a business. Contains the fields and values of the generic [BusinessUnitDraft](ctp:api:type:BusinessUnitDraft) that are used specifically for creating a [Company](ctp:api:type:Company)."""

    def __init__(
        self,
        *,
        key: str,
        status: typing.Optional["BusinessUnitStatus"] = None,
        stores: typing.Optional[typing.List["StoreResourceIdentifier"]] = None,
        store_mode: typing.Optional["BusinessUnitStoreMode"] = None,
        name: str,
        contact_email: typing.Optional[str] = None,
        associate_mode: typing.Optional["BusinessUnitAssociateMode"] = None,
        associates: typing.Optional[typing.List["AssociateDraft"]] = None,
        addresses: typing.Optional[typing.List["BaseAddress"]] = None,
        shipping_addresses: typing.Optional[typing.List["int"]] = None,
        default_shipping_address: typing.Optional[int] = None,
        billing_addresses: typing.Optional[typing.List["int"]] = None,
        default_billing_address: typing.Optional[int] = None,
        custom: typing.Optional["CustomFieldsDraft"] = None
    ):
        super().__init__(
            key=key,
            status=status,
            stores=stores,
            store_mode=store_mode,
            name=name,
            contact_email=contact_email,
            associate_mode=associate_mode,
            associates=associates,
            addresses=addresses,
            shipping_addresses=shipping_addresses,
            default_shipping_address=default_shipping_address,
            billing_addresses=billing_addresses,
            default_billing_address=default_billing_address,
            custom=custom,
            unit_type=BusinessUnitType.COMPANY,
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CompanyDraft":
        from ._schemas.business_unit import CompanyDraftSchema

        return CompanyDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.business_unit import CompanyDraftSchema

        return CompanyDraftSchema().dump(self)


class Division(BusinessUnit):
    """Business Unit type to model divisions that are part of the [Company](ctp:api:type:Company) or a higher-order Division.
    Contains specific fields and values that differentiate a Division from the generic [BusinessUnit](ctp:api:type:BusinessUnit).

    """

    def __init__(
        self,
        *,
        id: str,
        version: int,
        created_at: datetime.datetime,
        last_modified_at: datetime.datetime,
        last_modified_by: typing.Optional["LastModifiedBy"] = None,
        created_by: typing.Optional["CreatedBy"] = None,
        key: str,
        status: "BusinessUnitStatus",
        stores: typing.Optional[typing.List["StoreKeyReference"]] = None,
        store_mode: "BusinessUnitStoreMode",
        name: str,
        contact_email: typing.Optional[str] = None,
        custom: typing.Optional["CustomFields"] = None,
        addresses: typing.List["Address"],
        shipping_address_ids: typing.Optional[typing.List["str"]] = None,
        default_shipping_address_id: typing.Optional[str] = None,
        billing_address_ids: typing.Optional[typing.List["str"]] = None,
        default_billing_address_id: typing.Optional[str] = None,
        associate_mode: "BusinessUnitAssociateMode",
        associates: typing.List["Associate"],
        inherited_associates: typing.Optional[typing.List["InheritedAssociate"]] = None,
        parent_unit: "BusinessUnitKeyReference",
        top_level_unit: "BusinessUnitKeyReference"
    ):
        super().__init__(
            id=id,
            version=version,
            created_at=created_at,
            last_modified_at=last_modified_at,
            last_modified_by=last_modified_by,
            created_by=created_by,
            key=key,
            status=status,
            stores=stores,
            store_mode=store_mode,
            name=name,
            contact_email=contact_email,
            custom=custom,
            addresses=addresses,
            shipping_address_ids=shipping_address_ids,
            default_shipping_address_id=default_shipping_address_id,
            billing_address_ids=billing_address_ids,
            default_billing_address_id=default_billing_address_id,
            associate_mode=associate_mode,
            associates=associates,
            inherited_associates=inherited_associates,
            parent_unit=parent_unit,
            top_level_unit=top_level_unit,
            unit_type=BusinessUnitType.DIVISION,
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "Division":
        from ._schemas.business_unit import DivisionSchema

        return DivisionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.business_unit import DivisionSchema

        return DivisionSchema().dump(self)


class DivisionDraft(BusinessUnitDraft):
    """Draft type to model divisions that are part of a [Company](ctp:api:type:Company) or a higher-order [Division](ctp:api:type:Division).
    Contains the fields and values of the generic [BusinessUnitDraft](ctp:api:type:BusinessUnitDraft) that are used specifically for creating a Division.

    """

    #: The parent unit of this Division. Can be a Company or a Division.
    parent_unit: "BusinessUnitResourceIdentifier"

    def __init__(
        self,
        *,
        key: str,
        status: typing.Optional["BusinessUnitStatus"] = None,
        stores: typing.Optional[typing.List["StoreResourceIdentifier"]] = None,
        store_mode: typing.Optional["BusinessUnitStoreMode"] = None,
        name: str,
        contact_email: typing.Optional[str] = None,
        associate_mode: typing.Optional["BusinessUnitAssociateMode"] = None,
        associates: typing.Optional[typing.List["AssociateDraft"]] = None,
        addresses: typing.Optional[typing.List["BaseAddress"]] = None,
        shipping_addresses: typing.Optional[typing.List["int"]] = None,
        default_shipping_address: typing.Optional[int] = None,
        billing_addresses: typing.Optional[typing.List["int"]] = None,
        default_billing_address: typing.Optional[int] = None,
        custom: typing.Optional["CustomFieldsDraft"] = None,
        parent_unit: "BusinessUnitResourceIdentifier"
    ):
        self.parent_unit = parent_unit

        super().__init__(
            key=key,
            status=status,
            stores=stores,
            store_mode=store_mode,
            name=name,
            contact_email=contact_email,
            associate_mode=associate_mode,
            associates=associates,
            addresses=addresses,
            shipping_addresses=shipping_addresses,
            default_shipping_address=default_shipping_address,
            billing_addresses=billing_addresses,
            default_billing_address=default_billing_address,
            custom=custom,
            unit_type=BusinessUnitType.DIVISION,
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "DivisionDraft":
        from ._schemas.business_unit import DivisionDraftSchema

        return DivisionDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.business_unit import DivisionDraftSchema

        return DivisionDraftSchema().dump(self)


class InheritedAssociate(_BaseType):
    #: Inherited roles of the Associate within a Business Unit.
    associate_role_assignments: typing.List["InheritedAssociateRoleAssignment"]
    #: The [Customer](ctp:api:type:Customer) that acts as an Associate in the Business Unit.
    customer: "CustomerReference"

    def __init__(
        self,
        *,
        associate_role_assignments: typing.List["InheritedAssociateRoleAssignment"],
        customer: "CustomerReference"
    ):
        self.associate_role_assignments = associate_role_assignments
        self.customer = customer

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "InheritedAssociate":
        from ._schemas.business_unit import InheritedAssociateSchema

        return InheritedAssociateSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.business_unit import InheritedAssociateSchema

        return InheritedAssociateSchema().dump(self)


class InheritedAssociateRoleAssignment(_BaseType):
    #: Inherited role the Associate holds within a Business Unit.
    associate_role: "AssociateRoleKeyReference"
    #: Reference to the parent Business Unit where the assignment is defined explicitly.
    source: "BusinessUnitKeyReference"

    def __init__(
        self,
        *,
        associate_role: "AssociateRoleKeyReference",
        source: "BusinessUnitKeyReference"
    ):
        self.associate_role = associate_role
        self.source = source

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "InheritedAssociateRoleAssignment":
        from ._schemas.business_unit import InheritedAssociateRoleAssignmentSchema

        return InheritedAssociateRoleAssignmentSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.business_unit import InheritedAssociateRoleAssignmentSchema

        return InheritedAssociateRoleAssignmentSchema().dump(self)


class BusinessUnitAddAddressAction(BusinessUnitUpdateAction):
    """Adding an address to a [Business Unit](ctp:api:type:BusinessUnit) generates a [BusinessUnitAddressAdded](ctp:api:type:BusinessUnitAddressAddedMessage) Message."""

    #: Address to add to the addresses of the [Business Unit](ctp:api:type:BusinessUnit).
    address: "BaseAddress"

    def __init__(self, *, address: "BaseAddress"):
        self.address = address

        super().__init__(action="addAddress")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "BusinessUnitAddAddressAction":
        from ._schemas.business_unit import BusinessUnitAddAddressActionSchema

        return BusinessUnitAddAddressActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.business_unit import BusinessUnitAddAddressActionSchema

        return BusinessUnitAddAddressActionSchema().dump(self)


class BusinessUnitAddAssociateAction(BusinessUnitUpdateAction):
    """Adding an Associate to a [Business Unit](ctp:api:type:BusinessUnit) generates a [BusinessUnitAssociateAdded](ctp:api:type:BusinessUnitAssociateAddedMessage) Message."""

    #: The Associate to add.
    associate: "AssociateDraft"

    def __init__(self, *, associate: "AssociateDraft"):
        self.associate = associate

        super().__init__(action="addAssociate")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "BusinessUnitAddAssociateAction":
        from ._schemas.business_unit import BusinessUnitAddAssociateActionSchema

        return BusinessUnitAddAssociateActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.business_unit import BusinessUnitAddAssociateActionSchema

        return BusinessUnitAddAssociateActionSchema().dump(self)


class BusinessUnitAddBillingAddressIdAction(BusinessUnitUpdateAction):
    """Adding a billing address to a [Business Unit](ctp:api:type:BusinessUnit) generates a [BusinessUnitBillingAddressAdded](ctp:api:type:BusinessUnitBillingAddressAddedMessage) Message."""

    #: ID of the address to add as a billing address. Either `addressId` or `addressKey` is required.
    address_id: typing.Optional[str]
    #: Key of the address to add as a billing address. Either `addressId` or `addressKey` is required.
    address_key: typing.Optional[str]

    def __init__(
        self,
        *,
        address_id: typing.Optional[str] = None,
        address_key: typing.Optional[str] = None
    ):
        self.address_id = address_id
        self.address_key = address_key

        super().__init__(action="addBillingAddressId")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "BusinessUnitAddBillingAddressIdAction":
        from ._schemas.business_unit import BusinessUnitAddBillingAddressIdActionSchema

        return BusinessUnitAddBillingAddressIdActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.business_unit import BusinessUnitAddBillingAddressIdActionSchema

        return BusinessUnitAddBillingAddressIdActionSchema().dump(self)


class BusinessUnitAddShippingAddressIdAction(BusinessUnitUpdateAction):
    """Adding a shipping address to a [Business Unit](ctp:api:type:BusinessUnit) generates a [BusinessUnitShippingAddressAdded](ctp:api:type:BusinessUnitShippingAddressAddedMessage) Message."""

    #: ID of the address to add as a shipping address. Either `addressId` or `addressKey` is required.
    address_id: typing.Optional[str]
    #: Key of the address to add as a shipping address. Either `addressId` or `addressKey` is required.
    address_key: typing.Optional[str]

    def __init__(
        self,
        *,
        address_id: typing.Optional[str] = None,
        address_key: typing.Optional[str] = None
    ):
        self.address_id = address_id
        self.address_key = address_key

        super().__init__(action="addShippingAddressId")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "BusinessUnitAddShippingAddressIdAction":
        from ._schemas.business_unit import BusinessUnitAddShippingAddressIdActionSchema

        return BusinessUnitAddShippingAddressIdActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.business_unit import BusinessUnitAddShippingAddressIdActionSchema

        return BusinessUnitAddShippingAddressIdActionSchema().dump(self)


class BusinessUnitAddStoreAction(BusinessUnitUpdateAction):
    """Adding a [Store](ctp:api:type:Store) to a [Business Unit](ctp:api:type:BusinessUnit) generates a [BusinessUnitStoreAdded](ctp:api:type:BusinessUnitStoreAddedMessage) Message.
    Only applicable when `storeMode` is `Explicit`.

    """

    #: [Store](ctp:api:type:Store) to add.
    store: "StoreResourceIdentifier"

    def __init__(self, *, store: "StoreResourceIdentifier"):
        self.store = store

        super().__init__(action="addStore")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "BusinessUnitAddStoreAction":
        from ._schemas.business_unit import BusinessUnitAddStoreActionSchema

        return BusinessUnitAddStoreActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.business_unit import BusinessUnitAddStoreActionSchema

        return BusinessUnitAddStoreActionSchema().dump(self)


class BusinessUnitChangeAddressAction(BusinessUnitUpdateAction):
    """Changing the address on a Business Unit generates the [BusinessUnitAddressChanged](ctp:api:type:BusinessUnitAddressChangedMessage) Message."""

    #: ID of the address to change. Either `addressId` or `addressKey` is required.
    address_id: typing.Optional[str]
    #: Key of the address to change. Either `addressId` or `addressKey` is required.
    address_key: typing.Optional[str]
    #: New address to set.
    address: "BaseAddress"

    def __init__(
        self,
        *,
        address_id: typing.Optional[str] = None,
        address_key: typing.Optional[str] = None,
        address: "BaseAddress"
    ):
        self.address_id = address_id
        self.address_key = address_key
        self.address = address

        super().__init__(action="changeAddress")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "BusinessUnitChangeAddressAction":
        from ._schemas.business_unit import BusinessUnitChangeAddressActionSchema

        return BusinessUnitChangeAddressActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.business_unit import BusinessUnitChangeAddressActionSchema

        return BusinessUnitChangeAddressActionSchema().dump(self)


class BusinessUnitChangeAssociateAction(BusinessUnitUpdateAction):
    """Updating the [Associate](ctp:api:type:Associate) on a [Business Unit](ctp:api:type:BusinessUnit) generates the [BusinessUnitAssociateChanged](ctp:api:type:BusinessUnitAssociateChangedMessage) Message."""

    #: New version of an existing Associate.
    associate: "AssociateDraft"

    def __init__(self, *, associate: "AssociateDraft"):
        self.associate = associate

        super().__init__(action="changeAssociate")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "BusinessUnitChangeAssociateAction":
        from ._schemas.business_unit import BusinessUnitChangeAssociateActionSchema

        return BusinessUnitChangeAssociateActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.business_unit import BusinessUnitChangeAssociateActionSchema

        return BusinessUnitChangeAssociateActionSchema().dump(self)


class BusinessUnitChangeAssociateModeAction(BusinessUnitUpdateAction):
    """Only Business Units of type `Division` can be changed to `ExplicitAndFromParent`.
    This update action generates a [BusinessUnitAssociateModeChanged](ctp:api:type:BusinessUnitAssociateModeChangedMessage) Message.

    """

    #: The new value for `associateMode`.
    associate_mode: "BusinessUnitAssociateMode"

    def __init__(self, *, associate_mode: "BusinessUnitAssociateMode"):
        self.associate_mode = associate_mode

        super().__init__(action="changeAssociateMode")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "BusinessUnitChangeAssociateModeAction":
        from ._schemas.business_unit import BusinessUnitChangeAssociateModeActionSchema

        return BusinessUnitChangeAssociateModeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.business_unit import BusinessUnitChangeAssociateModeActionSchema

        return BusinessUnitChangeAssociateModeActionSchema().dump(self)


class BusinessUnitChangeNameAction(BusinessUnitUpdateAction):
    """Updating the name on a [Business Unit](ctp:api:type:BusinessUnit) generates a [BusinessUnitNameChanged](ctp:api:type:BusinessUnitNameChangedMessage) Message."""

    #: New name to set.
    name: str

    def __init__(self, *, name: str):
        self.name = name

        super().__init__(action="changeName")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "BusinessUnitChangeNameAction":
        from ._schemas.business_unit import BusinessUnitChangeNameActionSchema

        return BusinessUnitChangeNameActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.business_unit import BusinessUnitChangeNameActionSchema

        return BusinessUnitChangeNameActionSchema().dump(self)


class BusinessUnitChangeParentUnitAction(BusinessUnitUpdateAction):
    """Changing the parent of a [Business Unit](ctp:api:type:BusinessUnit) generates a [BusinessUnitParentUnitChanged](ctp:api:type:BusinessUnitParentUnitChangedMessage) Message."""

    #: New parent unit of the [Business Unit](ctp:api:type:BusinessUnit).
    parent_unit: "BusinessUnitResourceIdentifier"

    def __init__(self, *, parent_unit: "BusinessUnitResourceIdentifier"):
        self.parent_unit = parent_unit

        super().__init__(action="changeParentUnit")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "BusinessUnitChangeParentUnitAction":
        from ._schemas.business_unit import BusinessUnitChangeParentUnitActionSchema

        return BusinessUnitChangeParentUnitActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.business_unit import BusinessUnitChangeParentUnitActionSchema

        return BusinessUnitChangeParentUnitActionSchema().dump(self)


class BusinessUnitChangeStatusAction(BusinessUnitUpdateAction):
    """Changing the status of a [Business Unit](ctp:api:type:BusinessUnit) generates a [BusinessUnitStatusChanged](ctp:api:type:BusinessUnitStatusChangedMessage) Message."""

    #: New status to set.
    status: str

    def __init__(self, *, status: str):
        self.status = status

        super().__init__(action="changeStatus")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "BusinessUnitChangeStatusAction":
        from ._schemas.business_unit import BusinessUnitChangeStatusActionSchema

        return BusinessUnitChangeStatusActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.business_unit import BusinessUnitChangeStatusActionSchema

        return BusinessUnitChangeStatusActionSchema().dump(self)


class BusinessUnitRemoveAddressAction(BusinessUnitUpdateAction):
    """Removing the address from a [Business Unit](ctp:api:type:BusinessUnit) generates the [BusinessUnitAddressRemoved](ctp:api:type:BusinessUnitAddressRemovedMessage) Message."""

    #: ID of the address to be removed. Either `addressId` or `addressKey` is required.
    address_id: typing.Optional[str]
    #: Key of the address to be removed. Either `addressId` or `addressKey` is required.
    address_key: typing.Optional[str]

    def __init__(
        self,
        *,
        address_id: typing.Optional[str] = None,
        address_key: typing.Optional[str] = None
    ):
        self.address_id = address_id
        self.address_key = address_key

        super().__init__(action="removeAddress")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "BusinessUnitRemoveAddressAction":
        from ._schemas.business_unit import BusinessUnitRemoveAddressActionSchema

        return BusinessUnitRemoveAddressActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.business_unit import BusinessUnitRemoveAddressActionSchema

        return BusinessUnitRemoveAddressActionSchema().dump(self)


class BusinessUnitRemoveAssociateAction(BusinessUnitUpdateAction):
    """Removing an [Associate](ctp:api:type:Associate) from a [Business Unit](ctp:api:type:BusinessUnit) generates a [BusinessUnitAssociateRemoved](ctp:api:type:BusinessUnitAssociateRemovedMessage) Message."""

    #: [Associate](ctp:api:type:Associate) to remove.
    customer: "CustomerResourceIdentifier"

    def __init__(self, *, customer: "CustomerResourceIdentifier"):
        self.customer = customer

        super().__init__(action="removeAssociate")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "BusinessUnitRemoveAssociateAction":
        from ._schemas.business_unit import BusinessUnitRemoveAssociateActionSchema

        return BusinessUnitRemoveAssociateActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.business_unit import BusinessUnitRemoveAssociateActionSchema

        return BusinessUnitRemoveAssociateActionSchema().dump(self)


class BusinessUnitRemoveBillingAddressIdAction(BusinessUnitUpdateAction):
    """Removing a billing address from a [Business Unit](ctp:api:type:BusinessUnit) generates a [BusinessUnitBillingAddressRemoved](ctp:api:type:BusinessUnitBillingAddressRemovedMessage) Message."""

    #: ID of the address to be removed from `billingAddressIds`. Either `addressId` or `addressKey` is required.
    address_id: typing.Optional[str]
    #: Key of the address to be removed from `billingAddressIds`. Either `addressId` or `addressKey` is required.
    address_key: typing.Optional[str]

    def __init__(
        self,
        *,
        address_id: typing.Optional[str] = None,
        address_key: typing.Optional[str] = None
    ):
        self.address_id = address_id
        self.address_key = address_key

        super().__init__(action="removeBillingAddressId")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "BusinessUnitRemoveBillingAddressIdAction":
        from ._schemas.business_unit import (
            BusinessUnitRemoveBillingAddressIdActionSchema,
        )

        return BusinessUnitRemoveBillingAddressIdActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.business_unit import (
            BusinessUnitRemoveBillingAddressIdActionSchema,
        )

        return BusinessUnitRemoveBillingAddressIdActionSchema().dump(self)


class BusinessUnitRemoveShippingAddressIdAction(BusinessUnitUpdateAction):
    """Removing a shipping address from a [Business Unit](ctp:api:type:BusinessUnit) generates a [BusinessUnitShippingAddressRemoved](ctp:api:type:BusinessUnitShippingAddressRemovedMessage) Message."""

    #: ID of the address to be removed from `shippingAddressIds`. Either `addressId` or `addressKey` is required.
    address_id: typing.Optional[str]
    #: Key of the address to be removed from `shippingAddressIds`. Either `addressId` or `addressKey` is required.
    address_key: typing.Optional[str]

    def __init__(
        self,
        *,
        address_id: typing.Optional[str] = None,
        address_key: typing.Optional[str] = None
    ):
        self.address_id = address_id
        self.address_key = address_key

        super().__init__(action="removeShippingAddressId")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "BusinessUnitRemoveShippingAddressIdAction":
        from ._schemas.business_unit import (
            BusinessUnitRemoveShippingAddressIdActionSchema,
        )

        return BusinessUnitRemoveShippingAddressIdActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.business_unit import (
            BusinessUnitRemoveShippingAddressIdActionSchema,
        )

        return BusinessUnitRemoveShippingAddressIdActionSchema().dump(self)


class BusinessUnitRemoveStoreAction(BusinessUnitUpdateAction):
    """Removes a Store from the Business Unit.
    Newly created [Carts](ctp:api:type:Cart) and [Orders](ctp:api:type:Order) can no longer reference the removed Store for the Business Unit.
    We recommend cleaning up unordered Carts that still have the Store assigned after calling this update action since those cannot be converted to Orders.
    Orders created before the Store was removed remain unchanged.
    Generates a [BusinessUnitStoreRemoved](ctp:api:type:BusinessUnitStoreRemovedMessage) Message.
    Only applicable when `storeMode` is `Explicit`.

    """

    #: [Store](ctp:api:type:Store) to remove.
    store: "StoreResourceIdentifier"

    def __init__(self, *, store: "StoreResourceIdentifier"):
        self.store = store

        super().__init__(action="removeStore")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "BusinessUnitRemoveStoreAction":
        from ._schemas.business_unit import BusinessUnitRemoveStoreActionSchema

        return BusinessUnitRemoveStoreActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.business_unit import BusinessUnitRemoveStoreActionSchema

        return BusinessUnitRemoveStoreActionSchema().dump(self)


class BusinessUnitSetAddressCustomFieldAction(BusinessUnitUpdateAction):
    #: ID of the address to be extended.
    address_id: str
    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: Trying to remove a field that does not exist will fail with an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
    #: If `value` is provided, it is set for the field defined by `name`.
    value: typing.Optional[typing.Any]

    def __init__(
        self, *, address_id: str, name: str, value: typing.Optional[typing.Any] = None
    ):
        self.address_id = address_id
        self.name = name
        self.value = value

        super().__init__(action="setAddressCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "BusinessUnitSetAddressCustomFieldAction":
        from ._schemas.business_unit import (
            BusinessUnitSetAddressCustomFieldActionSchema,
        )

        return BusinessUnitSetAddressCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.business_unit import (
            BusinessUnitSetAddressCustomFieldActionSchema,
        )

        return BusinessUnitSetAddressCustomFieldActionSchema().dump(self)


class BusinessUnitSetAddressCustomTypeAction(BusinessUnitUpdateAction):
    #: Defines the [Type](ctp:api:type:Type) that extends the `address` with [Custom Fields](/../api/projects/custom-fields).
    #: If absent, any existing Type and Custom Fields are removed from the `address`.
    type: typing.Optional["TypeResourceIdentifier"]
    #: Sets the [Custom Fields](/../api/projects/custom-fields) for the `address`.
    fields: typing.Optional["FieldContainer"]
    #: ID of the address to be extended.
    address_id: str

    def __init__(
        self,
        *,
        type: typing.Optional["TypeResourceIdentifier"] = None,
        fields: typing.Optional["FieldContainer"] = None,
        address_id: str
    ):
        self.type = type
        self.fields = fields
        self.address_id = address_id

        super().__init__(action="setAddressCustomType")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "BusinessUnitSetAddressCustomTypeAction":
        from ._schemas.business_unit import BusinessUnitSetAddressCustomTypeActionSchema

        return BusinessUnitSetAddressCustomTypeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.business_unit import BusinessUnitSetAddressCustomTypeActionSchema

        return BusinessUnitSetAddressCustomTypeActionSchema().dump(self)


class BusinessUnitSetAssociatesAction(BusinessUnitUpdateAction):
    """Changes the Associates of a [Business Unit](ctp:api:type:BusinessUnit), generates a [BusinessUnitAssociatesSet](ctp:api:type:BusinessUnitAssociatesSetMessage) Message."""

    #: The new list of Associates. If not provided, any existing list is removed.
    associates: typing.List["AssociateDraft"]

    def __init__(self, *, associates: typing.List["AssociateDraft"]):
        self.associates = associates

        super().__init__(action="setAssociates")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "BusinessUnitSetAssociatesAction":
        from ._schemas.business_unit import BusinessUnitSetAssociatesActionSchema

        return BusinessUnitSetAssociatesActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.business_unit import BusinessUnitSetAssociatesActionSchema

        return BusinessUnitSetAssociatesActionSchema().dump(self)


class BusinessUnitSetContactEmailAction(BusinessUnitUpdateAction):
    """Setting the contact email on a [Business Unit](ctp:api:type:BusinessUnit) generates a [BusinessUnitContactEmailSet](ctp:api:type:BusinessUnitContactEmailSetMessage) Message."""

    #: Email to set.
    #: If `contactEmail` is absent or `null`, the existing contact email, if any, will be removed.
    contact_email: typing.Optional[str]

    def __init__(self, *, contact_email: typing.Optional[str] = None):
        self.contact_email = contact_email

        super().__init__(action="setContactEmail")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "BusinessUnitSetContactEmailAction":
        from ._schemas.business_unit import BusinessUnitSetContactEmailActionSchema

        return BusinessUnitSetContactEmailActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.business_unit import BusinessUnitSetContactEmailActionSchema

        return BusinessUnitSetContactEmailActionSchema().dump(self)


class BusinessUnitSetCustomFieldAction(BusinessUnitUpdateAction):
    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: Trying to remove a field that does not exist will fail with an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
    #: If `value` is provided, it is set for the field defined by `name`.
    value: typing.Optional[typing.Any]

    def __init__(self, *, name: str, value: typing.Optional[typing.Any] = None):
        self.name = name
        self.value = value

        super().__init__(action="setCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "BusinessUnitSetCustomFieldAction":
        from ._schemas.business_unit import BusinessUnitSetCustomFieldActionSchema

        return BusinessUnitSetCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.business_unit import BusinessUnitSetCustomFieldActionSchema

        return BusinessUnitSetCustomFieldActionSchema().dump(self)


class BusinessUnitSetCustomTypeAction(BusinessUnitUpdateAction):
    #: Defines the [Type](ctp:api:type:Type) that extends the BusinessUnit with [Custom Fields](/../api/projects/custom-fields).
    #: If absent, any existing Type and Custom Fields are removed from the BusinessUnit.
    type: typing.Optional["TypeResourceIdentifier"]
    #: Sets the [Custom Fields](/../api/projects/custom-fields) for the BusinessUnit.
    fields: typing.Optional["FieldContainer"]

    def __init__(
        self,
        *,
        type: typing.Optional["TypeResourceIdentifier"] = None,
        fields: typing.Optional["FieldContainer"] = None
    ):
        self.type = type
        self.fields = fields

        super().__init__(action="setCustomType")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "BusinessUnitSetCustomTypeAction":
        from ._schemas.business_unit import BusinessUnitSetCustomTypeActionSchema

        return BusinessUnitSetCustomTypeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.business_unit import BusinessUnitSetCustomTypeActionSchema

        return BusinessUnitSetCustomTypeActionSchema().dump(self)


class BusinessUnitSetDefaultBillingAddressAction(BusinessUnitUpdateAction):
    """Setting the default billing address on a [Business Unit](ctp:api:type:BusinessUnit) generates the [BusinessUnitDefaultBillingAddressSet](ctp:api:type:BusinessUnitDefaultBillingAddressSetMessage) Message."""

    #: ID of the address to add as a billing address. Either `addressId` or `addressKey` is required.
    address_id: typing.Optional[str]
    #: Key of the address to add as a billing address. Either `addressId` or `addressKey` is required.
    address_key: typing.Optional[str]

    def __init__(
        self,
        *,
        address_id: typing.Optional[str] = None,
        address_key: typing.Optional[str] = None
    ):
        self.address_id = address_id
        self.address_key = address_key

        super().__init__(action="setDefaultBillingAddress")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "BusinessUnitSetDefaultBillingAddressAction":
        from ._schemas.business_unit import (
            BusinessUnitSetDefaultBillingAddressActionSchema,
        )

        return BusinessUnitSetDefaultBillingAddressActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.business_unit import (
            BusinessUnitSetDefaultBillingAddressActionSchema,
        )

        return BusinessUnitSetDefaultBillingAddressActionSchema().dump(self)


class BusinessUnitSetDefaultShippingAddressAction(BusinessUnitUpdateAction):
    """Setting the default shipping address on a [Business Unit](ctp:api:type:BusinessUnit) generates a [BusinessUnitDefaultShippingAddressSet](ctp:api:type:BusinessUnitDefaultShippingAddressSetMessage) Message."""

    #: ID of the address to add as a shipping address. Either `addressId` or `addressKey` is required.
    address_id: typing.Optional[str]
    #: Key of the address to add as a shipping address. Either `addressId` or `addressKey` is required.
    address_key: typing.Optional[str]

    def __init__(
        self,
        *,
        address_id: typing.Optional[str] = None,
        address_key: typing.Optional[str] = None
    ):
        self.address_id = address_id
        self.address_key = address_key

        super().__init__(action="setDefaultShippingAddress")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "BusinessUnitSetDefaultShippingAddressAction":
        from ._schemas.business_unit import (
            BusinessUnitSetDefaultShippingAddressActionSchema,
        )

        return BusinessUnitSetDefaultShippingAddressActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.business_unit import (
            BusinessUnitSetDefaultShippingAddressActionSchema,
        )

        return BusinessUnitSetDefaultShippingAddressActionSchema().dump(self)


class BusinessUnitSetStoreModeAction(BusinessUnitUpdateAction):
    """Only Business Units of type `Division` can be have a store mode of `FromParent`. Changing the `storeMode` to `FromParent` empties the `stores` array on the BusinessUnit.
    This update action generates a [BusinessUnitStoreModeChanged](ctp:api:type:BusinessUnitStoreModeChangedMessage) Message.

    """

    #: Set to `Explicit` to specify Stores for the Business Unit. Set to `FromParent` to inherit Stores from a parent.
    store_mode: "BusinessUnitStoreMode"
    #: Set the [Stores](ctp:api:type:Store) the Business Unit is associated with. Can only be set if `storeMode` is `Explicit`.
    stores: typing.Optional[typing.List["StoreResourceIdentifier"]]

    def __init__(
        self,
        *,
        store_mode: "BusinessUnitStoreMode",
        stores: typing.Optional[typing.List["StoreResourceIdentifier"]] = None
    ):
        self.store_mode = store_mode
        self.stores = stores

        super().__init__(action="setStoreMode")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "BusinessUnitSetStoreModeAction":
        from ._schemas.business_unit import BusinessUnitSetStoreModeActionSchema

        return BusinessUnitSetStoreModeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.business_unit import BusinessUnitSetStoreModeActionSchema

        return BusinessUnitSetStoreModeActionSchema().dump(self)


class BusinessUnitSetStoresAction(BusinessUnitUpdateAction):
    """Sets the Stores of the Business Unit. Can only be set if the Business Unit `storeMode` is `Explicit`.
    [Carts](ctp:api:type:Cart) and [Orders](ctp:api:type:Order) created after the Set Stores update must use the new Stores of
    the Business Unit and, if set, their [Product Selections](ctp:api:type:ProductSelection), and [Channels](ctp:api:type:Channel).
    Orders created before the Set Stores update action remain unchanged.
    Setting the Stores on a Business Unit generates a [BusinessUnitStoresSet](ctp:api:type:BusinessUnitStoresSetMessage) Message.

    """

    #: [Stores](ctp:api:type:Store) to set. Overrides the current list of Stores.
    stores: typing.Optional[typing.List["StoreResourceIdentifier"]]

    def __init__(
        self, *, stores: typing.Optional[typing.List["StoreResourceIdentifier"]] = None
    ):
        self.stores = stores

        super().__init__(action="setStores")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "BusinessUnitSetStoresAction":
        from ._schemas.business_unit import BusinessUnitSetStoresActionSchema

        return BusinessUnitSetStoresActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.business_unit import BusinessUnitSetStoresActionSchema

        return BusinessUnitSetStoresActionSchema().dump(self)
