# This file is automatically generated by the rmf-codegen project.
#
# The Python code generator is maintained by Lab Digital. If you want to
# contribute to this project then please do not edit this file directly
# but send a pull request to the Lab Digital fork of rmf-codegen at
# https://github.com/labd/rmf-codegen

import datetime
import enum
import typing

from ._abstract import _BaseType
from .common import BaseResource, Reference, ReferenceTypeId, ResourceIdentifier

if typing.TYPE_CHECKING:
    from .business_unit import BusinessUnitKeyReference, BusinessUnitResourceIdentifier
    from .cart_discount import (
        CartDiscountReference,
        CartDiscountTarget,
        CartDiscountValue,
    )
    from .channel import ChannelReference, ChannelResourceIdentifier
    from .common import (
        Address,
        BaseAddress,
        CentPrecisionMoney,
        CreatedBy,
        LastModifiedBy,
        LocalizedString,
        Money,
        Price,
        Reference,
        ReferenceTypeId,
        TypedMoney,
    )
    from .customer_group import CustomerGroupReference, CustomerGroupResourceIdentifier
    from .discount_code import DiscountCodeReference
    from .order import Delivery, DeliveryDraft, ItemState, OrderReference, PaymentInfo
    from .payment import PaymentResourceIdentifier
    from .product import ProductVariant
    from .product_type import ProductTypeReference
    from .shipping_method import (
        ShippingMethodReference,
        ShippingMethodResourceIdentifier,
        ShippingRate,
        ShippingRateDraft,
    )
    from .shopping_list import ShoppingListResourceIdentifier
    from .store import StoreKeyReference, StoreResourceIdentifier
    from .tax_category import (
        SubRate,
        TaxCategoryReference,
        TaxCategoryResourceIdentifier,
        TaxRate,
    )
    from .type import (
        CustomFields,
        CustomFieldsDraft,
        FieldContainer,
        TypeResourceIdentifier,
    )

__all__ = [
    "Cart",
    "CartAddCustomLineItemAction",
    "CartAddCustomShippingMethodAction",
    "CartAddDiscountCodeAction",
    "CartAddItemShippingAddressAction",
    "CartAddLineItemAction",
    "CartAddPaymentAction",
    "CartAddShippingMethodAction",
    "CartAddShoppingListAction",
    "CartApplyDeltaToCustomLineItemShippingDetailsTargetsAction",
    "CartApplyDeltaToLineItemShippingDetailsTargetsAction",
    "CartChangeCustomLineItemMoneyAction",
    "CartChangeCustomLineItemPriceModeAction",
    "CartChangeCustomLineItemQuantityAction",
    "CartChangeLineItemQuantityAction",
    "CartChangeTaxCalculationModeAction",
    "CartChangeTaxModeAction",
    "CartChangeTaxRoundingModeAction",
    "CartDraft",
    "CartFreezeCartAction",
    "CartOrigin",
    "CartPagedQueryResponse",
    "CartRecalculateAction",
    "CartReference",
    "CartRemoveCustomLineItemAction",
    "CartRemoveDiscountCodeAction",
    "CartRemoveItemShippingAddressAction",
    "CartRemoveLineItemAction",
    "CartRemovePaymentAction",
    "CartRemoveShippingMethodAction",
    "CartResourceIdentifier",
    "CartSetAnonymousIdAction",
    "CartSetBillingAddressAction",
    "CartSetBillingAddressCustomFieldAction",
    "CartSetBillingAddressCustomTypeAction",
    "CartSetBusinessUnitAction",
    "CartSetCartTotalTaxAction",
    "CartSetCountryAction",
    "CartSetCustomFieldAction",
    "CartSetCustomLineItemCustomFieldAction",
    "CartSetCustomLineItemCustomTypeAction",
    "CartSetCustomLineItemShippingDetailsAction",
    "CartSetCustomLineItemTaxAmountAction",
    "CartSetCustomLineItemTaxRateAction",
    "CartSetCustomShippingMethodAction",
    "CartSetCustomTypeAction",
    "CartSetCustomerEmailAction",
    "CartSetCustomerGroupAction",
    "CartSetCustomerIdAction",
    "CartSetDeleteDaysAfterLastModificationAction",
    "CartSetDeliveryAddressCustomFieldAction",
    "CartSetDeliveryAddressCustomTypeAction",
    "CartSetDirectDiscountsAction",
    "CartSetItemShippingAddressCustomFieldAction",
    "CartSetItemShippingAddressCustomTypeAction",
    "CartSetKeyAction",
    "CartSetLineItemCustomFieldAction",
    "CartSetLineItemCustomTypeAction",
    "CartSetLineItemDistributionChannelAction",
    "CartSetLineItemInventoryModeAction",
    "CartSetLineItemPriceAction",
    "CartSetLineItemShippingDetailsAction",
    "CartSetLineItemSupplyChannelAction",
    "CartSetLineItemTaxAmountAction",
    "CartSetLineItemTaxRateAction",
    "CartSetLineItemTotalPriceAction",
    "CartSetLocaleAction",
    "CartSetShippingAddressAction",
    "CartSetShippingAddressCustomFieldAction",
    "CartSetShippingAddressCustomTypeAction",
    "CartSetShippingCustomFieldAction",
    "CartSetShippingCustomTypeAction",
    "CartSetShippingMethodAction",
    "CartSetShippingMethodTaxAmountAction",
    "CartSetShippingMethodTaxRateAction",
    "CartSetShippingRateInputAction",
    "CartState",
    "CartUnfreezeCartAction",
    "CartUpdate",
    "CartUpdateAction",
    "CartUpdateItemShippingAddressAction",
    "ClassificationShippingRateInput",
    "ClassificationShippingRateInputDraft",
    "CustomLineItem",
    "CustomLineItemDraft",
    "CustomLineItemImportDraft",
    "CustomLineItemPriceMode",
    "CustomShippingDraft",
    "DirectDiscount",
    "DirectDiscountDraft",
    "DirectDiscountReference",
    "DiscountCodeInfo",
    "DiscountCodeState",
    "DiscountedLineItemPortion",
    "DiscountedLineItemPrice",
    "DiscountedLineItemPriceForQuantity",
    "ExternalLineItemTotalPrice",
    "ExternalTaxAmountDraft",
    "ExternalTaxRateDraft",
    "InventoryMode",
    "ItemShippingDetails",
    "ItemShippingDetailsDraft",
    "ItemShippingTarget",
    "LineItem",
    "LineItemDraft",
    "LineItemMode",
    "LineItemPriceMode",
    "MethodTaxRate",
    "MethodTaxedPrice",
    "ProductPublishScope",
    "ReplicaCartDraft",
    "RoundingMode",
    "ScoreShippingRateInput",
    "ScoreShippingRateInputDraft",
    "Shipping",
    "ShippingDraft",
    "ShippingInfo",
    "ShippingMethodState",
    "ShippingMode",
    "ShippingRateInput",
    "ShippingRateInputDraft",
    "TaxCalculationMode",
    "TaxMode",
    "TaxPortion",
    "TaxPortionDraft",
    "TaxedItemPrice",
    "TaxedPrice",
    "TaxedPriceDraft",
]


class Cart(BaseResource):
    #: User-defined unique identifier of the Cart.
    key: typing.Optional[str]
    #: `id` of the [Customer](ctp:api:type:Customer) that the Cart belongs to.
    customer_id: typing.Optional[str]
    #: Email address of the Customer that the Cart belongs to.
    customer_email: typing.Optional[str]
    #: [Reference](ctp:api:type:Reference) to the Customer Group of the Customer that the Cart belongs to. Used for [LineItem Price selection](ctp:api:type:LineItemPriceSelection).
    customer_group: typing.Optional["CustomerGroupReference"]
    #: [Anonymous session](ctp:api:type:AnonymousSession) associated with the Cart.
    anonymous_id: typing.Optional[str]
    #: [Reference](ctp:api:type:Reference) to a Business Unit the Cart belongs to.
    business_unit: typing.Optional["BusinessUnitKeyReference"]
    #: [Reference](ctp:api:type:Reference) to a Store the Cart belongs to.
    store: typing.Optional["StoreKeyReference"]
    #: [Line Items](ctp:api:type:LineItems) added to the Cart.
    line_items: typing.List["LineItem"]
    #: [Custom Line Items](ctp:api:type:CustomLineItems) added to the Cart.
    custom_line_items: typing.List["CustomLineItem"]
    #: Sum of all [LineItem](ctp:api:type:LineItem) quantities, excluding [CustomLineItems](ctp:api:type:CustomLineItem). Only present when the Cart has at least one LineItem.
    total_line_item_quantity: typing.Optional[int]
    #: Sum of the `totalPrice` field of all [LineItems](ctp:api:type:LineItem) and [CustomLineItems](ctp:api:type:CustomLineItem), and if available, the `price` field of [ShippingInfo](ctp:api:type:ShippingInfo).
    #:
    #: Taxes are included if [TaxRate](ctp:api:type:TaxRate) `includedInPrice` is `true` for each price.
    total_price: "CentPrecisionMoney"
    #: - For a Cart with `Platform` [TaxMode](ctp:api:type:TaxMode), it is automatically set when a [shipping address is set](ctp:api:type:CartSetShippingAddressAction).
    #: - For a Cart with `External` [TaxMode](ctp:api:type:TaxMode), it is automatically set when the external Tax Rate for all Line Items, Custom Line Items, and Shipping Methods in the Cart are set.
    taxed_price: typing.Optional["TaxedPrice"]
    #: Sum of the `taxedPrice` field of [ShippingInfo](ctp:api:type:ShippingInfo) across all Shipping Methods.
    taxed_shipping_price: typing.Optional["TaxedPrice"]
    #: Indicates how Tax Rates are set.
    tax_mode: "TaxMode"
    #: Indicates how monetary values are rounded when calculating taxes for `taxedPrice`.
    tax_rounding_mode: "RoundingMode"
    #: Indicates how taxes are calculated when calculating taxes for `taxedPrice`.
    tax_calculation_mode: "TaxCalculationMode"
    #: Indicates how stock quantities are tracked for Line Items in the Cart.
    inventory_mode: "InventoryMode"
    #: Current status of the Cart.
    cart_state: "CartState"
    #: Billing address associated with the Cart.
    billing_address: typing.Optional["Address"]
    #: Shipping address associated with the Cart. Determines eligible [ShippingMethod](ctp:api:type:ShippingMethod) rates and Tax Rates of Line Items.
    shipping_address: typing.Optional["Address"]
    #: Indicates whether the Cart has one or multiple Shipping Methods.
    shipping_mode: "ShippingMode"
    #: User-defined unique identifier of the Shipping Method in a Cart with `Single` [ShippingMode](ctp:api:type:ShippingMode).
    shipping_key: typing.Optional[str]
    #: Shipping-related information of a Cart with `Single` [ShippingMode](ctp:api:type:ShippingMode). Automatically set when a [Shipping Method is set](ctp:api:type:CartSetShippingMethodAction).
    shipping_info: typing.Optional["ShippingInfo"]
    #: Input used to select a [ShippingRatePriceTier](ctp:api:type:ShippingRatePriceTier).
    #: The data type of this field depends on the `shippingRateInputType.type` configured in the [Project](ctp:api:type:Project):
    #:
    #: - If `CartClassification`, it is [ClassificationShippingRateInput](ctp:api:type:ClassificationShippingRateInput).
    #: - If `CartScore`, it is [ScoreShippingRateInput](ctp:api:type:ScoreShippingRateInput).
    #: - If `CartValue`, it cannot be used.
    shipping_rate_input: typing.Optional["ShippingRateInput"]
    #: Custom Fields of the Shipping Method in a Cart with `Single` [ShippingMode](ctp:api:type:ShippingMode).
    shipping_custom_fields: typing.Optional["CustomFields"]
    #: Shipping-related information of a Cart with `Multiple` [ShippingMode](ctp:api:type:ShippingMode). Updated automatically each time a new [Shipping Method is added](ctp:api:type:CartAddShippingMethodAction).
    shipping: typing.List["Shipping"]
    #: Additional shipping addresses of the Cart as specified by [LineItems](ctp:api:type:LineItem) using the `shippingDetails` field.
    #:
    #: Eligible Shipping Methods or applicable Tax Rates are determined by the address in `shippingAddress`, and not `itemShippingAddresses`.
    item_shipping_addresses: typing.List["Address"]
    #: Discount Codes applied to the Cart. A Cart that has `directDiscounts` cannot have `discountCodes`.
    discount_codes: typing.List["DiscountCodeInfo"]
    #: Direct Discounts added to the Cart. A Cart that has `discountCodes` cannot have `directDiscounts`.
    direct_discounts: typing.List["DirectDiscount"]
    #: Automatically set when a Line Item with `GiftLineItem` [LineItemMode](ctp:api:type:LineItemMode) is [removed](ctp:api:type:CartRemoveLineItemAction) from the Cart.
    refused_gifts: typing.List["CartDiscountReference"]
    #: Payment information related to the Cart.
    payment_info: typing.Optional["PaymentInfo"]
    #: Used for [LineItem Price selection](ctp:api:type:LineItemPriceSelection).
    country: typing.Optional[str]
    #: Languages of the Cart. Can only contain languages supported by the [Project](ctp:api:type:Project).
    locale: typing.Optional[str]
    #: Indicates how the Cart was created.
    origin: "CartOrigin"
    #: Custom Fields of the Cart.
    custom: typing.Optional["CustomFields"]
    #: Number of days after which an active Cart is deleted since its last modification. Configured in [Project settings](ctp:api:type:CartsConfiguration).
    delete_days_after_last_modification: typing.Optional[int]
    #: Present on resources updated after 1 February 2019 except for [events not tracked](/../api/client-logging#events-tracked).
    last_modified_by: typing.Optional["LastModifiedBy"]
    #: Present on resources created after 1 February 2019 except for [events not tracked](/../api/client-logging#events-tracked).
    created_by: typing.Optional["CreatedBy"]

    def __init__(
        self,
        *,
        id: str,
        version: int,
        created_at: datetime.datetime,
        last_modified_at: datetime.datetime,
        key: typing.Optional[str] = None,
        customer_id: typing.Optional[str] = None,
        customer_email: typing.Optional[str] = None,
        customer_group: typing.Optional["CustomerGroupReference"] = None,
        anonymous_id: typing.Optional[str] = None,
        business_unit: typing.Optional["BusinessUnitKeyReference"] = None,
        store: typing.Optional["StoreKeyReference"] = None,
        line_items: typing.List["LineItem"],
        custom_line_items: typing.List["CustomLineItem"],
        total_line_item_quantity: typing.Optional[int] = None,
        total_price: "CentPrecisionMoney",
        taxed_price: typing.Optional["TaxedPrice"] = None,
        taxed_shipping_price: typing.Optional["TaxedPrice"] = None,
        tax_mode: "TaxMode",
        tax_rounding_mode: "RoundingMode",
        tax_calculation_mode: "TaxCalculationMode",
        inventory_mode: "InventoryMode",
        cart_state: "CartState",
        billing_address: typing.Optional["Address"] = None,
        shipping_address: typing.Optional["Address"] = None,
        shipping_mode: "ShippingMode",
        shipping_key: typing.Optional[str] = None,
        shipping_info: typing.Optional["ShippingInfo"] = None,
        shipping_rate_input: typing.Optional["ShippingRateInput"] = None,
        shipping_custom_fields: typing.Optional["CustomFields"] = None,
        shipping: typing.List["Shipping"],
        item_shipping_addresses: typing.List["Address"],
        discount_codes: typing.List["DiscountCodeInfo"],
        direct_discounts: typing.List["DirectDiscount"],
        refused_gifts: typing.List["CartDiscountReference"],
        payment_info: typing.Optional["PaymentInfo"] = None,
        country: typing.Optional[str] = None,
        locale: typing.Optional[str] = None,
        origin: "CartOrigin",
        custom: typing.Optional["CustomFields"] = None,
        delete_days_after_last_modification: typing.Optional[int] = None,
        last_modified_by: typing.Optional["LastModifiedBy"] = None,
        created_by: typing.Optional["CreatedBy"] = None
    ):
        self.key = key
        self.customer_id = customer_id
        self.customer_email = customer_email
        self.customer_group = customer_group
        self.anonymous_id = anonymous_id
        self.business_unit = business_unit
        self.store = store
        self.line_items = line_items
        self.custom_line_items = custom_line_items
        self.total_line_item_quantity = total_line_item_quantity
        self.total_price = total_price
        self.taxed_price = taxed_price
        self.taxed_shipping_price = taxed_shipping_price
        self.tax_mode = tax_mode
        self.tax_rounding_mode = tax_rounding_mode
        self.tax_calculation_mode = tax_calculation_mode
        self.inventory_mode = inventory_mode
        self.cart_state = cart_state
        self.billing_address = billing_address
        self.shipping_address = shipping_address
        self.shipping_mode = shipping_mode
        self.shipping_key = shipping_key
        self.shipping_info = shipping_info
        self.shipping_rate_input = shipping_rate_input
        self.shipping_custom_fields = shipping_custom_fields
        self.shipping = shipping
        self.item_shipping_addresses = item_shipping_addresses
        self.discount_codes = discount_codes
        self.direct_discounts = direct_discounts
        self.refused_gifts = refused_gifts
        self.payment_info = payment_info
        self.country = country
        self.locale = locale
        self.origin = origin
        self.custom = custom
        self.delete_days_after_last_modification = delete_days_after_last_modification
        self.last_modified_by = last_modified_by
        self.created_by = created_by

        super().__init__(
            id=id,
            version=version,
            created_at=created_at,
            last_modified_at=last_modified_at,
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "Cart":
        from ._schemas.cart import CartSchema

        return CartSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartSchema

        return CartSchema().dump(self)


class CartDraft(_BaseType):
    #: Currency the Cart uses.
    currency: str
    #: User-defined unique identifier for the Cart.
    key: typing.Optional[str]
    #: `id` of the [Customer](ctp:api:type:Customer) that the Cart belongs to.
    customer_id: typing.Optional[str]
    #: Email address of the Customer that the Cart belongs to.
    customer_email: typing.Optional[str]
    #: [ResourceIdentifier](ctp:api:type:ResourceIdentifier) to the Customer Group of the Customer that the Cart belongs to. Used for [LineItem Price selection](ctp:api:type:LineItemPriceSelection).
    #:
    #: It is automatically set if the Customer referenced in `customerId` belongs to a Customer Group.
    #: It can also be set explicitly when no `customerId` is present.
    customer_group: typing.Optional["CustomerGroupResourceIdentifier"]
    #: [Anonymous session](ctp:api:type:AnonymousSession) associated with the Cart.
    anonymous_id: typing.Optional[str]
    #: [ResourceIdentifier](ctp:api:type:ResourceIdentifier) to the Business Unit the Cart should belong to. When the `customerId` of the Cart is also set, the [Customer](ctp:api:type:Customer) must be an [Associate](ctp:api:type:Associate) of the Business Unit.
    business_unit: typing.Optional["BusinessUnitResourceIdentifier"]
    #: [ResourceIdentifier](ctp:api:type:ResourceIdentifier) to the Store the Cart should belong to. Once set, it cannot be updated.
    store: typing.Optional["StoreResourceIdentifier"]
    #: [Line Items](ctp:api:type:LineItems) to add to the Cart.
    line_items: typing.Optional[typing.List["LineItemDraft"]]
    #: [Custom Line Items](ctp:api:type:CustomLineItems) to add to the Cart.
    custom_line_items: typing.Optional[typing.List["CustomLineItemDraft"]]
    #: Determines how Tax Rates are set.
    tax_mode: typing.Optional["TaxMode"]
    #: External Tax Rate for the `shippingMethod` if the Cart has `External` [TaxMode](ctp:api:type:TaxMode).
    external_tax_rate_for_shipping_method: typing.Optional["ExternalTaxRateDraft"]
    #: Determines how monetary values are rounded when calculating taxes for `taxedPrice`.
    tax_rounding_mode: typing.Optional["RoundingMode"]
    #: Determines how taxes are calculated when calculating taxes for `taxedPrice`.
    tax_calculation_mode: typing.Optional["TaxCalculationMode"]
    #: Determines how stock quantities are tracked for Line Items in the Cart.
    inventory_mode: typing.Optional["InventoryMode"]
    #: Billing address associated with the Cart.
    billing_address: typing.Optional["BaseAddress"]
    #: Shipping address associated with the Cart. Determines eligible [ShippingMethod](ctp:api:type:ShippingMethod) rates and Tax Rates of Line Items.
    shipping_address: typing.Optional["BaseAddress"]
    #: Shipping Method for a Cart with `Single` [ShippingMode](ctp:api:type:ShippingMode). If the referenced [ShippingMethod](ctp:api:type:ShippingMethod) has a `predicate` that does not match the Cart, an [InvalidOperation](ctp:api:type:InvalidOperationError) error is returned when [creating a Cart](ctp:api:endpoint:/{projectKey}/carts:POST).
    shipping_method: typing.Optional["ShippingMethodResourceIdentifier"]
    #: Used as an input to select a [ShippingRatePriceTier](ctp:api:type:ShippingRatePriceTier).
    #: The data type of this field depends on the `shippingRateInputType.type` configured in the [Project](ctp:api:type:Project):
    #:
    #: - If `CartClassification`, it must be [ClassificationShippingRateInputDraft](ctp:api:type:ClassificationShippingRateInputDraft).
    #: - If `CartScore`, it must be [ScoreShippingRateInputDraft](ctp:api:type:ScoreShippingRateInputDraft).
    #: - If `CartValue`, it cannot be set.
    shipping_rate_input: typing.Optional["ShippingRateInputDraft"]
    #: - If set to `Single`, only a single Shipping Method can be added to the Cart.
    #: - If set to `Multiple`, multiple Shipping Methods can be added to the Cart.
    shipping_mode: typing.Optional["ShippingMode"]
    #: Custom Shipping Methods for a Cart with `Multiple` [ShippingMode](ctp:api:type:ShippingMode).
    custom_shipping: typing.Optional[typing.List["CustomShippingDraft"]]
    #: Shipping Methods for a Cart with `Multiple` [ShippingMode](ctp:api:type:ShippingMode).
    shipping: typing.Optional[typing.List["ShippingDraft"]]
    #: Multiple shipping addresses of the Cart. Each address must contain a `key` that is unique in this Cart.
    #: The keys are used by [LineItems](ctp:api:type:LineItem) to reference these addresses under their `shippingDetails`.
    #:
    #: Eligible Shipping Methods or applicable Tax Rates are determined by the address `shippingAddress`, and not `itemShippingAddresses`.
    item_shipping_addresses: typing.Optional[typing.List["BaseAddress"]]
    #: `code` of the existing [DiscountCodes](ctp:api:type:DiscountCode) to add to the Cart.
    discount_codes: typing.Optional[typing.List["str"]]
    #: Used for [LineItem Price selection](ctp:api:type:LineItemPriceSelection).
    #: If used for [Create Cart in Store](ctp:api:endpoint:/{projectKey}/in-store/carts:POST), the provided country must be one of the [Store's](ctp:api:type:Store) `countries`.
    country: typing.Optional[str]
    #: Languages of the Cart. Can only contain languages supported by the [Project](ctp:api:type:Project).
    locale: typing.Optional[str]
    #: Indicates how the Cart was created.
    origin: typing.Optional["CartOrigin"]
    #: Number of days after which an active Cart is deleted since its last modification.
    #: If not provided, the default value for this field configured in [Project settings](ctp:api:type:CartsConfiguration) is assigned.
    #:
    #: Create a [ChangeSubscription](ctp:api:type:ChangeSubscription) for Carts to receive a [ResourceDeletedDeliveryPayload](ctp:api:type:ResourceDeletedDeliveryPayload) upon deletion of the Cart.
    delete_days_after_last_modification: typing.Optional[int]
    #: Custom Fields for the Cart.
    custom: typing.Optional["CustomFieldsDraft"]

    def __init__(
        self,
        *,
        currency: str,
        key: typing.Optional[str] = None,
        customer_id: typing.Optional[str] = None,
        customer_email: typing.Optional[str] = None,
        customer_group: typing.Optional["CustomerGroupResourceIdentifier"] = None,
        anonymous_id: typing.Optional[str] = None,
        business_unit: typing.Optional["BusinessUnitResourceIdentifier"] = None,
        store: typing.Optional["StoreResourceIdentifier"] = None,
        line_items: typing.Optional[typing.List["LineItemDraft"]] = None,
        custom_line_items: typing.Optional[typing.List["CustomLineItemDraft"]] = None,
        tax_mode: typing.Optional["TaxMode"] = None,
        external_tax_rate_for_shipping_method: typing.Optional[
            "ExternalTaxRateDraft"
        ] = None,
        tax_rounding_mode: typing.Optional["RoundingMode"] = None,
        tax_calculation_mode: typing.Optional["TaxCalculationMode"] = None,
        inventory_mode: typing.Optional["InventoryMode"] = None,
        billing_address: typing.Optional["BaseAddress"] = None,
        shipping_address: typing.Optional["BaseAddress"] = None,
        shipping_method: typing.Optional["ShippingMethodResourceIdentifier"] = None,
        shipping_rate_input: typing.Optional["ShippingRateInputDraft"] = None,
        shipping_mode: typing.Optional["ShippingMode"] = None,
        custom_shipping: typing.Optional[typing.List["CustomShippingDraft"]] = None,
        shipping: typing.Optional[typing.List["ShippingDraft"]] = None,
        item_shipping_addresses: typing.Optional[typing.List["BaseAddress"]] = None,
        discount_codes: typing.Optional[typing.List["str"]] = None,
        country: typing.Optional[str] = None,
        locale: typing.Optional[str] = None,
        origin: typing.Optional["CartOrigin"] = None,
        delete_days_after_last_modification: typing.Optional[int] = None,
        custom: typing.Optional["CustomFieldsDraft"] = None
    ):
        self.currency = currency
        self.key = key
        self.customer_id = customer_id
        self.customer_email = customer_email
        self.customer_group = customer_group
        self.anonymous_id = anonymous_id
        self.business_unit = business_unit
        self.store = store
        self.line_items = line_items
        self.custom_line_items = custom_line_items
        self.tax_mode = tax_mode
        self.external_tax_rate_for_shipping_method = (
            external_tax_rate_for_shipping_method
        )
        self.tax_rounding_mode = tax_rounding_mode
        self.tax_calculation_mode = tax_calculation_mode
        self.inventory_mode = inventory_mode
        self.billing_address = billing_address
        self.shipping_address = shipping_address
        self.shipping_method = shipping_method
        self.shipping_rate_input = shipping_rate_input
        self.shipping_mode = shipping_mode
        self.custom_shipping = custom_shipping
        self.shipping = shipping
        self.item_shipping_addresses = item_shipping_addresses
        self.discount_codes = discount_codes
        self.country = country
        self.locale = locale
        self.origin = origin
        self.delete_days_after_last_modification = delete_days_after_last_modification
        self.custom = custom

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CartDraft":
        from ._schemas.cart import CartDraftSchema

        return CartDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartDraftSchema

        return CartDraftSchema().dump(self)


class CartOrigin(enum.Enum):
    """Indicates who created the Cart."""

    CUSTOMER = "Customer"
    MERCHANT = "Merchant"
    QUOTE = "Quote"


class CartPagedQueryResponse(_BaseType):
    """[PagedQueryResult](/../api/general-concepts#pagedqueryresult) with results containing an array of [Cart](ctp:api:type:Cart)."""

    #: Number of [results requested](/../api/general-concepts#limit).
    limit: int
    #: Number of [elements skipped](/../api/general-concepts#offset).
    offset: int
    #: Actual number of results returned.
    count: int
    #: Total number of results matching the query.
    #: This number is an estimation that is not [strongly consistent](/../api/general-concepts#strong-consistency).
    #: This field is returned by default.
    #: For improved performance, calculating this field can be deactivated by using the query parameter `withTotal=false`.
    #: When the results are filtered with a [Query Predicate](/../api/predicates/query), `total` is subject to a [limit](/../api/limits#queries).
    total: typing.Optional[int]
    #: [Carts](ctp:api:type:Cart) matching the query.
    results: typing.List["Cart"]

    def __init__(
        self,
        *,
        limit: int,
        offset: int,
        count: int,
        total: typing.Optional[int] = None,
        results: typing.List["Cart"]
    ):
        self.limit = limit
        self.offset = offset
        self.count = count
        self.total = total
        self.results = results

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartPagedQueryResponse":
        from ._schemas.cart import CartPagedQueryResponseSchema

        return CartPagedQueryResponseSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartPagedQueryResponseSchema

        return CartPagedQueryResponseSchema().dump(self)


class CartReference(Reference):
    """[Reference](ctp:api:type:Reference) to a [Cart](ctp:api:type:Cart)."""

    #: Contains the representation of the expanded Cart. Only present in responses to requests with [Reference Expansion](/../api/general-concepts#reference-expansion) for Carts.
    obj: typing.Optional["Cart"]

    def __init__(self, *, id: str, obj: typing.Optional["Cart"] = None):
        self.obj = obj

        super().__init__(id=id, type_id=ReferenceTypeId.CART)

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CartReference":
        from ._schemas.cart import CartReferenceSchema

        return CartReferenceSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartReferenceSchema

        return CartReferenceSchema().dump(self)


class CartResourceIdentifier(ResourceIdentifier):
    """[ResourceIdentifier](ctp:api:type:ResourceIdentifier) to a [Cart](ctp:api:type:Cart)."""

    def __init__(
        self, *, id: typing.Optional[str] = None, key: typing.Optional[str] = None
    ):
        super().__init__(id=id, key=key, type_id=ReferenceTypeId.CART)

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartResourceIdentifier":
        from ._schemas.cart import CartResourceIdentifierSchema

        return CartResourceIdentifierSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartResourceIdentifierSchema

        return CartResourceIdentifierSchema().dump(self)


class CartState(enum.Enum):
    """Indicates the current status of a Cart."""

    ACTIVE = "Active"
    MERGED = "Merged"
    ORDERED = "Ordered"
    FROZEN = "Frozen"


class CartUpdate(_BaseType):
    #: Expected version of the Cart on which the changes apply.
    #: If the expected version does not match the actual version, a [409 Conflict](/../api/errors#409-conflict) is returned.
    version: int
    #: Update actions to be performed on the Cart.
    actions: typing.List["CartUpdateAction"]

    def __init__(self, *, version: int, actions: typing.List["CartUpdateAction"]):
        self.version = version
        self.actions = actions

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CartUpdate":
        from ._schemas.cart import CartUpdateSchema

        return CartUpdateSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartUpdateSchema

        return CartUpdateSchema().dump(self)


class CartUpdateAction(_BaseType):
    action: str

    def __init__(self, *, action: str):
        self.action = action

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CartUpdateAction":
        if data["action"] == "addCustomLineItem":
            from ._schemas.cart import CartAddCustomLineItemActionSchema

            return CartAddCustomLineItemActionSchema().load(data)
        if data["action"] == "addCustomShippingMethod":
            from ._schemas.cart import CartAddCustomShippingMethodActionSchema

            return CartAddCustomShippingMethodActionSchema().load(data)
        if data["action"] == "addDiscountCode":
            from ._schemas.cart import CartAddDiscountCodeActionSchema

            return CartAddDiscountCodeActionSchema().load(data)
        if data["action"] == "addItemShippingAddress":
            from ._schemas.cart import CartAddItemShippingAddressActionSchema

            return CartAddItemShippingAddressActionSchema().load(data)
        if data["action"] == "addLineItem":
            from ._schemas.cart import CartAddLineItemActionSchema

            return CartAddLineItemActionSchema().load(data)
        if data["action"] == "addPayment":
            from ._schemas.cart import CartAddPaymentActionSchema

            return CartAddPaymentActionSchema().load(data)
        if data["action"] == "addShippingMethod":
            from ._schemas.cart import CartAddShippingMethodActionSchema

            return CartAddShippingMethodActionSchema().load(data)
        if data["action"] == "addShoppingList":
            from ._schemas.cart import CartAddShoppingListActionSchema

            return CartAddShoppingListActionSchema().load(data)
        if data["action"] == "applyDeltaToCustomLineItemShippingDetailsTargets":
            from ._schemas.cart import (
                CartApplyDeltaToCustomLineItemShippingDetailsTargetsActionSchema,
            )

            return (
                CartApplyDeltaToCustomLineItemShippingDetailsTargetsActionSchema().load(
                    data
                )
            )
        if data["action"] == "applyDeltaToLineItemShippingDetailsTargets":
            from ._schemas.cart import (
                CartApplyDeltaToLineItemShippingDetailsTargetsActionSchema,
            )

            return CartApplyDeltaToLineItemShippingDetailsTargetsActionSchema().load(
                data
            )
        if data["action"] == "changeCustomLineItemMoney":
            from ._schemas.cart import CartChangeCustomLineItemMoneyActionSchema

            return CartChangeCustomLineItemMoneyActionSchema().load(data)
        if data["action"] == "changeCustomLineItemPriceMode":
            from ._schemas.cart import CartChangeCustomLineItemPriceModeActionSchema

            return CartChangeCustomLineItemPriceModeActionSchema().load(data)
        if data["action"] == "changeCustomLineItemQuantity":
            from ._schemas.cart import CartChangeCustomLineItemQuantityActionSchema

            return CartChangeCustomLineItemQuantityActionSchema().load(data)
        if data["action"] == "changeLineItemQuantity":
            from ._schemas.cart import CartChangeLineItemQuantityActionSchema

            return CartChangeLineItemQuantityActionSchema().load(data)
        if data["action"] == "changeTaxCalculationMode":
            from ._schemas.cart import CartChangeTaxCalculationModeActionSchema

            return CartChangeTaxCalculationModeActionSchema().load(data)
        if data["action"] == "changeTaxMode":
            from ._schemas.cart import CartChangeTaxModeActionSchema

            return CartChangeTaxModeActionSchema().load(data)
        if data["action"] == "changeTaxRoundingMode":
            from ._schemas.cart import CartChangeTaxRoundingModeActionSchema

            return CartChangeTaxRoundingModeActionSchema().load(data)
        if data["action"] == "freezeCart":
            from ._schemas.cart import CartFreezeCartActionSchema

            return CartFreezeCartActionSchema().load(data)
        if data["action"] == "recalculate":
            from ._schemas.cart import CartRecalculateActionSchema

            return CartRecalculateActionSchema().load(data)
        if data["action"] == "removeCustomLineItem":
            from ._schemas.cart import CartRemoveCustomLineItemActionSchema

            return CartRemoveCustomLineItemActionSchema().load(data)
        if data["action"] == "removeDiscountCode":
            from ._schemas.cart import CartRemoveDiscountCodeActionSchema

            return CartRemoveDiscountCodeActionSchema().load(data)
        if data["action"] == "removeItemShippingAddress":
            from ._schemas.cart import CartRemoveItemShippingAddressActionSchema

            return CartRemoveItemShippingAddressActionSchema().load(data)
        if data["action"] == "removeLineItem":
            from ._schemas.cart import CartRemoveLineItemActionSchema

            return CartRemoveLineItemActionSchema().load(data)
        if data["action"] == "removePayment":
            from ._schemas.cart import CartRemovePaymentActionSchema

            return CartRemovePaymentActionSchema().load(data)
        if data["action"] == "removeShippingMethod":
            from ._schemas.cart import CartRemoveShippingMethodActionSchema

            return CartRemoveShippingMethodActionSchema().load(data)
        if data["action"] == "setAnonymousId":
            from ._schemas.cart import CartSetAnonymousIdActionSchema

            return CartSetAnonymousIdActionSchema().load(data)
        if data["action"] == "setBillingAddress":
            from ._schemas.cart import CartSetBillingAddressActionSchema

            return CartSetBillingAddressActionSchema().load(data)
        if data["action"] == "setBillingAddressCustomField":
            from ._schemas.cart import CartSetBillingAddressCustomFieldActionSchema

            return CartSetBillingAddressCustomFieldActionSchema().load(data)
        if data["action"] == "setBillingAddressCustomType":
            from ._schemas.cart import CartSetBillingAddressCustomTypeActionSchema

            return CartSetBillingAddressCustomTypeActionSchema().load(data)
        if data["action"] == "setBusinessUnit":
            from ._schemas.cart import CartSetBusinessUnitActionSchema

            return CartSetBusinessUnitActionSchema().load(data)
        if data["action"] == "setCartTotalTax":
            from ._schemas.cart import CartSetCartTotalTaxActionSchema

            return CartSetCartTotalTaxActionSchema().load(data)
        if data["action"] == "setCountry":
            from ._schemas.cart import CartSetCountryActionSchema

            return CartSetCountryActionSchema().load(data)
        if data["action"] == "setCustomField":
            from ._schemas.cart import CartSetCustomFieldActionSchema

            return CartSetCustomFieldActionSchema().load(data)
        if data["action"] == "setCustomLineItemCustomField":
            from ._schemas.cart import CartSetCustomLineItemCustomFieldActionSchema

            return CartSetCustomLineItemCustomFieldActionSchema().load(data)
        if data["action"] == "setCustomLineItemCustomType":
            from ._schemas.cart import CartSetCustomLineItemCustomTypeActionSchema

            return CartSetCustomLineItemCustomTypeActionSchema().load(data)
        if data["action"] == "setCustomLineItemShippingDetails":
            from ._schemas.cart import CartSetCustomLineItemShippingDetailsActionSchema

            return CartSetCustomLineItemShippingDetailsActionSchema().load(data)
        if data["action"] == "setCustomLineItemTaxAmount":
            from ._schemas.cart import CartSetCustomLineItemTaxAmountActionSchema

            return CartSetCustomLineItemTaxAmountActionSchema().load(data)
        if data["action"] == "setCustomLineItemTaxRate":
            from ._schemas.cart import CartSetCustomLineItemTaxRateActionSchema

            return CartSetCustomLineItemTaxRateActionSchema().load(data)
        if data["action"] == "setCustomShippingMethod":
            from ._schemas.cart import CartSetCustomShippingMethodActionSchema

            return CartSetCustomShippingMethodActionSchema().load(data)
        if data["action"] == "setCustomType":
            from ._schemas.cart import CartSetCustomTypeActionSchema

            return CartSetCustomTypeActionSchema().load(data)
        if data["action"] == "setCustomerEmail":
            from ._schemas.cart import CartSetCustomerEmailActionSchema

            return CartSetCustomerEmailActionSchema().load(data)
        if data["action"] == "setCustomerGroup":
            from ._schemas.cart import CartSetCustomerGroupActionSchema

            return CartSetCustomerGroupActionSchema().load(data)
        if data["action"] == "setCustomerId":
            from ._schemas.cart import CartSetCustomerIdActionSchema

            return CartSetCustomerIdActionSchema().load(data)
        if data["action"] == "setDeleteDaysAfterLastModification":
            from ._schemas.cart import (
                CartSetDeleteDaysAfterLastModificationActionSchema,
            )

            return CartSetDeleteDaysAfterLastModificationActionSchema().load(data)
        if data["action"] == "setDeliveryAddressCustomField":
            from ._schemas.cart import CartSetDeliveryAddressCustomFieldActionSchema

            return CartSetDeliveryAddressCustomFieldActionSchema().load(data)
        if data["action"] == "setDeliveryAddressCustomType":
            from ._schemas.cart import CartSetDeliveryAddressCustomTypeActionSchema

            return CartSetDeliveryAddressCustomTypeActionSchema().load(data)
        if data["action"] == "setDirectDiscounts":
            from ._schemas.cart import CartSetDirectDiscountsActionSchema

            return CartSetDirectDiscountsActionSchema().load(data)
        if data["action"] == "setItemShippingAddressCustomField":
            from ._schemas.cart import CartSetItemShippingAddressCustomFieldActionSchema

            return CartSetItemShippingAddressCustomFieldActionSchema().load(data)
        if data["action"] == "setItemShippingAddressCustomType":
            from ._schemas.cart import CartSetItemShippingAddressCustomTypeActionSchema

            return CartSetItemShippingAddressCustomTypeActionSchema().load(data)
        if data["action"] == "setKey":
            from ._schemas.cart import CartSetKeyActionSchema

            return CartSetKeyActionSchema().load(data)
        if data["action"] == "setLineItemCustomField":
            from ._schemas.cart import CartSetLineItemCustomFieldActionSchema

            return CartSetLineItemCustomFieldActionSchema().load(data)
        if data["action"] == "setLineItemCustomType":
            from ._schemas.cart import CartSetLineItemCustomTypeActionSchema

            return CartSetLineItemCustomTypeActionSchema().load(data)
        if data["action"] == "setLineItemDistributionChannel":
            from ._schemas.cart import CartSetLineItemDistributionChannelActionSchema

            return CartSetLineItemDistributionChannelActionSchema().load(data)
        if data["action"] == "setLineItemInventoryMode":
            from ._schemas.cart import CartSetLineItemInventoryModeActionSchema

            return CartSetLineItemInventoryModeActionSchema().load(data)
        if data["action"] == "setLineItemPrice":
            from ._schemas.cart import CartSetLineItemPriceActionSchema

            return CartSetLineItemPriceActionSchema().load(data)
        if data["action"] == "setLineItemShippingDetails":
            from ._schemas.cart import CartSetLineItemShippingDetailsActionSchema

            return CartSetLineItemShippingDetailsActionSchema().load(data)
        if data["action"] == "setLineItemSupplyChannel":
            from ._schemas.cart import CartSetLineItemSupplyChannelActionSchema

            return CartSetLineItemSupplyChannelActionSchema().load(data)
        if data["action"] == "setLineItemTaxAmount":
            from ._schemas.cart import CartSetLineItemTaxAmountActionSchema

            return CartSetLineItemTaxAmountActionSchema().load(data)
        if data["action"] == "setLineItemTaxRate":
            from ._schemas.cart import CartSetLineItemTaxRateActionSchema

            return CartSetLineItemTaxRateActionSchema().load(data)
        if data["action"] == "setLineItemTotalPrice":
            from ._schemas.cart import CartSetLineItemTotalPriceActionSchema

            return CartSetLineItemTotalPriceActionSchema().load(data)
        if data["action"] == "setLocale":
            from ._schemas.cart import CartSetLocaleActionSchema

            return CartSetLocaleActionSchema().load(data)
        if data["action"] == "setShippingAddress":
            from ._schemas.cart import CartSetShippingAddressActionSchema

            return CartSetShippingAddressActionSchema().load(data)
        if data["action"] == "setShippingAddressCustomField":
            from ._schemas.cart import CartSetShippingAddressCustomFieldActionSchema

            return CartSetShippingAddressCustomFieldActionSchema().load(data)
        if data["action"] == "setShippingAddressCustomType":
            from ._schemas.cart import CartSetShippingAddressCustomTypeActionSchema

            return CartSetShippingAddressCustomTypeActionSchema().load(data)
        if data["action"] == "setShippingCustomField":
            from ._schemas.cart import CartSetShippingCustomFieldActionSchema

            return CartSetShippingCustomFieldActionSchema().load(data)
        if data["action"] == "setShippingCustomType":
            from ._schemas.cart import CartSetShippingCustomTypeActionSchema

            return CartSetShippingCustomTypeActionSchema().load(data)
        if data["action"] == "setShippingMethod":
            from ._schemas.cart import CartSetShippingMethodActionSchema

            return CartSetShippingMethodActionSchema().load(data)
        if data["action"] == "setShippingMethodTaxAmount":
            from ._schemas.cart import CartSetShippingMethodTaxAmountActionSchema

            return CartSetShippingMethodTaxAmountActionSchema().load(data)
        if data["action"] == "setShippingMethodTaxRate":
            from ._schemas.cart import CartSetShippingMethodTaxRateActionSchema

            return CartSetShippingMethodTaxRateActionSchema().load(data)
        if data["action"] == "setShippingRateInput":
            from ._schemas.cart import CartSetShippingRateInputActionSchema

            return CartSetShippingRateInputActionSchema().load(data)
        if data["action"] == "unfreezeCart":
            from ._schemas.cart import CartUnfreezeCartActionSchema

            return CartUnfreezeCartActionSchema().load(data)
        if data["action"] == "updateItemShippingAddress":
            from ._schemas.cart import CartUpdateItemShippingAddressActionSchema

            return CartUpdateItemShippingAddressActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartUpdateActionSchema

        return CartUpdateActionSchema().dump(self)


class CustomLineItem(_BaseType):
    """A generic item that can be added to the Cart but is not bound to a Product that can be used for discounts (negative money), vouchers, complex cart rules, additional services, or fees.
    You control the lifecycle of this item.

    """

    #: Unique identifier of the Custom Line Item.
    id: str
    #: Name of the Custom Line Item.
    name: "LocalizedString"
    #: Money value of the Custom Line Item.
    money: "TypedMoney"
    #: Automatically set after the `taxRate` is set.
    taxed_price: typing.Optional["TaxedItemPrice"]
    #: Total price of the Custom Line Item (`money` multiplied by `quantity`).
    #: If the Custom Line Item is discounted, the total price is `discountedPricePerQuantity` multiplied by `quantity`.
    #:
    #: Includes taxes if the [TaxRate](ctp:api:type:TaxRate) `includedInPrice` is `true`.
    total_price: "CentPrecisionMoney"
    #: User-defined identifier used in a deep-link URL for the Custom Line Item.
    #: It matches the pattern `[a-zA-Z0-9_-]{2,256}`.
    slug: str
    #: Number of Custom Line Items in the Cart.
    quantity: int
    #: State of the Custom Line Item in the Cart.
    state: typing.List["ItemState"]
    #: Used to select a Tax Rate when a Cart has the `Platform` [TaxMode](ctp:api:type:TaxMode).
    tax_category: typing.Optional["TaxCategoryReference"]
    #: - For a Cart with `Platform` [TaxMode](ctp:api:type:TaxMode), the `taxRate` of Custom Line Items is set automatically once a shipping address is set. The rate is based on the [TaxCategory](ctp:api:type:TaxCategory) that applies for the shipping address.
    #: - For a Cart with `External` TaxMode, the `taxRate` of Custom Line Items can be set using [ExternalTaxRateDraft](ctp:api:type:ExternalTaxRateDraft).
    tax_rate: typing.Optional["TaxRate"]
    #: Discounted price of a single quantity of the Custom Line Item.
    discounted_price_per_quantity: typing.List["DiscountedLineItemPriceForQuantity"]
    #: Custom Fields of the Custom Line Item.
    custom: typing.Optional["CustomFields"]
    #: Container for Custom Line Item-specific addresses.
    shipping_details: typing.Optional["ItemShippingDetails"]
    #: Indicates whether Cart Discounts with a matching [CartDiscountCustomLineItemsTarget](ctp:api:type:CartDiscountCustomLineItemsTarget) are applied to the Custom Line Item.
    price_mode: "CustomLineItemPriceMode"

    def __init__(
        self,
        *,
        id: str,
        name: "LocalizedString",
        money: "TypedMoney",
        taxed_price: typing.Optional["TaxedItemPrice"] = None,
        total_price: "CentPrecisionMoney",
        slug: str,
        quantity: int,
        state: typing.List["ItemState"],
        tax_category: typing.Optional["TaxCategoryReference"] = None,
        tax_rate: typing.Optional["TaxRate"] = None,
        discounted_price_per_quantity: typing.List[
            "DiscountedLineItemPriceForQuantity"
        ],
        custom: typing.Optional["CustomFields"] = None,
        shipping_details: typing.Optional["ItemShippingDetails"] = None,
        price_mode: "CustomLineItemPriceMode"
    ):
        self.id = id
        self.name = name
        self.money = money
        self.taxed_price = taxed_price
        self.total_price = total_price
        self.slug = slug
        self.quantity = quantity
        self.state = state
        self.tax_category = tax_category
        self.tax_rate = tax_rate
        self.discounted_price_per_quantity = discounted_price_per_quantity
        self.custom = custom
        self.shipping_details = shipping_details
        self.price_mode = price_mode

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CustomLineItem":
        from ._schemas.cart import CustomLineItemSchema

        return CustomLineItemSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CustomLineItemSchema

        return CustomLineItemSchema().dump(self)


class CustomLineItemDraft(_BaseType):
    #: Name of the Custom Line Item.
    name: "LocalizedString"
    #: Number of Custom Line Items to add to the Cart.
    quantity: typing.Optional[int]
    #: Money value of the Custom Line Item.
    #: The value can be negative.
    money: "Money"
    #: User-defined identifier used in a deep-link URL for the Custom Line Item.
    #: It must match the pattern `[a-zA-Z0-9_-]{2,256}`.
    slug: str
    #: Used to select a Tax Rate when a Cart has the `Platform` [TaxMode](ctp:api:type:TaxMode).
    #: This field is required for `Platform` [TaxMode](ctp:api:type:TaxMode).
    tax_category: typing.Optional["TaxCategoryResourceIdentifier"]
    #: External Tax Rate for the Custom Line Item if the Cart has the `External` [TaxMode](ctp:api:type:TaxMode).
    external_tax_rate: typing.Optional["ExternalTaxRateDraft"]
    #: Custom Fields for the Custom Line Item.
    custom: typing.Optional["CustomFieldsDraft"]
    #: Container for Custom Line Item-specific addresses.
    shipping_details: typing.Optional["ItemShippingDetailsDraft"]
    #: - If `Standard`, Cart Discounts with a matching [CartDiscountCustomLineItemsTarget](ctp:api:type:CartDiscountCustomLineItemsTarget)
    #: are applied to the Custom Line Item.
    #: - If `External`, Cart Discounts are not considered on the Custom Line Item.
    price_mode: "CustomLineItemPriceMode"

    def __init__(
        self,
        *,
        name: "LocalizedString",
        quantity: typing.Optional[int] = None,
        money: "Money",
        slug: str,
        tax_category: typing.Optional["TaxCategoryResourceIdentifier"] = None,
        external_tax_rate: typing.Optional["ExternalTaxRateDraft"] = None,
        custom: typing.Optional["CustomFieldsDraft"] = None,
        shipping_details: typing.Optional["ItemShippingDetailsDraft"] = None,
        price_mode: "CustomLineItemPriceMode"
    ):
        self.name = name
        self.quantity = quantity
        self.money = money
        self.slug = slug
        self.tax_category = tax_category
        self.external_tax_rate = external_tax_rate
        self.custom = custom
        self.shipping_details = shipping_details
        self.price_mode = price_mode

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CustomLineItemDraft":
        from ._schemas.cart import CustomLineItemDraftSchema

        return CustomLineItemDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CustomLineItemDraftSchema

        return CustomLineItemDraftSchema().dump(self)


class CustomLineItemPriceMode(enum.Enum):
    """Determines if Cart Discounts can be applied to a Custom Line Item in the Cart."""

    STANDARD = "Standard"
    EXTERNAL = "External"


class CustomShippingDraft(_BaseType):
    #: User-defined unique identifier of the custom Shipping Method in the Cart with `Multiple` [ShippingMode](ctp:api:type:ShippingMode).
    key: str
    #: Name of the custom Shipping Method.
    shipping_method_name: str
    #: Determines the shipping rate and Tax Rate of the associated Line Items.
    shipping_address: typing.Optional["BaseAddress"]
    #: Determines the shipping price.
    shipping_rate: "ShippingRateDraft"
    #: Input used to select a [ShippingRatePriceTier](ctp:api:type:ShippingRatePriceTier).
    #: The data type of this field depends on the `shippingRateInputType.type` configured in the [Project](ctp:api:type:Project):
    #:
    #: - If `CartClassification`, it must be [ClassificationShippingRateInputDraft](ctp:api:type:ClassificationShippingRateInputDraft).
    #: - If `CartScore`, it must be [ScoreShippingRateInputDraft](ctp:api:type:ScoreShippingRateInputDraft).
    #: - If `CartValue`, it cannot be set.
    shipping_rate_input: typing.Optional["ShippingRateInputDraft"]
    #: Tax Category used to determine a shipping Tax Rate if the Cart has the `Platform` [TaxMode](ctp:api:type:TaxMode).
    tax_category: typing.Optional["TaxCategoryResourceIdentifier"]
    #: Tax Rate used to tax a shipping expense if the Cart has the `External` [TaxMode](ctp:api:type:TaxMode).
    external_tax_rate: typing.Optional["ExternalTaxRateDraft"]
    #: Deliveries to be shipped with the custom Shipping Method.
    deliveries: typing.Optional[typing.List["DeliveryDraft"]]
    #: Custom Fields for the custom Shipping Method.
    custom: typing.Optional["CustomFieldsDraft"]

    def __init__(
        self,
        *,
        key: str,
        shipping_method_name: str,
        shipping_address: typing.Optional["BaseAddress"] = None,
        shipping_rate: "ShippingRateDraft",
        shipping_rate_input: typing.Optional["ShippingRateInputDraft"] = None,
        tax_category: typing.Optional["TaxCategoryResourceIdentifier"] = None,
        external_tax_rate: typing.Optional["ExternalTaxRateDraft"] = None,
        deliveries: typing.Optional[typing.List["DeliveryDraft"]] = None,
        custom: typing.Optional["CustomFieldsDraft"] = None
    ):
        self.key = key
        self.shipping_method_name = shipping_method_name
        self.shipping_address = shipping_address
        self.shipping_rate = shipping_rate
        self.shipping_rate_input = shipping_rate_input
        self.tax_category = tax_category
        self.external_tax_rate = external_tax_rate
        self.deliveries = deliveries
        self.custom = custom

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CustomShippingDraft":
        from ._schemas.cart import CustomShippingDraftSchema

        return CustomShippingDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CustomShippingDraftSchema

        return CustomShippingDraftSchema().dump(self)


class DirectDiscount(_BaseType):
    """Represents a [CartDiscount](ctp:api:type:CartDiscount) that is only associated with a single Cart or Order."""

    #: Unique identifier of the Direct Discount.
    id: str
    #: Effect of the Discount on the Cart.
    value: "CartDiscountValue"
    #: Part of the Cart that is discounted.
    #:
    #: Empty when the `value` is set to `giftLineItem`.
    target: typing.Optional["CartDiscountTarget"]

    def __init__(
        self,
        *,
        id: str,
        value: "CartDiscountValue",
        target: typing.Optional["CartDiscountTarget"] = None
    ):
        self.id = id
        self.value = value
        self.target = target

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "DirectDiscount":
        from ._schemas.cart import DirectDiscountSchema

        return DirectDiscountSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import DirectDiscountSchema

        return DirectDiscountSchema().dump(self)


class DirectDiscountDraft(_BaseType):
    """Represents a [CartDiscount](ctp:api:type:CartDiscount) that can only be associated with a single Cart or Order.

    Direct Discounts are always active and valid, and have the default `Stacking` [StackingMode](ctp:api:type:StackingMode).
    They apply in the order in which they are listed in the `directDiscounts` array of [Carts](ctp:api:type:Cart) or [Orders](ctp:api:type:Order), and do not have a sorting order like Cart Discounts.

    If a Direct Discount is present, any matching Cart Discounts in the Project are ignored.
    Additionally, a Cart or Order supports either Discount Codes or Direct Discounts at the same time.

    """

    #: Defines the effect the Discount will have.
    value: "CartDiscountValue"
    #: Defines what part of the Cart will be discounted.
    #:
    #: If `value` is set to `giftLineItem`, this must not be set.
    target: typing.Optional["CartDiscountTarget"]

    def __init__(
        self,
        *,
        value: "CartDiscountValue",
        target: typing.Optional["CartDiscountTarget"] = None
    ):
        self.value = value
        self.target = target

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "DirectDiscountDraft":
        from ._schemas.cart import DirectDiscountDraftSchema

        return DirectDiscountDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import DirectDiscountDraftSchema

        return DirectDiscountDraftSchema().dump(self)


class DirectDiscountReference(Reference):
    """[Reference](ctp:api:type:Reference) to a [DirectDiscount](ctp:api:type:DirectDiscount)."""

    def __init__(self, *, id: str):
        super().__init__(id=id, type_id=ReferenceTypeId.DIRECT_DISCOUNT)

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "DirectDiscountReference":
        from ._schemas.cart import DirectDiscountReferenceSchema

        return DirectDiscountReferenceSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import DirectDiscountReferenceSchema

        return DirectDiscountReferenceSchema().dump(self)


class DiscountCodeInfo(_BaseType):
    #: Discount Code associated with the Cart or Order.
    discount_code: "DiscountCodeReference"
    #: Indicates the state of the Discount Code applied to the Cart or Order.
    state: "DiscountCodeState"

    def __init__(
        self, *, discount_code: "DiscountCodeReference", state: "DiscountCodeState"
    ):
        self.discount_code = discount_code
        self.state = state

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "DiscountCodeInfo":
        from ._schemas.cart import DiscountCodeInfoSchema

        return DiscountCodeInfoSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import DiscountCodeInfoSchema

        return DiscountCodeInfoSchema().dump(self)


class DiscountCodeState(enum.Enum):
    """Indicates the state of a Discount Code in a Cart.

    If an Order is created from a Cart with a state other than `MatchesCart`, a [DiscountCodeNonApplicable](ctp:api:type:DiscountCodeNonApplicableError) error is returned.

    """

    NOT_ACTIVE = "NotActive"
    NOT_VALID = "NotValid"
    DOES_NOT_MATCH_CART = "DoesNotMatchCart"
    MATCHES_CART = "MatchesCart"
    MAX_APPLICATION_REACHED = "MaxApplicationReached"
    APPLICATION_STOPPED_BY_PREVIOUS_DISCOUNT = "ApplicationStoppedByPreviousDiscount"


class DiscountedLineItemPortion(_BaseType):
    #: A [CartDiscountReference](ctp:api:type:CartDiscountReference) or [DirectDiscountReference](ctp:api:type:DirectDiscountReference) for the applicable discount on the Line Item.
    discount: "Reference"
    #: Money value of the discount applicable.
    discounted_amount: "TypedMoney"

    def __init__(self, *, discount: "Reference", discounted_amount: "TypedMoney"):
        self.discount = discount
        self.discounted_amount = discounted_amount

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "DiscountedLineItemPortion":
        from ._schemas.cart import DiscountedLineItemPortionSchema

        return DiscountedLineItemPortionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import DiscountedLineItemPortionSchema

        return DiscountedLineItemPortionSchema().dump(self)


class DiscountedLineItemPrice(_BaseType):
    #: Money value of the discounted Line Item or Custom Line Item.
    value: "TypedMoney"
    #: Discount applicable on the Line Item or Custom Line Item.
    included_discounts: typing.List["DiscountedLineItemPortion"]

    def __init__(
        self,
        *,
        value: "TypedMoney",
        included_discounts: typing.List["DiscountedLineItemPortion"]
    ):
        self.value = value
        self.included_discounts = included_discounts

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "DiscountedLineItemPrice":
        from ._schemas.cart import DiscountedLineItemPriceSchema

        return DiscountedLineItemPriceSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import DiscountedLineItemPriceSchema

        return DiscountedLineItemPriceSchema().dump(self)


class DiscountedLineItemPriceForQuantity(_BaseType):
    #: Number of Line Items or Custom Line Items in the Cart.
    quantity: int
    #: Discounted price of the Line Item or Custom Line Item.
    discounted_price: "DiscountedLineItemPrice"

    def __init__(self, *, quantity: int, discounted_price: "DiscountedLineItemPrice"):
        self.quantity = quantity
        self.discounted_price = discounted_price

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "DiscountedLineItemPriceForQuantity":
        from ._schemas.cart import DiscountedLineItemPriceForQuantitySchema

        return DiscountedLineItemPriceForQuantitySchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import DiscountedLineItemPriceForQuantitySchema

        return DiscountedLineItemPriceForQuantitySchema().dump(self)


class ExternalLineItemTotalPrice(_BaseType):
    #: Price of the Line Item.
    #:
    #: The value is selected from the Product Variant according to the [Product](ctp:api:type:Product) `priceMode`.
    price: "Money"
    #: Total price of the Line Item.
    total_price: "Money"

    def __init__(self, *, price: "Money", total_price: "Money"):
        self.price = price
        self.total_price = total_price

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ExternalLineItemTotalPrice":
        from ._schemas.cart import ExternalLineItemTotalPriceSchema

        return ExternalLineItemTotalPriceSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import ExternalLineItemTotalPriceSchema

        return ExternalLineItemTotalPriceSchema().dump(self)


class ExternalTaxAmountDraft(_BaseType):
    """Cannot be used in [LineItemDraft](ctp:api:type:LineItemDraft) or [CustomLineItemDraft](ctp:api:type:CustomLineItemDraft).

    Can only be set by these update actions:

    - [Set LineItem TaxAmount](ctp:api:type:CartSetLineItemTaxAmountAction), [Set CustomLineItem TaxAmount](ctp:api:type:CartSetCustomLineItemTaxAmountAction), or [Set ShippingMethod TaxAmount](ctp:api:type:CartSetShippingMethodTaxAmountAction) on Carts
    - [Set LineItem TaxAmount](ctp:api:type:OrderEditSetLineItemTaxAmountAction), [Set CustomLineItem TaxAmount](ctp:api:type:OrderEditSetCustomLineItemTaxAmountAction), or [Set ShippingMethod TaxAmount](ctp:api:type:OrderEditSetShippingMethodTaxAmountAction) on Order Edits

    """

    #: Total gross amount (`totalNet` + `taxPortions`) of the Line Item or Custom Line Item.
    total_gross: "Money"
    #: Tax Rates and subrates of states and countries.
    tax_rate: "ExternalTaxRateDraft"

    def __init__(self, *, total_gross: "Money", tax_rate: "ExternalTaxRateDraft"):
        self.total_gross = total_gross
        self.tax_rate = tax_rate

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ExternalTaxAmountDraft":
        from ._schemas.cart import ExternalTaxAmountDraftSchema

        return ExternalTaxAmountDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import ExternalTaxAmountDraftSchema

        return ExternalTaxAmountDraftSchema().dump(self)


class ExternalTaxRateDraft(_BaseType):
    """Controls calculation of taxed prices for Line Items, Custom Line Items, and Shipping Methods as explained in [Cart tax calculation](ctp:api:type:CartTaxCalculation)."""

    #: Name of the Tax Rate.
    name: str
    #: Percentage in the range of 0-1.
    #:
    #: - If no `subRates` are specified, a value must be defined.
    #: - If `subRates` are specified, this can be omitted or its value must be the sum of all `subRates` amounts.
    amount: typing.Optional[float]
    #: - If set to `false`, the related price is considered the net price and the provided `amount` is applied to calculate the gross price.
    #: - If set to `true`, the related price is considered the gross price, and the provided `amount` is applied to calculate the net price.
    included_in_price: typing.Optional[bool]
    #: Country for which the tax applies.
    country: str
    #: State within the specified country.
    state: typing.Optional[str]
    #: For countries (such as the US) where the total tax is a combination of multiple taxes (such as state and local taxes).
    sub_rates: typing.Optional[typing.List["SubRate"]]

    def __init__(
        self,
        *,
        name: str,
        amount: typing.Optional[float] = None,
        included_in_price: typing.Optional[bool] = None,
        country: str,
        state: typing.Optional[str] = None,
        sub_rates: typing.Optional[typing.List["SubRate"]] = None
    ):
        self.name = name
        self.amount = amount
        self.included_in_price = included_in_price
        self.country = country
        self.state = state
        self.sub_rates = sub_rates

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ExternalTaxRateDraft":
        from ._schemas.cart import ExternalTaxRateDraftSchema

        return ExternalTaxRateDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import ExternalTaxRateDraftSchema

        return ExternalTaxRateDraftSchema().dump(self)


class InventoryMode(enum.Enum):
    """Indicates how Line Items in a Cart are tracked."""

    NONE = "None"
    TRACK_ONLY = "TrackOnly"
    RESERVE_ON_ORDER = "ReserveOnOrder"


class ItemShippingDetails(_BaseType):
    #: Holds information on the quantity of Line Items or Custom Line Items and the address it is shipped.
    targets: typing.List["ItemShippingTarget"]
    #: - `true` if the quantity of Line Items or Custom Line Items is equal to the sum of sub-quantities defined in `targets`.
    #: - `false` if the quantity of Line Items or Custom Line Items is not equal to the sum of sub-quantities defined in `targets`.
    #:   Ordering a Cart when the value is `false` returns an [InvalidItemShippingDetails](ctp:api:type:InvalidItemShippingDetailsError) error.
    valid: bool

    def __init__(self, *, targets: typing.List["ItemShippingTarget"], valid: bool):
        self.targets = targets
        self.valid = valid

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ItemShippingDetails":
        from ._schemas.cart import ItemShippingDetailsSchema

        return ItemShippingDetailsSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import ItemShippingDetailsSchema

        return ItemShippingDetailsSchema().dump(self)


class ItemShippingDetailsDraft(_BaseType):
    """For order creation and updates, the sum of the `targets` must match the quantity of the Line Items or Custom Line Items."""

    #: Holds information on the quantity of Line Items or Custom Line Items and the address it is shipped.
    #:
    #: If multiple shipping addresses are present for a Line Item or Custom Line Item, sub-quantities must be specified.
    targets: typing.List["ItemShippingTarget"]

    def __init__(self, *, targets: typing.List["ItemShippingTarget"]):
        self.targets = targets

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ItemShippingDetailsDraft":
        from ._schemas.cart import ItemShippingDetailsDraftSchema

        return ItemShippingDetailsDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import ItemShippingDetailsDraftSchema

        return ItemShippingDetailsDraftSchema().dump(self)


class ItemShippingTarget(_BaseType):
    """Determines the address (as a reference to an address in `itemShippingAddresses`) and the quantity shipped to the address.

    If multiple shipping addresses are present for a Line Item or Custom Line Item, sub-quantities must be specified.
    An array of addresses and sub-quantities is stored per Line Item or Custom Line Item.

    """

    #: Key of the address in the [Cart](ctp:api:type:Cart) `itemShippingAddresses`.
    #: Duplicate address keys are not allowed.
    address_key: str
    #: Quantity of Line Items or Custom Line Items shipped to the address with the specified `addressKey`.
    #:
    #: If a quantity is updated to `0` when defining [ItemShippingDetailsDraft](ctp:api:type:ItemShippingDetailsDraft), the `targets` are removed from a Line Item or Custom Line Item in the resulting [ItemShippingDetails](ctp:api:type:ItemShippingDetails).
    quantity: int
    #: User-defined unique identifier of the Shipping Method in a Cart with `Multiple` [ShippingMode](ctp:api:type:ShippingMode).
    #:
    #: It connects Line Item quantities with individual shipping addresses.
    shipping_method_key: typing.Optional[str]

    def __init__(
        self,
        *,
        address_key: str,
        quantity: int,
        shipping_method_key: typing.Optional[str] = None
    ):
        self.address_key = address_key
        self.quantity = quantity
        self.shipping_method_key = shipping_method_key

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ItemShippingTarget":
        from ._schemas.cart import ItemShippingTargetSchema

        return ItemShippingTargetSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import ItemShippingTargetSchema

        return ItemShippingTargetSchema().dump(self)


class LineItem(_BaseType):
    """The representation of a [Line Item](/../api/carts-orders-overview#line-items) in a Cart."""

    #: Unique identifier of the LineItem.
    id: str
    #: User-defined unique identifier of the LineItem.
    key: typing.Optional[str]
    #: `id` of the [Product](ctp:api:type:Product) the Line Item is based on.
    product_id: str
    #: `key` of the [Product](ctp:api:type:Product).
    #:
    #: This field is only present on:
    #:
    #: - Line Items in a [Cart](ctp:api:type:Cart) when the `key` is available on that specific Product at the time the Line Item was created or updated on the Cart.
    #: - [Orders](ctp:api:type:Order) when the `key` is available on the specific Product at the time the Order was created from the Cart.
    #:
    #: Present on resources created or updated after 3 December 2021.
    product_key: typing.Optional[str]
    #: Name of the Product.
    name: "LocalizedString"
    #: `slug` of the current version of the Product. Updated automatically if the `slug` changes. Empty if the Product has been deleted.
    #: The `productSlug` field of LineItem is not expanded when using [Reference Expansion](/../api/general-concepts#reference-expansion).
    product_slug: typing.Optional["LocalizedString"]
    #: Product Type of the Product.
    product_type: "ProductTypeReference"
    #: Holds the data of the Product Variant added to the Cart.
    #:
    #: The data is saved at the time the Product Variant is added to the Cart and is not updated automatically when Product Variant data changes.
    #: Must be updated using the [Recalculate](ctp:api:type:CartRecalculateAction) update action.
    variant: "ProductVariant"
    #: Price of a Line Item selected from the Product Variant according to the [Product](ctp:api:type:Product) `priceMode`. If the `priceMode` is `Embedded` [ProductPriceMode](ctp:api:type:ProductPriceModeEnum) and the `variant` field hasn't been updated, the price may not correspond to a price in `variant.prices`.
    price: "Price"
    #: Number of Line Items of the given Product Variant present in the Cart.
    quantity: int
    #: Total price of this Line Item equalling `price` multiplied by `quantity`. If the Line Item is discounted, the total price is the `discountedPricePerQuantity` multiplied by `quantity`.
    #: Includes taxes if the [TaxRate](ctp:api:type:TaxRate) `includedInPrice` is `true`.
    total_price: "CentPrecisionMoney"
    #: Discounted price of a single quantity of the Line Item.
    discounted_price_per_quantity: typing.List["DiscountedLineItemPriceForQuantity"]
    #: Automatically set after `taxRate` is set.
    taxed_price: typing.Optional["TaxedItemPrice"]
    #: Taxed price of the Shipping Method that is automatically set after `perMethodTaxRate` is set.
    taxed_price_portions: typing.List["MethodTaxedPrice"]
    #: State of the Line Item in the Cart.
    state: typing.List["ItemState"]
    #: - For a Cart with `Platform` [TaxMode](ctp:api:type:TaxMode), the `taxRate` of Line Items is set automatically once a shipping address is set. The rate is based on the [TaxCategory](ctp:api:type:TaxCategory) that applies for the shipping address.
    #: - For a Cart with `External` TaxMode, the `taxRate` of Line Items can be set using [ExternalTaxRateDraft](ctp:api:type:ExternalTaxRateDraft).
    tax_rate: typing.Optional["TaxRate"]
    #: Tax Rate per Shipping Method for a Cart with `Multiple` [ShippingMode](ctp:api:type:ShippingMode). For a Cart with `Platform` [TaxMode](ctp:api:type:TaxMode) it is automatically set after the [Shipping Method is added](ctp:api:type:CartAddShippingMethodAction).
    #: For a Cart with `External` [TaxMode](ctp:api:type:TaxMode), the Tax Rate must be set with [ExternalTaxRateDraft](ctp:api:type:ExternalTaxRateDraft).
    per_method_tax_rate: typing.List["MethodTaxRate"]
    #: Identifies [Inventory entries](/../api/projects/inventory) that are reserved. The referenced Channel has the `InventorySupply` [ChannelRoleEnum](ctp:api:type:ChannelRoleEnum).
    supply_channel: typing.Optional["ChannelReference"]
    #: Used to [select](ctp:api:type:LineItemPriceSelection) a Product Price. The referenced Channel has the `ProductDistribution` [ChannelRoleEnum](ctp:api:type:ChannelRoleEnum).
    distribution_channel: typing.Optional["ChannelReference"]
    #: Indicates how the Price for the Line Item is set.
    price_mode: "LineItemPriceMode"
    #: Indicates how the Line Item is added to the Cart.
    line_item_mode: "LineItemMode"
    #: Inventory mode specific to this Line Item only, and valid for the entire `quantity` of the Line Item.
    #: Only present if the inventory mode is different from the `inventoryMode` specified on the [Cart](ctp:api:type:Cart).
    inventory_mode: typing.Optional["InventoryMode"]
    #: Container for Line Item-specific addresses.
    shipping_details: typing.Optional["ItemShippingDetails"]
    #: Custom Fields of the Line Item.
    custom: typing.Optional["CustomFields"]
    #: Date and time (UTC) the Line Item was added to the Cart.
    added_at: typing.Optional[datetime.datetime]
    #: Date and time (UTC) the Line Item was last updated.
    last_modified_at: typing.Optional[datetime.datetime]

    def __init__(
        self,
        *,
        id: str,
        key: typing.Optional[str] = None,
        product_id: str,
        product_key: typing.Optional[str] = None,
        name: "LocalizedString",
        product_slug: typing.Optional["LocalizedString"] = None,
        product_type: "ProductTypeReference",
        variant: "ProductVariant",
        price: "Price",
        quantity: int,
        total_price: "CentPrecisionMoney",
        discounted_price_per_quantity: typing.List[
            "DiscountedLineItemPriceForQuantity"
        ],
        taxed_price: typing.Optional["TaxedItemPrice"] = None,
        taxed_price_portions: typing.List["MethodTaxedPrice"],
        state: typing.List["ItemState"],
        tax_rate: typing.Optional["TaxRate"] = None,
        per_method_tax_rate: typing.List["MethodTaxRate"],
        supply_channel: typing.Optional["ChannelReference"] = None,
        distribution_channel: typing.Optional["ChannelReference"] = None,
        price_mode: "LineItemPriceMode",
        line_item_mode: "LineItemMode",
        inventory_mode: typing.Optional["InventoryMode"] = None,
        shipping_details: typing.Optional["ItemShippingDetails"] = None,
        custom: typing.Optional["CustomFields"] = None,
        added_at: typing.Optional[datetime.datetime] = None,
        last_modified_at: typing.Optional[datetime.datetime] = None
    ):
        self.id = id
        self.key = key
        self.product_id = product_id
        self.product_key = product_key
        self.name = name
        self.product_slug = product_slug
        self.product_type = product_type
        self.variant = variant
        self.price = price
        self.quantity = quantity
        self.total_price = total_price
        self.discounted_price_per_quantity = discounted_price_per_quantity
        self.taxed_price = taxed_price
        self.taxed_price_portions = taxed_price_portions
        self.state = state
        self.tax_rate = tax_rate
        self.per_method_tax_rate = per_method_tax_rate
        self.supply_channel = supply_channel
        self.distribution_channel = distribution_channel
        self.price_mode = price_mode
        self.line_item_mode = line_item_mode
        self.inventory_mode = inventory_mode
        self.shipping_details = shipping_details
        self.custom = custom
        self.added_at = added_at
        self.last_modified_at = last_modified_at

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "LineItem":
        from ._schemas.cart import LineItemSchema

        return LineItemSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import LineItemSchema

        return LineItemSchema().dump(self)


class LineItemDraft(_BaseType):
    """For Product Variant identification, either the `productId` and `variantId`, or `sku` must be provided."""

    #: User-defined unique identifier of the LineItem.
    key: typing.Optional[str]
    #: `id` of a published [Product](ctp:api:type:Product).
    product_id: typing.Optional[str]
    #: `id` of the [ProductVariant](ctp:api:type:ProductVariant) in the Product.
    #: If not provided, the Master Variant is used.
    variant_id: typing.Optional[int]
    #: `sku` of the [ProductVariant](ctp:api:type:ProductVariant).
    sku: typing.Optional[str]
    #: Quantity of the Product Variant to add to the Cart.
    quantity: typing.Optional[int]
    #: Date and time (UTC) the Product Variant is added to the Cart.
    #: If not set, it defaults to the current date and time.
    #:
    #: Optional for backwards compatibility reasons.
    added_at: typing.Optional[datetime.datetime]
    #: Used to [select](ctp:api:type:LineItemPriceSelection) a Product Price.
    #: The referenced Channel must have the `ProductDistribution` [ChannelRoleEnum](ctp:api:type:ChannelRoleEnum).
    #:
    #: If the Cart is bound to a [Store](ctp:api:type:Store) with `distributionChannels` set,
    #: the Channel must match one of the Store's distribution channels.
    distribution_channel: typing.Optional["ChannelResourceIdentifier"]
    #: Used to identify [Inventory entries](/../api/projects/inventory) that must be reserved.
    #: The referenced Channel must have the `InventorySupply` [ChannelRoleEnum](ctp:api:type:ChannelRoleEnum).
    supply_channel: typing.Optional["ChannelResourceIdentifier"]
    #: Sets the [LineItem](ctp:api:type:LineItem) `price` value, and the `priceMode` to `ExternalPrice` [LineItemPriceMode](ctp:api:type:LineItemPriceMode).
    external_price: typing.Optional["Money"]
    #: Sets the [LineItem](ctp:api:type:LineItem) `price` and `totalPrice` values, and the `priceMode` to `ExternalTotal` [LineItemPriceMode](ctp:api:type:LineItemPriceMode).
    external_total_price: typing.Optional["ExternalLineItemTotalPrice"]
    #: External Tax Rate for the Line Item if the Cart has the `External` [TaxMode](ctp:api:type:TaxMode).
    external_tax_rate: typing.Optional["ExternalTaxRateDraft"]
    #: Inventory mode specific to the Line Item only, and valid for the entire `quantity` of the Line Item.
    #: Set only if the inventory mode should be different from the `inventoryMode` specified on the [Cart](ctp:api:type:Cart).
    inventory_mode: typing.Optional["InventoryMode"]
    #: Container for Line Item-specific addresses.
    shipping_details: typing.Optional["ItemShippingDetailsDraft"]
    #: Custom Fields for the Line Item.
    custom: typing.Optional["CustomFieldsDraft"]

    def __init__(
        self,
        *,
        key: typing.Optional[str] = None,
        product_id: typing.Optional[str] = None,
        variant_id: typing.Optional[int] = None,
        sku: typing.Optional[str] = None,
        quantity: typing.Optional[int] = None,
        added_at: typing.Optional[datetime.datetime] = None,
        distribution_channel: typing.Optional["ChannelResourceIdentifier"] = None,
        supply_channel: typing.Optional["ChannelResourceIdentifier"] = None,
        external_price: typing.Optional["Money"] = None,
        external_total_price: typing.Optional["ExternalLineItemTotalPrice"] = None,
        external_tax_rate: typing.Optional["ExternalTaxRateDraft"] = None,
        inventory_mode: typing.Optional["InventoryMode"] = None,
        shipping_details: typing.Optional["ItemShippingDetailsDraft"] = None,
        custom: typing.Optional["CustomFieldsDraft"] = None
    ):
        self.key = key
        self.product_id = product_id
        self.variant_id = variant_id
        self.sku = sku
        self.quantity = quantity
        self.added_at = added_at
        self.distribution_channel = distribution_channel
        self.supply_channel = supply_channel
        self.external_price = external_price
        self.external_total_price = external_total_price
        self.external_tax_rate = external_tax_rate
        self.inventory_mode = inventory_mode
        self.shipping_details = shipping_details
        self.custom = custom

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "LineItemDraft":
        from ._schemas.cart import LineItemDraftSchema

        return LineItemDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import LineItemDraftSchema

        return LineItemDraftSchema().dump(self)


class LineItemMode(enum.Enum):
    """Indicates how a Line Item is added to a Cart."""

    STANDARD = "Standard"
    GIFT_LINE_ITEM = "GiftLineItem"


class LineItemPriceMode(enum.Enum):
    """This mode indicates how the price is set for the Line Item."""

    PLATFORM = "Platform"
    EXTERNAL_PRICE = "ExternalPrice"
    EXTERNAL_TOTAL = "ExternalTotal"


class MethodTaxRate(_BaseType):
    #: User-defined unique identifier of the Shipping Method in a Cart with `Multiple` [ShippingMode](ctp:api:type:ShippingMode).
    shipping_method_key: str
    #: Tax Rate for the Shipping Method.
    tax_rate: typing.Optional["TaxRate"]

    def __init__(
        self, *, shipping_method_key: str, tax_rate: typing.Optional["TaxRate"] = None
    ):
        self.shipping_method_key = shipping_method_key
        self.tax_rate = tax_rate

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "MethodTaxRate":
        from ._schemas.cart import MethodTaxRateSchema

        return MethodTaxRateSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import MethodTaxRateSchema

        return MethodTaxRateSchema().dump(self)


class MethodTaxedPrice(_BaseType):
    #: User-defined unique identifier of the Shipping Method in a Cart with `Multiple` [ShippingMode](ctp:api:type:ShippingMode).
    shipping_method_key: str
    #: Taxed price for the Shipping Method.
    taxed_price: typing.Optional["TaxedItemPrice"]

    def __init__(
        self,
        *,
        shipping_method_key: str,
        taxed_price: typing.Optional["TaxedItemPrice"] = None
    ):
        self.shipping_method_key = shipping_method_key
        self.taxed_price = taxed_price

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "MethodTaxedPrice":
        from ._schemas.cart import MethodTaxedPriceSchema

        return MethodTaxedPriceSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import MethodTaxedPriceSchema

        return MethodTaxedPriceSchema().dump(self)


class ReplicaCartDraft(_BaseType):
    """Used for [replicating an existing Cart](/../api/projects/carts#replicate-cart) or Order."""

    #: [Reference](ctp:api:type:Reference) to a [Cart](ctp:api:type:Cart) or [Order](ctp:api:type:Order) that is replicated.
    reference: typing.Union["CartReference", "OrderReference"]
    #: User-defined unique identifier for the Cart.
    key: typing.Optional[str]

    def __init__(
        self,
        *,
        reference: typing.Union["CartReference", "OrderReference"],
        key: typing.Optional[str] = None
    ):
        self.reference = reference
        self.key = key

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ReplicaCartDraft":
        from ._schemas.cart import ReplicaCartDraftSchema

        return ReplicaCartDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import ReplicaCartDraftSchema

        return ReplicaCartDraftSchema().dump(self)


class RoundingMode(enum.Enum):
    """Determines how monetary values are rounded."""

    HALF_EVEN = "HalfEven"
    HALF_UP = "HalfUp"
    HALF_DOWN = "HalfDown"


class Shipping(_BaseType):
    #: User-defined unique identifier of the Shipping in a Cart with `Multiple` [ShippingMode](ctp:api:type:ShippingMode).
    shipping_key: str
    #: Automatically set when the [Shipping Method is added](ctp:api:type:CartAddShippingMethodAction).
    shipping_info: "ShippingInfo"
    #: Determines the shipping rates and Tax Rates of associated Line Items.
    shipping_address: "Address"
    #: Used as an input to select a [ShippingRatePriceTier](ctp:api:type:ShippingRatePriceTier).
    #: The data type of this field depends on the `shippingRateInputType.type` configured in the [Project](ctp:api:type:Project):
    #:
    #: - If `CartClassification`, it is [ClassificationShippingRateInput](ctp:api:type:ClassificationShippingRateInput).
    #: - If `CartScore`, it is [ScoreShippingRateInput](ctp:api:type:ScoreShippingRateInput).
    #: - If `CartValue`, it cannot be used.
    shipping_rate_input: typing.Optional["ShippingRateInput"]
    #: Custom Fields of Shipping with `Multiple` [ShippingMode](ctp:api:type:ShippingMode).
    shipping_custom_fields: typing.Optional["CustomFields"]

    def __init__(
        self,
        *,
        shipping_key: str,
        shipping_info: "ShippingInfo",
        shipping_address: "Address",
        shipping_rate_input: typing.Optional["ShippingRateInput"] = None,
        shipping_custom_fields: typing.Optional["CustomFields"] = None
    ):
        self.shipping_key = shipping_key
        self.shipping_info = shipping_info
        self.shipping_address = shipping_address
        self.shipping_rate_input = shipping_rate_input
        self.shipping_custom_fields = shipping_custom_fields

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "Shipping":
        from ._schemas.cart import ShippingSchema

        return ShippingSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import ShippingSchema

        return ShippingSchema().dump(self)


class ShippingDraft(_BaseType):
    """Wraps all shipping-related information (such as address, rate, deliveries) per Shipping Method for Carts with multiple Shipping Methods."""

    #: User-defined unique identifier for the Shipping in a Cart with `Multiple` [ShippingMode](ctp:api:type:ShippingMode).
    key: str
    #: Shipping Methods added to the Cart with `Multiple` [ShippingMode](ctp:api:type:ShippingMode).
    shipping_method: typing.Optional["ShippingMethodReference"]
    #: Determines the shipping rate and Tax Rate of the associated Line Items.
    shipping_address: "BaseAddress"
    #: Input used to select a [ShippingRatePriceTier](ctp:api:type:ShippingRatePriceTier).
    #: The data type of this field depends on the `shippingRateInputType.type` configured in the [Project](ctp:api:type:Project):
    #:
    #: - If `CartClassification`, it must be [ClassificationShippingRateInputDraft](ctp:api:type:ClassificationShippingRateInputDraft).
    #: - If `CartScore`, it must be [ScoreShippingRateInputDraft](ctp:api:type:ScoreShippingRateInputDraft).
    #: - If `CartValue`, it cannot be set.
    shipping_rate_input: typing.Optional["ShippingRateInputDraft"]
    #: Tax Rate used for taxing a shipping expense if the Cart has the `External` [TaxMode](ctp:api:type:TaxMode).
    external_tax_rate: typing.Optional["ExternalTaxRateDraft"]
    #: Deliveries to be shipped with the Shipping Method.
    deliveries: typing.Optional[typing.List["DeliveryDraft"]]
    #: Custom Fields for Shipping.
    custom: typing.Optional["CustomFieldsDraft"]

    def __init__(
        self,
        *,
        key: str,
        shipping_method: typing.Optional["ShippingMethodReference"] = None,
        shipping_address: "BaseAddress",
        shipping_rate_input: typing.Optional["ShippingRateInputDraft"] = None,
        external_tax_rate: typing.Optional["ExternalTaxRateDraft"] = None,
        deliveries: typing.Optional[typing.List["DeliveryDraft"]] = None,
        custom: typing.Optional["CustomFieldsDraft"] = None
    ):
        self.key = key
        self.shipping_method = shipping_method
        self.shipping_address = shipping_address
        self.shipping_rate_input = shipping_rate_input
        self.external_tax_rate = external_tax_rate
        self.deliveries = deliveries
        self.custom = custom

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ShippingDraft":
        from ._schemas.cart import ShippingDraftSchema

        return ShippingDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import ShippingDraftSchema

        return ShippingDraftSchema().dump(self)


class ShippingInfo(_BaseType):
    #: Name of the Shipping Method.
    shipping_method_name: str
    #: Determined based on the [ShippingRate](ctp:api:type:ShippingRate) and its tiered prices, and either the sum of [LineItem](ctp:api:type:LineItem) prices or the `shippingRateInput` field.
    price: "CentPrecisionMoney"
    #: Used to determine the price.
    shipping_rate: "ShippingRate"
    #: Automatically set after the `taxRate` is set.
    taxed_price: typing.Optional["TaxedItemPrice"]
    #: Automatically set in the `Platform` [TaxMode](ctp:api:type:TaxMode) after the [shipping address is set](ctp:api:type:CartSetShippingAddressAction).
    #:
    #: For the `External` [TaxMode](ctp:api:type:TaxMode) the Tax Rate must be set explicitly with the [ExternalTaxRateDraft](ctp:api:type:ExternalTaxRateDraft).
    tax_rate: typing.Optional["TaxRate"]
    #: Used to select a Tax Rate when a Cart has the `Platform` [TaxMode](ctp:api:type:TaxMode).
    tax_category: typing.Optional["TaxCategoryReference"]
    #: Not set if a custom Shipping Method is used.
    shipping_method: typing.Optional["ShippingMethodReference"]
    #: Information on how items are delivered to customers.
    deliveries: typing.Optional[typing.List["Delivery"]]
    #: Discounted price of the Shipping Method.
    discounted_price: typing.Optional["DiscountedLineItemPrice"]
    #: Indicates whether the [ShippingMethod](ctp:api:type:ShippingMethod) referenced in this ShippingInfo is allowed for the Cart.
    shipping_method_state: "ShippingMethodState"

    def __init__(
        self,
        *,
        shipping_method_name: str,
        price: "CentPrecisionMoney",
        shipping_rate: "ShippingRate",
        taxed_price: typing.Optional["TaxedItemPrice"] = None,
        tax_rate: typing.Optional["TaxRate"] = None,
        tax_category: typing.Optional["TaxCategoryReference"] = None,
        shipping_method: typing.Optional["ShippingMethodReference"] = None,
        deliveries: typing.Optional[typing.List["Delivery"]] = None,
        discounted_price: typing.Optional["DiscountedLineItemPrice"] = None,
        shipping_method_state: "ShippingMethodState"
    ):
        self.shipping_method_name = shipping_method_name
        self.price = price
        self.shipping_rate = shipping_rate
        self.taxed_price = taxed_price
        self.tax_rate = tax_rate
        self.tax_category = tax_category
        self.shipping_method = shipping_method
        self.deliveries = deliveries
        self.discounted_price = discounted_price
        self.shipping_method_state = shipping_method_state

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ShippingInfo":
        from ._schemas.cart import ShippingInfoSchema

        return ShippingInfoSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import ShippingInfoSchema

        return ShippingInfoSchema().dump(self)


class ShippingMethodState(enum.Enum):
    """Determines whether a [ShippingMethod](ctp:api:type:ShippingMethod) is allowed for a Cart."""

    DOES_NOT_MATCH_CART = "DoesNotMatchCart"
    MATCHES_CART = "MatchesCart"


class ShippingMode(enum.Enum):
    SINGLE = "Single"
    MULTIPLE = "Multiple"


class ShippingRateInput(_BaseType):
    type: str

    def __init__(self, *, type: str):
        self.type = type

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ShippingRateInput":
        if data["type"] == "Classification":
            from ._schemas.cart import ClassificationShippingRateInputSchema

            return ClassificationShippingRateInputSchema().load(data)
        if data["type"] == "Score":
            from ._schemas.cart import ScoreShippingRateInputSchema

            return ScoreShippingRateInputSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import ShippingRateInputSchema

        return ShippingRateInputSchema().dump(self)


class ClassificationShippingRateInput(ShippingRateInput):
    #: Key of the value used as a programmatic identifier.
    key: str
    #: Descriptive localized label of the value.
    label: "LocalizedString"

    def __init__(self, *, key: str, label: "LocalizedString"):
        self.key = key
        self.label = label

        super().__init__(type="Classification")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ClassificationShippingRateInput":
        from ._schemas.cart import ClassificationShippingRateInputSchema

        return ClassificationShippingRateInputSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import ClassificationShippingRateInputSchema

        return ClassificationShippingRateInputSchema().dump(self)


class ScoreShippingRateInput(ShippingRateInput):
    #: Abstract value for categorizing a Cart.
    score: int

    def __init__(self, *, score: int):
        self.score = score

        super().__init__(type="Score")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ScoreShippingRateInput":
        from ._schemas.cart import ScoreShippingRateInputSchema

        return ScoreShippingRateInputSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import ScoreShippingRateInputSchema

        return ScoreShippingRateInputSchema().dump(self)


class ShippingRateInputDraft(_BaseType):
    """Generic type holding specifc ShippingRateInputDraft types."""

    type: str

    def __init__(self, *, type: str):
        self.type = type

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ShippingRateInputDraft":
        if data["type"] == "Classification":
            from ._schemas.cart import ClassificationShippingRateInputDraftSchema

            return ClassificationShippingRateInputDraftSchema().load(data)
        if data["type"] == "Score":
            from ._schemas.cart import ScoreShippingRateInputDraftSchema

            return ScoreShippingRateInputDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import ShippingRateInputDraftSchema

        return ShippingRateInputDraftSchema().dump(self)


class ClassificationShippingRateInputDraft(ShippingRateInputDraft):
    #: Key of the value used as a programmatic identifier.
    key: str

    def __init__(self, *, key: str):
        self.key = key

        super().__init__(type="Classification")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ClassificationShippingRateInputDraft":
        from ._schemas.cart import ClassificationShippingRateInputDraftSchema

        return ClassificationShippingRateInputDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import ClassificationShippingRateInputDraftSchema

        return ClassificationShippingRateInputDraftSchema().dump(self)


class ScoreShippingRateInputDraft(ShippingRateInputDraft):
    #: Abstract value for categorizing a Cart.
    score: int

    def __init__(self, *, score: int):
        self.score = score

        super().__init__(type="Score")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ScoreShippingRateInputDraft":
        from ._schemas.cart import ScoreShippingRateInputDraftSchema

        return ScoreShippingRateInputDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import ScoreShippingRateInputDraftSchema

        return ScoreShippingRateInputDraftSchema().dump(self)


class TaxCalculationMode(enum.Enum):
    """Determines in which [Tax calculation mode](/carts-orders-overview#tax-calculation-mode) taxed prices are calculated."""

    LINE_ITEM_LEVEL = "LineItemLevel"
    UNIT_PRICE_LEVEL = "UnitPriceLevel"


class TaxMode(enum.Enum):
    """Indicates how taxes are set on the Cart."""

    PLATFORM = "Platform"
    EXTERNAL = "External"
    EXTERNAL_AMOUNT = "ExternalAmount"
    DISABLED = "Disabled"


class TaxPortion(_BaseType):
    """The tax portions are calculated from the [TaxRates](ctp:api:type:TaxRate).
    If a Tax Rate has [SubRates](ctp:api:type:SubRate), they are used and can be identified by name.
    Tax portions from Line Items with the same `rate` and `name` are accumulated to the same tax portion.

    """

    #: Name of the tax portion.
    name: typing.Optional[str]
    #: A number in the range 0-1.
    rate: float
    #: Money value of the tax portion.
    amount: "CentPrecisionMoney"

    def __init__(
        self,
        *,
        name: typing.Optional[str] = None,
        rate: float,
        amount: "CentPrecisionMoney"
    ):
        self.name = name
        self.rate = rate
        self.amount = amount

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "TaxPortion":
        from ._schemas.cart import TaxPortionSchema

        return TaxPortionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import TaxPortionSchema

        return TaxPortionSchema().dump(self)


class TaxPortionDraft(_BaseType):
    """Represents the portions that sum up to the `totalGross` field of a [TaxedPrice](ctp:api:type:TaxedPrice).

    The portions are calculated from the [TaxRates](ctp:api:type:TaxRate).
    If a Tax Rate has [SubRates](ctp:api:type:SubRate), they are used and can be identified by name.
    Tax portions from Line Items with the same `rate` and `name` will be accumulated to the same tax portion.

    """

    #: Name of the tax portion.
    name: typing.Optional[str]
    #: A number in the range 0-1.
    rate: float
    #: Money value for the tax portion.
    amount: "Money"

    def __init__(
        self, *, name: typing.Optional[str] = None, rate: float, amount: "Money"
    ):
        self.name = name
        self.rate = rate
        self.amount = amount

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "TaxPortionDraft":
        from ._schemas.cart import TaxPortionDraftSchema

        return TaxPortionDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import TaxPortionDraftSchema

        return TaxPortionDraftSchema().dump(self)


class TaxedItemPrice(_BaseType):
    #: Total net amount of the Line Item or Custom Line Item.
    total_net: "CentPrecisionMoney"
    #: Total gross amount of the Line Item or Custom Line Item.
    total_gross: "CentPrecisionMoney"
    #: Total tax applicable for the Line Item or Custom Line Item.
    #: Automatically calculated as the difference between the `totalGross` and `totalNet` values.
    total_tax: typing.Optional["CentPrecisionMoney"]

    def __init__(
        self,
        *,
        total_net: "CentPrecisionMoney",
        total_gross: "CentPrecisionMoney",
        total_tax: typing.Optional["CentPrecisionMoney"] = None
    ):
        self.total_net = total_net
        self.total_gross = total_gross
        self.total_tax = total_tax

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "TaxedItemPrice":
        from ._schemas.cart import TaxedItemPriceSchema

        return TaxedItemPriceSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import TaxedItemPriceSchema

        return TaxedItemPriceSchema().dump(self)


class TaxedPrice(_BaseType):
    #: Total net price of the Cart or Order.
    total_net: "CentPrecisionMoney"
    #: Total gross price of the Cart or Order.
    total_gross: "CentPrecisionMoney"
    #: Taxable portions added to the total net price.
    #:
    #: Calculated from the [TaxRates](ctp:api:type:TaxRate).
    tax_portions: typing.List["TaxPortion"]
    #: Total tax applicable for the Cart or Order.
    #:
    #: Automatically calculated as the difference between the `totalGross` and `totalNet` values.
    total_tax: typing.Optional["CentPrecisionMoney"]

    def __init__(
        self,
        *,
        total_net: "CentPrecisionMoney",
        total_gross: "CentPrecisionMoney",
        tax_portions: typing.List["TaxPortion"],
        total_tax: typing.Optional["CentPrecisionMoney"] = None
    ):
        self.total_net = total_net
        self.total_gross = total_gross
        self.tax_portions = tax_portions
        self.total_tax = total_tax

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "TaxedPrice":
        from ._schemas.cart import TaxedPriceSchema

        return TaxedPriceSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import TaxedPriceSchema

        return TaxedPriceSchema().dump(self)


class TaxedPriceDraft(_BaseType):
    #: Total net price of the Line Item or Custom Line Item.
    total_net: "Money"
    #: Total gross price of the Line Item or Custom Line Item.
    total_gross: "Money"
    #: Taxable portions added to the `totalGross`.
    #:
    #: Calculated from the [TaxRates](ctp:api:type:TaxRate).
    tax_portions: typing.List["TaxPortionDraft"]

    def __init__(
        self,
        *,
        total_net: "Money",
        total_gross: "Money",
        tax_portions: typing.List["TaxPortionDraft"]
    ):
        self.total_net = total_net
        self.total_gross = total_gross
        self.tax_portions = tax_portions

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "TaxedPriceDraft":
        from ._schemas.cart import TaxedPriceDraftSchema

        return TaxedPriceDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import TaxedPriceDraftSchema

        return TaxedPriceDraftSchema().dump(self)


class CartAddCustomLineItemAction(CartUpdateAction):
    """If the Cart already contains a [CustomLineItem](ctp:api:type:CustomLineItem) with the same `slug`, `name`, `money`, `taxCategory`, `state`,
    and Custom Fields, then only the quantity of the existing Custom Line Item is increased.
    If [CustomLineItem](ctp:api:type:CustomLineItem) `shippingDetails` are set, they are merged with the `targets` that already exist on the
    [ItemShippingDetails](ctp:api:type:ItemShippingDetails) of the Custom Line Item.
    In case of overlapping address keys the [ItemShippingTarget](ctp:api:type:ItemShippingTarget) `quantity` is summed up.

    If the Cart already contains a Custom Line Item with the same slug that is otherwise not identical, an [InvalidOperation](ctp:api:type:InvalidOperationError) error is returned.

    If the Tax Rate is not set, a [MissingTaxRateForCountry](ctp:api:type:MissingTaxRateForCountryError) error is returned.

    """

    #: Money value of the Custom Line Item.
    #: The value can be negative.
    money: "Money"
    #: Name of the Custom Line Item.
    name: "LocalizedString"
    #: Number of Custom Line Items to add to the Cart.
    quantity: typing.Optional[int]
    #: User-defined identifier used in a deep-link URL for the Custom Line Item.
    #: It must match the pattern `[a-zA-Z0-9_-]{2,256}`.
    slug: str
    #: Used to select a Tax Rate when a Cart has the `Platform` [TaxMode](ctp:api:type:TaxMode).
    #:
    #: If [TaxMode](ctp:api:type:TaxMode) is `Platform`, this field must not be empty.
    tax_category: typing.Optional["TaxCategoryResourceIdentifier"]
    #: An external Tax Rate can be set if the Cart has `External` [TaxMode](ctp:api:type:TaxMode).
    external_tax_rate: typing.Optional["ExternalTaxRateDraft"]
    #: Container for Custom Line Item-specific addresses.
    shipping_details: typing.Optional["ItemShippingDetailsDraft"]
    #: Custom Fields for the Custom Line Item.
    custom: typing.Optional["CustomFieldsDraft"]
    #: - If `Standard`, Cart Discounts with a matching [CartDiscountCustomLineItemsTarget](ctp:api:type:CartDiscountCustomLineItemsTarget)
    #: are applied to the Custom Line Item.
    #: - If `External`, Cart Discounts are not considered on the Custom Line Item.
    price_mode: typing.Optional["CustomLineItemPriceMode"]

    def __init__(
        self,
        *,
        money: "Money",
        name: "LocalizedString",
        quantity: typing.Optional[int] = None,
        slug: str,
        tax_category: typing.Optional["TaxCategoryResourceIdentifier"] = None,
        external_tax_rate: typing.Optional["ExternalTaxRateDraft"] = None,
        shipping_details: typing.Optional["ItemShippingDetailsDraft"] = None,
        custom: typing.Optional["CustomFieldsDraft"] = None,
        price_mode: typing.Optional["CustomLineItemPriceMode"] = None
    ):
        self.money = money
        self.name = name
        self.quantity = quantity
        self.slug = slug
        self.tax_category = tax_category
        self.external_tax_rate = external_tax_rate
        self.shipping_details = shipping_details
        self.custom = custom
        self.price_mode = price_mode

        super().__init__(action="addCustomLineItem")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartAddCustomLineItemAction":
        from ._schemas.cart import CartAddCustomLineItemActionSchema

        return CartAddCustomLineItemActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartAddCustomLineItemActionSchema

        return CartAddCustomLineItemActionSchema().dump(self)


class CartAddCustomShippingMethodAction(CartUpdateAction):
    """To add a custom Shipping Method (independent of the [ShippingMethods](ctp:api:type:ShippingMethod) managed through
    the [Shipping Methods API](/projects/shippingMethods)) to the Cart, it **must have** the `Multiple` [ShippingMode](ctp:api:type:ShippingMode).

    """

    #: User-defined identifier for the custom Shipping Method that must be unique across the Cart with `Multiple` [ShippingMode](ctp:api:type:ShippingMode).
    shipping_key: str
    #: Name of the custom Shipping Method.
    shipping_method_name: str
    #: Determines the shipping rate and Tax Rate of the associated Line Items.
    shipping_address: "BaseAddress"
    #: Determines the shipping price.
    shipping_rate: "ShippingRateDraft"
    #: Input used to select a [ShippingRatePriceTier](ctp:api:type:ShippingRatePriceTier).
    #: The data type of this field depends on the `shippingRateInputType.type` configured in the [Project](ctp:api:type:Project):
    #:
    #: - If `CartClassification`, it must be [ClassificationShippingRateInputDraft](ctp:api:type:ClassificationShippingRateInputDraft).
    #: - If `CartScore`, it must be [ScoreShippingRateInputDraft](ctp:api:type:ScoreShippingRateInputDraft).
    #: - If `CartValue`, it cannot be set.
    shipping_rate_input: typing.Optional["ShippingRateInputDraft"]
    #: Tax Category used to determine a shipping Tax Rate if the Cart has the `Platform` [TaxMode](ctp:api:type:TaxMode).
    tax_category: typing.Optional["TaxCategoryResourceIdentifier"]
    #: Tax Rate used to tax a shipping expense if the Cart has the `External` [TaxMode](ctp:api:type:TaxMode).
    external_tax_rate: typing.Optional["ExternalTaxRateDraft"]
    #: Deliveries to be shipped with the custom Shipping Method.
    deliveries: typing.Optional[typing.List["DeliveryDraft"]]
    #: Custom Fields for the custom Shipping Method.
    custom: typing.Optional["CustomFieldsDraft"]

    def __init__(
        self,
        *,
        shipping_key: str,
        shipping_method_name: str,
        shipping_address: "BaseAddress",
        shipping_rate: "ShippingRateDraft",
        shipping_rate_input: typing.Optional["ShippingRateInputDraft"] = None,
        tax_category: typing.Optional["TaxCategoryResourceIdentifier"] = None,
        external_tax_rate: typing.Optional["ExternalTaxRateDraft"] = None,
        deliveries: typing.Optional[typing.List["DeliveryDraft"]] = None,
        custom: typing.Optional["CustomFieldsDraft"] = None
    ):
        self.shipping_key = shipping_key
        self.shipping_method_name = shipping_method_name
        self.shipping_address = shipping_address
        self.shipping_rate = shipping_rate
        self.shipping_rate_input = shipping_rate_input
        self.tax_category = tax_category
        self.external_tax_rate = external_tax_rate
        self.deliveries = deliveries
        self.custom = custom

        super().__init__(action="addCustomShippingMethod")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartAddCustomShippingMethodAction":
        from ._schemas.cart import CartAddCustomShippingMethodActionSchema

        return CartAddCustomShippingMethodActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartAddCustomShippingMethodActionSchema

        return CartAddCustomShippingMethodActionSchema().dump(self)


class CartAddDiscountCodeAction(CartUpdateAction):
    """Adds a [DiscountCode](ctp:api:type:DiscountCode) to the Cart to activate the related [Cart Discounts](/../api/projects/cartDiscounts).
    Adding a Discount Code is only possible if no [DirectDiscount](ctp:api:type:DirectDiscount) has been applied to the Cart.
    Discount Codes can be added to [frozen Carts](ctp:api:type:FrozenCarts), but their [DiscountCodeState](ctp:api:type:DiscountCodeState) is then `DoesNotMatchCart`.

    The maximum number of Discount Codes in a Cart is restricted by a [limit](/../api/limits#carts).

    Specific Error Code: [MatchingPriceNotFound](ctp:api:type:MatchingPriceNotFoundError)

    """

    #: `code` of a [DiscountCode](ctp:api:type:DiscountCode).
    code: str

    def __init__(self, *, code: str):
        self.code = code

        super().__init__(action="addDiscountCode")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartAddDiscountCodeAction":
        from ._schemas.cart import CartAddDiscountCodeActionSchema

        return CartAddDiscountCodeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartAddDiscountCodeActionSchema

        return CartAddDiscountCodeActionSchema().dump(self)


class CartAddItemShippingAddressAction(CartUpdateAction):
    """Adds an address to a Cart when shipping to multiple addresses is desired."""

    #: Address to append to `itemShippingAddresses`.
    #:
    #: The new Address must have a `key` that is unique accross this Cart.
    address: "BaseAddress"

    def __init__(self, *, address: "BaseAddress"):
        self.address = address

        super().__init__(action="addItemShippingAddress")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartAddItemShippingAddressAction":
        from ._schemas.cart import CartAddItemShippingAddressActionSchema

        return CartAddItemShippingAddressActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartAddItemShippingAddressActionSchema

        return CartAddItemShippingAddressActionSchema().dump(self)


class CartAddLineItemAction(CartUpdateAction):
    """If the Cart contains a [LineItem](ctp:api:type:LineItem) for a Product Variant with the same [LineItemMode](ctp:api:type:LineItemMode), [Custom Fields](/../api/projects/custom-fields), supply and distribution channel, then only the quantity of the existing Line Item is increased.
    If [LineItem](ctp:api:type:LineItem) `shippingDetails` is set, it is merged. All addresses will be present afterwards and, for address keys present in both shipping details, the quantity will be summed up.
    A new Line Item is added when the `externalPrice` or `externalTotalPrice` is set in this update action.
    The [LineItem](ctp:api:type:LineItem) price is set as described in [LineItem Price selection](ctp:api:type:LineItemPriceSelection).

    If the Tax Rate is not set, a [MissingTaxRateForCountry](ctp:api:type:MissingTaxRateForCountryError) error is returned.

    If the Line Items do not have a Price according to the [Product](ctp:api:type:Product) `priceMode` value for a selected currency and/or country, Customer Group, or Channel, a [MatchingPriceNotFound](ctp:api:type:MatchingPriceNotFoundError) error is returned.

    """

    #: User-defined unique identifier of the LineItem.
    key: typing.Optional[str]
    #: `id` of the published [Product](ctp:api:type:Product).
    #:
    #: Either the `productId` and `variantId`, or `sku` must be provided.
    product_id: typing.Optional[str]
    #: `id` of the [ProductVariant](ctp:api:type:ProductVariant) in the Product.
    #: If not provided, the Master Variant is used.
    #:
    #: Either the `productId` and `variantId`, or `sku` must be provided.
    variant_id: typing.Optional[int]
    #: SKU of the [ProductVariant](ctp:api:type:ProductVariant).
    #:
    #: Either the `productId` and `variantId`, or `sku` must be provided.
    sku: typing.Optional[str]
    #: Quantity of the Product Variant to add to the Cart.
    quantity: typing.Optional[int]
    #: Date and time (UTC) the Product Variant is added to the Cart.
    #: If not set, it defaults to the current date and time.
    #:
    #: Optional for backwards compatibility reasons.
    added_at: typing.Optional[datetime.datetime]
    #: Used to [select](ctp:api:type:LineItemPriceSelection) a Product Price.
    #: The Channel must have the `ProductDistribution` [ChannelRoleEnum](ctp:api:type:ChannelRoleEnum).
    #: If the Cart is bound to a [Store](ctp:api:type:Store) with `distributionChannels` set, the Channel must match one of the Store's distribution channels.
    distribution_channel: typing.Optional["ChannelResourceIdentifier"]
    #: Used to identify [Inventory entries](/../api/projects/inventory) that must be reserved.
    #: The Channel must have the `InventorySupply` [ChannelRoleEnum](ctp:api:type:ChannelRoleEnum).
    supply_channel: typing.Optional["ChannelResourceIdentifier"]
    #: Sets the [LineItem](ctp:api:type:LineItem) `price` value, and the `priceMode` to `ExternalPrice` [LineItemPriceMode](ctp:api:type:LineItemPriceMode).
    external_price: typing.Optional["Money"]
    #: Sets the [LineItem](ctp:api:type:LineItem) `price` and `totalPrice` values, and the `priceMode` to `ExternalTotal` [LineItemPriceMode](ctp:api:type:LineItemPriceMode).
    external_total_price: typing.Optional["ExternalLineItemTotalPrice"]
    #: External Tax Rate for the Line Item, if the Cart has the `External` [TaxMode](ctp:api:type:TaxMode).
    external_tax_rate: typing.Optional["ExternalTaxRateDraft"]
    #: Inventory mode specific to the Line Item only, and valid for the entire `quantity` of the Line Item.
    #: Set only if the inventory mode should be different from the `inventoryMode` specified on the [Cart](ctp:api:type:Cart).
    inventory_mode: typing.Optional["InventoryMode"]
    #: Container for Line Item-specific addresses.
    shipping_details: typing.Optional["ItemShippingDetailsDraft"]
    #: Custom Fields for the Line Item.
    custom: typing.Optional["CustomFieldsDraft"]

    def __init__(
        self,
        *,
        key: typing.Optional[str] = None,
        product_id: typing.Optional[str] = None,
        variant_id: typing.Optional[int] = None,
        sku: typing.Optional[str] = None,
        quantity: typing.Optional[int] = None,
        added_at: typing.Optional[datetime.datetime] = None,
        distribution_channel: typing.Optional["ChannelResourceIdentifier"] = None,
        supply_channel: typing.Optional["ChannelResourceIdentifier"] = None,
        external_price: typing.Optional["Money"] = None,
        external_total_price: typing.Optional["ExternalLineItemTotalPrice"] = None,
        external_tax_rate: typing.Optional["ExternalTaxRateDraft"] = None,
        inventory_mode: typing.Optional["InventoryMode"] = None,
        shipping_details: typing.Optional["ItemShippingDetailsDraft"] = None,
        custom: typing.Optional["CustomFieldsDraft"] = None
    ):
        self.key = key
        self.product_id = product_id
        self.variant_id = variant_id
        self.sku = sku
        self.quantity = quantity
        self.added_at = added_at
        self.distribution_channel = distribution_channel
        self.supply_channel = supply_channel
        self.external_price = external_price
        self.external_total_price = external_total_price
        self.external_tax_rate = external_tax_rate
        self.inventory_mode = inventory_mode
        self.shipping_details = shipping_details
        self.custom = custom

        super().__init__(action="addLineItem")

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CartAddLineItemAction":
        from ._schemas.cart import CartAddLineItemActionSchema

        return CartAddLineItemActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartAddLineItemActionSchema

        return CartAddLineItemActionSchema().dump(self)


class CartAddPaymentAction(CartUpdateAction):
    #: Payment to add to the Cart.
    #: Must not be assigned to another Order or active Cart already.
    payment: "PaymentResourceIdentifier"

    def __init__(self, *, payment: "PaymentResourceIdentifier"):
        self.payment = payment

        super().__init__(action="addPayment")

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CartAddPaymentAction":
        from ._schemas.cart import CartAddPaymentActionSchema

        return CartAddPaymentActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartAddPaymentActionSchema

        return CartAddPaymentActionSchema().dump(self)


class CartAddShippingMethodAction(CartUpdateAction):
    """Adds a Shipping Method for a specified shipping address to a Cart with `Multiple` [ShippingMode](ctp:api:type:ShippingMode)."""

    #: User-defined identifier for the [Shipping](ctp:api:type:Shipping) that must be unique across the Cart with `Multiple` [ShippingMode](ctp:api:type:ShippingMode).
    shipping_key: str
    #: RecourceIdentifier to a [ShippingMethod](ctp:api:type:ShippingMethod) to add to the Cart with `Multiple` [ShippingMode](ctp:api:type:ShippingMode).
    #: If the referenced Shipping Method has a predicate that does not match the Cart, an [InvalidOperation](ctp:api:type:InvalidOperationError) error is returned.
    shipping_method: "ShippingMethodResourceIdentifier"
    #: Determines the shipping rate and Tax Rate of the Line Items.
    shipping_address: "BaseAddress"
    #: Input used to select a [ShippingRatePriceTier](ctp:api:type:ShippingRatePriceTier).
    #: The data type of this field depends on the `shippingRateInputType.type` configured in the [Project](ctp:api:type:Project):
    #:
    #: - If `CartClassification`, it must be [ClassificationShippingRateInputDraft](ctp:api:type:ClassificationShippingRateInputDraft).
    #: - If `CartScore`, it must be [ScoreShippingRateInputDraft](ctp:api:type:ScoreShippingRateInputDraft).
    #: - If `CartValue`, it cannot be set.
    shipping_rate_input: typing.Optional["ShippingRateInputDraft"]
    #: Tax Rate used to tax a shipping expense if the Cart has the `External` [TaxMode](ctp:api:type:TaxMode).
    external_tax_rate: typing.Optional["ExternalTaxRateDraft"]
    #: Deliveries to be shipped with the referenced Shipping Method.
    deliveries: typing.Optional[typing.List["DeliveryDraft"]]
    #: Custom Fields for the Shipping Method.
    custom: typing.Optional["CustomFieldsDraft"]

    def __init__(
        self,
        *,
        shipping_key: str,
        shipping_method: "ShippingMethodResourceIdentifier",
        shipping_address: "BaseAddress",
        shipping_rate_input: typing.Optional["ShippingRateInputDraft"] = None,
        external_tax_rate: typing.Optional["ExternalTaxRateDraft"] = None,
        deliveries: typing.Optional[typing.List["DeliveryDraft"]] = None,
        custom: typing.Optional["CustomFieldsDraft"] = None
    ):
        self.shipping_key = shipping_key
        self.shipping_method = shipping_method
        self.shipping_address = shipping_address
        self.shipping_rate_input = shipping_rate_input
        self.external_tax_rate = external_tax_rate
        self.deliveries = deliveries
        self.custom = custom

        super().__init__(action="addShippingMethod")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartAddShippingMethodAction":
        from ._schemas.cart import CartAddShippingMethodActionSchema

        return CartAddShippingMethodActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartAddShippingMethodActionSchema

        return CartAddShippingMethodActionSchema().dump(self)


class CartAddShoppingListAction(CartUpdateAction):
    """Adds all [LineItems](ctp:api:type:LineItem) of a [ShoppingList](ctp:api:type:ShoppingList) to the Cart."""

    #: Shopping List that contains the Line Items to be added.
    shopping_list: "ShoppingListResourceIdentifier"
    #: `distributionChannel` to set for all [LineItems](ctp:api:type:LineItem) that are added to the Cart.
    #: The Channel must have the `ProductDistribution` [ChannelRoleEnum](ctp:api:type:ChannelRoleEnum).
    distribution_channel: typing.Optional["ChannelResourceIdentifier"]
    #: `supplyChannel` to set for all [LineItems](ctp:api:type:LineItem) that are added to the Cart.
    #: The Channel must have the `InventorySupply` [ChannelRoleEnum](ctp:api:type:ChannelRoleEnum).
    supply_channel: typing.Optional["ChannelResourceIdentifier"]

    def __init__(
        self,
        *,
        shopping_list: "ShoppingListResourceIdentifier",
        distribution_channel: typing.Optional["ChannelResourceIdentifier"] = None,
        supply_channel: typing.Optional["ChannelResourceIdentifier"] = None
    ):
        self.shopping_list = shopping_list
        self.distribution_channel = distribution_channel
        self.supply_channel = supply_channel

        super().__init__(action="addShoppingList")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartAddShoppingListAction":
        from ._schemas.cart import CartAddShoppingListActionSchema

        return CartAddShoppingListActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartAddShoppingListActionSchema

        return CartAddShoppingListActionSchema().dump(self)


class CartApplyDeltaToCustomLineItemShippingDetailsTargetsAction(CartUpdateAction):
    #: `id` of the [CustomLineItem](ctp:api:type:CustomLineItem) to update.
    custom_line_item_id: str
    #: Using positive or negative quantities increases or decreases the number of items shipped to an address.
    targets_delta: typing.List["ItemShippingTarget"]

    def __init__(
        self,
        *,
        custom_line_item_id: str,
        targets_delta: typing.List["ItemShippingTarget"]
    ):
        self.custom_line_item_id = custom_line_item_id
        self.targets_delta = targets_delta

        super().__init__(action="applyDeltaToCustomLineItemShippingDetailsTargets")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartApplyDeltaToCustomLineItemShippingDetailsTargetsAction":
        from ._schemas.cart import (
            CartApplyDeltaToCustomLineItemShippingDetailsTargetsActionSchema,
        )

        return CartApplyDeltaToCustomLineItemShippingDetailsTargetsActionSchema().load(
            data
        )

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import (
            CartApplyDeltaToCustomLineItemShippingDetailsTargetsActionSchema,
        )

        return CartApplyDeltaToCustomLineItemShippingDetailsTargetsActionSchema().dump(
            self
        )


class CartApplyDeltaToLineItemShippingDetailsTargetsAction(CartUpdateAction):
    """To override the shipping details, see [Set LineItemShippingDetails](ctp:api:type:CartSetLineItemShippingDetailsAction)."""

    #: `id` of the [LineItem](ctp:api:type:LineItem) to update.
    line_item_id: str
    #: Using positive or negative quantities increases or decreases the number of items shipped to an address.
    targets_delta: typing.List["ItemShippingTarget"]

    def __init__(
        self, *, line_item_id: str, targets_delta: typing.List["ItemShippingTarget"]
    ):
        self.line_item_id = line_item_id
        self.targets_delta = targets_delta

        super().__init__(action="applyDeltaToLineItemShippingDetailsTargets")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartApplyDeltaToLineItemShippingDetailsTargetsAction":
        from ._schemas.cart import (
            CartApplyDeltaToLineItemShippingDetailsTargetsActionSchema,
        )

        return CartApplyDeltaToLineItemShippingDetailsTargetsActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import (
            CartApplyDeltaToLineItemShippingDetailsTargetsActionSchema,
        )

        return CartApplyDeltaToLineItemShippingDetailsTargetsActionSchema().dump(self)


class CartChangeCustomLineItemMoneyAction(CartUpdateAction):
    #: `id` of the [CustomLineItem](ctp:api:type:CustomLineItem) to update.
    custom_line_item_id: str
    #: Value to set. Must not be empty. Can be a negative amount.
    money: "Money"

    def __init__(self, *, custom_line_item_id: str, money: "Money"):
        self.custom_line_item_id = custom_line_item_id
        self.money = money

        super().__init__(action="changeCustomLineItemMoney")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartChangeCustomLineItemMoneyAction":
        from ._schemas.cart import CartChangeCustomLineItemMoneyActionSchema

        return CartChangeCustomLineItemMoneyActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartChangeCustomLineItemMoneyActionSchema

        return CartChangeCustomLineItemMoneyActionSchema().dump(self)


class CartChangeCustomLineItemPriceModeAction(CartUpdateAction):
    #: `id` of the [CustomLineItem](ctp:api:type:CustomLineItem) to update.
    custom_line_item_id: str
    #: New value to set. Must not be empty.
    mode: "CustomLineItemPriceMode"

    def __init__(self, *, custom_line_item_id: str, mode: "CustomLineItemPriceMode"):
        self.custom_line_item_id = custom_line_item_id
        self.mode = mode

        super().__init__(action="changeCustomLineItemPriceMode")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartChangeCustomLineItemPriceModeAction":
        from ._schemas.cart import CartChangeCustomLineItemPriceModeActionSchema

        return CartChangeCustomLineItemPriceModeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartChangeCustomLineItemPriceModeActionSchema

        return CartChangeCustomLineItemPriceModeActionSchema().dump(self)


class CartChangeCustomLineItemQuantityAction(CartUpdateAction):
    """When multiple shipping addresses are set for a Custom Line Item,
    use the [Add CustomLineItem](ctp:api:type:CartAddCustomLineItemAction) update action to change the shipping details.
    Since it is not possible for the API to infer how the overall change in the Custom Line Item quantity should be distributed over the sub-quantities,
    the `shippingDetails` field is kept in its current state to avoid data loss.

    To change the Custom Line Item quantity and shipping details together,
    use this update action in combination with the [Set CustomLineItemShippingDetails](ctp:api:type:CartSetCustomLineItemShippingDetailsAction) update action
    in a single Cart update command.

    """

    #: `id` of the [CustomLineItem](ctp:api:type:CustomLineItem) to update.
    custom_line_item_id: str
    #: New value to set.
    #:
    #: If `0`, the Custom Line Item is removed from the Cart.
    quantity: int

    def __init__(self, *, custom_line_item_id: str, quantity: int):
        self.custom_line_item_id = custom_line_item_id
        self.quantity = quantity

        super().__init__(action="changeCustomLineItemQuantity")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartChangeCustomLineItemQuantityAction":
        from ._schemas.cart import CartChangeCustomLineItemQuantityActionSchema

        return CartChangeCustomLineItemQuantityActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartChangeCustomLineItemQuantityActionSchema

        return CartChangeCustomLineItemQuantityActionSchema().dump(self)


class CartChangeLineItemQuantityAction(CartUpdateAction):
    """When multiple shipping addresses are set for a Line Item,
    use the [Remove LineItem](ctp:api:type:CartRemoveLineItemAction) and [Add LineItem](ctp:api:type:CartAddLineItemAction) update action
    to change the shipping details.
    Since it is not possible for the API to infer how the overall change in the Line Item quantity should be distributed over the sub-quantities,
    the `shippingDetails` field is kept in its current state to avoid data loss.

    To change the Line Item quantity and shipping details together,
    use this update action in combination with the [Set LineItemShippingDetails](ctp:api:type:CartSetCustomLineItemShippingDetailsAction) update action
    in a single Cart update command.

    The [LineItem](ctp:api:type:LineItem) price is set as described in [LineItem Price selection](ctp:api:type:LineItemPriceSelection).

    """

    #: `id` of the [LineItem](ctp:api:type:LineItem) to update.
    line_item_id: str
    #: New value to set.
    #:
    #: If `0`, the Line Item is removed from the Cart.
    quantity: int
    #: Sets the [LineItem](ctp:api:type:LineItem) `price` to the given value when changing the quantity of a Line Item with the `ExternalPrice` [LineItemPriceMode](ctp:api:type:LineItemPriceMode).
    #:
    #: The LineItem price is updated as described in LineItem Price selection.
    external_price: typing.Optional["Money"]
    #: Sets the [LineItem](ctp:api:type:LineItem) `price` and `totalPrice` to the given value when changing the quantity of a Line Item with the `ExternalTotal` [LineItemPriceMode](ctp:api:type:LineItemPriceMode).
    external_total_price: typing.Optional["ExternalLineItemTotalPrice"]

    def __init__(
        self,
        *,
        line_item_id: str,
        quantity: int,
        external_price: typing.Optional["Money"] = None,
        external_total_price: typing.Optional["ExternalLineItemTotalPrice"] = None
    ):
        self.line_item_id = line_item_id
        self.quantity = quantity
        self.external_price = external_price
        self.external_total_price = external_total_price

        super().__init__(action="changeLineItemQuantity")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartChangeLineItemQuantityAction":
        from ._schemas.cart import CartChangeLineItemQuantityActionSchema

        return CartChangeLineItemQuantityActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartChangeLineItemQuantityActionSchema

        return CartChangeLineItemQuantityActionSchema().dump(self)


class CartChangeTaxCalculationModeAction(CartUpdateAction):
    """Changing the tax calculation mode leads to [recalculation of taxes](/../api/carts-orders-overview#cart-tax-calculation)."""

    #: New value to set.
    tax_calculation_mode: "TaxCalculationMode"

    def __init__(self, *, tax_calculation_mode: "TaxCalculationMode"):
        self.tax_calculation_mode = tax_calculation_mode

        super().__init__(action="changeTaxCalculationMode")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartChangeTaxCalculationModeAction":
        from ._schemas.cart import CartChangeTaxCalculationModeActionSchema

        return CartChangeTaxCalculationModeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartChangeTaxCalculationModeActionSchema

        return CartChangeTaxCalculationModeActionSchema().dump(self)


class CartChangeTaxModeAction(CartUpdateAction):
    """- When `External` [TaxMode](ctp:api:type:TaxMode) is changed to `Platform` or `Disabled`, all previously set external Tax Rates are removed.
    - When set to `Platform`, Line Items, Custom Line Items, and Shipping Method require a Tax Category with a Tax Rate for the Cart's `shippingAddress`.

    """

    #: The new TaxMode.
    tax_mode: "TaxMode"

    def __init__(self, *, tax_mode: "TaxMode"):
        self.tax_mode = tax_mode

        super().__init__(action="changeTaxMode")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartChangeTaxModeAction":
        from ._schemas.cart import CartChangeTaxModeActionSchema

        return CartChangeTaxModeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartChangeTaxModeActionSchema

        return CartChangeTaxModeActionSchema().dump(self)


class CartChangeTaxRoundingModeAction(CartUpdateAction):
    """Changing the tax rounding mode leads to [recalculation of taxes](/../api/carts-orders-overview#cart-tax-calculation)."""

    #: New value to set.
    tax_rounding_mode: "RoundingMode"

    def __init__(self, *, tax_rounding_mode: "RoundingMode"):
        self.tax_rounding_mode = tax_rounding_mode

        super().__init__(action="changeTaxRoundingMode")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartChangeTaxRoundingModeAction":
        from ._schemas.cart import CartChangeTaxRoundingModeActionSchema

        return CartChangeTaxRoundingModeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartChangeTaxRoundingModeActionSchema

        return CartChangeTaxRoundingModeActionSchema().dump(self)


class CartFreezeCartAction(CartUpdateAction):
    """Changes the [CartState](ctp:api:type:CartState) from `Active` to `Frozen`. Results in a [Frozen Cart](ctp:api:type:FrozenCarts).
    Fails with [InvalidOperation](ctp:api:type:InvalidOperation) error when the Cart is empty.

    """

    def __init__(self):
        super().__init__(action="freezeCart")

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CartFreezeCartAction":
        from ._schemas.cart import CartFreezeCartActionSchema

        return CartFreezeCartActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartFreezeCartActionSchema

        return CartFreezeCartActionSchema().dump(self)


class CartRecalculateAction(CartUpdateAction):
    """This update action does not set any Cart field in particular, but it triggers several [Cart updates](/../api/carts-orders-overview#cart-updates)
    to bring prices and discounts to the latest state. Those can become stale over time when no Cart updates have been performed for a while and
    prices on related Products have changed in the meanwhile.

    If the `priceMode` of the [Product](ctp:api:type:Product) related to a Line Item is of `Embedded` [ProductPriceMode](ctp:api:type:ProductPriceModeEnum),
    the updated `price` of that [LineItem](ctp:api:type:LineItem) may not correspond to a Price in the `variant.prices` anymore.

    """

    #: - Leave empty or set to `false` to only update the Prices and TaxRates of the Line Items.
    #: - Set to `true` to update the Line Items' product data (like `name`, `variant` and `productType`) also.
    update_product_data: typing.Optional[bool]

    def __init__(self, *, update_product_data: typing.Optional[bool] = None):
        self.update_product_data = update_product_data

        super().__init__(action="recalculate")

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CartRecalculateAction":
        from ._schemas.cart import CartRecalculateActionSchema

        return CartRecalculateActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartRecalculateActionSchema

        return CartRecalculateActionSchema().dump(self)


class CartRemoveCustomLineItemAction(CartUpdateAction):
    """This update action does not support specifying quantities, unlike the [Remove LineItem](ctp:api:type:CartRemoveLineItemAction) update action.

    If `shippingDetails` must be partially removed, use the [Change CustomLineItem Quantity](ctp:api:type:CartChangeCustomLineItemQuantityAction) update action.

    """

    #: `id` of the Custom Line Item to remove.
    custom_line_item_id: str

    def __init__(self, *, custom_line_item_id: str):
        self.custom_line_item_id = custom_line_item_id

        super().__init__(action="removeCustomLineItem")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartRemoveCustomLineItemAction":
        from ._schemas.cart import CartRemoveCustomLineItemActionSchema

        return CartRemoveCustomLineItemActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartRemoveCustomLineItemActionSchema

        return CartRemoveCustomLineItemActionSchema().dump(self)


class CartRemoveDiscountCodeAction(CartUpdateAction):
    #: Discount Code to remove from the Cart.
    discount_code: "DiscountCodeReference"

    def __init__(self, *, discount_code: "DiscountCodeReference"):
        self.discount_code = discount_code

        super().__init__(action="removeDiscountCode")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartRemoveDiscountCodeAction":
        from ._schemas.cart import CartRemoveDiscountCodeActionSchema

        return CartRemoveDiscountCodeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartRemoveDiscountCodeActionSchema

        return CartRemoveDiscountCodeActionSchema().dump(self)


class CartRemoveItemShippingAddressAction(CartUpdateAction):
    """An address can only be removed if it is not referenced in any [ItemShippingTarget](ctp:api:type:ItemShippingTarget) of the Cart."""

    #: `key` of the Address to remove from `itemShippingAddresses`.
    address_key: str

    def __init__(self, *, address_key: str):
        self.address_key = address_key

        super().__init__(action="removeItemShippingAddress")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartRemoveItemShippingAddressAction":
        from ._schemas.cart import CartRemoveItemShippingAddressActionSchema

        return CartRemoveItemShippingAddressActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartRemoveItemShippingAddressActionSchema

        return CartRemoveItemShippingAddressActionSchema().dump(self)


class CartRemoveLineItemAction(CartUpdateAction):
    """The [LineItem](ctp:api:type:LineItem) price is updated as described in [LineItem Price selection](ctp:api:type:LineItemPriceSelection)."""

    #: `id` of the Line Item to remove.
    line_item_id: str
    #: New value to set.
    #: If absent or `0`, the Line Item is removed from the Cart.
    quantity: typing.Optional[int]
    #: Sets the [LineItem](ctp:api:type:LineItem) `price` to the given value when decreasing the quantity of a Line Item with the `ExternalPrice` [LineItemPriceMode](ctp:api:type:LineItemPriceMode).
    external_price: typing.Optional["Money"]
    #: Sets the [LineItem](ctp:api:type:LineItem) `price` and `totalPrice` to the given value when decreasing the quantity of a Line Item with the `ExternalTotal` [LineItemPriceMode](ctp:api:type:LineItemPriceMode).
    external_total_price: typing.Optional["ExternalLineItemTotalPrice"]
    #: Container for Line Item-specific addresses to remove.
    shipping_details_to_remove: typing.Optional["ItemShippingDetailsDraft"]

    def __init__(
        self,
        *,
        line_item_id: str,
        quantity: typing.Optional[int] = None,
        external_price: typing.Optional["Money"] = None,
        external_total_price: typing.Optional["ExternalLineItemTotalPrice"] = None,
        shipping_details_to_remove: typing.Optional["ItemShippingDetailsDraft"] = None
    ):
        self.line_item_id = line_item_id
        self.quantity = quantity
        self.external_price = external_price
        self.external_total_price = external_total_price
        self.shipping_details_to_remove = shipping_details_to_remove

        super().__init__(action="removeLineItem")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartRemoveLineItemAction":
        from ._schemas.cart import CartRemoveLineItemActionSchema

        return CartRemoveLineItemActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartRemoveLineItemActionSchema

        return CartRemoveLineItemActionSchema().dump(self)


class CartRemovePaymentAction(CartUpdateAction):
    #: Payment to remove from the Cart.
    payment: "PaymentResourceIdentifier"

    def __init__(self, *, payment: "PaymentResourceIdentifier"):
        self.payment = payment

        super().__init__(action="removePayment")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartRemovePaymentAction":
        from ._schemas.cart import CartRemovePaymentActionSchema

        return CartRemovePaymentActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartRemovePaymentActionSchema

        return CartRemovePaymentActionSchema().dump(self)


class CartRemoveShippingMethodAction(CartUpdateAction):
    """Removes a Shipping Method from a Cart that has the `Multiple` [ShippingMode](ctp:api:type:ShippingMode)."""

    #: User-defined unique identifier of the Shipping Method to remove from the Cart.
    shipping_key: str

    def __init__(self, *, shipping_key: str):
        self.shipping_key = shipping_key

        super().__init__(action="removeShippingMethod")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartRemoveShippingMethodAction":
        from ._schemas.cart import CartRemoveShippingMethodActionSchema

        return CartRemoveShippingMethodActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartRemoveShippingMethodActionSchema

        return CartRemoveShippingMethodActionSchema().dump(self)


class CartSetAnonymousIdAction(CartUpdateAction):
    #: Value to set.
    #: If empty, any existing value is removed.
    anonymous_id: typing.Optional[str]

    def __init__(self, *, anonymous_id: typing.Optional[str] = None):
        self.anonymous_id = anonymous_id

        super().__init__(action="setAnonymousId")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartSetAnonymousIdAction":
        from ._schemas.cart import CartSetAnonymousIdActionSchema

        return CartSetAnonymousIdActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartSetAnonymousIdActionSchema

        return CartSetAnonymousIdActionSchema().dump(self)


class CartSetBillingAddressAction(CartUpdateAction):
    #: Value to set.
    #: If empty, any existing value is removed.
    address: typing.Optional["BaseAddress"]

    def __init__(self, *, address: typing.Optional["BaseAddress"] = None):
        self.address = address

        super().__init__(action="setBillingAddress")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartSetBillingAddressAction":
        from ._schemas.cart import CartSetBillingAddressActionSchema

        return CartSetBillingAddressActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartSetBillingAddressActionSchema

        return CartSetBillingAddressActionSchema().dump(self)


class CartSetBillingAddressCustomFieldAction(CartUpdateAction):
    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: Removing a field that does not exist returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
    #: If `value` is provided, it is set for the field defined by `name`.
    value: typing.Optional[typing.Any]

    def __init__(self, *, name: str, value: typing.Optional[typing.Any] = None):
        self.name = name
        self.value = value

        super().__init__(action="setBillingAddressCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartSetBillingAddressCustomFieldAction":
        from ._schemas.cart import CartSetBillingAddressCustomFieldActionSchema

        return CartSetBillingAddressCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartSetBillingAddressCustomFieldActionSchema

        return CartSetBillingAddressCustomFieldActionSchema().dump(self)


class CartSetBillingAddressCustomTypeAction(CartUpdateAction):
    #: Defines the [Type](ctp:api:type:Type) that extends the `billingAddress` with [Custom Fields](/../api/projects/custom-fields).
    #: If absent, any existing Type and Custom Fields are removed from the `billingAddress`.
    type: typing.Optional["TypeResourceIdentifier"]
    #: Sets the [Custom Fields](/../api/projects/custom-fields) fields for the `billingAddress`.
    fields: typing.Optional["FieldContainer"]

    def __init__(
        self,
        *,
        type: typing.Optional["TypeResourceIdentifier"] = None,
        fields: typing.Optional["FieldContainer"] = None
    ):
        self.type = type
        self.fields = fields

        super().__init__(action="setBillingAddressCustomType")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartSetBillingAddressCustomTypeAction":
        from ._schemas.cart import CartSetBillingAddressCustomTypeActionSchema

        return CartSetBillingAddressCustomTypeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartSetBillingAddressCustomTypeActionSchema

        return CartSetBillingAddressCustomTypeActionSchema().dump(self)


class CartSetBusinessUnitAction(CartUpdateAction):
    """Updates the Business Unit on the Cart. The Cart must have an existing Business Unit assigned already."""

    #: New Business Unit to assign to the Cart, which must have access to the [Store](/../api/projects/stores) that is set on the Cart.
    business_unit: "BusinessUnitResourceIdentifier"

    def __init__(self, *, business_unit: "BusinessUnitResourceIdentifier"):
        self.business_unit = business_unit

        super().__init__(action="setBusinessUnit")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartSetBusinessUnitAction":
        from ._schemas.cart import CartSetBusinessUnitActionSchema

        return CartSetBusinessUnitActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartSetBusinessUnitActionSchema

        return CartSetBusinessUnitActionSchema().dump(self)


class CartSetCartTotalTaxAction(CartUpdateAction):
    """This update action results in the `taxedPrice` field being added to the Cart when the `ExternalAmount` [TaxMode](ctp:api:type:TaxMode) is used."""

    #: The Cart's total gross price becoming the `totalGross` field (`totalNet` + taxes) on the Cart's `taxedPrice`.
    external_total_gross: "Money"
    #: Set if the `externalTotalGross` price is a sum of portions with different tax rates.
    external_tax_portions: typing.Optional[typing.List["TaxPortionDraft"]]

    def __init__(
        self,
        *,
        external_total_gross: "Money",
        external_tax_portions: typing.Optional[typing.List["TaxPortionDraft"]] = None
    ):
        self.external_total_gross = external_total_gross
        self.external_tax_portions = external_tax_portions

        super().__init__(action="setCartTotalTax")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartSetCartTotalTaxAction":
        from ._schemas.cart import CartSetCartTotalTaxActionSchema

        return CartSetCartTotalTaxActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartSetCartTotalTaxActionSchema

        return CartSetCartTotalTaxActionSchema().dump(self)


class CartSetCountryAction(CartUpdateAction):
    """Setting the country can lead to changes in the [LineItem](ctp:api:type:LineItem) prices."""

    #: Value to set.
    #: If empty, any existing value is removed.
    #:
    #: If the Cart is bound to a `store`, the provided value must be included in the [Store's](ctp:api:type:Store) `countries`.
    #: Otherwise a [CountryNotConfiguredInStore](ctp:api:type:CountryNotConfiguredInStoreError) error is returned.
    country: typing.Optional[str]

    def __init__(self, *, country: typing.Optional[str] = None):
        self.country = country

        super().__init__(action="setCountry")

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CartSetCountryAction":
        from ._schemas.cart import CartSetCountryActionSchema

        return CartSetCountryActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartSetCountryActionSchema

        return CartSetCountryActionSchema().dump(self)


class CartSetCustomFieldAction(CartUpdateAction):
    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: Removing a field that does not exist returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
    #: If `value` is provided, it is set for the field defined by `name`.
    value: typing.Optional[typing.Any]

    def __init__(self, *, name: str, value: typing.Optional[typing.Any] = None):
        self.name = name
        self.value = value

        super().__init__(action="setCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartSetCustomFieldAction":
        from ._schemas.cart import CartSetCustomFieldActionSchema

        return CartSetCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartSetCustomFieldActionSchema

        return CartSetCustomFieldActionSchema().dump(self)


class CartSetCustomLineItemCustomFieldAction(CartUpdateAction):
    #: `id` of the [CustomLineItem](ctp:api:type:CustomLineItem) to update.
    custom_line_item_id: str
    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: Removing a field that does not exist returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
    #: If `value` is provided, it is set for the field defined by `name`.
    value: typing.Optional[typing.Any]

    def __init__(
        self,
        *,
        custom_line_item_id: str,
        name: str,
        value: typing.Optional[typing.Any] = None
    ):
        self.custom_line_item_id = custom_line_item_id
        self.name = name
        self.value = value

        super().__init__(action="setCustomLineItemCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartSetCustomLineItemCustomFieldAction":
        from ._schemas.cart import CartSetCustomLineItemCustomFieldActionSchema

        return CartSetCustomLineItemCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartSetCustomLineItemCustomFieldActionSchema

        return CartSetCustomLineItemCustomFieldActionSchema().dump(self)


class CartSetCustomLineItemCustomTypeAction(CartUpdateAction):
    #: `id` of the [CustomLineItem](ctp:api:type:CustomLineItem) to update.
    custom_line_item_id: str
    #: Defines the [Type](ctp:api:type:Type) that extends the CustomLineItem with [Custom Fields](/../api/projects/custom-fields).
    #: If absent, any existing Type and Custom Fields are removed from the CustomLineItem.
    type: typing.Optional["TypeResourceIdentifier"]
    #: Sets the [Custom Fields](/../api/projects/custom-fields) fields for the CustomLineItem.
    fields: typing.Optional["FieldContainer"]

    def __init__(
        self,
        *,
        custom_line_item_id: str,
        type: typing.Optional["TypeResourceIdentifier"] = None,
        fields: typing.Optional["FieldContainer"] = None
    ):
        self.custom_line_item_id = custom_line_item_id
        self.type = type
        self.fields = fields

        super().__init__(action="setCustomLineItemCustomType")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartSetCustomLineItemCustomTypeAction":
        from ._schemas.cart import CartSetCustomLineItemCustomTypeActionSchema

        return CartSetCustomLineItemCustomTypeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartSetCustomLineItemCustomTypeActionSchema

        return CartSetCustomLineItemCustomTypeActionSchema().dump(self)


class CartSetCustomLineItemShippingDetailsAction(CartUpdateAction):
    #: `id` of the [CustomLineItem](ctp:api:type:CustomLineItem) to update.
    custom_line_item_id: str
    #: Value to set.
    #: If empty, any existing value is removed.
    shipping_details: typing.Optional["ItemShippingDetailsDraft"]

    def __init__(
        self,
        *,
        custom_line_item_id: str,
        shipping_details: typing.Optional["ItemShippingDetailsDraft"] = None
    ):
        self.custom_line_item_id = custom_line_item_id
        self.shipping_details = shipping_details

        super().__init__(action="setCustomLineItemShippingDetails")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartSetCustomLineItemShippingDetailsAction":
        from ._schemas.cart import CartSetCustomLineItemShippingDetailsActionSchema

        return CartSetCustomLineItemShippingDetailsActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartSetCustomLineItemShippingDetailsActionSchema

        return CartSetCustomLineItemShippingDetailsActionSchema().dump(self)


class CartSetCustomLineItemTaxAmountAction(CartUpdateAction):
    """Can be used if the Cart has the `ExternalAmount` [TaxMode](ctp:api:type:TaxMode)."""

    #: `id` of the [CustomLineItem](ctp:api:type:CustomLineItem) to update.
    custom_line_item_id: str
    #: Value to set.
    #: If empty, any existing value is removed.
    external_tax_amount: typing.Optional["ExternalTaxAmountDraft"]

    def __init__(
        self,
        *,
        custom_line_item_id: str,
        external_tax_amount: typing.Optional["ExternalTaxAmountDraft"] = None
    ):
        self.custom_line_item_id = custom_line_item_id
        self.external_tax_amount = external_tax_amount

        super().__init__(action="setCustomLineItemTaxAmount")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartSetCustomLineItemTaxAmountAction":
        from ._schemas.cart import CartSetCustomLineItemTaxAmountActionSchema

        return CartSetCustomLineItemTaxAmountActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartSetCustomLineItemTaxAmountActionSchema

        return CartSetCustomLineItemTaxAmountActionSchema().dump(self)


class CartSetCustomLineItemTaxRateAction(CartUpdateAction):
    """Can be used if the Cart has the `External` [TaxMode](ctp:api:type:TaxMode)."""

    #: `id` of the [CustomLineItem](ctp:api:type:CustomLineItem) to update.
    custom_line_item_id: str
    #: Value to set.
    #: If empty, an existing value is removed.
    external_tax_rate: typing.Optional["ExternalTaxRateDraft"]

    def __init__(
        self,
        *,
        custom_line_item_id: str,
        external_tax_rate: typing.Optional["ExternalTaxRateDraft"] = None
    ):
        self.custom_line_item_id = custom_line_item_id
        self.external_tax_rate = external_tax_rate

        super().__init__(action="setCustomLineItemTaxRate")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartSetCustomLineItemTaxRateAction":
        from ._schemas.cart import CartSetCustomLineItemTaxRateActionSchema

        return CartSetCustomLineItemTaxRateActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartSetCustomLineItemTaxRateActionSchema

        return CartSetCustomLineItemTaxRateActionSchema().dump(self)


class CartSetCustomShippingMethodAction(CartUpdateAction):
    """To set the Cart's custom Shipping Method (independent of the [ShippingMethods](ctp:api:type:ShippingMethod) managed through
    the [Shipping Methods API](/projects/shippingMethods)) the Cart must have
    the `Single` [ShippingMode](ctp:api:type:ShippingMode) and a `shippingAddress`.

    To unset a custom Shipping Method on a Cart, use the [Set ShippingMethod](ctp:api:type:CartSetShippingMethodAction) update action
    without the `shippingMethod` field instead.

    """

    #: Name of the custom Shipping Method.
    shipping_method_name: str
    #: Determines the shipping price.
    shipping_rate: "ShippingRateDraft"
    #: Tax Category used to determine the Tax Rate when the Cart has the `Platform` [TaxMode](ctp:api:type:TaxMode).
    tax_category: typing.Optional["TaxCategoryResourceIdentifier"]
    #: External Tax Rate for the `shippingRate` to be set if the Cart has the `External` [TaxMode](ctp:api:type:TaxMode).
    external_tax_rate: typing.Optional["ExternalTaxRateDraft"]

    def __init__(
        self,
        *,
        shipping_method_name: str,
        shipping_rate: "ShippingRateDraft",
        tax_category: typing.Optional["TaxCategoryResourceIdentifier"] = None,
        external_tax_rate: typing.Optional["ExternalTaxRateDraft"] = None
    ):
        self.shipping_method_name = shipping_method_name
        self.shipping_rate = shipping_rate
        self.tax_category = tax_category
        self.external_tax_rate = external_tax_rate

        super().__init__(action="setCustomShippingMethod")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartSetCustomShippingMethodAction":
        from ._schemas.cart import CartSetCustomShippingMethodActionSchema

        return CartSetCustomShippingMethodActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartSetCustomShippingMethodActionSchema

        return CartSetCustomShippingMethodActionSchema().dump(self)


class CartSetCustomTypeAction(CartUpdateAction):
    #: Defines the [Type](ctp:api:type:Type) that extends the Cart with [Custom Fields](/../api/projects/custom-fields).
    #: If absent, any existing Type and Custom Fields are removed from the Cart.
    type: typing.Optional["TypeResourceIdentifier"]
    #: Sets the [Custom Fields](/../api/projects/custom-fields) fields for the Cart.
    fields: typing.Optional["FieldContainer"]

    def __init__(
        self,
        *,
        type: typing.Optional["TypeResourceIdentifier"] = None,
        fields: typing.Optional["FieldContainer"] = None
    ):
        self.type = type
        self.fields = fields

        super().__init__(action="setCustomType")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartSetCustomTypeAction":
        from ._schemas.cart import CartSetCustomTypeActionSchema

        return CartSetCustomTypeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartSetCustomTypeActionSchema

        return CartSetCustomTypeActionSchema().dump(self)


class CartSetCustomerEmailAction(CartUpdateAction):
    #: Value to set.
    #: If empty, any existing value is removed.
    email: typing.Optional[str]

    def __init__(self, *, email: typing.Optional[str] = None):
        self.email = email

        super().__init__(action="setCustomerEmail")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartSetCustomerEmailAction":
        from ._schemas.cart import CartSetCustomerEmailActionSchema

        return CartSetCustomerEmailActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartSetCustomerEmailActionSchema

        return CartSetCustomerEmailActionSchema().dump(self)


class CartSetCustomerGroupAction(CartUpdateAction):
    """This update action can only be used if a Customer is not assigned to a Cart.
    If a Customer is already assigned, the Cart has the same Customer Group as the assigned Customer.

    Setting the Customer Group also updates the [LineItem](ctp:api:type:LineItem) `prices` according to the Customer Group.

    """

    #: Value to set.
    #: If empty, any existing value is removed.
    customer_group: typing.Optional["CustomerGroupResourceIdentifier"]

    def __init__(
        self,
        *,
        customer_group: typing.Optional["CustomerGroupResourceIdentifier"] = None
    ):
        self.customer_group = customer_group

        super().__init__(action="setCustomerGroup")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartSetCustomerGroupAction":
        from ._schemas.cart import CartSetCustomerGroupActionSchema

        return CartSetCustomerGroupActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartSetCustomerGroupActionSchema

        return CartSetCustomerGroupActionSchema().dump(self)


class CartSetCustomerIdAction(CartUpdateAction):
    """Setting the Cart's `customerId` can lead to updates on all its [LineItem](ctp:api:type:LineItem) `prices`.

    If the Customer with the specified `id` cannot be found, this update action returns a
    [ReferencedResourceNotFound](ctp:api:type:ReferencedResourceNotFoundError) error.

    """

    #: `id` of an existing [Customer](ctp:api:type:Customer). If empty, any value is removed.
    customer_id: typing.Optional[str]

    def __init__(self, *, customer_id: typing.Optional[str] = None):
        self.customer_id = customer_id

        super().__init__(action="setCustomerId")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartSetCustomerIdAction":
        from ._schemas.cart import CartSetCustomerIdActionSchema

        return CartSetCustomerIdActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartSetCustomerIdActionSchema

        return CartSetCustomerIdActionSchema().dump(self)


class CartSetDeleteDaysAfterLastModificationAction(CartUpdateAction):
    """Number of days after which a Cart with `Active` [CartState](ctp:api:type:CartState) is deleted since its last modification.

    If a [ChangeSubscription](ctp:api:type:ChangeSubscription) exists for Carts, a [ResourceDeletedDeliveryPayload](ctp:api:type:ResourceDeletedDeliveryPayload) is sent.

    """

    #: Value to set.
    #: If not provided, the default value for this field configured in [Project settings](ctp:api:type:CartsConfiguration) is assigned.
    delete_days_after_last_modification: typing.Optional[int]

    def __init__(
        self, *, delete_days_after_last_modification: typing.Optional[int] = None
    ):
        self.delete_days_after_last_modification = delete_days_after_last_modification

        super().__init__(action="setDeleteDaysAfterLastModification")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartSetDeleteDaysAfterLastModificationAction":
        from ._schemas.cart import CartSetDeleteDaysAfterLastModificationActionSchema

        return CartSetDeleteDaysAfterLastModificationActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartSetDeleteDaysAfterLastModificationActionSchema

        return CartSetDeleteDaysAfterLastModificationActionSchema().dump(self)


class CartSetDeliveryAddressCustomFieldAction(CartUpdateAction):
    #: `id` of the [Delivery](ctp:api:type:Delivery).
    delivery_id: str
    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: Removing a field that does not exist returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
    #: If `value` is provided, it is set for the field defined by `name`.
    value: typing.Optional[typing.Any]

    def __init__(
        self, *, delivery_id: str, name: str, value: typing.Optional[typing.Any] = None
    ):
        self.delivery_id = delivery_id
        self.name = name
        self.value = value

        super().__init__(action="setDeliveryAddressCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartSetDeliveryAddressCustomFieldAction":
        from ._schemas.cart import CartSetDeliveryAddressCustomFieldActionSchema

        return CartSetDeliveryAddressCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartSetDeliveryAddressCustomFieldActionSchema

        return CartSetDeliveryAddressCustomFieldActionSchema().dump(self)


class CartSetDeliveryAddressCustomTypeAction(CartUpdateAction):
    #: `id` of the [Delivery](ctp:api:type:Delivery).
    delivery_id: str
    #: Defines the [Type](ctp:api:type:Type) that extends the [Delivery](ctp:api:type:Delivery) `address` with [Custom Fields](/../api/projects/custom-fields).
    #: If absent, any existing Type and Custom Fields are removed from the [Delivery](ctp:api:type:Delivery) `address`.
    type: typing.Optional["TypeResourceIdentifier"]
    #: Sets the [Custom Fields](/../api/projects/custom-fields) fields for the [Delivery](ctp:api:type:Delivery) `address`.
    fields: typing.Optional["FieldContainer"]

    def __init__(
        self,
        *,
        delivery_id: str,
        type: typing.Optional["TypeResourceIdentifier"] = None,
        fields: typing.Optional["FieldContainer"] = None
    ):
        self.delivery_id = delivery_id
        self.type = type
        self.fields = fields

        super().__init__(action="setDeliveryAddressCustomType")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartSetDeliveryAddressCustomTypeAction":
        from ._schemas.cart import CartSetDeliveryAddressCustomTypeActionSchema

        return CartSetDeliveryAddressCustomTypeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartSetDeliveryAddressCustomTypeActionSchema

        return CartSetDeliveryAddressCustomTypeActionSchema().dump(self)


class CartSetDirectDiscountsAction(CartUpdateAction):
    """Adds a [DirectDiscount](ctp:api:type:DirectDiscount), but only if no [DiscountCode](ctp:api:type:DiscountCode) has been added to the Cart.
    Either a Discount Code or a Direct Discount can exist on a Cart at the same time.

    """

    #: - If set, all existing Direct Discounts are replaced.
    #:   The discounts apply in the order they are added to the list.
    #: - If empty, all existing Direct Discounts are removed and all affected prices on the Cart or Order are recalculated.
    discounts: typing.List["DirectDiscountDraft"]

    def __init__(self, *, discounts: typing.List["DirectDiscountDraft"]):
        self.discounts = discounts

        super().__init__(action="setDirectDiscounts")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartSetDirectDiscountsAction":
        from ._schemas.cart import CartSetDirectDiscountsActionSchema

        return CartSetDirectDiscountsActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartSetDirectDiscountsActionSchema

        return CartSetDirectDiscountsActionSchema().dump(self)


class CartSetItemShippingAddressCustomFieldAction(CartUpdateAction):
    #: `key` of the [Address](ctp:api:type:Address) in `itemShippingAddress`.
    address_key: str
    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: Removing a field that does not exist returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
    #: If `value` is provided, it is set for the field defined by `name`.
    value: typing.Optional[typing.Any]

    def __init__(
        self, *, address_key: str, name: str, value: typing.Optional[typing.Any] = None
    ):
        self.address_key = address_key
        self.name = name
        self.value = value

        super().__init__(action="setItemShippingAddressCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartSetItemShippingAddressCustomFieldAction":
        from ._schemas.cart import CartSetItemShippingAddressCustomFieldActionSchema

        return CartSetItemShippingAddressCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartSetItemShippingAddressCustomFieldActionSchema

        return CartSetItemShippingAddressCustomFieldActionSchema().dump(self)


class CartSetItemShippingAddressCustomTypeAction(CartUpdateAction):
    #: `key` of the [Address](ctp:api:type:Address) in `itemShippingAddress`.
    address_key: str
    #: Defines the [Type](ctp:api:type:Type) that extends the `itemShippingAddress` with [Custom Fields](/../api/projects/custom-fields).
    #: If absent, any existing Type and Custom Fields are removed from the `itemShippingAddress`.
    type: typing.Optional["TypeResourceIdentifier"]
    #: Sets the [Custom Fields](/../api/projects/custom-fields) fields for the `itemShippingAddress`.
    fields: typing.Optional["FieldContainer"]

    def __init__(
        self,
        *,
        address_key: str,
        type: typing.Optional["TypeResourceIdentifier"] = None,
        fields: typing.Optional["FieldContainer"] = None
    ):
        self.address_key = address_key
        self.type = type
        self.fields = fields

        super().__init__(action="setItemShippingAddressCustomType")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartSetItemShippingAddressCustomTypeAction":
        from ._schemas.cart import CartSetItemShippingAddressCustomTypeActionSchema

        return CartSetItemShippingAddressCustomTypeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartSetItemShippingAddressCustomTypeActionSchema

        return CartSetItemShippingAddressCustomTypeActionSchema().dump(self)


class CartSetKeyAction(CartUpdateAction):
    #: Value to set.
    #: If empty, any existing key will be removed.
    key: typing.Optional[str]

    def __init__(self, *, key: typing.Optional[str] = None):
        self.key = key

        super().__init__(action="setKey")

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CartSetKeyAction":
        from ._schemas.cart import CartSetKeyActionSchema

        return CartSetKeyActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartSetKeyActionSchema

        return CartSetKeyActionSchema().dump(self)


class CartSetLineItemCustomFieldAction(CartUpdateAction):
    #: `id` of the [LineItem](ctp:api:type:LineItem) to update.
    line_item_id: str
    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: Removing a field that does not exist returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
    #: If `value` is provided, it is set for the field defined by `name`.
    value: typing.Optional[typing.Any]

    def __init__(
        self, *, line_item_id: str, name: str, value: typing.Optional[typing.Any] = None
    ):
        self.line_item_id = line_item_id
        self.name = name
        self.value = value

        super().__init__(action="setLineItemCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartSetLineItemCustomFieldAction":
        from ._schemas.cart import CartSetLineItemCustomFieldActionSchema

        return CartSetLineItemCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartSetLineItemCustomFieldActionSchema

        return CartSetLineItemCustomFieldActionSchema().dump(self)


class CartSetLineItemCustomTypeAction(CartUpdateAction):
    #: `id` of the [LineItem](ctp:api:type:LineItem) to update.
    line_item_id: str
    #: Defines the [Type](ctp:api:type:Type) that extends the Line Item with [Custom Fields](/../api/projects/custom-fields).
    #: If absent, any existing Type and Custom Fields are removed from the Line Item.
    type: typing.Optional["TypeResourceIdentifier"]
    #: Sets the [Custom Fields](/../api/projects/custom-fields) fields for the Line Item.
    fields: typing.Optional["FieldContainer"]

    def __init__(
        self,
        *,
        line_item_id: str,
        type: typing.Optional["TypeResourceIdentifier"] = None,
        fields: typing.Optional["FieldContainer"] = None
    ):
        self.line_item_id = line_item_id
        self.type = type
        self.fields = fields

        super().__init__(action="setLineItemCustomType")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartSetLineItemCustomTypeAction":
        from ._schemas.cart import CartSetLineItemCustomTypeActionSchema

        return CartSetLineItemCustomTypeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartSetLineItemCustomTypeActionSchema

        return CartSetLineItemCustomTypeActionSchema().dump(self)


class CartSetLineItemDistributionChannelAction(CartUpdateAction):
    """Setting a distribution channel for a [LineItem](ctp:api:type:LineItem) can lead to an updated `price` as described in [LineItem Price selection](ctp:api:type:LineItemPriceSelection)."""

    #: `id` of the [LineItem](ctp:api:type:LineItem) to update.
    line_item_id: str
    #: - If present, a [Reference](ctp:api:type:Reference) to the Channel is set for the [LineItem](ctp:api:type:LineItem) specified by `lineItemId`.
    #: - If not present, the current [Reference](ctp:api:type:Reference) to a distribution channel is removed from the [LineItem](ctp:api:type:LineItem) specified by `lineItemId`.
    #:   The Channel must have the `ProductDistribution` [ChannelRoleEnum](ctp:api:type:ChannelRoleEnum).
    distribution_channel: typing.Optional["ChannelResourceIdentifier"]

    def __init__(
        self,
        *,
        line_item_id: str,
        distribution_channel: typing.Optional["ChannelResourceIdentifier"] = None
    ):
        self.line_item_id = line_item_id
        self.distribution_channel = distribution_channel

        super().__init__(action="setLineItemDistributionChannel")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartSetLineItemDistributionChannelAction":
        from ._schemas.cart import CartSetLineItemDistributionChannelActionSchema

        return CartSetLineItemDistributionChannelActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartSetLineItemDistributionChannelActionSchema

        return CartSetLineItemDistributionChannelActionSchema().dump(self)


class CartSetLineItemInventoryModeAction(CartUpdateAction):
    #: `id` of the [LineItem](ctp:api:type:LineItem) to update.
    line_item_id: str
    #: Inventory mode specific to the Line Item only, and valid for the entire `quantity` of the Line Item.
    #: Set only if the inventory mode should be different from the `inventoryMode` specified on the [Cart](ctp:api:type:Cart).
    inventory_mode: typing.Optional["InventoryMode"]

    def __init__(
        self,
        *,
        line_item_id: str,
        inventory_mode: typing.Optional["InventoryMode"] = None
    ):
        self.line_item_id = line_item_id
        self.inventory_mode = inventory_mode

        super().__init__(action="setLineItemInventoryMode")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartSetLineItemInventoryModeAction":
        from ._schemas.cart import CartSetLineItemInventoryModeActionSchema

        return CartSetLineItemInventoryModeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartSetLineItemInventoryModeActionSchema

        return CartSetLineItemInventoryModeActionSchema().dump(self)


class CartSetLineItemPriceAction(CartUpdateAction):
    """Sets the [LineItem](ctp:api:type:LineItem) `price` and changes the `priceMode` to `ExternalPrice` [LineItemPriceMode](ctp:api:type:LineItemPriceMode)."""

    #: `id` of the [LineItem](ctp:api:type:LineItem) to update.
    line_item_id: str
    #: Value to set.
    #: If `externalPrice` is not given and the `priceMode` is `ExternalPrice`, the external price is unset and the `priceMode` is set to `Platform`.
    external_price: typing.Optional["Money"]

    def __init__(
        self, *, line_item_id: str, external_price: typing.Optional["Money"] = None
    ):
        self.line_item_id = line_item_id
        self.external_price = external_price

        super().__init__(action="setLineItemPrice")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartSetLineItemPriceAction":
        from ._schemas.cart import CartSetLineItemPriceActionSchema

        return CartSetLineItemPriceActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartSetLineItemPriceActionSchema

        return CartSetLineItemPriceActionSchema().dump(self)


class CartSetLineItemShippingDetailsAction(CartUpdateAction):
    #: `id` of the [LineItem](ctp:api:type:LineItem) to update.
    line_item_id: str
    #: Value to set.
    #: If empty, the existing value is removed.
    shipping_details: typing.Optional["ItemShippingDetailsDraft"]

    def __init__(
        self,
        *,
        line_item_id: str,
        shipping_details: typing.Optional["ItemShippingDetailsDraft"] = None
    ):
        self.line_item_id = line_item_id
        self.shipping_details = shipping_details

        super().__init__(action="setLineItemShippingDetails")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartSetLineItemShippingDetailsAction":
        from ._schemas.cart import CartSetLineItemShippingDetailsActionSchema

        return CartSetLineItemShippingDetailsActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartSetLineItemShippingDetailsActionSchema

        return CartSetLineItemShippingDetailsActionSchema().dump(self)


class CartSetLineItemSupplyChannelAction(CartUpdateAction):
    """Performing this action has no impact on inventory that should be reserved."""

    #: `id` of the [LineItem](ctp:api:type:LineItem) to update.
    line_item_id: str
    #: - If present, a [Reference](ctp:api:type:Reference) to the Channel is set for the [LineItem](ctp:api:type:LineItem) specified by `lineItemId`.
    #: - If not present, the current [Reference](ctp:api:type:Reference) to a supply channel will be removed from the [LineItem](ctp:api:type:LineItem) specified by `lineItemId`.
    #:   The Channel must have the `InventorySupply` [ChannelRoleEnum](ctp:api:type:ChannelRoleEnum).
    supply_channel: typing.Optional["ChannelResourceIdentifier"]

    def __init__(
        self,
        *,
        line_item_id: str,
        supply_channel: typing.Optional["ChannelResourceIdentifier"] = None
    ):
        self.line_item_id = line_item_id
        self.supply_channel = supply_channel

        super().__init__(action="setLineItemSupplyChannel")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartSetLineItemSupplyChannelAction":
        from ._schemas.cart import CartSetLineItemSupplyChannelActionSchema

        return CartSetLineItemSupplyChannelActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartSetLineItemSupplyChannelActionSchema

        return CartSetLineItemSupplyChannelActionSchema().dump(self)


class CartSetLineItemTaxAmountAction(CartUpdateAction):
    """Can be used if the Cart has the `ExternalAmount` [TaxMode](ctp:api:type:TaxMode)."""

    #: `id` of the [LineItem](ctp:api:type:LineItem) to update.
    line_item_id: str
    #: Value to set.
    #: If empty, any existing value is removed.
    external_tax_amount: typing.Optional["ExternalTaxAmountDraft"]
    #: `key` of the [ShippingMethod](ctp:api:type:ShippingMethod) used for this Line Item.
    #: This is required for Carts with `Multiple` [ShippingMode](ctp:api:type:ShippingMode).
    shipping_key: typing.Optional[str]

    def __init__(
        self,
        *,
        line_item_id: str,
        external_tax_amount: typing.Optional["ExternalTaxAmountDraft"] = None,
        shipping_key: typing.Optional[str] = None
    ):
        self.line_item_id = line_item_id
        self.external_tax_amount = external_tax_amount
        self.shipping_key = shipping_key

        super().__init__(action="setLineItemTaxAmount")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartSetLineItemTaxAmountAction":
        from ._schemas.cart import CartSetLineItemTaxAmountActionSchema

        return CartSetLineItemTaxAmountActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartSetLineItemTaxAmountActionSchema

        return CartSetLineItemTaxAmountActionSchema().dump(self)


class CartSetLineItemTaxRateAction(CartUpdateAction):
    """Can be used if the Cart has the `External` [TaxMode](ctp:api:type:TaxMode)."""

    #: `id` of the [LineItem](ctp:api:type:LineItem) to update.
    line_item_id: str
    #: Value to set.
    #: If empty, any existing value is removed.
    external_tax_rate: typing.Optional["ExternalTaxRateDraft"]
    #: `key` of the [ShippingMethod](ctp:api:type:ShippingMethod) used for this Line Item.
    #: This is required for Carts with `Multiple` [ShippingMode](ctp:api:type:ShippingMode).
    shipping_key: typing.Optional[str]

    def __init__(
        self,
        *,
        line_item_id: str,
        external_tax_rate: typing.Optional["ExternalTaxRateDraft"] = None,
        shipping_key: typing.Optional[str] = None
    ):
        self.line_item_id = line_item_id
        self.external_tax_rate = external_tax_rate
        self.shipping_key = shipping_key

        super().__init__(action="setLineItemTaxRate")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartSetLineItemTaxRateAction":
        from ._schemas.cart import CartSetLineItemTaxRateActionSchema

        return CartSetLineItemTaxRateActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartSetLineItemTaxRateActionSchema

        return CartSetLineItemTaxRateActionSchema().dump(self)


class CartSetLineItemTotalPriceAction(CartUpdateAction):
    """Sets the [LineItem](ctp:api:type:LineItem) `totalPrice` and `price`, and changes the `priceMode` to `ExternalTotal` [LineItemPriceMode](ctp:api:type:LineItemPriceMode)."""

    #: `id` of the [LineItem](ctp:api:type:LineItem) to update.
    line_item_id: str
    #: Value to set.
    #: If `externalTotalPrice` is not given and the `priceMode` is `ExternalTotal`, the external price is unset and the `priceMode` is set to `Platform`.
    external_total_price: typing.Optional["ExternalLineItemTotalPrice"]

    def __init__(
        self,
        *,
        line_item_id: str,
        external_total_price: typing.Optional["ExternalLineItemTotalPrice"] = None
    ):
        self.line_item_id = line_item_id
        self.external_total_price = external_total_price

        super().__init__(action="setLineItemTotalPrice")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartSetLineItemTotalPriceAction":
        from ._schemas.cart import CartSetLineItemTotalPriceActionSchema

        return CartSetLineItemTotalPriceActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartSetLineItemTotalPriceActionSchema

        return CartSetLineItemTotalPriceActionSchema().dump(self)


class CartSetLocaleAction(CartUpdateAction):
    #: Value to set.
    #: Must be one of the [Project](ctp:api:type:Project)'s `languages`.
    #: If empty, any existing value will be removed.
    locale: typing.Optional[str]

    def __init__(self, *, locale: typing.Optional[str] = None):
        self.locale = locale

        super().__init__(action="setLocale")

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CartSetLocaleAction":
        from ._schemas.cart import CartSetLocaleActionSchema

        return CartSetLocaleActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartSetLocaleActionSchema

        return CartSetLocaleActionSchema().dump(self)


class CartSetShippingAddressAction(CartUpdateAction):
    """Setting the shipping address also sets the [TaxRate](ctp:api:type:TaxRate) of Line Items and calculates the [TaxedPrice](ctp:api:type:TaxedPrice).

    If a matching price cannot be found for the given shipping address during [Line Item Price selection](ctp:api:type:LineItemPriceSelection),
    a [MissingTaxRateForCountry](ctp:api:type:MissingTaxRateForCountryError) error is returned.

    If you want to allow shipping to states inside a country that are not explicitly covered by a TaxRate,
    set the `countryTaxRateFallbackEnabled` field to `true` in the [CartsConfiguration](ctp:api:type:CartsConfiguration) by using
    the [Change CountryTaxRateFallbackEnabled](ctp:api:type:ProjectChangeCountryTaxRateFallbackEnabledAction) update action.

    """

    #: Value to set.
    #: If not set, the shipping address is unset, and the `taxedPrice` and `taxRate` are unset in all Line Items of the Cart.
    address: typing.Optional["BaseAddress"]

    def __init__(self, *, address: typing.Optional["BaseAddress"] = None):
        self.address = address

        super().__init__(action="setShippingAddress")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartSetShippingAddressAction":
        from ._schemas.cart import CartSetShippingAddressActionSchema

        return CartSetShippingAddressActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartSetShippingAddressActionSchema

        return CartSetShippingAddressActionSchema().dump(self)


class CartSetShippingAddressCustomFieldAction(CartUpdateAction):
    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: Removing a field that does not exist returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
    #: If `value` is provided, it is set for the field defined by `name`.
    value: typing.Optional[typing.Any]

    def __init__(self, *, name: str, value: typing.Optional[typing.Any] = None):
        self.name = name
        self.value = value

        super().__init__(action="setShippingAddressCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartSetShippingAddressCustomFieldAction":
        from ._schemas.cart import CartSetShippingAddressCustomFieldActionSchema

        return CartSetShippingAddressCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartSetShippingAddressCustomFieldActionSchema

        return CartSetShippingAddressCustomFieldActionSchema().dump(self)


class CartSetShippingAddressCustomTypeAction(CartUpdateAction):
    #: Defines the [Type](ctp:api:type:Type) that extends the `shippingAddress` with [Custom Fields](/../api/projects/custom-fields).
    #: If absent, any existing Type and Custom Fields are removed from the `shippingAddress`.
    type: typing.Optional["TypeResourceIdentifier"]
    #: Sets the [Custom Fields](/../api/projects/custom-fields) fields for the `shippingAddress`.
    fields: typing.Optional["FieldContainer"]

    def __init__(
        self,
        *,
        type: typing.Optional["TypeResourceIdentifier"] = None,
        fields: typing.Optional["FieldContainer"] = None
    ):
        self.type = type
        self.fields = fields

        super().__init__(action="setShippingAddressCustomType")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartSetShippingAddressCustomTypeAction":
        from ._schemas.cart import CartSetShippingAddressCustomTypeActionSchema

        return CartSetShippingAddressCustomTypeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartSetShippingAddressCustomTypeActionSchema

        return CartSetShippingAddressCustomTypeActionSchema().dump(self)


class CartSetShippingCustomFieldAction(CartUpdateAction):
    #: The `shippingKey` of the [Shipping](ctp:api:type:Shipping) to customize. Used to specify which Shipping Method to customize
    #: on a Cart with `Multiple` [ShippingMode](ctp:api:type:ShippingMode).
    #: Leave this empty to customize the one and only ShippingMethod on a `Single` ShippingMode Cart.
    shipping_key: typing.Optional[str]
    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: Trying to remove a field that does not exist will fail with an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
    #: If `value` is provided, it is set for the field defined by `name`.
    value: typing.Optional[typing.Any]

    def __init__(
        self,
        *,
        shipping_key: typing.Optional[str] = None,
        name: str,
        value: typing.Optional[typing.Any] = None
    ):
        self.shipping_key = shipping_key
        self.name = name
        self.value = value

        super().__init__(action="setShippingCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartSetShippingCustomFieldAction":
        from ._schemas.cart import CartSetShippingCustomFieldActionSchema

        return CartSetShippingCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartSetShippingCustomFieldActionSchema

        return CartSetShippingCustomFieldActionSchema().dump(self)


class CartSetShippingCustomTypeAction(CartUpdateAction):
    """This action sets, overwrites, or removes any existing Custom Type and Custom Fields for the Cart's `shippingMethod` or `shipping`."""

    #: The `shippingKey` of the [Shipping](ctp:api:type:Shipping) to customize. Used to specify which Shipping Method to customize
    #: on a Cart with `Multiple` [ShippingMode](ctp:api:type:ShippingMode).
    #: Leave this empty to customize the one and only ShippingMethod on a `Single` ShippingMode Cart.
    shipping_key: typing.Optional[str]
    #: Defines the [Type](ctp:api:type:Type) that extends the specified ShippingMethod with [Custom Fields](/../api/projects/custom-fields).
    #: If absent, any existing Type and Custom Fields are removed from the ShippingMethod.
    type: typing.Optional["TypeResourceIdentifier"]
    #: Sets the [Custom Fields](/../api/projects/custom-fields) fields for the `shippingMethod`.
    fields: typing.Optional["FieldContainer"]

    def __init__(
        self,
        *,
        shipping_key: typing.Optional[str] = None,
        type: typing.Optional["TypeResourceIdentifier"] = None,
        fields: typing.Optional["FieldContainer"] = None
    ):
        self.shipping_key = shipping_key
        self.type = type
        self.fields = fields

        super().__init__(action="setShippingCustomType")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartSetShippingCustomTypeAction":
        from ._schemas.cart import CartSetShippingCustomTypeActionSchema

        return CartSetShippingCustomTypeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartSetShippingCustomTypeActionSchema

        return CartSetShippingCustomTypeActionSchema().dump(self)


class CartSetShippingMethodAction(CartUpdateAction):
    """To set the Cart's Shipping Method the Cart must have the `Single` [ShippingMode](ctp:api:type:ShippingMode) and a `shippingAddress`."""

    #: Value to set.
    #: If empty, any existing value is removed.
    #:
    #: If the referenced Shipping Method has a predicate that does not match the Cart, an [InvalidOperation](ctp:api:type:InvalidOperationError) error is returned.
    shipping_method: typing.Optional["ShippingMethodResourceIdentifier"]
    #: An external Tax Rate can be set if the Cart has the `External` [TaxMode](ctp:api:type:TaxMode).
    external_tax_rate: typing.Optional["ExternalTaxRateDraft"]

    def __init__(
        self,
        *,
        shipping_method: typing.Optional["ShippingMethodResourceIdentifier"] = None,
        external_tax_rate: typing.Optional["ExternalTaxRateDraft"] = None
    ):
        self.shipping_method = shipping_method
        self.external_tax_rate = external_tax_rate

        super().__init__(action="setShippingMethod")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartSetShippingMethodAction":
        from ._schemas.cart import CartSetShippingMethodActionSchema

        return CartSetShippingMethodActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartSetShippingMethodActionSchema

        return CartSetShippingMethodActionSchema().dump(self)


class CartSetShippingMethodTaxAmountAction(CartUpdateAction):
    """A Shipping Method tax amount can be set if the Cart has the `ExternalAmount` [TaxMode](ctp:api:type:TaxMode)."""

    #: `key` of the [ShippingMethod](ctp:api:type:ShippingMethod) to update. This is required for Carts with `Multiple` [ShippingMode](ctp:api:type:ShippingMode).
    shipping_key: typing.Optional[str]
    #: Value to set.
    #: If empty, any existing value is removed.
    external_tax_amount: typing.Optional["ExternalTaxAmountDraft"]

    def __init__(
        self,
        *,
        shipping_key: typing.Optional[str] = None,
        external_tax_amount: typing.Optional["ExternalTaxAmountDraft"] = None
    ):
        self.shipping_key = shipping_key
        self.external_tax_amount = external_tax_amount

        super().__init__(action="setShippingMethodTaxAmount")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartSetShippingMethodTaxAmountAction":
        from ._schemas.cart import CartSetShippingMethodTaxAmountActionSchema

        return CartSetShippingMethodTaxAmountActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartSetShippingMethodTaxAmountActionSchema

        return CartSetShippingMethodTaxAmountActionSchema().dump(self)


class CartSetShippingMethodTaxRateAction(CartUpdateAction):
    """A Shipping Method Tax Rate can be set if the Cart has the `External` [TaxMode](ctp:api:type:TaxMode)."""

    #: `key` of the [ShippingMethod](ctp:api:type:ShippingMethod) to update. This is required for Carts with `Multiple` [ShippingMode](ctp:api:type:ShippingMode).
    shipping_key: typing.Optional[str]
    #: Value to set.
    #: If empty, any existing value is removed.
    external_tax_rate: typing.Optional["ExternalTaxRateDraft"]

    def __init__(
        self,
        *,
        shipping_key: typing.Optional[str] = None,
        external_tax_rate: typing.Optional["ExternalTaxRateDraft"] = None
    ):
        self.shipping_key = shipping_key
        self.external_tax_rate = external_tax_rate

        super().__init__(action="setShippingMethodTaxRate")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartSetShippingMethodTaxRateAction":
        from ._schemas.cart import CartSetShippingMethodTaxRateActionSchema

        return CartSetShippingMethodTaxRateActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartSetShippingMethodTaxRateActionSchema

        return CartSetShippingMethodTaxRateActionSchema().dump(self)


class CartSetShippingRateInputAction(CartUpdateAction):
    """Input used to select a [ShippingRatePriceTier](ctp:api:type:ShippingRatePriceTier).
    If no matching tier can be found, or the input is not set, the default price for the shipping rate is used.

    """

    #: The data type of this field depends on the `shippingRateInputType.type` configured in the [Project](ctp:api:type:Project):
    #:
    #: - If `CartClassification`, it must be [ClassificationShippingRateInputDraft](ctp:api:type:ClassificationShippingRateInputDraft).
    #: - If `CartScore`, it must be [ScoreShippingRateInputDraft](ctp:api:type:ScoreShippingRateInputDraft).
    #: - If `CartValue`, it cannot be set.
    shipping_rate_input: typing.Optional["ShippingRateInputDraft"]

    def __init__(
        self, *, shipping_rate_input: typing.Optional["ShippingRateInputDraft"] = None
    ):
        self.shipping_rate_input = shipping_rate_input

        super().__init__(action="setShippingRateInput")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartSetShippingRateInputAction":
        from ._schemas.cart import CartSetShippingRateInputActionSchema

        return CartSetShippingRateInputActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartSetShippingRateInputActionSchema

        return CartSetShippingRateInputActionSchema().dump(self)


class CartUnfreezeCartAction(CartUpdateAction):
    """Changes the [CartState](ctp:api:type:CartState) from `Frozen` to `Active`. Reactivates a [Frozen Cart](ctp:api:type:FrozenCarts).
    This action updates all prices in the Cart according to latest Prices on related Product Variants and Shipping Methods and by applying all discounts currently being active and applicable for the Cart.

    """

    def __init__(self):
        super().__init__(action="unfreezeCart")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartUnfreezeCartAction":
        from ._schemas.cart import CartUnfreezeCartActionSchema

        return CartUnfreezeCartActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartUnfreezeCartActionSchema

        return CartUnfreezeCartActionSchema().dump(self)


class CartUpdateItemShippingAddressAction(CartUpdateAction):
    """Updates an address in `itemShippingAddresses` by keeping the Address `key`."""

    #: The new Address with the same `key` as the Address it will replace.
    address: "BaseAddress"

    def __init__(self, *, address: "BaseAddress"):
        self.address = address

        super().__init__(action="updateItemShippingAddress")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartUpdateItemShippingAddressAction":
        from ._schemas.cart import CartUpdateItemShippingAddressActionSchema

        return CartUpdateItemShippingAddressActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CartUpdateItemShippingAddressActionSchema

        return CartUpdateItemShippingAddressActionSchema().dump(self)


class CustomLineItemImportDraft(_BaseType):
    name: "LocalizedString"
    #: The amount of a CustomLineItem in the cart.
    #: Must be a positive integer.
    quantity: int
    #: The cost to add to the cart. The amount can be negative.
    money: "Money"
    slug: str
    state: typing.Optional[typing.List["ItemState"]]
    tax_rate: typing.Optional["TaxRate"]
    tax_category: typing.Optional["TaxCategoryResourceIdentifier"]
    #: The custom fields.
    custom: typing.Optional["CustomFieldsDraft"]
    shipping_details: typing.Optional["ItemShippingDetailsDraft"]
    #: - If `Standard`, Cart Discounts with a matching [CartDiscountCustomLineItemsTarget](ctp:api:type:CartDiscountCustomLineItemsTarget)
    #: are applied to the Custom Line Item.
    #: - If `External`, Cart Discounts are not considered on the Custom Line Item.
    price_mode: "CustomLineItemPriceMode"

    def __init__(
        self,
        *,
        name: "LocalizedString",
        quantity: int,
        money: "Money",
        slug: str,
        state: typing.Optional[typing.List["ItemState"]] = None,
        tax_rate: typing.Optional["TaxRate"] = None,
        tax_category: typing.Optional["TaxCategoryResourceIdentifier"] = None,
        custom: typing.Optional["CustomFieldsDraft"] = None,
        shipping_details: typing.Optional["ItemShippingDetailsDraft"] = None,
        price_mode: "CustomLineItemPriceMode"
    ):
        self.name = name
        self.quantity = quantity
        self.money = money
        self.slug = slug
        self.state = state
        self.tax_rate = tax_rate
        self.tax_category = tax_category
        self.custom = custom
        self.shipping_details = shipping_details
        self.price_mode = price_mode

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CustomLineItemImportDraft":
        from ._schemas.cart import CustomLineItemImportDraftSchema

        return CustomLineItemImportDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart import CustomLineItemImportDraftSchema

        return CustomLineItemImportDraftSchema().dump(self)


class ProductPublishScope(enum.Enum):
    """The scope controls which part of the product information is published."""

    ALL = "All"
    PRICES = "Prices"
