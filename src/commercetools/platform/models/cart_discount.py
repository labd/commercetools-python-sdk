# This file is automatically generated by the rmf-codegen project.
#
# The Python code generator is maintained by Lab Digital. If you want to
# contribute to this project then please do not edit this file directly
# but send a pull request to the Lab Digital fork of rmf-codegen at
# https://github.com/labd/rmf-codegen

import datetime
import enum
import typing

from ._abstract import _BaseType
from .common import BaseResource, Reference, ReferenceTypeId, ResourceIdentifier

if typing.TYPE_CHECKING:
    from .channel import ChannelReference, ChannelResourceIdentifier
    from .common import (
        CentPrecisionMoney,
        CreatedBy,
        LastModifiedBy,
        LocalizedString,
        Money,
        Reference,
        ReferenceTypeId,
        TypedMoney,
        TypedMoneyDraft,
    )
    from .product import ProductReference, ProductResourceIdentifier
    from .store import StoreKeyReference, StoreResourceIdentifier
    from .type import (
        CustomFields,
        CustomFieldsDraft,
        FieldContainer,
        TypeResourceIdentifier,
    )

__all__ = [
    "CartDiscount",
    "CartDiscountAddStoreAction",
    "CartDiscountChangeCartPredicateAction",
    "CartDiscountChangeIsActiveAction",
    "CartDiscountChangeNameAction",
    "CartDiscountChangeRequiresDiscountCodeAction",
    "CartDiscountChangeSortOrderAction",
    "CartDiscountChangeStackingModeAction",
    "CartDiscountChangeTargetAction",
    "CartDiscountChangeValueAction",
    "CartDiscountCustomLineItemsTarget",
    "CartDiscountDraft",
    "CartDiscountLineItemsTarget",
    "CartDiscountPagedQueryResponse",
    "CartDiscountReference",
    "CartDiscountRemoveStoreAction",
    "CartDiscountResourceIdentifier",
    "CartDiscountSetCustomFieldAction",
    "CartDiscountSetCustomTypeAction",
    "CartDiscountSetDescriptionAction",
    "CartDiscountSetKeyAction",
    "CartDiscountSetStoresAction",
    "CartDiscountSetValidFromAction",
    "CartDiscountSetValidFromAndUntilAction",
    "CartDiscountSetValidUntilAction",
    "CartDiscountShippingCostTarget",
    "CartDiscountTarget",
    "CartDiscountTotalPriceTarget",
    "CartDiscountUpdate",
    "CartDiscountUpdateAction",
    "CartDiscountValue",
    "CartDiscountValueAbsolute",
    "CartDiscountValueAbsoluteDraft",
    "CartDiscountValueDraft",
    "CartDiscountValueFixed",
    "CartDiscountValueFixedDraft",
    "CartDiscountValueGiftLineItem",
    "CartDiscountValueGiftLineItemDraft",
    "CartDiscountValueRelative",
    "CartDiscountValueRelativeDraft",
    "MultiBuyCustomLineItemsTarget",
    "MultiBuyLineItemsTarget",
    "SelectionMode",
    "StackingMode",
]


class CartDiscount(BaseResource):
    #: Present on resources updated after 1 February 2019 except for [events not tracked](/../api/general-concepts#events-tracked).
    last_modified_by: typing.Optional["LastModifiedBy"]
    #: Present on resources created after 1 February 2019 except for [events not tracked](/../api/general-concepts#events-tracked).
    created_by: typing.Optional["CreatedBy"]
    #: Name of the CartDiscount.
    name: "LocalizedString"
    #: User-defined unique identifier of the CartDiscount.
    key: typing.Optional[str]
    #: Description of the CartDiscount.
    description: typing.Optional["LocalizedString"]
    #: Effect of the CartDiscount on the `target`.
    value: "CartDiscountValue"
    #: Valid [Cart Predicate](/../api/projects/predicates#cart-predicates).
    cart_predicate: str
    #: Segment of the Cart that is discounted.
    #:
    #: Empty, if the `value` is `giftLineItem`.
    target: typing.Optional["CartDiscountTarget"]
    #: Value between `0` and `1`.
    #: All matching CartDiscounts are applied to a Cart in the order defined by this field.
    #: A Discount with a higher sortOrder is prioritized.
    #: The sort order is unambiguous among all CartDiscounts.
    sort_order: str
    #: - If a value exists, the Cart Discount applies on [Carts](ctp:api:type:Cart) having a [Store](ctp:api:type:Store) matching any Store defined for this field.
    #: - If empty, the Cart Discount applies on all [Carts](ctp:api:type:Cart), irrespective of a Store.
    stores: typing.List["StoreKeyReference"]
    #: Indicates if the CartDiscount is active and can be applied to the Cart.
    is_active: bool
    #: Date and time (UTC) from which the Discount is effective.
    valid_from: typing.Optional[datetime.datetime]
    #: Date and time (UTC) until which the Discount is effective.
    valid_until: typing.Optional[datetime.datetime]
    #: Indicates if the Discount is used in connection with a [DiscountCode](ctp:api:type:DiscountCode).
    requires_discount_code: bool
    #: References of all resources that are addressed in the predicate.
    #: The API generates this array from the predicate.
    references: typing.List["Reference"]
    #: Indicates whether the application of the CartDiscount causes other discounts to be ignored.
    stacking_mode: "StackingMode"
    #: Custom Fields of the CartDiscount.
    custom: typing.Optional["CustomFields"]

    def __init__(
        self,
        *,
        id: str,
        version: int,
        created_at: datetime.datetime,
        last_modified_at: datetime.datetime,
        last_modified_by: typing.Optional["LastModifiedBy"] = None,
        created_by: typing.Optional["CreatedBy"] = None,
        name: "LocalizedString",
        key: typing.Optional[str] = None,
        description: typing.Optional["LocalizedString"] = None,
        value: "CartDiscountValue",
        cart_predicate: str,
        target: typing.Optional["CartDiscountTarget"] = None,
        sort_order: str,
        stores: typing.List["StoreKeyReference"],
        is_active: bool,
        valid_from: typing.Optional[datetime.datetime] = None,
        valid_until: typing.Optional[datetime.datetime] = None,
        requires_discount_code: bool,
        references: typing.List["Reference"],
        stacking_mode: "StackingMode",
        custom: typing.Optional["CustomFields"] = None
    ):
        self.last_modified_by = last_modified_by
        self.created_by = created_by
        self.name = name
        self.key = key
        self.description = description
        self.value = value
        self.cart_predicate = cart_predicate
        self.target = target
        self.sort_order = sort_order
        self.stores = stores
        self.is_active = is_active
        self.valid_from = valid_from
        self.valid_until = valid_until
        self.requires_discount_code = requires_discount_code
        self.references = references
        self.stacking_mode = stacking_mode
        self.custom = custom

        super().__init__(
            id=id,
            version=version,
            created_at=created_at,
            last_modified_at=last_modified_at,
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CartDiscount":
        from ._schemas.cart_discount import CartDiscountSchema

        return CartDiscountSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountSchema

        return CartDiscountSchema().dump(self)


class CartDiscountDraft(_BaseType):
    #: Name of the CartDiscount.
    name: "LocalizedString"
    #: User-defined unique identifier for the CartDiscount.
    key: typing.Optional[str]
    #: Description of the CartDiscount.
    description: typing.Optional["LocalizedString"]
    #: Effect of the CartDiscount on the `target`.
    value: "CartDiscountValueDraft"
    #: Valid [Cart Predicate](/../api/projects/predicates#cart-predicates).
    cart_predicate: str
    #: Segment of the Cart that will be discounted.
    #:
    #: Must not be set if the `value` is `giftLineItem`.
    target: typing.Optional["CartDiscountTarget"]
    #: Value between `0` and `1`.
    #: A Discount with a higher sortOrder is prioritized.
    #: The sort order must be unambiguous among all CartDiscounts.
    sort_order: str
    #: - If defined, the Cart Discount applies on [Carts](ctp:api:type:Cart) having a [Store](ctp:api:type:Store) matching any Store defined for this field.
    #: - If not defined, the Cart Discount applies on all Carts, irrespective of a Store.
    #:
    #: If the referenced Stores exceed the [limit](/../api/limits#cart-discounts-stores), a [MaxStoreReferencesReached](ctp:api:type:MaxStoreReferencesReachedError) error is returned.
    #:
    #: If the referenced Stores exceed the [limit](/../api/limits#cart-discounts) for Cart Discounts that do not require a Discount Code, a [StoreCartDiscountsLimitReached](ctp:api:type:StoreCartDiscountsLimitReachedError) error is returned.
    stores: typing.Optional[typing.List["StoreResourceIdentifier"]]
    #: Only active Discounts can be applied to the Cart.
    #: If the [limit](/../api/limits#cart-discounts) for active Cart Discounts is reached, a [MaxCartDiscountsReached](ctp:api:type:MaxCartDiscountsReachedError) error is returned.
    is_active: typing.Optional[bool]
    #: Date and time (UTC) from which the Discount is effective.
    valid_from: typing.Optional[datetime.datetime]
    #: Date and time (UTC) until which the Discount is effective.
    valid_until: typing.Optional[datetime.datetime]
    #: States whether the Discount can only be used in a connection with a [DiscountCode](ctp:api:type:DiscountCode).
    requires_discount_code: typing.Optional[bool]
    #: Specifies whether the application of this discount causes the following discounts to be ignored.
    stacking_mode: typing.Optional["StackingMode"]
    #: Custom Fields of the CartDiscount.
    custom: typing.Optional["CustomFieldsDraft"]

    def __init__(
        self,
        *,
        name: "LocalizedString",
        key: typing.Optional[str] = None,
        description: typing.Optional["LocalizedString"] = None,
        value: "CartDiscountValueDraft",
        cart_predicate: str,
        target: typing.Optional["CartDiscountTarget"] = None,
        sort_order: str,
        stores: typing.Optional[typing.List["StoreResourceIdentifier"]] = None,
        is_active: typing.Optional[bool] = None,
        valid_from: typing.Optional[datetime.datetime] = None,
        valid_until: typing.Optional[datetime.datetime] = None,
        requires_discount_code: typing.Optional[bool] = None,
        stacking_mode: typing.Optional["StackingMode"] = None,
        custom: typing.Optional["CustomFieldsDraft"] = None
    ):
        self.name = name
        self.key = key
        self.description = description
        self.value = value
        self.cart_predicate = cart_predicate
        self.target = target
        self.sort_order = sort_order
        self.stores = stores
        self.is_active = is_active
        self.valid_from = valid_from
        self.valid_until = valid_until
        self.requires_discount_code = requires_discount_code
        self.stacking_mode = stacking_mode
        self.custom = custom

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CartDiscountDraft":
        from ._schemas.cart_discount import CartDiscountDraftSchema

        return CartDiscountDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountDraftSchema

        return CartDiscountDraftSchema().dump(self)


class CartDiscountPagedQueryResponse(_BaseType):
    """[PagedQueryResult](/../api/general-concepts#pagedqueryresult) with `results` containing an array of [CartDiscount](ctp:api:type:CartDiscount)."""

    #: Number of [results requested](/../api/general-concepts#limit).
    limit: int
    #: Number of [elements skipped](/../api/general-concepts#offset).
    offset: int
    #: Actual number of results returned.
    count: int
    #: Total number of results matching the query.
    #: This number is an estimation that is not [strongly consistent](/../api/general-concepts#strong-consistency).
    #: This field is returned by default.
    #: For improved performance, calculating this field can be deactivated by using the query parameter `withTotal=false`.
    #: When the results are filtered with a [Query Predicate](/../api/predicates/query), `total` is subject to a [limit](/../api/limits#queries).
    total: typing.Optional[int]
    #: [CartDiscounts](ctp:api:type:CartDiscount) matching the query.
    results: typing.List["CartDiscount"]

    def __init__(
        self,
        *,
        limit: int,
        offset: int,
        count: int,
        total: typing.Optional[int] = None,
        results: typing.List["CartDiscount"]
    ):
        self.limit = limit
        self.offset = offset
        self.count = count
        self.total = total
        self.results = results

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartDiscountPagedQueryResponse":
        from ._schemas.cart_discount import CartDiscountPagedQueryResponseSchema

        return CartDiscountPagedQueryResponseSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountPagedQueryResponseSchema

        return CartDiscountPagedQueryResponseSchema().dump(self)


class CartDiscountReference(Reference):
    """[Reference](ctp:api:type:Reference) to a [CartDiscount](ctp:api:type:CartDiscount)."""

    #: Contains the representation of the expanded CartDiscount. Only present in responses to requests with [Reference Expansion](/../api/general-concepts#reference-expansion) for CartDiscounts.
    obj: typing.Optional["CartDiscount"]

    def __init__(self, *, id: str, obj: typing.Optional["CartDiscount"] = None):
        self.obj = obj

        super().__init__(id=id, type_id=ReferenceTypeId.CART_DISCOUNT)

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CartDiscountReference":
        from ._schemas.cart_discount import CartDiscountReferenceSchema

        return CartDiscountReferenceSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountReferenceSchema

        return CartDiscountReferenceSchema().dump(self)


class CartDiscountResourceIdentifier(ResourceIdentifier):
    """[ResourceIdentifier](ctp:api:type:ResourceIdentifier) to a [CartDiscount](ctp:api:type:CartDiscount). Either `id` or `key` is required. If both are set, an [InvalidJsonInput](/../api/errors#invalidjsoninput) error is returned."""

    def __init__(
        self, *, id: typing.Optional[str] = None, key: typing.Optional[str] = None
    ):

        super().__init__(id=id, key=key, type_id=ReferenceTypeId.CART_DISCOUNT)

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartDiscountResourceIdentifier":
        from ._schemas.cart_discount import CartDiscountResourceIdentifierSchema

        return CartDiscountResourceIdentifierSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountResourceIdentifierSchema

        return CartDiscountResourceIdentifierSchema().dump(self)


class CartDiscountTarget(_BaseType):
    type: str

    def __init__(self, *, type: str):
        self.type = type

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CartDiscountTarget":
        if data["type"] == "customLineItems":
            from ._schemas.cart_discount import CartDiscountCustomLineItemsTargetSchema

            return CartDiscountCustomLineItemsTargetSchema().load(data)
        if data["type"] == "lineItems":
            from ._schemas.cart_discount import CartDiscountLineItemsTargetSchema

            return CartDiscountLineItemsTargetSchema().load(data)
        if data["type"] == "shipping":
            from ._schemas.cart_discount import CartDiscountShippingCostTargetSchema

            return CartDiscountShippingCostTargetSchema().load(data)
        if data["type"] == "totalPrice":
            from ._schemas.cart_discount import CartDiscountTotalPriceTargetSchema

            return CartDiscountTotalPriceTargetSchema().load(data)
        if data["type"] == "multiBuyCustomLineItems":
            from ._schemas.cart_discount import MultiBuyCustomLineItemsTargetSchema

            return MultiBuyCustomLineItemsTargetSchema().load(data)
        if data["type"] == "multiBuyLineItems":
            from ._schemas.cart_discount import MultiBuyLineItemsTargetSchema

            return MultiBuyLineItemsTargetSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountTargetSchema

        return CartDiscountTargetSchema().dump(self)


class CartDiscountCustomLineItemsTarget(CartDiscountTarget):
    """Discount is applied to [CustomLineItems](ctp:api:type:CustomLineItem) matching the `predicate`."""

    #: Valid [CustomLineItem target predicate](/../api/projects/predicates#customlineitem-field-identifiers).
    predicate: str

    def __init__(self, *, predicate: str):
        self.predicate = predicate

        super().__init__(type="customLineItems")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartDiscountCustomLineItemsTarget":
        from ._schemas.cart_discount import CartDiscountCustomLineItemsTargetSchema

        return CartDiscountCustomLineItemsTargetSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountCustomLineItemsTargetSchema

        return CartDiscountCustomLineItemsTargetSchema().dump(self)


class CartDiscountLineItemsTarget(CartDiscountTarget):
    """Discount is applied to [LineItems](ctp:api:type:LineItem) matching the `predicate`."""

    #: Valid [LineItem target predicate](/../api/projects/predicates#lineitem-field-identifiers).
    predicate: str

    def __init__(self, *, predicate: str):
        self.predicate = predicate

        super().__init__(type="lineItems")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartDiscountLineItemsTarget":
        from ._schemas.cart_discount import CartDiscountLineItemsTargetSchema

        return CartDiscountLineItemsTargetSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountLineItemsTargetSchema

        return CartDiscountLineItemsTargetSchema().dump(self)


class CartDiscountShippingCostTarget(CartDiscountTarget):
    """Discount is applied to the shipping costs of the [Cart](ctp:api:type:Cart)."""

    def __init__(self):

        super().__init__(type="shipping")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartDiscountShippingCostTarget":
        from ._schemas.cart_discount import CartDiscountShippingCostTargetSchema

        return CartDiscountShippingCostTargetSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountShippingCostTargetSchema

        return CartDiscountShippingCostTargetSchema().dump(self)


class CartDiscountTotalPriceTarget(CartDiscountTarget):
    """Discount is applied to the total price of the [Cart](ctp:api:type:Cart)."""

    def __init__(self):

        super().__init__(type="totalPrice")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartDiscountTotalPriceTarget":
        from ._schemas.cart_discount import CartDiscountTotalPriceTargetSchema

        return CartDiscountTotalPriceTargetSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountTotalPriceTargetSchema

        return CartDiscountTotalPriceTargetSchema().dump(self)


class CartDiscountUpdate(_BaseType):
    #: Expected version of the CartDiscount on which the changes should be applied.
    #: If the expected version does not match the actual version, a [ConcurrentModification](ctp:api:type:ConcurrentModificationError) error will be returned.
    version: int
    #: Update actions to be performed on the CartDiscount.
    actions: typing.List["CartDiscountUpdateAction"]

    def __init__(
        self, *, version: int, actions: typing.List["CartDiscountUpdateAction"]
    ):
        self.version = version
        self.actions = actions

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CartDiscountUpdate":
        from ._schemas.cart_discount import CartDiscountUpdateSchema

        return CartDiscountUpdateSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountUpdateSchema

        return CartDiscountUpdateSchema().dump(self)


class CartDiscountUpdateAction(_BaseType):
    action: str

    def __init__(self, *, action: str):
        self.action = action

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartDiscountUpdateAction":
        if data["action"] == "addStore":
            from ._schemas.cart_discount import CartDiscountAddStoreActionSchema

            return CartDiscountAddStoreActionSchema().load(data)
        if data["action"] == "changeCartPredicate":
            from ._schemas.cart_discount import (
                CartDiscountChangeCartPredicateActionSchema,
            )

            return CartDiscountChangeCartPredicateActionSchema().load(data)
        if data["action"] == "changeIsActive":
            from ._schemas.cart_discount import CartDiscountChangeIsActiveActionSchema

            return CartDiscountChangeIsActiveActionSchema().load(data)
        if data["action"] == "changeName":
            from ._schemas.cart_discount import CartDiscountChangeNameActionSchema

            return CartDiscountChangeNameActionSchema().load(data)
        if data["action"] == "changeRequiresDiscountCode":
            from ._schemas.cart_discount import (
                CartDiscountChangeRequiresDiscountCodeActionSchema,
            )

            return CartDiscountChangeRequiresDiscountCodeActionSchema().load(data)
        if data["action"] == "changeSortOrder":
            from ._schemas.cart_discount import CartDiscountChangeSortOrderActionSchema

            return CartDiscountChangeSortOrderActionSchema().load(data)
        if data["action"] == "changeStackingMode":
            from ._schemas.cart_discount import (
                CartDiscountChangeStackingModeActionSchema,
            )

            return CartDiscountChangeStackingModeActionSchema().load(data)
        if data["action"] == "changeTarget":
            from ._schemas.cart_discount import CartDiscountChangeTargetActionSchema

            return CartDiscountChangeTargetActionSchema().load(data)
        if data["action"] == "changeValue":
            from ._schemas.cart_discount import CartDiscountChangeValueActionSchema

            return CartDiscountChangeValueActionSchema().load(data)
        if data["action"] == "removeStore":
            from ._schemas.cart_discount import CartDiscountRemoveStoreActionSchema

            return CartDiscountRemoveStoreActionSchema().load(data)
        if data["action"] == "setCustomField":
            from ._schemas.cart_discount import CartDiscountSetCustomFieldActionSchema

            return CartDiscountSetCustomFieldActionSchema().load(data)
        if data["action"] == "setCustomType":
            from ._schemas.cart_discount import CartDiscountSetCustomTypeActionSchema

            return CartDiscountSetCustomTypeActionSchema().load(data)
        if data["action"] == "setDescription":
            from ._schemas.cart_discount import CartDiscountSetDescriptionActionSchema

            return CartDiscountSetDescriptionActionSchema().load(data)
        if data["action"] == "setKey":
            from ._schemas.cart_discount import CartDiscountSetKeyActionSchema

            return CartDiscountSetKeyActionSchema().load(data)
        if data["action"] == "setStores":
            from ._schemas.cart_discount import CartDiscountSetStoresActionSchema

            return CartDiscountSetStoresActionSchema().load(data)
        if data["action"] == "setValidFrom":
            from ._schemas.cart_discount import CartDiscountSetValidFromActionSchema

            return CartDiscountSetValidFromActionSchema().load(data)
        if data["action"] == "setValidFromAndUntil":
            from ._schemas.cart_discount import (
                CartDiscountSetValidFromAndUntilActionSchema,
            )

            return CartDiscountSetValidFromAndUntilActionSchema().load(data)
        if data["action"] == "setValidUntil":
            from ._schemas.cart_discount import CartDiscountSetValidUntilActionSchema

            return CartDiscountSetValidUntilActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountUpdateActionSchema

        return CartDiscountUpdateActionSchema().dump(self)


class CartDiscountValue(_BaseType):
    type: str

    def __init__(self, *, type: str):
        self.type = type

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CartDiscountValue":
        if data["type"] == "absolute":
            from ._schemas.cart_discount import CartDiscountValueAbsoluteSchema

            return CartDiscountValueAbsoluteSchema().load(data)
        if data["type"] == "fixed":
            from ._schemas.cart_discount import CartDiscountValueFixedSchema

            return CartDiscountValueFixedSchema().load(data)
        if data["type"] == "giftLineItem":
            from ._schemas.cart_discount import CartDiscountValueGiftLineItemSchema

            return CartDiscountValueGiftLineItemSchema().load(data)
        if data["type"] == "relative":
            from ._schemas.cart_discount import CartDiscountValueRelativeSchema

            return CartDiscountValueRelativeSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountValueSchema

        return CartDiscountValueSchema().dump(self)


class CartDiscountValueAbsolute(CartDiscountValue):
    """Discounts the [CartDiscountTarget](ctp:api:type:CartDiscountTarget) by an absolute amount (not allowed for [MultiBuyLineItemsTarget](ctp:api:type:MultiBuyLineItemsTarget) and [MultiBuyCustomLineItemsTarget](ctp:api:type:MultiBuyCustomLineItemsTarget))."""

    #: Cent precision money values in different currencies.
    money: typing.List["CentPrecisionMoney"]

    def __init__(self, *, money: typing.List["CentPrecisionMoney"]):
        self.money = money

        super().__init__(type="absolute")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartDiscountValueAbsolute":
        from ._schemas.cart_discount import CartDiscountValueAbsoluteSchema

        return CartDiscountValueAbsoluteSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountValueAbsoluteSchema

        return CartDiscountValueAbsoluteSchema().dump(self)


class CartDiscountValueDraft(_BaseType):
    type: str

    def __init__(self, *, type: str):
        self.type = type

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartDiscountValueDraft":
        if data["type"] == "absolute":
            from ._schemas.cart_discount import CartDiscountValueAbsoluteDraftSchema

            return CartDiscountValueAbsoluteDraftSchema().load(data)
        if data["type"] == "fixed":
            from ._schemas.cart_discount import CartDiscountValueFixedDraftSchema

            return CartDiscountValueFixedDraftSchema().load(data)
        if data["type"] == "giftLineItem":
            from ._schemas.cart_discount import CartDiscountValueGiftLineItemDraftSchema

            return CartDiscountValueGiftLineItemDraftSchema().load(data)
        if data["type"] == "relative":
            from ._schemas.cart_discount import CartDiscountValueRelativeDraftSchema

            return CartDiscountValueRelativeDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountValueDraftSchema

        return CartDiscountValueDraftSchema().dump(self)


class CartDiscountValueAbsoluteDraft(CartDiscountValueDraft):
    #: Money values in different currencies.
    #: An absolute Cart Discount will match a price only if the array contains a value with the same currency. For example, if it contains 10€ and 15$, the matching € price will be decreased by 10€ and the matching $ price will be decreased by 15$. If the array has multiple values of the same currency, the API returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
    #:
    #: If the array is empty, the discount does not apply.
    money: typing.List["Money"]

    def __init__(self, *, money: typing.List["Money"]):
        self.money = money

        super().__init__(type="absolute")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartDiscountValueAbsoluteDraft":
        from ._schemas.cart_discount import CartDiscountValueAbsoluteDraftSchema

        return CartDiscountValueAbsoluteDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountValueAbsoluteDraftSchema

        return CartDiscountValueAbsoluteDraftSchema().dump(self)


class CartDiscountValueFixed(CartDiscountValue):
    """Sets the [DiscountedLineItemPrice](ctp:api:type:DiscountedLineItemPrice) of the [CartDiscountLineItemsTarget](ctp:api:type:CartDiscountLineItemsTarget) or [CartDiscountCustomLineItemsTarget](ctp:api:type:CartDiscountCustomLineItemsTarget) to the value specified in the `money` field, if it is lower than the current Line Item price for the same currency. If the Line Item price is already discounted to a price equal to or lower than the respective price in the `money` field, this Discount is not applied. If the `quantity` of the Line Item eligible for the Discount is greater than `1`, the fixed price discount is only applied to the Line Item portion for which the `money` value is lesser than their current price."""

    #: Money values in [cent precision](ctp:api:type:CentPrecisionMoney) or [high precision](ctp:api:type:HighPrecisionMoney) of different currencies.
    money: typing.List["TypedMoney"]

    def __init__(self, *, money: typing.List["TypedMoney"]):
        self.money = money

        super().__init__(type="fixed")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartDiscountValueFixed":
        from ._schemas.cart_discount import CartDiscountValueFixedSchema

        return CartDiscountValueFixedSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountValueFixedSchema

        return CartDiscountValueFixedSchema().dump(self)


class CartDiscountValueFixedDraft(CartDiscountValueDraft):
    """Sets the [DiscountedLineItemPrice](ctp:api:type:DiscountedLineItemPrice) of the [CartDiscountLineItemsTarget](ctp:api:type:CartDiscountLineItemsTarget) or [CartDiscountCustomLineItemsTarget](ctp:api:type:CartDiscountCustomLineItemsTarget) to the value specified in the `money` field, if it is lower than the current Line Item price for the same currency. If the Line Item price is already discounted to a price equal to or lower than the respective price in the `money` field, this Discount is not applied."""

    #: Money values provided either in [cent precision](ctp:api:type:Money) or [high precision](ctp:api:type:HighPrecisionMoneyDraft) for different currencies.
    #: A fixed Cart Discount will match a price only if the array contains a value with the same currency. For example, if it contains 10€ and 15$, the matching € price will be discounted by 10€ and the matching $ price will be discounted to 15$. If the array has multiple values of the same currency, the API returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
    #:
    #: If the array is empty, the discount does not apply.
    money: typing.List["TypedMoneyDraft"]

    def __init__(self, *, money: typing.List["TypedMoneyDraft"]):
        self.money = money

        super().__init__(type="fixed")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartDiscountValueFixedDraft":
        from ._schemas.cart_discount import CartDiscountValueFixedDraftSchema

        return CartDiscountValueFixedDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountValueFixedDraftSchema

        return CartDiscountValueFixedDraftSchema().dump(self)


class CartDiscountValueGiftLineItem(CartDiscountValue):
    #: Reference to a Product.
    product: "ProductReference"
    #: [ProductVariant](ctp:api:type:ProductVariant) of the Product.
    variant_id: int
    #: Channel must have the [ChannelRoleEnum](ctp:api:type:ChannelRoleEnum) `InventorySupply`.
    supply_channel: typing.Optional["ChannelReference"]
    #: Channel must have the [ChannelRoleEnum](ctp:api:type:ChannelRoleEnum) `ProductDistribution`.
    distribution_channel: typing.Optional["ChannelReference"]

    def __init__(
        self,
        *,
        product: "ProductReference",
        variant_id: int,
        supply_channel: typing.Optional["ChannelReference"] = None,
        distribution_channel: typing.Optional["ChannelReference"] = None
    ):
        self.product = product
        self.variant_id = variant_id
        self.supply_channel = supply_channel
        self.distribution_channel = distribution_channel

        super().__init__(type="giftLineItem")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartDiscountValueGiftLineItem":
        from ._schemas.cart_discount import CartDiscountValueGiftLineItemSchema

        return CartDiscountValueGiftLineItemSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountValueGiftLineItemSchema

        return CartDiscountValueGiftLineItemSchema().dump(self)


class CartDiscountValueGiftLineItemDraft(CartDiscountValueDraft):
    """Can only be used in a [CartDiscountDraft](ctp:api:type:CartDiscountDraft) with no `target` specified.
    Hence, this type can not be used in the [Change Value](ctp:api:type:CartDiscountChangeValueAction) update action.

    """

    #: ResourceIdentifier of a Product.
    product: "ProductResourceIdentifier"
    #: [ProductVariant](ctp:api:type:ProductVariant) of the Product.
    variant_id: int
    #: Channel must have the role `InventorySupply`.
    supply_channel: typing.Optional["ChannelResourceIdentifier"]
    #: Channel must have the role `ProductDistribution`.
    distribution_channel: typing.Optional["ChannelResourceIdentifier"]

    def __init__(
        self,
        *,
        product: "ProductResourceIdentifier",
        variant_id: int,
        supply_channel: typing.Optional["ChannelResourceIdentifier"] = None,
        distribution_channel: typing.Optional["ChannelResourceIdentifier"] = None
    ):
        self.product = product
        self.variant_id = variant_id
        self.supply_channel = supply_channel
        self.distribution_channel = distribution_channel

        super().__init__(type="giftLineItem")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartDiscountValueGiftLineItemDraft":
        from ._schemas.cart_discount import CartDiscountValueGiftLineItemDraftSchema

        return CartDiscountValueGiftLineItemDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountValueGiftLineItemDraftSchema

        return CartDiscountValueGiftLineItemDraftSchema().dump(self)


class CartDiscountValueRelative(CartDiscountValue):
    """Discounts the [CartDiscountTarget](ctp:api:type:CartDiscountTarget) relative to its price."""

    #: Fraction (per ten thousand) the price is reduced by. For example, `1000` will result in a 10% price reduction.
    permyriad: int

    def __init__(self, *, permyriad: int):
        self.permyriad = permyriad

        super().__init__(type="relative")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartDiscountValueRelative":
        from ._schemas.cart_discount import CartDiscountValueRelativeSchema

        return CartDiscountValueRelativeSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountValueRelativeSchema

        return CartDiscountValueRelativeSchema().dump(self)


class CartDiscountValueRelativeDraft(CartDiscountValueDraft):
    #: Fraction (per ten thousand) the price is reduced by. For example, `1000` will result in a 10% price reduction.
    permyriad: int

    def __init__(self, *, permyriad: int):
        self.permyriad = permyriad

        super().__init__(type="relative")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartDiscountValueRelativeDraft":
        from ._schemas.cart_discount import CartDiscountValueRelativeDraftSchema

        return CartDiscountValueRelativeDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountValueRelativeDraftSchema

        return CartDiscountValueRelativeDraftSchema().dump(self)


class MultiBuyCustomLineItemsTarget(CartDiscountTarget):
    """This Discount target is similar to `MultiBuyLineItems`, but is applied on Custom Line Items instead of Line Items."""

    #: Valid [CustomLineItems target predicate](/../api/projects/predicates#customlineitem-field-identifiers). The Discount will be applied to Custom Line Items that are matched by the predicate.
    predicate: str
    #: Number of Custom Line Items to be present in order to trigger an application of this Discount.
    trigger_quantity: int
    #: Number of Custom Line Items that are discounted per application of this Discount.
    #: It must be less than or equal to the `triggerQuantity`.
    discounted_quantity: int
    #: Maximum number of times this Discount can be applied.
    #: Do not set if the Discount should be applied an unlimited number of times.
    max_occurrence: typing.Optional[int]
    #: Discounts particular Line Items only according to the SelectionMode.
    selection_mode: "SelectionMode"

    def __init__(
        self,
        *,
        predicate: str,
        trigger_quantity: int,
        discounted_quantity: int,
        max_occurrence: typing.Optional[int] = None,
        selection_mode: "SelectionMode"
    ):
        self.predicate = predicate
        self.trigger_quantity = trigger_quantity
        self.discounted_quantity = discounted_quantity
        self.max_occurrence = max_occurrence
        self.selection_mode = selection_mode

        super().__init__(type="multiBuyCustomLineItems")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MultiBuyCustomLineItemsTarget":
        from ._schemas.cart_discount import MultiBuyCustomLineItemsTargetSchema

        return MultiBuyCustomLineItemsTargetSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import MultiBuyCustomLineItemsTargetSchema

        return MultiBuyCustomLineItemsTargetSchema().dump(self)


class MultiBuyLineItemsTarget(CartDiscountTarget):
    #: Valid [LineItem target predicate](/../api/projects/predicates#lineitem-field-identifiers). The Discount will be applied to Line Items that are matched by the predicate.
    predicate: str
    #: Number of Line Items to be present in order to trigger an application of this Discount.
    trigger_quantity: int
    #: Number of Line Items that are discounted per application of this Discount.
    #: It must be less than or equal to the `triggerQuantity`.
    discounted_quantity: int
    #: Maximum number of times this Discount can be applied.
    #: Do not set if the Discount should be applied an unlimited number of times.
    max_occurrence: typing.Optional[int]
    #: Discounts particular Line Items only according to the SelectionMode.
    selection_mode: "SelectionMode"

    def __init__(
        self,
        *,
        predicate: str,
        trigger_quantity: int,
        discounted_quantity: int,
        max_occurrence: typing.Optional[int] = None,
        selection_mode: "SelectionMode"
    ):
        self.predicate = predicate
        self.trigger_quantity = trigger_quantity
        self.discounted_quantity = discounted_quantity
        self.max_occurrence = max_occurrence
        self.selection_mode = selection_mode

        super().__init__(type="multiBuyLineItems")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MultiBuyLineItemsTarget":
        from ._schemas.cart_discount import MultiBuyLineItemsTargetSchema

        return MultiBuyLineItemsTargetSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import MultiBuyLineItemsTargetSchema

        return MultiBuyLineItemsTargetSchema().dump(self)


class SelectionMode(enum.Enum):
    """Defines which matching items are to be discounted."""

    CHEAPEST = "Cheapest"
    MOST_EXPENSIVE = "MostExpensive"


class StackingMode(enum.Enum):
    """Describes how the Cart Discount interacts with other Discounts."""

    STACKING = "Stacking"
    STOP_AFTER_THIS_DISCOUNT = "StopAfterThisDiscount"


class CartDiscountAddStoreAction(CartDiscountUpdateAction):
    """If a referenced Store does not exist, a [ReferencedResourceNotFound](ctp:api:type:ReferencedResourceNotFoundError) error is returned.

    This action generates a [CartDiscountStoreAdded](ctp:api:type:CartDiscountStoreAddedMessage) Message.

    """

    #: [Store](ctp:api:type:Store) to add.
    #:
    #: A failed update can return the following errors:
    #:
    #: - If the referenced Stores exceed the [limit](/../api/limits#cart-discounts-stores), a [MaxStoreReferencesReached](ctp:api:type:MaxStoreReferencesReachedError) error is returned.
    #: - If the referenced Stores exceed the [limit](/../api/limits#cart-discounts) for Cart Discounts that do not require a Discount Code, a [StoreCartDiscountsLimitReached](ctp:api:type:StoreCartDiscountsLimitReachedError) error is returned.
    store: "StoreResourceIdentifier"

    def __init__(self, *, store: "StoreResourceIdentifier"):
        self.store = store

        super().__init__(action="addStore")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartDiscountAddStoreAction":
        from ._schemas.cart_discount import CartDiscountAddStoreActionSchema

        return CartDiscountAddStoreActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountAddStoreActionSchema

        return CartDiscountAddStoreActionSchema().dump(self)


class CartDiscountChangeCartPredicateAction(CartDiscountUpdateAction):
    #: New value to set.
    cart_predicate: str

    def __init__(self, *, cart_predicate: str):
        self.cart_predicate = cart_predicate

        super().__init__(action="changeCartPredicate")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartDiscountChangeCartPredicateAction":
        from ._schemas.cart_discount import CartDiscountChangeCartPredicateActionSchema

        return CartDiscountChangeCartPredicateActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountChangeCartPredicateActionSchema

        return CartDiscountChangeCartPredicateActionSchema().dump(self)


class CartDiscountChangeIsActiveAction(CartDiscountUpdateAction):
    #: New value to set.
    #: If set to `true`, the Discount will be applied to the Cart.
    #:
    #: If the limit for active Cart Discounts is reached, a [MaxCartDiscountsReached](ctp:api:type:MaxCartDiscountsReachedError) error is returned.
    is_active: bool

    def __init__(self, *, is_active: bool):
        self.is_active = is_active

        super().__init__(action="changeIsActive")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartDiscountChangeIsActiveAction":
        from ._schemas.cart_discount import CartDiscountChangeIsActiveActionSchema

        return CartDiscountChangeIsActiveActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountChangeIsActiveActionSchema

        return CartDiscountChangeIsActiveActionSchema().dump(self)


class CartDiscountChangeNameAction(CartDiscountUpdateAction):
    #: New value to set.
    name: "LocalizedString"

    def __init__(self, *, name: "LocalizedString"):
        self.name = name

        super().__init__(action="changeName")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartDiscountChangeNameAction":
        from ._schemas.cart_discount import CartDiscountChangeNameActionSchema

        return CartDiscountChangeNameActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountChangeNameActionSchema

        return CartDiscountChangeNameActionSchema().dump(self)


class CartDiscountChangeRequiresDiscountCodeAction(CartDiscountUpdateAction):
    #: New value to set.
    #: If set to `true`, the Discount can only be used in connection with a [DiscountCode](ctp:api:type:DiscountCode).
    requires_discount_code: bool

    def __init__(self, *, requires_discount_code: bool):
        self.requires_discount_code = requires_discount_code

        super().__init__(action="changeRequiresDiscountCode")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartDiscountChangeRequiresDiscountCodeAction":
        from ._schemas.cart_discount import (
            CartDiscountChangeRequiresDiscountCodeActionSchema,
        )

        return CartDiscountChangeRequiresDiscountCodeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import (
            CartDiscountChangeRequiresDiscountCodeActionSchema,
        )

        return CartDiscountChangeRequiresDiscountCodeActionSchema().dump(self)


class CartDiscountChangeSortOrderAction(CartDiscountUpdateAction):
    #: New value to set (between `0` and `1`).
    #: A Discount with a higher sortOrder is prioritized.
    sort_order: str

    def __init__(self, *, sort_order: str):
        self.sort_order = sort_order

        super().__init__(action="changeSortOrder")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartDiscountChangeSortOrderAction":
        from ._schemas.cart_discount import CartDiscountChangeSortOrderActionSchema

        return CartDiscountChangeSortOrderActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountChangeSortOrderActionSchema

        return CartDiscountChangeSortOrderActionSchema().dump(self)


class CartDiscountChangeStackingModeAction(CartDiscountUpdateAction):
    #: New value to set.
    stacking_mode: "StackingMode"

    def __init__(self, *, stacking_mode: "StackingMode"):
        self.stacking_mode = stacking_mode

        super().__init__(action="changeStackingMode")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartDiscountChangeStackingModeAction":
        from ._schemas.cart_discount import CartDiscountChangeStackingModeActionSchema

        return CartDiscountChangeStackingModeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountChangeStackingModeActionSchema

        return CartDiscountChangeStackingModeActionSchema().dump(self)


class CartDiscountChangeTargetAction(CartDiscountUpdateAction):
    #: New value to set.
    target: "CartDiscountTarget"

    def __init__(self, *, target: "CartDiscountTarget"):
        self.target = target

        super().__init__(action="changeTarget")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartDiscountChangeTargetAction":
        from ._schemas.cart_discount import CartDiscountChangeTargetActionSchema

        return CartDiscountChangeTargetActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountChangeTargetActionSchema

        return CartDiscountChangeTargetActionSchema().dump(self)


class CartDiscountChangeValueAction(CartDiscountUpdateAction):
    """Changes the [CartDiscountValue](ctp:api:type:CartDiscountValue) for [relative](ctp:api:type:CartDiscountValueRelative), [absolute](ctp:api:type:CartDiscountValueAbsolute) and [fixed price](ctp:api:type:CartDiscountValueFixed) CartDiscounts.
    Changing to [Gift Line Item](ctp:api:type:CartDiscountValueGiftLineItem) is not supported.

    """

    #: New value to set.
    #: When trying to set a [CartDiscountValueGiftLineItemDraft](ctp:api:type:CartDiscountValueGiftLineItemDraft) an [InvalidInput](ctp:api:type:InvalidInputError) error is returned.
    value: "CartDiscountValueDraft"

    def __init__(self, *, value: "CartDiscountValueDraft"):
        self.value = value

        super().__init__(action="changeValue")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartDiscountChangeValueAction":
        from ._schemas.cart_discount import CartDiscountChangeValueActionSchema

        return CartDiscountChangeValueActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountChangeValueActionSchema

        return CartDiscountChangeValueActionSchema().dump(self)


class CartDiscountRemoveStoreAction(CartDiscountUpdateAction):
    """If a referenced Store does not exist, a [ReferencedResourceNotFound](ctp:api:type:ReferencedResourceNotFoundError) error is returned.

    This action generates a [CartDiscountStoreRemoved](ctp:api:type:CartDiscountStoreRemovedMessage) Message.

    """

    #: [Store](ctp:api:type:Store) to remove.
    store: "StoreResourceIdentifier"

    def __init__(self, *, store: "StoreResourceIdentifier"):
        self.store = store

        super().__init__(action="removeStore")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartDiscountRemoveStoreAction":
        from ._schemas.cart_discount import CartDiscountRemoveStoreActionSchema

        return CartDiscountRemoveStoreActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountRemoveStoreActionSchema

        return CartDiscountRemoveStoreActionSchema().dump(self)


class CartDiscountSetCustomFieldAction(CartDiscountUpdateAction):
    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: Removing a field that does not exist returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
    #: If `value` is provided, it is set for the field defined by `name`.
    value: typing.Optional[typing.Any]

    def __init__(self, *, name: str, value: typing.Optional[typing.Any] = None):
        self.name = name
        self.value = value

        super().__init__(action="setCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartDiscountSetCustomFieldAction":
        from ._schemas.cart_discount import CartDiscountSetCustomFieldActionSchema

        return CartDiscountSetCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountSetCustomFieldActionSchema

        return CartDiscountSetCustomFieldActionSchema().dump(self)


class CartDiscountSetCustomTypeAction(CartDiscountUpdateAction):
    #: Defines the [Type](ctp:api:type:Type) that extends the CartDiscount with [Custom Fields](/../api/projects/custom-fields).
    #: If absent, any existing Type and Custom Fields are removed from the CartDiscount.
    type: typing.Optional["TypeResourceIdentifier"]
    #: Sets the [Custom Fields](/../api/projects/custom-fields) fields for the CartDiscount.
    fields: typing.Optional["FieldContainer"]

    def __init__(
        self,
        *,
        type: typing.Optional["TypeResourceIdentifier"] = None,
        fields: typing.Optional["FieldContainer"] = None
    ):
        self.type = type
        self.fields = fields

        super().__init__(action="setCustomType")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartDiscountSetCustomTypeAction":
        from ._schemas.cart_discount import CartDiscountSetCustomTypeActionSchema

        return CartDiscountSetCustomTypeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountSetCustomTypeActionSchema

        return CartDiscountSetCustomTypeActionSchema().dump(self)


class CartDiscountSetDescriptionAction(CartDiscountUpdateAction):
    #: Value to set. If empty, any existing value will be removed.
    description: typing.Optional["LocalizedString"]

    def __init__(self, *, description: typing.Optional["LocalizedString"] = None):
        self.description = description

        super().__init__(action="setDescription")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartDiscountSetDescriptionAction":
        from ._schemas.cart_discount import CartDiscountSetDescriptionActionSchema

        return CartDiscountSetDescriptionActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountSetDescriptionActionSchema

        return CartDiscountSetDescriptionActionSchema().dump(self)


class CartDiscountSetKeyAction(CartDiscountUpdateAction):
    #: Value to set. If empty, any existing value will be removed.
    key: typing.Optional[str]

    def __init__(self, *, key: typing.Optional[str] = None):
        self.key = key

        super().__init__(action="setKey")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartDiscountSetKeyAction":
        from ._schemas.cart_discount import CartDiscountSetKeyActionSchema

        return CartDiscountSetKeyActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountSetKeyActionSchema

        return CartDiscountSetKeyActionSchema().dump(self)


class CartDiscountSetStoresAction(CartDiscountUpdateAction):
    """If a referenced Store does not exist, a [ReferencedResourceNotFound](ctp:api:type:ReferencedResourceNotFoundError) error is returned.

    This action generates a [CartDiscountStoresSet](ctp:api:type:CartDiscountStoresSetMessage) Message.

    """

    #: [Stores](ctp:api:type:Store) to set.
    #: Overrides the current list of Stores.
    #: If empty, any existing values will be removed.
    #:
    #: A failed update can return the following errors:
    #:
    #: - If the referenced Stores exceed the [limit](/../api/limits#cart-discounts-stores), a [MaxStoreReferencesReached](ctp:api:type:MaxStoreReferencesReachedError) error is returned.
    #: - If the referenced Stores exceed the [limit](/../api/limits#cart-discounts) for Cart Discounts that do not require a Discount Code, a [StoreCartDiscountsLimitReached](ctp:api:type:StoreCartDiscountsLimitReachedError) error is returned.
    stores: typing.Optional[typing.List["StoreResourceIdentifier"]]

    def __init__(
        self, *, stores: typing.Optional[typing.List["StoreResourceIdentifier"]] = None
    ):
        self.stores = stores

        super().__init__(action="setStores")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartDiscountSetStoresAction":
        from ._schemas.cart_discount import CartDiscountSetStoresActionSchema

        return CartDiscountSetStoresActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountSetStoresActionSchema

        return CartDiscountSetStoresActionSchema().dump(self)


class CartDiscountSetValidFromAction(CartDiscountUpdateAction):
    #: Value to set.
    #: If empty, any existing value will be removed.
    valid_from: typing.Optional[datetime.datetime]

    def __init__(self, *, valid_from: typing.Optional[datetime.datetime] = None):
        self.valid_from = valid_from

        super().__init__(action="setValidFrom")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartDiscountSetValidFromAction":
        from ._schemas.cart_discount import CartDiscountSetValidFromActionSchema

        return CartDiscountSetValidFromActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountSetValidFromActionSchema

        return CartDiscountSetValidFromActionSchema().dump(self)


class CartDiscountSetValidFromAndUntilAction(CartDiscountUpdateAction):
    #: Value to set.
    #: If empty, any existing value will be removed.
    valid_from: typing.Optional[datetime.datetime]
    #: Value to set.
    #: If empty, any existing value will be removed.
    valid_until: typing.Optional[datetime.datetime]

    def __init__(
        self,
        *,
        valid_from: typing.Optional[datetime.datetime] = None,
        valid_until: typing.Optional[datetime.datetime] = None
    ):
        self.valid_from = valid_from
        self.valid_until = valid_until

        super().__init__(action="setValidFromAndUntil")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartDiscountSetValidFromAndUntilAction":
        from ._schemas.cart_discount import CartDiscountSetValidFromAndUntilActionSchema

        return CartDiscountSetValidFromAndUntilActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountSetValidFromAndUntilActionSchema

        return CartDiscountSetValidFromAndUntilActionSchema().dump(self)


class CartDiscountSetValidUntilAction(CartDiscountUpdateAction):
    #: Value to set.
    #: If empty, any existing value will be removed.
    valid_until: typing.Optional[datetime.datetime]

    def __init__(self, *, valid_until: typing.Optional[datetime.datetime] = None):
        self.valid_until = valid_until

        super().__init__(action="setValidUntil")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartDiscountSetValidUntilAction":
        from ._schemas.cart_discount import CartDiscountSetValidUntilActionSchema

        return CartDiscountSetValidUntilActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountSetValidUntilActionSchema

        return CartDiscountSetValidUntilActionSchema().dump(self)
