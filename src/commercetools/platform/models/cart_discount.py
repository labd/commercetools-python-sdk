# This file is automatically generated by the rmf-codegen project.
#
# The Python code generator is maintained by Lab Digital. If you want to
# contribute to this project then please do not edit this file directly
# but send a pull request to the Lab Digital fork of rmf-codegen at
# https://github.com/labd/rmf-codegen

import datetime
import enum
import typing

from ._abstract import _BaseType
from .common import BaseResource, Reference, ReferenceTypeId, ResourceIdentifier

if typing.TYPE_CHECKING:
    from .channel import ChannelReference, ChannelResourceIdentifier
    from .common import (
        CentPrecisionMoney,
        CreatedBy,
        LastModifiedBy,
        LocalizedString,
        Money,
        Reference,
        ReferenceTypeId,
    )
    from .product import ProductReference, ProductResourceIdentifier
    from .type import (
        CustomFields,
        CustomFieldsDraft,
        FieldContainer,
        TypeResourceIdentifier,
    )

__all__ = [
    "CartDiscount",
    "CartDiscountChangeCartPredicateAction",
    "CartDiscountChangeIsActiveAction",
    "CartDiscountChangeNameAction",
    "CartDiscountChangeRequiresDiscountCodeAction",
    "CartDiscountChangeSortOrderAction",
    "CartDiscountChangeStackingModeAction",
    "CartDiscountChangeTargetAction",
    "CartDiscountChangeValueAction",
    "CartDiscountCustomLineItemsTarget",
    "CartDiscountDraft",
    "CartDiscountLineItemsTarget",
    "CartDiscountPagedQueryResponse",
    "CartDiscountReference",
    "CartDiscountResourceIdentifier",
    "CartDiscountSetCustomFieldAction",
    "CartDiscountSetCustomTypeAction",
    "CartDiscountSetDescriptionAction",
    "CartDiscountSetKeyAction",
    "CartDiscountSetValidFromAction",
    "CartDiscountSetValidFromAndUntilAction",
    "CartDiscountSetValidUntilAction",
    "CartDiscountShippingCostTarget",
    "CartDiscountTarget",
    "CartDiscountUpdate",
    "CartDiscountUpdateAction",
    "CartDiscountValue",
    "CartDiscountValueAbsolute",
    "CartDiscountValueAbsoluteDraft",
    "CartDiscountValueDraft",
    "CartDiscountValueFixed",
    "CartDiscountValueFixedDraft",
    "CartDiscountValueGiftLineItem",
    "CartDiscountValueGiftLineItemDraft",
    "CartDiscountValueRelative",
    "CartDiscountValueRelativeDraft",
    "MultiBuyCustomLineItemsTarget",
    "MultiBuyLineItemsTarget",
    "SelectionMode",
    "StackingMode",
]


class CartDiscount(BaseResource):
    #: Present on resources updated after 1 February 2019 except for [events not tracked](/../api/client-logging#events-tracked).
    last_modified_by: typing.Optional["LastModifiedBy"]
    #: Present on resources created after 1 February 2019 except for [events not tracked](/../api/client-logging#events-tracked).
    created_by: typing.Optional["CreatedBy"]
    #: Name of the CartDiscount.
    name: "LocalizedString"
    #: User-defined unique identifier of the CartDiscount.
    key: typing.Optional[str]
    #: Description of the CartDiscount.
    description: typing.Optional["LocalizedString"]
    #: Effect of the CartDiscount.
    value: "CartDiscountValue"
    #: Valid [Cart Predicate](/../api/projects/predicates#cart-predicates).
    cart_predicate: str
    #: Sets a [CartDiscountTarget](ctp:api:type:CartDiscountTarget). Empty if `value` has type `giftLineItem`.
    target: typing.Optional["CartDiscountTarget"]
    #: Value between `0` and `1`.
    #: All matching CartDiscounts are applied to a Cart in the order defined by this field.
    #: A Discount with a higher sortOrder is prioritized.
    #: The sort order is unambiguous among all CartDiscounts.
    sort_order: str
    #: Indicates if the CartDiscount is active and can be applied to the Cart.
    is_active: bool
    #: Date and time (UTC) from which the Discount is effective.
    valid_from: typing.Optional[datetime.datetime]
    #: Date and time (UTC) until which the Discount is effective.
    valid_until: typing.Optional[datetime.datetime]
    #: Indicates if the Discount can be used in connection with a [DiscountCode](ctp:api:type:DiscountCode).
    requires_discount_code: bool
    #: References of all resources that are addressed in the predicate.
    #: The API generates this array from the predicate.
    references: typing.List["Reference"]
    #: Indicates whether the application of the CartDiscount causes other discounts to be ignored.
    stacking_mode: "StackingMode"
    #: Custom Fields of the CartDiscount.
    custom: typing.Optional["CustomFields"]

    def __init__(
        self,
        *,
        id: str,
        version: int,
        created_at: datetime.datetime,
        last_modified_at: datetime.datetime,
        last_modified_by: typing.Optional["LastModifiedBy"] = None,
        created_by: typing.Optional["CreatedBy"] = None,
        name: "LocalizedString",
        key: typing.Optional[str] = None,
        description: typing.Optional["LocalizedString"] = None,
        value: "CartDiscountValue",
        cart_predicate: str,
        target: typing.Optional["CartDiscountTarget"] = None,
        sort_order: str,
        is_active: bool,
        valid_from: typing.Optional[datetime.datetime] = None,
        valid_until: typing.Optional[datetime.datetime] = None,
        requires_discount_code: bool,
        references: typing.List["Reference"],
        stacking_mode: "StackingMode",
        custom: typing.Optional["CustomFields"] = None
    ):
        self.last_modified_by = last_modified_by
        self.created_by = created_by
        self.name = name
        self.key = key
        self.description = description
        self.value = value
        self.cart_predicate = cart_predicate
        self.target = target
        self.sort_order = sort_order
        self.is_active = is_active
        self.valid_from = valid_from
        self.valid_until = valid_until
        self.requires_discount_code = requires_discount_code
        self.references = references
        self.stacking_mode = stacking_mode
        self.custom = custom

        super().__init__(
            id=id,
            version=version,
            created_at=created_at,
            last_modified_at=last_modified_at,
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CartDiscount":
        from ._schemas.cart_discount import CartDiscountSchema

        return CartDiscountSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountSchema

        return CartDiscountSchema().dump(self)


class CartDiscountDraft(_BaseType):
    #: Name of the CartDiscount.
    name: "LocalizedString"
    #: User-defined unique identifier for the CartDiscount.
    key: typing.Optional[str]
    #: Description of the CartDiscount.
    description: typing.Optional["LocalizedString"]
    #: Effect of the CartDiscount.
    #: For a [target](ctp:api:type:CartDiscountTarget), relative or absolute Discount values or a fixed item Price value can be specified. If no target is specified, a [Gift Line Item](/../api/projects/cartDiscounts#gift-line-item) can be added to the Cart.
    value: "CartDiscountValueDraft"
    #: Valid [Cart Predicate](/../api/projects/predicates#cart-predicates).
    cart_predicate: str
    #: Must not be set when the `value` has type `giftLineItem`, otherwise a [CartDiscountTarget](ctp:api:type:CartDiscountTarget) must be set.
    target: typing.Optional["CartDiscountTarget"]
    #: Value between `0` and `1`.
    #: A Discount with a higher sortOrder is prioritized.
    #: The sort order must be unambiguous among all CartDiscounts.
    sort_order: str
    #: Only active Discounts can be applied to the Cart.
    is_active: typing.Optional[bool]
    #: Date and time (UTC) from which the Discount is effective.
    valid_from: typing.Optional[datetime.datetime]
    #: Date and time (UTC) until which the Discount is effective.
    valid_until: typing.Optional[datetime.datetime]
    #: States whether the Discount can only be used in a connection with a [DiscountCode](ctp:api:type:DiscountCode).
    requires_discount_code: typing.Optional[bool]
    #: Specifies whether the application of this discount causes the following discounts to be ignored.
    stacking_mode: typing.Optional["StackingMode"]
    #: Custom Fields of the CartDiscount.
    custom: typing.Optional["CustomFieldsDraft"]

    def __init__(
        self,
        *,
        name: "LocalizedString",
        key: typing.Optional[str] = None,
        description: typing.Optional["LocalizedString"] = None,
        value: "CartDiscountValueDraft",
        cart_predicate: str,
        target: typing.Optional["CartDiscountTarget"] = None,
        sort_order: str,
        is_active: typing.Optional[bool] = None,
        valid_from: typing.Optional[datetime.datetime] = None,
        valid_until: typing.Optional[datetime.datetime] = None,
        requires_discount_code: typing.Optional[bool] = None,
        stacking_mode: typing.Optional["StackingMode"] = None,
        custom: typing.Optional["CustomFieldsDraft"] = None
    ):
        self.name = name
        self.key = key
        self.description = description
        self.value = value
        self.cart_predicate = cart_predicate
        self.target = target
        self.sort_order = sort_order
        self.is_active = is_active
        self.valid_from = valid_from
        self.valid_until = valid_until
        self.requires_discount_code = requires_discount_code
        self.stacking_mode = stacking_mode
        self.custom = custom

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CartDiscountDraft":
        from ._schemas.cart_discount import CartDiscountDraftSchema

        return CartDiscountDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountDraftSchema

        return CartDiscountDraftSchema().dump(self)


class CartDiscountPagedQueryResponse(_BaseType):
    """[PagedQueryResult](/../api/general-concepts#pagedqueryresult) with `results` containing an array of [CartDiscount](ctp:api:type:CartDiscount)."""

    #: Number of [results requested](/../api/general-concepts#limit).
    limit: int
    #: Number of [elements skipped](/../api/general-concepts#offset).
    offset: int
    #: Actual number of results returned.
    count: int
    #: Total number of results matching the query.
    #: This number is an estimation that is not [strongly consistent](/../api/general-concepts#strong-consistency).
    #: This field is returned by default.
    #: For improved performance, calculating this field can be deactivated by using the query parameter `withTotal=false`.
    #: When the results are filtered with a [Query Predicate](/../api/predicates/query), `total` is subject to a [limit](/../api/limits#queries).
    total: typing.Optional[int]
    #: [CartDiscounts](ctp:api:type:CartDiscount) matching the query.
    results: typing.List["CartDiscount"]

    def __init__(
        self,
        *,
        limit: int,
        offset: int,
        count: int,
        total: typing.Optional[int] = None,
        results: typing.List["CartDiscount"]
    ):
        self.limit = limit
        self.offset = offset
        self.count = count
        self.total = total
        self.results = results

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartDiscountPagedQueryResponse":
        from ._schemas.cart_discount import CartDiscountPagedQueryResponseSchema

        return CartDiscountPagedQueryResponseSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountPagedQueryResponseSchema

        return CartDiscountPagedQueryResponseSchema().dump(self)


class CartDiscountReference(Reference):
    """[Reference](ctp:api:type:Reference) to a [CartDiscount](ctp:api:type:CartDiscount)."""

    #: Contains the representation of the expanded CartDiscount. Only present in responses to requests with [Reference Expansion](/../api/general-concepts#reference-expansion) for CartDiscounts.
    obj: typing.Optional["CartDiscount"]

    def __init__(self, *, id: str, obj: typing.Optional["CartDiscount"] = None):
        self.obj = obj

        super().__init__(id=id, type_id=ReferenceTypeId.CART_DISCOUNT)

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CartDiscountReference":
        from ._schemas.cart_discount import CartDiscountReferenceSchema

        return CartDiscountReferenceSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountReferenceSchema

        return CartDiscountReferenceSchema().dump(self)


class CartDiscountResourceIdentifier(ResourceIdentifier):
    """[ResourceIdentifier](ctp:api:type:ResourceIdentifier) to a [CartDiscount](ctp:api:type:CartDiscount)."""

    def __init__(
        self, *, id: typing.Optional[str] = None, key: typing.Optional[str] = None
    ):
        super().__init__(id=id, key=key, type_id=ReferenceTypeId.CART_DISCOUNT)

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartDiscountResourceIdentifier":
        from ._schemas.cart_discount import CartDiscountResourceIdentifierSchema

        return CartDiscountResourceIdentifierSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountResourceIdentifierSchema

        return CartDiscountResourceIdentifierSchema().dump(self)


class CartDiscountTarget(_BaseType):
    type: str

    def __init__(self, *, type: str):
        self.type = type

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CartDiscountTarget":
        if data["type"] == "customLineItems":
            from ._schemas.cart_discount import CartDiscountCustomLineItemsTargetSchema

            return CartDiscountCustomLineItemsTargetSchema().load(data)
        if data["type"] == "lineItems":
            from ._schemas.cart_discount import CartDiscountLineItemsTargetSchema

            return CartDiscountLineItemsTargetSchema().load(data)
        if data["type"] == "shipping":
            from ._schemas.cart_discount import CartDiscountShippingCostTargetSchema

            return CartDiscountShippingCostTargetSchema().load(data)
        if data["type"] == "multiBuyCustomLineItems":
            from ._schemas.cart_discount import MultiBuyCustomLineItemsTargetSchema

            return MultiBuyCustomLineItemsTargetSchema().load(data)
        if data["type"] == "multiBuyLineItems":
            from ._schemas.cart_discount import MultiBuyLineItemsTargetSchema

            return MultiBuyLineItemsTargetSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountTargetSchema

        return CartDiscountTargetSchema().dump(self)


class CartDiscountCustomLineItemsTarget(CartDiscountTarget):
    """Discount is applied to [CustomLineItems](ctp:api:type:CustomLineItem) matching the `predicate`."""

    #: Valid [CustomLineItem target predicate](/../api/projects/predicates#customlineitem-field-identifiers).
    predicate: str

    def __init__(self, *, predicate: str):
        self.predicate = predicate

        super().__init__(type="customLineItems")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartDiscountCustomLineItemsTarget":
        from ._schemas.cart_discount import CartDiscountCustomLineItemsTargetSchema

        return CartDiscountCustomLineItemsTargetSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountCustomLineItemsTargetSchema

        return CartDiscountCustomLineItemsTargetSchema().dump(self)


class CartDiscountLineItemsTarget(CartDiscountTarget):
    """Discount is applied to [LineItems](ctp:api:type:LineItem) matching the `predicate`."""

    #: Valid [LineItem target predicate](/../api/projects/predicates#lineitem-field-identifiers).
    predicate: str

    def __init__(self, *, predicate: str):
        self.predicate = predicate

        super().__init__(type="lineItems")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartDiscountLineItemsTarget":
        from ._schemas.cart_discount import CartDiscountLineItemsTargetSchema

        return CartDiscountLineItemsTargetSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountLineItemsTargetSchema

        return CartDiscountLineItemsTargetSchema().dump(self)


class CartDiscountShippingCostTarget(CartDiscountTarget):
    """Discount is applied to the shipping costs of the [Cart](ctp:api:type:Cart)."""

    def __init__(self):
        super().__init__(type="shipping")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartDiscountShippingCostTarget":
        from ._schemas.cart_discount import CartDiscountShippingCostTargetSchema

        return CartDiscountShippingCostTargetSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountShippingCostTargetSchema

        return CartDiscountShippingCostTargetSchema().dump(self)


class CartDiscountUpdate(_BaseType):
    #: Expected version of the CartDiscount on which the changes should be applied. If the expected version does not match the actual version, a [ConcurrentModification](ctp:api:type:ConcurrentModificationError) error is returned.
    version: int
    #: Update actions to be performed on the CartDiscount.
    actions: typing.List["CartDiscountUpdateAction"]

    def __init__(
        self, *, version: int, actions: typing.List["CartDiscountUpdateAction"]
    ):
        self.version = version
        self.actions = actions

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CartDiscountUpdate":
        from ._schemas.cart_discount import CartDiscountUpdateSchema

        return CartDiscountUpdateSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountUpdateSchema

        return CartDiscountUpdateSchema().dump(self)


class CartDiscountUpdateAction(_BaseType):
    action: str

    def __init__(self, *, action: str):
        self.action = action

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartDiscountUpdateAction":
        if data["action"] == "changeCartPredicate":
            from ._schemas.cart_discount import (
                CartDiscountChangeCartPredicateActionSchema,
            )

            return CartDiscountChangeCartPredicateActionSchema().load(data)
        if data["action"] == "changeIsActive":
            from ._schemas.cart_discount import CartDiscountChangeIsActiveActionSchema

            return CartDiscountChangeIsActiveActionSchema().load(data)
        if data["action"] == "changeName":
            from ._schemas.cart_discount import CartDiscountChangeNameActionSchema

            return CartDiscountChangeNameActionSchema().load(data)
        if data["action"] == "changeRequiresDiscountCode":
            from ._schemas.cart_discount import (
                CartDiscountChangeRequiresDiscountCodeActionSchema,
            )

            return CartDiscountChangeRequiresDiscountCodeActionSchema().load(data)
        if data["action"] == "changeSortOrder":
            from ._schemas.cart_discount import CartDiscountChangeSortOrderActionSchema

            return CartDiscountChangeSortOrderActionSchema().load(data)
        if data["action"] == "changeStackingMode":
            from ._schemas.cart_discount import (
                CartDiscountChangeStackingModeActionSchema,
            )

            return CartDiscountChangeStackingModeActionSchema().load(data)
        if data["action"] == "changeTarget":
            from ._schemas.cart_discount import CartDiscountChangeTargetActionSchema

            return CartDiscountChangeTargetActionSchema().load(data)
        if data["action"] == "changeValue":
            from ._schemas.cart_discount import CartDiscountChangeValueActionSchema

            return CartDiscountChangeValueActionSchema().load(data)
        if data["action"] == "setCustomField":
            from ._schemas.cart_discount import CartDiscountSetCustomFieldActionSchema

            return CartDiscountSetCustomFieldActionSchema().load(data)
        if data["action"] == "setCustomType":
            from ._schemas.cart_discount import CartDiscountSetCustomTypeActionSchema

            return CartDiscountSetCustomTypeActionSchema().load(data)
        if data["action"] == "setDescription":
            from ._schemas.cart_discount import CartDiscountSetDescriptionActionSchema

            return CartDiscountSetDescriptionActionSchema().load(data)
        if data["action"] == "setKey":
            from ._schemas.cart_discount import CartDiscountSetKeyActionSchema

            return CartDiscountSetKeyActionSchema().load(data)
        if data["action"] == "setValidFrom":
            from ._schemas.cart_discount import CartDiscountSetValidFromActionSchema

            return CartDiscountSetValidFromActionSchema().load(data)
        if data["action"] == "setValidFromAndUntil":
            from ._schemas.cart_discount import (
                CartDiscountSetValidFromAndUntilActionSchema,
            )

            return CartDiscountSetValidFromAndUntilActionSchema().load(data)
        if data["action"] == "setValidUntil":
            from ._schemas.cart_discount import CartDiscountSetValidUntilActionSchema

            return CartDiscountSetValidUntilActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountUpdateActionSchema

        return CartDiscountUpdateActionSchema().dump(self)


class CartDiscountValue(_BaseType):
    type: str

    def __init__(self, *, type: str):
        self.type = type

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CartDiscountValue":
        if data["type"] == "absolute":
            from ._schemas.cart_discount import CartDiscountValueAbsoluteSchema

            return CartDiscountValueAbsoluteSchema().load(data)
        if data["type"] == "fixed":
            from ._schemas.cart_discount import CartDiscountValueFixedSchema

            return CartDiscountValueFixedSchema().load(data)
        if data["type"] == "giftLineItem":
            from ._schemas.cart_discount import CartDiscountValueGiftLineItemSchema

            return CartDiscountValueGiftLineItemSchema().load(data)
        if data["type"] == "relative":
            from ._schemas.cart_discount import CartDiscountValueRelativeSchema

            return CartDiscountValueRelativeSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountValueSchema

        return CartDiscountValueSchema().dump(self)


class CartDiscountValueAbsolute(CartDiscountValue):
    """Discounts the [CartDiscountTarget](ctp:api:type:CartDiscountTarget) by an absolute amount (not allowed for [MultiBuyLineItemsTarget](ctp:api:type:MultiBuyLineItemsTarget) and [MultiBuyCustomLineItemsTarget](ctp:api:type:MultiBuyCustomLineItemsTarget))."""

    #: Cent precision money values in different currencies.
    money: typing.List["CentPrecisionMoney"]

    def __init__(self, *, money: typing.List["CentPrecisionMoney"]):
        self.money = money

        super().__init__(type="absolute")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartDiscountValueAbsolute":
        from ._schemas.cart_discount import CartDiscountValueAbsoluteSchema

        return CartDiscountValueAbsoluteSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountValueAbsoluteSchema

        return CartDiscountValueAbsoluteSchema().dump(self)


class CartDiscountValueDraft(_BaseType):
    type: str

    def __init__(self, *, type: str):
        self.type = type

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartDiscountValueDraft":
        if data["type"] == "absolute":
            from ._schemas.cart_discount import CartDiscountValueAbsoluteDraftSchema

            return CartDiscountValueAbsoluteDraftSchema().load(data)
        if data["type"] == "fixed":
            from ._schemas.cart_discount import CartDiscountValueFixedDraftSchema

            return CartDiscountValueFixedDraftSchema().load(data)
        if data["type"] == "giftLineItem":
            from ._schemas.cart_discount import CartDiscountValueGiftLineItemDraftSchema

            return CartDiscountValueGiftLineItemDraftSchema().load(data)
        if data["type"] == "relative":
            from ._schemas.cart_discount import CartDiscountValueRelativeDraftSchema

            return CartDiscountValueRelativeDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountValueDraftSchema

        return CartDiscountValueDraftSchema().dump(self)


class CartDiscountValueAbsoluteDraft(CartDiscountValueDraft):
    #: Money values in different currencies.
    #: An absolute Cart Discount will only match a price if this array contains a value with the same currency. If it contains 10€ and 15$, the matching € price will be decreased by 10€ and the matching $ price will be decreased by 15$.
    money: typing.List["Money"]

    def __init__(self, *, money: typing.List["Money"]):
        self.money = money

        super().__init__(type="absolute")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartDiscountValueAbsoluteDraft":
        from ._schemas.cart_discount import CartDiscountValueAbsoluteDraftSchema

        return CartDiscountValueAbsoluteDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountValueAbsoluteDraftSchema

        return CartDiscountValueAbsoluteDraftSchema().dump(self)


class CartDiscountValueFixed(CartDiscountValue):
    """Sets the [DiscountedLineItemPrice](ctp:api:type:DiscountedLineItemPrice) of the [CartDiscountLineItemsTarget](ctp:api:type:CartDiscountLineItemsTarget) or [CartDiscountCustomLineItemsTarget](ctp:api:type:CartDiscountCustomLineItemsTarget) to the value specified in the `money` field, if it is lower than the current Line Item price for the same currency. If the Line Item price is already discounted to a price equal to or lower than the respective price in the `money` field, this Discount is not applied."""

    #: Cent precision money values in different currencies.
    money: typing.List["CentPrecisionMoney"]

    def __init__(self, *, money: typing.List["CentPrecisionMoney"]):
        self.money = money

        super().__init__(type="fixed")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartDiscountValueFixed":
        from ._schemas.cart_discount import CartDiscountValueFixedSchema

        return CartDiscountValueFixedSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountValueFixedSchema

        return CartDiscountValueFixedSchema().dump(self)


class CartDiscountValueFixedDraft(CartDiscountValueDraft):
    """Sets the [DiscountedLineItemPrice](ctp:api:type:DiscountedLineItemPrice) of the [CartDiscountLineItemsTarget](ctp:api:type:CartDiscountLineItemsTarget) or [CartDiscountCustomLineItemsTarget](ctp:api:type:CartDiscountCustomLineItemsTarget) to the value specified in the `money` field, if it is lower than the current Line Item price for the same currency. If the Line Item price is already discounted to a price equal to or lower than the respective price in the `money` field, this Discount is not applied."""

    #: Money values in different currencies.
    #: A fixed Cart Discount will only match a price if this array contains a value with the same currency. If it contains 10€ and 15$, the matching € price will be discounted by 10€ and the matching $ price will be discounted to 15$.
    money: typing.List["Money"]

    def __init__(self, *, money: typing.List["Money"]):
        self.money = money

        super().__init__(type="fixed")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartDiscountValueFixedDraft":
        from ._schemas.cart_discount import CartDiscountValueFixedDraftSchema

        return CartDiscountValueFixedDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountValueFixedDraftSchema

        return CartDiscountValueFixedDraftSchema().dump(self)


class CartDiscountValueGiftLineItem(CartDiscountValue):
    #: Reference to a Product.
    product: "ProductReference"
    #: [ProductVariant](ctp:api:type:ProductVariant) of the Product.
    variant_id: int
    #: Channel must have the [ChannelRoleEnum](ctp:api:type:ChannelRoleEnum) `InventorySupply`.
    supply_channel: typing.Optional["ChannelReference"]
    #: Channel must have the [ChannelRoleEnum](ctp:api:type:ChannelRoleEnum) `ProductDistribution`.
    distribution_channel: typing.Optional["ChannelReference"]

    def __init__(
        self,
        *,
        product: "ProductReference",
        variant_id: int,
        supply_channel: typing.Optional["ChannelReference"] = None,
        distribution_channel: typing.Optional["ChannelReference"] = None
    ):
        self.product = product
        self.variant_id = variant_id
        self.supply_channel = supply_channel
        self.distribution_channel = distribution_channel

        super().__init__(type="giftLineItem")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartDiscountValueGiftLineItem":
        from ._schemas.cart_discount import CartDiscountValueGiftLineItemSchema

        return CartDiscountValueGiftLineItemSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountValueGiftLineItemSchema

        return CartDiscountValueGiftLineItemSchema().dump(self)


class CartDiscountValueGiftLineItemDraft(CartDiscountValueDraft):
    #: ResourceIdentifier of a Product.
    product: "ProductResourceIdentifier"
    #: [ProductVariant](ctp:api:type:ProductVariant) of the Product.
    variant_id: int
    #: Channel must have the role `InventorySupply`.
    supply_channel: typing.Optional["ChannelResourceIdentifier"]
    #: Channel must have the role `ProductDistribution`.
    distribution_channel: typing.Optional["ChannelResourceIdentifier"]

    def __init__(
        self,
        *,
        product: "ProductResourceIdentifier",
        variant_id: int,
        supply_channel: typing.Optional["ChannelResourceIdentifier"] = None,
        distribution_channel: typing.Optional["ChannelResourceIdentifier"] = None
    ):
        self.product = product
        self.variant_id = variant_id
        self.supply_channel = supply_channel
        self.distribution_channel = distribution_channel

        super().__init__(type="giftLineItem")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartDiscountValueGiftLineItemDraft":
        from ._schemas.cart_discount import CartDiscountValueGiftLineItemDraftSchema

        return CartDiscountValueGiftLineItemDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountValueGiftLineItemDraftSchema

        return CartDiscountValueGiftLineItemDraftSchema().dump(self)


class CartDiscountValueRelative(CartDiscountValue):
    """Discounts the [CartDiscountTarget](ctp:api:type:CartDiscountTarget) relative to its price."""

    #: Fraction (per ten thousand) the price is reduced by. For example, `1000` will result in a 10% price reduction.
    permyriad: int

    def __init__(self, *, permyriad: int):
        self.permyriad = permyriad

        super().__init__(type="relative")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartDiscountValueRelative":
        from ._schemas.cart_discount import CartDiscountValueRelativeSchema

        return CartDiscountValueRelativeSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountValueRelativeSchema

        return CartDiscountValueRelativeSchema().dump(self)


class CartDiscountValueRelativeDraft(CartDiscountValueDraft):
    #: Fraction (per ten thousand) the price is reduced by. For example, `1000` will result in a 10% price reduction.
    permyriad: int

    def __init__(self, *, permyriad: int):
        self.permyriad = permyriad

        super().__init__(type="relative")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartDiscountValueRelativeDraft":
        from ._schemas.cart_discount import CartDiscountValueRelativeDraftSchema

        return CartDiscountValueRelativeDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountValueRelativeDraftSchema

        return CartDiscountValueRelativeDraftSchema().dump(self)


class MultiBuyCustomLineItemsTarget(CartDiscountTarget):
    """This Discount target is similar to `MultiBuyLineItems`, but is applied on Custom Line Items instead of Line Items."""

    #: Valid [CustomLineItems target predicate](/../api/projects/predicates#customlineitem-field-identifiers). The Discount will be applied to Custom Line Items that are matched by the predicate.
    predicate: str
    #: Number of Custom Line Items to be present in order to trigger an application of this Discount.
    trigger_quantity: int
    #: Number of Custom Line Items that are discounted per application of this Discount.
    discounted_quantity: int
    #: Maximum number of times this Discount can be applied.
    max_occurrence: typing.Optional[int]
    #: Discounts particular Line Items only according to the SelectionMode.
    selection_mode: "SelectionMode"

    def __init__(
        self,
        *,
        predicate: str,
        trigger_quantity: int,
        discounted_quantity: int,
        max_occurrence: typing.Optional[int] = None,
        selection_mode: "SelectionMode"
    ):
        self.predicate = predicate
        self.trigger_quantity = trigger_quantity
        self.discounted_quantity = discounted_quantity
        self.max_occurrence = max_occurrence
        self.selection_mode = selection_mode

        super().__init__(type="multiBuyCustomLineItems")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MultiBuyCustomLineItemsTarget":
        from ._schemas.cart_discount import MultiBuyCustomLineItemsTargetSchema

        return MultiBuyCustomLineItemsTargetSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import MultiBuyCustomLineItemsTargetSchema

        return MultiBuyCustomLineItemsTargetSchema().dump(self)


class MultiBuyLineItemsTarget(CartDiscountTarget):
    #: Valid [LineItem target predicate](/../api/projects/predicates#lineitem-field-identifiers). The Discount will be applied to Line Items that are matched by the predicate.
    predicate: str
    #: Number of Line Items to be present in order to trigger an application of this Discount.
    trigger_quantity: int
    #: Number of Line Items that are discounted per application of this Discount.
    discounted_quantity: int
    #: Maximum number of times this Discount can be applied.
    max_occurrence: typing.Optional[int]
    #: Discounts particular Line Items only according to the SelectionMode.
    selection_mode: "SelectionMode"

    def __init__(
        self,
        *,
        predicate: str,
        trigger_quantity: int,
        discounted_quantity: int,
        max_occurrence: typing.Optional[int] = None,
        selection_mode: "SelectionMode"
    ):
        self.predicate = predicate
        self.trigger_quantity = trigger_quantity
        self.discounted_quantity = discounted_quantity
        self.max_occurrence = max_occurrence
        self.selection_mode = selection_mode

        super().__init__(type="multiBuyLineItems")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MultiBuyLineItemsTarget":
        from ._schemas.cart_discount import MultiBuyLineItemsTargetSchema

        return MultiBuyLineItemsTargetSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import MultiBuyLineItemsTargetSchema

        return MultiBuyLineItemsTargetSchema().dump(self)


class SelectionMode(enum.Enum):
    """Defines which matching items are to be discounted."""

    CHEAPEST = "Cheapest"
    MOST_EXPENSIVE = "MostExpensive"


class StackingMode(enum.Enum):
    """Describes how the Cart Discount interacts with other Discounts."""

    STACKING = "Stacking"
    STOP_AFTER_THIS_DISCOUNT = "StopAfterThisDiscount"


class CartDiscountChangeCartPredicateAction(CartDiscountUpdateAction):
    #: New value to set.
    cart_predicate: str

    def __init__(self, *, cart_predicate: str):
        self.cart_predicate = cart_predicate

        super().__init__(action="changeCartPredicate")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartDiscountChangeCartPredicateAction":
        from ._schemas.cart_discount import CartDiscountChangeCartPredicateActionSchema

        return CartDiscountChangeCartPredicateActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountChangeCartPredicateActionSchema

        return CartDiscountChangeCartPredicateActionSchema().dump(self)


class CartDiscountChangeIsActiveAction(CartDiscountUpdateAction):
    #: New value to set.
    #: If set to `true`, the Discount will be applied to the Cart.
    is_active: bool

    def __init__(self, *, is_active: bool):
        self.is_active = is_active

        super().__init__(action="changeIsActive")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartDiscountChangeIsActiveAction":
        from ._schemas.cart_discount import CartDiscountChangeIsActiveActionSchema

        return CartDiscountChangeIsActiveActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountChangeIsActiveActionSchema

        return CartDiscountChangeIsActiveActionSchema().dump(self)


class CartDiscountChangeNameAction(CartDiscountUpdateAction):
    #: New value to set.
    name: "LocalizedString"

    def __init__(self, *, name: "LocalizedString"):
        self.name = name

        super().__init__(action="changeName")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartDiscountChangeNameAction":
        from ._schemas.cart_discount import CartDiscountChangeNameActionSchema

        return CartDiscountChangeNameActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountChangeNameActionSchema

        return CartDiscountChangeNameActionSchema().dump(self)


class CartDiscountChangeRequiresDiscountCodeAction(CartDiscountUpdateAction):
    #: New value to set.
    #: If set to `true`, the Discount can only be used in connection with a [DiscountCode](ctp:api:type:DiscountCode).
    requires_discount_code: bool

    def __init__(self, *, requires_discount_code: bool):
        self.requires_discount_code = requires_discount_code

        super().__init__(action="changeRequiresDiscountCode")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartDiscountChangeRequiresDiscountCodeAction":
        from ._schemas.cart_discount import (
            CartDiscountChangeRequiresDiscountCodeActionSchema,
        )

        return CartDiscountChangeRequiresDiscountCodeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import (
            CartDiscountChangeRequiresDiscountCodeActionSchema,
        )

        return CartDiscountChangeRequiresDiscountCodeActionSchema().dump(self)


class CartDiscountChangeSortOrderAction(CartDiscountUpdateAction):
    #: New value to set (between `0` and `1`).
    #: A Discount with a higher sortOrder is prioritized.
    sort_order: str

    def __init__(self, *, sort_order: str):
        self.sort_order = sort_order

        super().__init__(action="changeSortOrder")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartDiscountChangeSortOrderAction":
        from ._schemas.cart_discount import CartDiscountChangeSortOrderActionSchema

        return CartDiscountChangeSortOrderActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountChangeSortOrderActionSchema

        return CartDiscountChangeSortOrderActionSchema().dump(self)


class CartDiscountChangeStackingModeAction(CartDiscountUpdateAction):
    #: New value to set.
    stacking_mode: "StackingMode"

    def __init__(self, *, stacking_mode: "StackingMode"):
        self.stacking_mode = stacking_mode

        super().__init__(action="changeStackingMode")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartDiscountChangeStackingModeAction":
        from ._schemas.cart_discount import CartDiscountChangeStackingModeActionSchema

        return CartDiscountChangeStackingModeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountChangeStackingModeActionSchema

        return CartDiscountChangeStackingModeActionSchema().dump(self)


class CartDiscountChangeTargetAction(CartDiscountUpdateAction):
    #: New value to set.
    target: "CartDiscountTarget"

    def __init__(self, *, target: "CartDiscountTarget"):
        self.target = target

        super().__init__(action="changeTarget")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartDiscountChangeTargetAction":
        from ._schemas.cart_discount import CartDiscountChangeTargetActionSchema

        return CartDiscountChangeTargetActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountChangeTargetActionSchema

        return CartDiscountChangeTargetActionSchema().dump(self)


class CartDiscountChangeValueAction(CartDiscountUpdateAction):
    #: New value to set.
    value: "CartDiscountValueDraft"

    def __init__(self, *, value: "CartDiscountValueDraft"):
        self.value = value

        super().__init__(action="changeValue")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartDiscountChangeValueAction":
        from ._schemas.cart_discount import CartDiscountChangeValueActionSchema

        return CartDiscountChangeValueActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountChangeValueActionSchema

        return CartDiscountChangeValueActionSchema().dump(self)


class CartDiscountSetCustomFieldAction(CartDiscountUpdateAction):
    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: Removing a field that does not exist returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
    #: If `value` is provided, it is set for the field defined by `name`.
    value: typing.Optional[typing.Any]

    def __init__(self, *, name: str, value: typing.Optional[typing.Any] = None):
        self.name = name
        self.value = value

        super().__init__(action="setCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartDiscountSetCustomFieldAction":
        from ._schemas.cart_discount import CartDiscountSetCustomFieldActionSchema

        return CartDiscountSetCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountSetCustomFieldActionSchema

        return CartDiscountSetCustomFieldActionSchema().dump(self)


class CartDiscountSetCustomTypeAction(CartDiscountUpdateAction):
    #: Defines the [Type](ctp:api:type:Type) that extends the CartDiscount with [Custom Fields](/../api/projects/custom-fields).
    #: If absent, any existing Type and Custom Fields are removed from the CartDiscount.
    type: typing.Optional["TypeResourceIdentifier"]
    #: Sets the [Custom Fields](/../api/projects/custom-fields) fields for the CartDiscount.
    fields: typing.Optional["FieldContainer"]

    def __init__(
        self,
        *,
        type: typing.Optional["TypeResourceIdentifier"] = None,
        fields: typing.Optional["FieldContainer"] = None
    ):
        self.type = type
        self.fields = fields

        super().__init__(action="setCustomType")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartDiscountSetCustomTypeAction":
        from ._schemas.cart_discount import CartDiscountSetCustomTypeActionSchema

        return CartDiscountSetCustomTypeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountSetCustomTypeActionSchema

        return CartDiscountSetCustomTypeActionSchema().dump(self)


class CartDiscountSetDescriptionAction(CartDiscountUpdateAction):
    #: Value to set. If empty, any existing value will be removed.
    description: typing.Optional["LocalizedString"]

    def __init__(self, *, description: typing.Optional["LocalizedString"] = None):
        self.description = description

        super().__init__(action="setDescription")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartDiscountSetDescriptionAction":
        from ._schemas.cart_discount import CartDiscountSetDescriptionActionSchema

        return CartDiscountSetDescriptionActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountSetDescriptionActionSchema

        return CartDiscountSetDescriptionActionSchema().dump(self)


class CartDiscountSetKeyAction(CartDiscountUpdateAction):
    #: Value to set. If empty, any existing value will be removed.
    key: typing.Optional[str]

    def __init__(self, *, key: typing.Optional[str] = None):
        self.key = key

        super().__init__(action="setKey")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartDiscountSetKeyAction":
        from ._schemas.cart_discount import CartDiscountSetKeyActionSchema

        return CartDiscountSetKeyActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountSetKeyActionSchema

        return CartDiscountSetKeyActionSchema().dump(self)


class CartDiscountSetValidFromAction(CartDiscountUpdateAction):
    #: Value to set.
    #: If empty, any existing value will be removed.
    valid_from: typing.Optional[datetime.datetime]

    def __init__(self, *, valid_from: typing.Optional[datetime.datetime] = None):
        self.valid_from = valid_from

        super().__init__(action="setValidFrom")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartDiscountSetValidFromAction":
        from ._schemas.cart_discount import CartDiscountSetValidFromActionSchema

        return CartDiscountSetValidFromActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountSetValidFromActionSchema

        return CartDiscountSetValidFromActionSchema().dump(self)


class CartDiscountSetValidFromAndUntilAction(CartDiscountUpdateAction):
    #: Value to set.
    #: If empty, any existing value will be removed.
    valid_from: typing.Optional[datetime.datetime]
    #: Value to set.
    #: If empty, any existing value will be removed.
    valid_until: typing.Optional[datetime.datetime]

    def __init__(
        self,
        *,
        valid_from: typing.Optional[datetime.datetime] = None,
        valid_until: typing.Optional[datetime.datetime] = None
    ):
        self.valid_from = valid_from
        self.valid_until = valid_until

        super().__init__(action="setValidFromAndUntil")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartDiscountSetValidFromAndUntilAction":
        from ._schemas.cart_discount import CartDiscountSetValidFromAndUntilActionSchema

        return CartDiscountSetValidFromAndUntilActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountSetValidFromAndUntilActionSchema

        return CartDiscountSetValidFromAndUntilActionSchema().dump(self)


class CartDiscountSetValidUntilAction(CartDiscountUpdateAction):
    #: Value to set.
    #: If empty, any existing value will be removed.
    valid_until: typing.Optional[datetime.datetime]

    def __init__(self, *, valid_until: typing.Optional[datetime.datetime] = None):
        self.valid_until = valid_until

        super().__init__(action="setValidUntil")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartDiscountSetValidUntilAction":
        from ._schemas.cart_discount import CartDiscountSetValidUntilActionSchema

        return CartDiscountSetValidUntilActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.cart_discount import CartDiscountSetValidUntilActionSchema

        return CartDiscountSetValidUntilActionSchema().dump(self)
