# This file is automatically generated by the rmf-codegen project.
#
# The Python code generator is maintained by Lab Digital. If you want to
# contribute to this project then please do not edit this file directly
# but send a pull request to the Lab Digital fork of rmf-codegen at
# https://github.com/labd/rmf-codegen

import datetime
import enum
import typing

from ._abstract import _BaseType
from .common import BaseResource, Reference, ReferenceTypeId, ResourceIdentifier

if typing.TYPE_CHECKING:
    from .common import (
        Asset,
        AssetDraft,
        AssetSource,
        CreatedBy,
        LastModifiedBy,
        LocalizedString,
        ReferenceTypeId,
    )
    from .type import (
        CustomFields,
        CustomFieldsDraft,
        FieldContainer,
        TypeResourceIdentifier,
    )

__all__ = [
    "Category",
    "CategoryAddAssetAction",
    "CategoryChangeAssetNameAction",
    "CategoryChangeAssetOrderAction",
    "CategoryChangeNameAction",
    "CategoryChangeOrderHintAction",
    "CategoryChangeParentAction",
    "CategoryChangeSlugAction",
    "CategoryDraft",
    "CategoryPagedQueryResponse",
    "CategoryReference",
    "CategoryRemoveAssetAction",
    "CategoryResourceIdentifier",
    "CategorySetAssetCustomFieldAction",
    "CategorySetAssetCustomTypeAction",
    "CategorySetAssetDescriptionAction",
    "CategorySetAssetKeyAction",
    "CategorySetAssetSourcesAction",
    "CategorySetAssetTagsAction",
    "CategorySetCustomFieldAction",
    "CategorySetCustomTypeAction",
    "CategorySetDescriptionAction",
    "CategorySetExternalIdAction",
    "CategorySetKeyAction",
    "CategorySetMetaDescriptionAction",
    "CategorySetMetaKeywordsAction",
    "CategorySetMetaTitleAction",
    "CategoryUpdate",
    "CategoryUpdateAction",
]


class Category(BaseResource):
    #: Present on resources updated after 1 February 2019 except for [events not tracked](/../api/general-concepts#events-tracked).
    last_modified_by: typing.Optional["LastModifiedBy"]
    #: Present on resources created after 1 February 2019 except for [events not tracked](/../api/general-concepts#events-tracked).
    created_by: typing.Optional["CreatedBy"]
    #: Name of the Category.
    name: "LocalizedString"
    #: User-defined identifier used as a deep-link URL to the related Category per [Locale](ctp:api:type:Locale).
    #: A Category can have the same slug for different Locales, but they are unique across the [Project](ctp:api:type:Project).
    #: Valid slugs match the pattern `^[A-Za-z0-9_-]{2,256}+$`.
    #: For [good performance](/../api/predicates/query#performance-considerations), indexes are provided for the first 15 `languages` set in a Project.
    slug: "LocalizedString"
    #: Description of the Category.
    description: typing.Optional["LocalizedString"]
    #: Contains the parent path towards the root Category.
    ancestors: typing.List["CategoryReference"]
    #: Parent Category of this Category.
    parent: typing.Optional["CategoryReference"]
    #: Decimal value between 0 and 1. Frontend applications can use this value for ordering Categories within the same level in the category tree.
    order_hint: str
    #: Additional identifier for external systems like customer relationship management (CRM) or enterprise resource planning (ERP).
    external_id: typing.Optional[str]
    #: Name of the Category used by external search engines for improved search engine performance.
    meta_title: typing.Optional["LocalizedString"]
    #: Description of the Category used by external search engines for improved search engine performance.
    meta_description: typing.Optional["LocalizedString"]
    #: Keywords related to the Category for improved search engine performance.
    meta_keywords: typing.Optional["LocalizedString"]
    #: Custom Fields for the Category.
    custom: typing.Optional["CustomFields"]
    #: Media related to the Category.
    assets: typing.Optional[typing.List["Asset"]]
    #: User-defined unique identifier of the Category.
    key: typing.Optional[str]

    def __init__(
        self,
        *,
        id: str,
        version: int,
        created_at: datetime.datetime,
        last_modified_at: datetime.datetime,
        last_modified_by: typing.Optional["LastModifiedBy"] = None,
        created_by: typing.Optional["CreatedBy"] = None,
        name: "LocalizedString",
        slug: "LocalizedString",
        description: typing.Optional["LocalizedString"] = None,
        ancestors: typing.List["CategoryReference"],
        parent: typing.Optional["CategoryReference"] = None,
        order_hint: str,
        external_id: typing.Optional[str] = None,
        meta_title: typing.Optional["LocalizedString"] = None,
        meta_description: typing.Optional["LocalizedString"] = None,
        meta_keywords: typing.Optional["LocalizedString"] = None,
        custom: typing.Optional["CustomFields"] = None,
        assets: typing.Optional[typing.List["Asset"]] = None,
        key: typing.Optional[str] = None
    ):
        self.last_modified_by = last_modified_by
        self.created_by = created_by
        self.name = name
        self.slug = slug
        self.description = description
        self.ancestors = ancestors
        self.parent = parent
        self.order_hint = order_hint
        self.external_id = external_id
        self.meta_title = meta_title
        self.meta_description = meta_description
        self.meta_keywords = meta_keywords
        self.custom = custom
        self.assets = assets
        self.key = key

        super().__init__(
            id=id,
            version=version,
            created_at=created_at,
            last_modified_at=last_modified_at,
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "Category":
        from ._schemas.category import CategorySchema

        return CategorySchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.category import CategorySchema

        return CategorySchema().dump(self)


class CategoryDraft(_BaseType):
    #: Name of the Category.
    name: "LocalizedString"
    #: User-defined identifier used as a deep-link URL to the related Category.
    #: A Category can have the same slug for different [Locales](ctp:api:type:Locale), but it must be unique across the [Project](ctp:api:type:Project).
    #: Valid slugs must match the pattern `^[A-Za-z0-9_-]{2,256}+$`.
    slug: "LocalizedString"
    #: Description of the Category.
    description: typing.Optional["LocalizedString"]
    #: Parent Category of the Category.
    #: The parent can be set by its `id` or `key`.
    parent: typing.Optional["CategoryResourceIdentifier"]
    #: Decimal value between 0 and 1. Frontend applications can use this value for ordering Categories within the same level in the category tree.
    #: If not set, a random value will be assigned.
    order_hint: typing.Optional[str]
    #: Additional identifier for external systems like customer relationship management (CRM) or enterprise resource planning (ERP).
    external_id: typing.Optional[str]
    #: Name of the Category used by external search engines for improved search engine performance.
    meta_title: typing.Optional["LocalizedString"]
    #: Description of the Category used by external search engines for improved search engine performance.
    meta_description: typing.Optional["LocalizedString"]
    #: Keywords related to the Category for improved search engine performance.
    meta_keywords: typing.Optional["LocalizedString"]
    #: Custom Fields for the Category.
    custom: typing.Optional["CustomFieldsDraft"]
    #: Media related to the Category.
    assets: typing.Optional[typing.List["AssetDraft"]]
    #: User-defined unique identifier for the Category.
    key: typing.Optional[str]

    def __init__(
        self,
        *,
        name: "LocalizedString",
        slug: "LocalizedString",
        description: typing.Optional["LocalizedString"] = None,
        parent: typing.Optional["CategoryResourceIdentifier"] = None,
        order_hint: typing.Optional[str] = None,
        external_id: typing.Optional[str] = None,
        meta_title: typing.Optional["LocalizedString"] = None,
        meta_description: typing.Optional["LocalizedString"] = None,
        meta_keywords: typing.Optional["LocalizedString"] = None,
        custom: typing.Optional["CustomFieldsDraft"] = None,
        assets: typing.Optional[typing.List["AssetDraft"]] = None,
        key: typing.Optional[str] = None
    ):
        self.name = name
        self.slug = slug
        self.description = description
        self.parent = parent
        self.order_hint = order_hint
        self.external_id = external_id
        self.meta_title = meta_title
        self.meta_description = meta_description
        self.meta_keywords = meta_keywords
        self.custom = custom
        self.assets = assets
        self.key = key

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CategoryDraft":
        from ._schemas.category import CategoryDraftSchema

        return CategoryDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.category import CategoryDraftSchema

        return CategoryDraftSchema().dump(self)


class CategoryPagedQueryResponse(_BaseType):
    """[PagedQueryResult](/../api/general-concepts#pagedqueryresult) with results containing an array of [Category](ctp:api:type:Category)."""

    #: Number of [results requested](/../api/general-concepts#limit).
    limit: int
    #: Number of [elements skipped](/../api/general-concepts#offset).
    offset: int
    #: Actual number of results returned.
    count: int
    #: Total number of results matching the query.
    #: This number is an estimation that is not [strongly consistent](/../api/general-concepts#strong-consistency).
    #: This field is returned by default.
    #: For improved performance, calculating this field can be deactivated by using the query parameter `withTotal=false`.
    #: When the results are filtered with a [Query Predicate](/../api/predicates/query), `total` is subject to a [limit](/../api/limits#queries).
    total: typing.Optional[int]
    #: [Category](ctp:api:type:Category) matching the query.
    results: typing.List["Category"]

    def __init__(
        self,
        *,
        limit: int,
        offset: int,
        count: int,
        total: typing.Optional[int] = None,
        results: typing.List["Category"]
    ):
        self.limit = limit
        self.offset = offset
        self.count = count
        self.total = total
        self.results = results

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CategoryPagedQueryResponse":
        from ._schemas.category import CategoryPagedQueryResponseSchema

        return CategoryPagedQueryResponseSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.category import CategoryPagedQueryResponseSchema

        return CategoryPagedQueryResponseSchema().dump(self)


class CategoryReference(Reference):
    """[Reference](ctp:api:type:Reference) to a [Category](ctp:api:type:Category)."""

    #: Contains the representation of the expanded Category. Only present in responses to requests with [Reference Expansion](/../api/general-concepts#reference-expansion) for Categories.
    obj: typing.Optional["Category"]

    def __init__(self, *, id: str, obj: typing.Optional["Category"] = None):
        self.obj = obj

        super().__init__(id=id, type_id=ReferenceTypeId.CATEGORY)

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CategoryReference":
        from ._schemas.category import CategoryReferenceSchema

        return CategoryReferenceSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.category import CategoryReferenceSchema

        return CategoryReferenceSchema().dump(self)


class CategoryResourceIdentifier(ResourceIdentifier):
    """[ResourceIdentifier](ctp:api:type:ResourceIdentifier) to a [Category](ctp:api:type:Category). Either `id` or `key` is required. If both are set, an [InvalidJsonInput](/../api/errors#invalidjsoninput) error is returned."""

    def __init__(
        self, *, id: typing.Optional[str] = None, key: typing.Optional[str] = None
    ):

        super().__init__(id=id, key=key, type_id=ReferenceTypeId.CATEGORY)

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CategoryResourceIdentifier":
        from ._schemas.category import CategoryResourceIdentifierSchema

        return CategoryResourceIdentifierSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.category import CategoryResourceIdentifierSchema

        return CategoryResourceIdentifierSchema().dump(self)


class CategoryUpdate(_BaseType):
    #: Expected version of the Category on which the changes should be applied.
    #: If the expected version does not match the actual version, a [ConcurrentModification](ctp:api:type:ConcurrentModificationError) error will be returned.
    version: int
    #: Update actions to be performed on the Category.
    actions: typing.List["CategoryUpdateAction"]

    def __init__(self, *, version: int, actions: typing.List["CategoryUpdateAction"]):
        self.version = version
        self.actions = actions

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CategoryUpdate":
        from ._schemas.category import CategoryUpdateSchema

        return CategoryUpdateSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.category import CategoryUpdateSchema

        return CategoryUpdateSchema().dump(self)


class CategoryUpdateAction(_BaseType):
    action: str

    def __init__(self, *, action: str):
        self.action = action

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CategoryUpdateAction":
        if data["action"] == "addAsset":
            from ._schemas.category import CategoryAddAssetActionSchema

            return CategoryAddAssetActionSchema().load(data)
        if data["action"] == "changeAssetName":
            from ._schemas.category import CategoryChangeAssetNameActionSchema

            return CategoryChangeAssetNameActionSchema().load(data)
        if data["action"] == "changeAssetOrder":
            from ._schemas.category import CategoryChangeAssetOrderActionSchema

            return CategoryChangeAssetOrderActionSchema().load(data)
        if data["action"] == "changeName":
            from ._schemas.category import CategoryChangeNameActionSchema

            return CategoryChangeNameActionSchema().load(data)
        if data["action"] == "changeOrderHint":
            from ._schemas.category import CategoryChangeOrderHintActionSchema

            return CategoryChangeOrderHintActionSchema().load(data)
        if data["action"] == "changeParent":
            from ._schemas.category import CategoryChangeParentActionSchema

            return CategoryChangeParentActionSchema().load(data)
        if data["action"] == "changeSlug":
            from ._schemas.category import CategoryChangeSlugActionSchema

            return CategoryChangeSlugActionSchema().load(data)
        if data["action"] == "removeAsset":
            from ._schemas.category import CategoryRemoveAssetActionSchema

            return CategoryRemoveAssetActionSchema().load(data)
        if data["action"] == "setAssetCustomField":
            from ._schemas.category import CategorySetAssetCustomFieldActionSchema

            return CategorySetAssetCustomFieldActionSchema().load(data)
        if data["action"] == "setAssetCustomType":
            from ._schemas.category import CategorySetAssetCustomTypeActionSchema

            return CategorySetAssetCustomTypeActionSchema().load(data)
        if data["action"] == "setAssetDescription":
            from ._schemas.category import CategorySetAssetDescriptionActionSchema

            return CategorySetAssetDescriptionActionSchema().load(data)
        if data["action"] == "setAssetKey":
            from ._schemas.category import CategorySetAssetKeyActionSchema

            return CategorySetAssetKeyActionSchema().load(data)
        if data["action"] == "setAssetSources":
            from ._schemas.category import CategorySetAssetSourcesActionSchema

            return CategorySetAssetSourcesActionSchema().load(data)
        if data["action"] == "setAssetTags":
            from ._schemas.category import CategorySetAssetTagsActionSchema

            return CategorySetAssetTagsActionSchema().load(data)
        if data["action"] == "setCustomField":
            from ._schemas.category import CategorySetCustomFieldActionSchema

            return CategorySetCustomFieldActionSchema().load(data)
        if data["action"] == "setCustomType":
            from ._schemas.category import CategorySetCustomTypeActionSchema

            return CategorySetCustomTypeActionSchema().load(data)
        if data["action"] == "setDescription":
            from ._schemas.category import CategorySetDescriptionActionSchema

            return CategorySetDescriptionActionSchema().load(data)
        if data["action"] == "setExternalId":
            from ._schemas.category import CategorySetExternalIdActionSchema

            return CategorySetExternalIdActionSchema().load(data)
        if data["action"] == "setKey":
            from ._schemas.category import CategorySetKeyActionSchema

            return CategorySetKeyActionSchema().load(data)
        if data["action"] == "setMetaDescription":
            from ._schemas.category import CategorySetMetaDescriptionActionSchema

            return CategorySetMetaDescriptionActionSchema().load(data)
        if data["action"] == "setMetaKeywords":
            from ._schemas.category import CategorySetMetaKeywordsActionSchema

            return CategorySetMetaKeywordsActionSchema().load(data)
        if data["action"] == "setMetaTitle":
            from ._schemas.category import CategorySetMetaTitleActionSchema

            return CategorySetMetaTitleActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.category import CategoryUpdateActionSchema

        return CategoryUpdateActionSchema().dump(self)


class CategoryAddAssetAction(CategoryUpdateAction):
    #: Value to append.
    asset: "AssetDraft"
    #: Position in the array at which the Asset should be put. When specified, the value must be between `0` and the total number of Assets minus `1`.
    position: typing.Optional[int]

    def __init__(self, *, asset: "AssetDraft", position: typing.Optional[int] = None):
        self.asset = asset
        self.position = position

        super().__init__(action="addAsset")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CategoryAddAssetAction":
        from ._schemas.category import CategoryAddAssetActionSchema

        return CategoryAddAssetActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.category import CategoryAddAssetActionSchema

        return CategoryAddAssetActionSchema().dump(self)


class CategoryChangeAssetNameAction(CategoryUpdateAction):
    #: New value to set. Either `assetId` or `assetKey` is required.
    asset_id: typing.Optional[str]
    #: New value to set. Either `assetId` or `assetKey` is required.
    asset_key: typing.Optional[str]
    #: New value to set. Must not be empty.
    name: "LocalizedString"

    def __init__(
        self,
        *,
        asset_id: typing.Optional[str] = None,
        asset_key: typing.Optional[str] = None,
        name: "LocalizedString"
    ):
        self.asset_id = asset_id
        self.asset_key = asset_key
        self.name = name

        super().__init__(action="changeAssetName")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CategoryChangeAssetNameAction":
        from ._schemas.category import CategoryChangeAssetNameActionSchema

        return CategoryChangeAssetNameActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.category import CategoryChangeAssetNameActionSchema

        return CategoryChangeAssetNameActionSchema().dump(self)


class CategoryChangeAssetOrderAction(CategoryUpdateAction):
    """This update action changes the order of the `assets` array. The new order is defined by listing the `id`s of the Assets."""

    #: New value to set. Must contain all Asset `id`s.
    asset_order: typing.List["str"]

    def __init__(self, *, asset_order: typing.List["str"]):
        self.asset_order = asset_order

        super().__init__(action="changeAssetOrder")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CategoryChangeAssetOrderAction":
        from ._schemas.category import CategoryChangeAssetOrderActionSchema

        return CategoryChangeAssetOrderActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.category import CategoryChangeAssetOrderActionSchema

        return CategoryChangeAssetOrderActionSchema().dump(self)


class CategoryChangeNameAction(CategoryUpdateAction):
    #: New value to set. Must not be empty.
    name: "LocalizedString"

    def __init__(self, *, name: "LocalizedString"):
        self.name = name

        super().__init__(action="changeName")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CategoryChangeNameAction":
        from ._schemas.category import CategoryChangeNameActionSchema

        return CategoryChangeNameActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.category import CategoryChangeNameActionSchema

        return CategoryChangeNameActionSchema().dump(self)


class CategoryChangeOrderHintAction(CategoryUpdateAction):
    #: New value to set. Must be a decimal value between 0 and 1.
    order_hint: str

    def __init__(self, *, order_hint: str):
        self.order_hint = order_hint

        super().__init__(action="changeOrderHint")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CategoryChangeOrderHintAction":
        from ._schemas.category import CategoryChangeOrderHintActionSchema

        return CategoryChangeOrderHintActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.category import CategoryChangeOrderHintActionSchema

        return CategoryChangeOrderHintActionSchema().dump(self)


class CategoryChangeParentAction(CategoryUpdateAction):
    #: New value to set as parent.
    parent: "CategoryResourceIdentifier"

    def __init__(self, *, parent: "CategoryResourceIdentifier"):
        self.parent = parent

        super().__init__(action="changeParent")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CategoryChangeParentAction":
        from ._schemas.category import CategoryChangeParentActionSchema

        return CategoryChangeParentActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.category import CategoryChangeParentActionSchema

        return CategoryChangeParentActionSchema().dump(self)


class CategoryChangeSlugAction(CategoryUpdateAction):
    """Changing the slug produces the [CategorySlugChanged](ctp:api:type:CategorySlugChangedMessage) Message."""

    #: New value to set. Must not be empty.
    #: A Category can have the same slug for different [Locales](ctp:api:type:Locale), but it must be unique across the [Project](ctp:api:type:Project).
    #: Valid slugs must match the pattern `^[A-Za-z0-9_-]{2,256}+$`.
    slug: "LocalizedString"

    def __init__(self, *, slug: "LocalizedString"):
        self.slug = slug

        super().__init__(action="changeSlug")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CategoryChangeSlugAction":
        from ._schemas.category import CategoryChangeSlugActionSchema

        return CategoryChangeSlugActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.category import CategoryChangeSlugActionSchema

        return CategoryChangeSlugActionSchema().dump(self)


class CategoryRemoveAssetAction(CategoryUpdateAction):
    #: Value to remove. Either `assetId` or `assetKey` is required.
    asset_id: typing.Optional[str]
    #: Value to remove. Either `assetId` or `assetKey` is required.
    asset_key: typing.Optional[str]

    def __init__(
        self,
        *,
        asset_id: typing.Optional[str] = None,
        asset_key: typing.Optional[str] = None
    ):
        self.asset_id = asset_id
        self.asset_key = asset_key

        super().__init__(action="removeAsset")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CategoryRemoveAssetAction":
        from ._schemas.category import CategoryRemoveAssetActionSchema

        return CategoryRemoveAssetActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.category import CategoryRemoveAssetActionSchema

        return CategoryRemoveAssetActionSchema().dump(self)


class CategorySetAssetCustomFieldAction(CategoryUpdateAction):
    #: New value to set. Either `assetId` or `assetKey` is required.
    asset_id: typing.Optional[str]
    #: New value to set. Either `assetId` or `assetKey` is required.
    asset_key: typing.Optional[str]
    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: Removing a field that does not exist returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
    #: If `value` is provided, it is set for the field defined by `name`.
    value: typing.Optional[typing.Any]

    def __init__(
        self,
        *,
        asset_id: typing.Optional[str] = None,
        asset_key: typing.Optional[str] = None,
        name: str,
        value: typing.Optional[typing.Any] = None
    ):
        self.asset_id = asset_id
        self.asset_key = asset_key
        self.name = name
        self.value = value

        super().__init__(action="setAssetCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CategorySetAssetCustomFieldAction":
        from ._schemas.category import CategorySetAssetCustomFieldActionSchema

        return CategorySetAssetCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.category import CategorySetAssetCustomFieldActionSchema

        return CategorySetAssetCustomFieldActionSchema().dump(self)


class CategorySetAssetCustomTypeAction(CategoryUpdateAction):
    #: New value to set. Either `assetId` or `assetKey` is required.
    asset_id: typing.Optional[str]
    #: New value to set. Either `assetId` or `assetKey` is required.
    asset_key: typing.Optional[str]
    #: Defines the [Type](ctp:api:type:Type) that extends the Asset with [Custom Fields](/../api/projects/custom-fields).
    #: If absent, any existing Type and Custom Fields are removed from the Asset.
    type: typing.Optional["TypeResourceIdentifier"]
    #: Sets the [Custom Fields](/../api/projects/custom-fields) fields for the Asset.
    fields: typing.Optional["FieldContainer"]

    def __init__(
        self,
        *,
        asset_id: typing.Optional[str] = None,
        asset_key: typing.Optional[str] = None,
        type: typing.Optional["TypeResourceIdentifier"] = None,
        fields: typing.Optional["FieldContainer"] = None
    ):
        self.asset_id = asset_id
        self.asset_key = asset_key
        self.type = type
        self.fields = fields

        super().__init__(action="setAssetCustomType")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CategorySetAssetCustomTypeAction":
        from ._schemas.category import CategorySetAssetCustomTypeActionSchema

        return CategorySetAssetCustomTypeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.category import CategorySetAssetCustomTypeActionSchema

        return CategorySetAssetCustomTypeActionSchema().dump(self)


class CategorySetAssetDescriptionAction(CategoryUpdateAction):
    #: New value to set. Either `assetId` or `assetKey` is required.
    asset_id: typing.Optional[str]
    #: New value to set. Either `assetId` or `assetKey` is required.
    asset_key: typing.Optional[str]
    #: Value to set. If empty, any existing value will be removed.
    description: typing.Optional["LocalizedString"]

    def __init__(
        self,
        *,
        asset_id: typing.Optional[str] = None,
        asset_key: typing.Optional[str] = None,
        description: typing.Optional["LocalizedString"] = None
    ):
        self.asset_id = asset_id
        self.asset_key = asset_key
        self.description = description

        super().__init__(action="setAssetDescription")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CategorySetAssetDescriptionAction":
        from ._schemas.category import CategorySetAssetDescriptionActionSchema

        return CategorySetAssetDescriptionActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.category import CategorySetAssetDescriptionActionSchema

        return CategorySetAssetDescriptionActionSchema().dump(self)


class CategorySetAssetKeyAction(CategoryUpdateAction):
    """Set or remove the `key` of an [Asset](ctp:api:type:Asset)."""

    #: Value to set.
    asset_id: str
    #: Value to set. If empty, any existing value will be removed.
    asset_key: typing.Optional[str]

    def __init__(self, *, asset_id: str, asset_key: typing.Optional[str] = None):
        self.asset_id = asset_id
        self.asset_key = asset_key

        super().__init__(action="setAssetKey")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CategorySetAssetKeyAction":
        from ._schemas.category import CategorySetAssetKeyActionSchema

        return CategorySetAssetKeyActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.category import CategorySetAssetKeyActionSchema

        return CategorySetAssetKeyActionSchema().dump(self)


class CategorySetAssetSourcesAction(CategoryUpdateAction):
    #: New value to set. Either `assetId` or `assetKey` is required.
    asset_id: typing.Optional[str]
    #: New value to set. Either `assetId` or `assetKey` is required.
    asset_key: typing.Optional[str]
    #: Must not be empty. At least one entry is required.
    sources: typing.List["AssetSource"]

    def __init__(
        self,
        *,
        asset_id: typing.Optional[str] = None,
        asset_key: typing.Optional[str] = None,
        sources: typing.List["AssetSource"]
    ):
        self.asset_id = asset_id
        self.asset_key = asset_key
        self.sources = sources

        super().__init__(action="setAssetSources")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CategorySetAssetSourcesAction":
        from ._schemas.category import CategorySetAssetSourcesActionSchema

        return CategorySetAssetSourcesActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.category import CategorySetAssetSourcesActionSchema

        return CategorySetAssetSourcesActionSchema().dump(self)


class CategorySetAssetTagsAction(CategoryUpdateAction):
    #: New value to set. Either `assetId` or `assetKey` is required.
    asset_id: typing.Optional[str]
    #: New value to set. Either `assetId` or `assetKey` is required.
    asset_key: typing.Optional[str]
    #: Keywords for categorizing and organizing Assets.
    tags: typing.Optional[typing.List["str"]]

    def __init__(
        self,
        *,
        asset_id: typing.Optional[str] = None,
        asset_key: typing.Optional[str] = None,
        tags: typing.Optional[typing.List["str"]] = None
    ):
        self.asset_id = asset_id
        self.asset_key = asset_key
        self.tags = tags

        super().__init__(action="setAssetTags")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CategorySetAssetTagsAction":
        from ._schemas.category import CategorySetAssetTagsActionSchema

        return CategorySetAssetTagsActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.category import CategorySetAssetTagsActionSchema

        return CategorySetAssetTagsActionSchema().dump(self)


class CategorySetCustomFieldAction(CategoryUpdateAction):
    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: Removing a field that does not exist returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
    #: If `value` is provided, it is set for the field defined by `name`.
    value: typing.Optional[typing.Any]

    def __init__(self, *, name: str, value: typing.Optional[typing.Any] = None):
        self.name = name
        self.value = value

        super().__init__(action="setCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CategorySetCustomFieldAction":
        from ._schemas.category import CategorySetCustomFieldActionSchema

        return CategorySetCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.category import CategorySetCustomFieldActionSchema

        return CategorySetCustomFieldActionSchema().dump(self)


class CategorySetCustomTypeAction(CategoryUpdateAction):
    #: Defines the [Type](ctp:api:type:Type) that extends the Category with [Custom Fields](/../api/projects/custom-fields).
    #: If absent, any existing Type and Custom Fields are removed from the Category.
    type: typing.Optional["TypeResourceIdentifier"]
    #: Sets the [Custom Fields](/../api/projects/custom-fields) fields for the Category.
    fields: typing.Optional["FieldContainer"]

    def __init__(
        self,
        *,
        type: typing.Optional["TypeResourceIdentifier"] = None,
        fields: typing.Optional["FieldContainer"] = None
    ):
        self.type = type
        self.fields = fields

        super().__init__(action="setCustomType")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CategorySetCustomTypeAction":
        from ._schemas.category import CategorySetCustomTypeActionSchema

        return CategorySetCustomTypeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.category import CategorySetCustomTypeActionSchema

        return CategorySetCustomTypeActionSchema().dump(self)


class CategorySetDescriptionAction(CategoryUpdateAction):
    #: Value to set. If empty, any existing value will be removed.
    description: typing.Optional["LocalizedString"]

    def __init__(self, *, description: typing.Optional["LocalizedString"] = None):
        self.description = description

        super().__init__(action="setDescription")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CategorySetDescriptionAction":
        from ._schemas.category import CategorySetDescriptionActionSchema

        return CategorySetDescriptionActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.category import CategorySetDescriptionActionSchema

        return CategorySetDescriptionActionSchema().dump(self)


class CategorySetExternalIdAction(CategoryUpdateAction):
    """This update action sets a new ID that can be used as an additional identifier for external systems like customer relationship management (CRM) or enterprise resource planning (ERP)."""

    #: Value to set. If empty, any existing value will be removed.
    external_id: typing.Optional[str]

    def __init__(self, *, external_id: typing.Optional[str] = None):
        self.external_id = external_id

        super().__init__(action="setExternalId")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CategorySetExternalIdAction":
        from ._schemas.category import CategorySetExternalIdActionSchema

        return CategorySetExternalIdActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.category import CategorySetExternalIdActionSchema

        return CategorySetExternalIdActionSchema().dump(self)


class CategorySetKeyAction(CategoryUpdateAction):
    #: Value to set. If empty, any existing value will be removed.
    key: typing.Optional[str]

    def __init__(self, *, key: typing.Optional[str] = None):
        self.key = key

        super().__init__(action="setKey")

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CategorySetKeyAction":
        from ._schemas.category import CategorySetKeyActionSchema

        return CategorySetKeyActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.category import CategorySetKeyActionSchema

        return CategorySetKeyActionSchema().dump(self)


class CategorySetMetaDescriptionAction(CategoryUpdateAction):
    #: Value to set.
    meta_description: typing.Optional["LocalizedString"]

    def __init__(self, *, meta_description: typing.Optional["LocalizedString"] = None):
        self.meta_description = meta_description

        super().__init__(action="setMetaDescription")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CategorySetMetaDescriptionAction":
        from ._schemas.category import CategorySetMetaDescriptionActionSchema

        return CategorySetMetaDescriptionActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.category import CategorySetMetaDescriptionActionSchema

        return CategorySetMetaDescriptionActionSchema().dump(self)


class CategorySetMetaKeywordsAction(CategoryUpdateAction):
    #: Value to set.
    meta_keywords: typing.Optional["LocalizedString"]

    def __init__(self, *, meta_keywords: typing.Optional["LocalizedString"] = None):
        self.meta_keywords = meta_keywords

        super().__init__(action="setMetaKeywords")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CategorySetMetaKeywordsAction":
        from ._schemas.category import CategorySetMetaKeywordsActionSchema

        return CategorySetMetaKeywordsActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.category import CategorySetMetaKeywordsActionSchema

        return CategorySetMetaKeywordsActionSchema().dump(self)


class CategorySetMetaTitleAction(CategoryUpdateAction):
    #: Value to set.
    meta_title: typing.Optional["LocalizedString"]

    def __init__(self, *, meta_title: typing.Optional["LocalizedString"] = None):
        self.meta_title = meta_title

        super().__init__(action="setMetaTitle")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CategorySetMetaTitleAction":
        from ._schemas.category import CategorySetMetaTitleActionSchema

        return CategorySetMetaTitleActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.category import CategorySetMetaTitleActionSchema

        return CategorySetMetaTitleActionSchema().dump(self)
