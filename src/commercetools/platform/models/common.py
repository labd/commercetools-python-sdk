# This file is automatically generated by the rmf-codegen project.
#
# The Python code generator is maintained by Lab Digital. If you want to
# contribute to this project then please do not edit this file directly
# but send a pull request to the Lab Digital fork of rmf-codegen at
# https://github.com/labd/rmf-codegen

import datetime
import enum
import typing

from ._abstract import _BaseType

if typing.TYPE_CHECKING:
    from .channel import ChannelReference, ChannelResourceIdentifier
    from .customer import CustomerReference
    from .customer_group import CustomerGroupReference, CustomerGroupResourceIdentifier
    from .product_discount import ProductDiscountReference
    from .type import CustomFields, CustomFieldsDraft

__all__ = [
    "Address",
    "AddressDraft",
    "Asset",
    "AssetDimensions",
    "AssetDraft",
    "AssetSource",
    "BaseAddress",
    "BaseResource",
    "CentPrecisionMoney",
    "CentPrecisionMoneyDraft",
    "ClientLogging",
    "CreatedBy",
    "DiscountedPrice",
    "DiscountedPriceDraft",
    "GeoJson",
    "GeoJsonPoint",
    "HighPrecisionMoney",
    "HighPrecisionMoneyDraft",
    "Image",
    "ImageDimensions",
    "KeyReference",
    "LastModifiedBy",
    "LocalizedString",
    "Money",
    "MoneyType",
    "PagedQueryResponse",
    "Price",
    "PriceDraft",
    "PriceTier",
    "PriceTierDraft",
    "QueryPrice",
    "Reference",
    "ReferenceTypeId",
    "ResourceIdentifier",
    "ScopedPrice",
    "TypedMoney",
    "TypedMoneyDraft",
    "Update",
    "UpdateAction",
]


class PagedQueryResponse(_BaseType):
    #: Number of [results requested](/../api/general-concepts#limit).
    limit: int
    #: Number of [elements skipped](/../api/general-concepts#offset).
    offset: int
    #: Actual number of results returned.
    count: int
    #: Total number of results matching the query.
    #: This number is an estimation that is not [strongly consistent](/../api/general-concepts#strong-consistency).
    #: This field is returned by default.
    #: For improved performance, calculating this field can be deactivated by using the query parameter `withTotal=false`.
    #: When the results are filtered with a [Query Predicate](/../api/predicates/query), `total` is subject to a [limit](/../api/limits#queries).
    total: typing.Optional[int]
    results: typing.List["BaseResource"]
    meta: typing.Optional[object]

    def __init__(
        self,
        *,
        limit: int,
        offset: int,
        count: int,
        total: typing.Optional[int] = None,
        results: typing.List["BaseResource"],
        meta: typing.Optional[object] = None
    ):
        self.limit = limit
        self.offset = offset
        self.count = count
        self.total = total
        self.results = results
        self.meta = meta

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "PagedQueryResponse":
        from ._schemas.common import PagedQueryResponseSchema

        return PagedQueryResponseSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import PagedQueryResponseSchema

        return PagedQueryResponseSchema().dump(self)


class Update(_BaseType):
    version: int
    actions: typing.List["UpdateAction"]

    def __init__(self, *, version: int, actions: typing.List["UpdateAction"]):
        self.version = version
        self.actions = actions

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "Update":
        from ._schemas.common import UpdateSchema

        return UpdateSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import UpdateSchema

        return UpdateSchema().dump(self)


class UpdateAction(_BaseType):
    action: str

    def __init__(self, *, action: str):
        self.action = action

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "UpdateAction":
        from ._schemas.common import UpdateActionSchema

        return UpdateActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import UpdateActionSchema

        return UpdateActionSchema().dump(self)


class Asset(_BaseType):
    #: Unique identifier of the Asset.
    id: str
    sources: typing.List["AssetSource"]
    #: Name of the Asset.
    name: "LocalizedString"
    #: Description of the Asset.
    description: typing.Optional["LocalizedString"]
    #: Keywords for categorizing and organizing Assets.
    tags: typing.Optional[typing.List["str"]]
    #: Custom Fields defined for the Asset.
    custom: typing.Optional["CustomFields"]
    #: User-defined identifier of the Asset. It is unique per [Category](ctp:api:type:Category) or [ProductVariant](ctp:api:type:ProductVariant).
    key: typing.Optional[str]

    def __init__(
        self,
        *,
        id: str,
        sources: typing.List["AssetSource"],
        name: "LocalizedString",
        description: typing.Optional["LocalizedString"] = None,
        tags: typing.Optional[typing.List["str"]] = None,
        custom: typing.Optional["CustomFields"] = None,
        key: typing.Optional[str] = None
    ):
        self.id = id
        self.sources = sources
        self.name = name
        self.description = description
        self.tags = tags
        self.custom = custom
        self.key = key

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "Asset":
        from ._schemas.common import AssetSchema

        return AssetSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import AssetSchema

        return AssetSchema().dump(self)


class AssetDimensions(_BaseType):
    """Dimensions of the Asset source specified by the number of pixels."""

    #: Width of the Asset source.
    w: int
    #: Height of the Asset source.
    h: int

    def __init__(self, *, w: int, h: int):
        self.w = w
        self.h = h

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "AssetDimensions":
        from ._schemas.common import AssetDimensionsSchema

        return AssetDimensionsSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import AssetDimensionsSchema

        return AssetDimensionsSchema().dump(self)


class AssetDraft(_BaseType):
    sources: typing.List["AssetSource"]
    #: Name of the Asset.
    name: "LocalizedString"
    #: Description of the Asset.
    description: typing.Optional["LocalizedString"]
    #: Keywords for categorizing and organizing Assets.
    tags: typing.Optional[typing.List["str"]]
    #: Custom Fields defined for the Asset.
    custom: typing.Optional["CustomFieldsDraft"]
    #: User-defined identifier for the Asset. Must be unique per [Category](ctp:api:type:Category) or [ProductVariant](ctp:api:type:ProductVariant).
    key: typing.Optional[str]

    def __init__(
        self,
        *,
        sources: typing.List["AssetSource"],
        name: "LocalizedString",
        description: typing.Optional["LocalizedString"] = None,
        tags: typing.Optional[typing.List["str"]] = None,
        custom: typing.Optional["CustomFieldsDraft"] = None,
        key: typing.Optional[str] = None
    ):
        self.sources = sources
        self.name = name
        self.description = description
        self.tags = tags
        self.custom = custom
        self.key = key

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "AssetDraft":
        from ._schemas.common import AssetDraftSchema

        return AssetDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import AssetDraftSchema

        return AssetDraftSchema().dump(self)


class AssetSource(_BaseType):
    """Representation of an [Asset](#asset) in a specific format, for example a video in a certain encoding, or an image in a certain resolution."""

    #: URI of the AssetSource.
    uri: str
    #: User-defined identifier of the AssetSource. Must be unique per [Asset](ctp:api:type:Asset).
    key: typing.Optional[str]
    #: Width and height of the AssetSource.
    dimensions: typing.Optional["AssetDimensions"]
    #: Indicates the type of content, for example `application/pdf`.
    content_type: typing.Optional[str]

    def __init__(
        self,
        *,
        uri: str,
        key: typing.Optional[str] = None,
        dimensions: typing.Optional["AssetDimensions"] = None,
        content_type: typing.Optional[str] = None
    ):
        self.uri = uri
        self.key = key
        self.dimensions = dimensions
        self.content_type = content_type

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "AssetSource":
        from ._schemas.common import AssetSourceSchema

        return AssetSourceSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import AssetSourceSchema

        return AssetSourceSchema().dump(self)


class BaseAddress(_BaseType):
    """Polymorphic base type that represents a postal address and contact details.
    Depending on the read or write action, it can be either [Address](ctp:api:type:Address) or [AddressDraft](ctp:api:type:AddressDraft) that
    only differ in the data type for the optional `custom` field.

    """

    #: Unique identifier of the Address.
    #:
    #: It is not recommended to set it manually since the API overwrites this ID when creating an Address for a [Customer](ctp:api:type:Customer).
    #: Use `key` instead and omit this field from the request to let the API generate the ID for the Address.
    id: typing.Optional[str]
    #: User-defined identifier of the Address that must be unique when multiple addresses are referenced in [BusinessUnits](ctp:api:type:BusinessUnit), [Customers](ctp:api:type:Customer), and `itemShippingAddresses` (LineItem-specific addresses) of a [Cart](ctp:api:type:Cart), [Order](ctp:api:type:Order), [QuoteRequest](ctp:api:type:QuoteRequest), or [Quote](ctp:api:type:Quote).
    key: typing.Optional[str]
    #: Name of the country.
    country: str
    #: Title of the contact, for example 'Dr.'
    title: typing.Optional[str]
    #: Salutation of the contact, for example 'Mr.' or 'Ms.'
    salutation: typing.Optional[str]
    #: Given name (first name) of the contact.
    first_name: typing.Optional[str]
    #: Family name (last name) of the contact.
    last_name: typing.Optional[str]
    #: Name of the street.
    street_name: typing.Optional[str]
    #: Street number.
    street_number: typing.Optional[str]
    #: Further information on the street address.
    additional_street_info: typing.Optional[str]
    #: Postal code.
    postal_code: typing.Optional[str]
    #: Name of the city.
    city: typing.Optional[str]
    #: Name of the region.
    region: typing.Optional[str]
    #: Name of the state, for example, Colorado.
    state: typing.Optional[str]
    #: Name of the company.
    company: typing.Optional[str]
    #: Name of the department.
    department: typing.Optional[str]
    #: Number or name of the building.
    building: typing.Optional[str]
    #: Number or name of the apartment.
    apartment: typing.Optional[str]
    #: Post office box number.
    p_o_box: typing.Optional[str]
    #: Phone number of the contact.
    phone: typing.Optional[str]
    #: Mobile phone number of the contact.
    mobile: typing.Optional[str]
    #: Email address of the contact.
    email: typing.Optional[str]
    #: Fax number of the contact.
    fax: typing.Optional[str]
    #: Further information on the Address.
    additional_address_info: typing.Optional[str]
    #: ID for the contact used in an external system.
    external_id: typing.Optional[str]

    def __init__(
        self,
        *,
        id: typing.Optional[str] = None,
        key: typing.Optional[str] = None,
        country: str,
        title: typing.Optional[str] = None,
        salutation: typing.Optional[str] = None,
        first_name: typing.Optional[str] = None,
        last_name: typing.Optional[str] = None,
        street_name: typing.Optional[str] = None,
        street_number: typing.Optional[str] = None,
        additional_street_info: typing.Optional[str] = None,
        postal_code: typing.Optional[str] = None,
        city: typing.Optional[str] = None,
        region: typing.Optional[str] = None,
        state: typing.Optional[str] = None,
        company: typing.Optional[str] = None,
        department: typing.Optional[str] = None,
        building: typing.Optional[str] = None,
        apartment: typing.Optional[str] = None,
        p_o_box: typing.Optional[str] = None,
        phone: typing.Optional[str] = None,
        mobile: typing.Optional[str] = None,
        email: typing.Optional[str] = None,
        fax: typing.Optional[str] = None,
        additional_address_info: typing.Optional[str] = None,
        external_id: typing.Optional[str] = None
    ):
        self.id = id
        self.key = key
        self.country = country
        self.title = title
        self.salutation = salutation
        self.first_name = first_name
        self.last_name = last_name
        self.street_name = street_name
        self.street_number = street_number
        self.additional_street_info = additional_street_info
        self.postal_code = postal_code
        self.city = city
        self.region = region
        self.state = state
        self.company = company
        self.department = department
        self.building = building
        self.apartment = apartment
        self.p_o_box = p_o_box
        self.phone = phone
        self.mobile = mobile
        self.email = email
        self.fax = fax
        self.additional_address_info = additional_address_info
        self.external_id = external_id

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "BaseAddress":
        from ._schemas.common import BaseAddressSchema

        return BaseAddressSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import BaseAddressSchema

        return BaseAddressSchema().dump(self)


class Address(BaseAddress):
    """Address type returned by read methods.
    Optionally, the `custom` field can be present in addition to the fields of a [BaseAddress](ctp:api:type:BaseAddress).

    """

    #: Custom Fields defined for the Address.
    custom: typing.Optional["CustomFields"]

    def __init__(
        self,
        *,
        id: typing.Optional[str] = None,
        key: typing.Optional[str] = None,
        country: str,
        title: typing.Optional[str] = None,
        salutation: typing.Optional[str] = None,
        first_name: typing.Optional[str] = None,
        last_name: typing.Optional[str] = None,
        street_name: typing.Optional[str] = None,
        street_number: typing.Optional[str] = None,
        additional_street_info: typing.Optional[str] = None,
        postal_code: typing.Optional[str] = None,
        city: typing.Optional[str] = None,
        region: typing.Optional[str] = None,
        state: typing.Optional[str] = None,
        company: typing.Optional[str] = None,
        department: typing.Optional[str] = None,
        building: typing.Optional[str] = None,
        apartment: typing.Optional[str] = None,
        p_o_box: typing.Optional[str] = None,
        phone: typing.Optional[str] = None,
        mobile: typing.Optional[str] = None,
        email: typing.Optional[str] = None,
        fax: typing.Optional[str] = None,
        additional_address_info: typing.Optional[str] = None,
        external_id: typing.Optional[str] = None,
        custom: typing.Optional["CustomFields"] = None
    ):
        self.custom = custom

        super().__init__(
            id=id,
            key=key,
            country=country,
            title=title,
            salutation=salutation,
            first_name=first_name,
            last_name=last_name,
            street_name=street_name,
            street_number=street_number,
            additional_street_info=additional_street_info,
            postal_code=postal_code,
            city=city,
            region=region,
            state=state,
            company=company,
            department=department,
            building=building,
            apartment=apartment,
            p_o_box=p_o_box,
            phone=phone,
            mobile=mobile,
            email=email,
            fax=fax,
            additional_address_info=additional_address_info,
            external_id=external_id,
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "Address":
        from ._schemas.common import AddressSchema

        return AddressSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import AddressSchema

        return AddressSchema().dump(self)


class AddressDraft(BaseAddress):
    """Address type to be used on write methods.
    Optionally, use the `custom` field in addition to the fields of a [BaseAddress](ctp:api:type:BaseAddress).

    """

    #: Custom Fields defined for the Address.
    custom: typing.Optional["CustomFieldsDraft"]

    def __init__(
        self,
        *,
        id: typing.Optional[str] = None,
        key: typing.Optional[str] = None,
        country: str,
        title: typing.Optional[str] = None,
        salutation: typing.Optional[str] = None,
        first_name: typing.Optional[str] = None,
        last_name: typing.Optional[str] = None,
        street_name: typing.Optional[str] = None,
        street_number: typing.Optional[str] = None,
        additional_street_info: typing.Optional[str] = None,
        postal_code: typing.Optional[str] = None,
        city: typing.Optional[str] = None,
        region: typing.Optional[str] = None,
        state: typing.Optional[str] = None,
        company: typing.Optional[str] = None,
        department: typing.Optional[str] = None,
        building: typing.Optional[str] = None,
        apartment: typing.Optional[str] = None,
        p_o_box: typing.Optional[str] = None,
        phone: typing.Optional[str] = None,
        mobile: typing.Optional[str] = None,
        email: typing.Optional[str] = None,
        fax: typing.Optional[str] = None,
        additional_address_info: typing.Optional[str] = None,
        external_id: typing.Optional[str] = None,
        custom: typing.Optional["CustomFieldsDraft"] = None
    ):
        self.custom = custom

        super().__init__(
            id=id,
            key=key,
            country=country,
            title=title,
            salutation=salutation,
            first_name=first_name,
            last_name=last_name,
            street_name=street_name,
            street_number=street_number,
            additional_street_info=additional_street_info,
            postal_code=postal_code,
            city=city,
            region=region,
            state=state,
            company=company,
            department=department,
            building=building,
            apartment=apartment,
            p_o_box=p_o_box,
            phone=phone,
            mobile=mobile,
            email=email,
            fax=fax,
            additional_address_info=additional_address_info,
            external_id=external_id,
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "AddressDraft":
        from ._schemas.common import AddressDraftSchema

        return AddressDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import AddressDraftSchema

        return AddressDraftSchema().dump(self)


class BaseResource(_BaseType):
    id: str
    version: int
    created_at: datetime.datetime
    last_modified_at: datetime.datetime

    def __init__(
        self,
        *,
        id: str,
        version: int,
        created_at: datetime.datetime,
        last_modified_at: datetime.datetime
    ):
        self.id = id
        self.version = version
        self.created_at = created_at
        self.last_modified_at = last_modified_at

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "BaseResource":
        from ._schemas.common import BaseResourceSchema

        return BaseResourceSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import BaseResourceSchema

        return BaseResourceSchema().dump(self)


class ClientLogging(_BaseType):
    """These objects represent information about which [API Client](/../api/projects/api-clients) created or modified a resource. For more information, see [Client Logging](/../api/general-concepts#client-logging)."""

    #: `id` of the [API Client](ctp:api:type:ApiClient) which created the resource.
    client_id: typing.Optional[str]
    #: [External user ID](/../api/general-concepts#external-user-ids) provided by `X-External-User-ID` HTTP Header.
    external_user_id: typing.Optional[str]
    #: Indicates the [Customer](ctp:api:type:Customer) who modified the resource using a token from the [password flow](/authorization#password-flow).
    customer: typing.Optional["CustomerReference"]
    #: Indicates that the resource was modified during an [anonymous session](ctp:api:type:AnonymousSession) with the logged ID.
    anonymous_id: typing.Optional[str]
    #: Indicates the [Customer](ctp:api:type:Customer) who created or modified the resource in the context of a [Business Unit](ctp:api:type:BusinessUnit). Only present when an Associate acts on behalf of a company using the [associate endpoints](/associates-overview#on-the-associate-endpoints).
    associate: typing.Optional["CustomerReference"]

    def __init__(
        self,
        *,
        client_id: typing.Optional[str] = None,
        external_user_id: typing.Optional[str] = None,
        customer: typing.Optional["CustomerReference"] = None,
        anonymous_id: typing.Optional[str] = None,
        associate: typing.Optional["CustomerReference"] = None
    ):
        self.client_id = client_id
        self.external_user_id = external_user_id
        self.customer = customer
        self.anonymous_id = anonymous_id
        self.associate = associate

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ClientLogging":
        from ._schemas.common import ClientLoggingSchema

        return ClientLoggingSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import ClientLoggingSchema

        return ClientLoggingSchema().dump(self)


class CreatedBy(ClientLogging):
    """Present on resources created after 1 February 2019 except for [events not tracked](/../api/general-concepts#events-tracked)."""

    def __init__(
        self,
        *,
        client_id: typing.Optional[str] = None,
        external_user_id: typing.Optional[str] = None,
        customer: typing.Optional["CustomerReference"] = None,
        anonymous_id: typing.Optional[str] = None,
        associate: typing.Optional["CustomerReference"] = None
    ):

        super().__init__(
            client_id=client_id,
            external_user_id=external_user_id,
            customer=customer,
            anonymous_id=anonymous_id,
            associate=associate,
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CreatedBy":
        from ._schemas.common import CreatedBySchema

        return CreatedBySchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import CreatedBySchema

        return CreatedBySchema().dump(self)


class DiscountedPrice(_BaseType):
    #: Money value of the discounted price.
    value: "TypedMoney"
    #: [ProductDiscount](ctp:api:type:ProductDiscount) related to the discounted price.
    discount: "ProductDiscountReference"

    def __init__(self, *, value: "TypedMoney", discount: "ProductDiscountReference"):
        self.value = value
        self.discount = discount

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "DiscountedPrice":
        from ._schemas.common import DiscountedPriceSchema

        return DiscountedPriceSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import DiscountedPriceSchema

        return DiscountedPriceSchema().dump(self)


class DiscountedPriceDraft(_BaseType):
    #: Sets the money value for the discounted price.
    value: "Money"
    #: Relates the referenced [ProductDiscount](ctp:api:type:ProductDiscount) to the discounted price.
    discount: "ProductDiscountReference"

    def __init__(self, *, value: "Money", discount: "ProductDiscountReference"):
        self.value = value
        self.discount = discount

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "DiscountedPriceDraft":
        from ._schemas.common import DiscountedPriceDraftSchema

        return DiscountedPriceDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import DiscountedPriceDraftSchema

        return DiscountedPriceDraftSchema().dump(self)


class GeoJson(_BaseType):
    """GeoJSON Geometry represents a [Geometry Object](https://datatracker.ietf.org/doc/html/rfc7946#section-3.1) as defined in the GeoJSON standard."""

    type: str

    def __init__(self, *, type: str):
        self.type = type

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "GeoJson":
        if data["type"] == "Point":
            from ._schemas.common import GeoJsonPointSchema

            return GeoJsonPointSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import GeoJsonSchema

        return GeoJsonSchema().dump(self)


class GeoJsonPoint(GeoJson):
    #: Longitude (stored on index `[0]`) and latitude (stored on index `[1]`) of the [Point](https://datatracker.ietf.org/doc/html/rfc7946#section-3.1.2).
    coordinates: typing.List["float"]

    def __init__(self, *, coordinates: typing.List["float"]):
        self.coordinates = coordinates

        super().__init__(type="Point")

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "GeoJsonPoint":
        from ._schemas.common import GeoJsonPointSchema

        return GeoJsonPointSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import GeoJsonPointSchema

        return GeoJsonPointSchema().dump(self)


class Image(_BaseType):
    #: URL of the image in its original size that must be unique within a single [ProductVariant](ctp:api:type:ProductVariant). If the Project is hosted in the China (AWS, Ningxia) Region, verify that the URL is not blocked due to firewall restrictions.
    url: str
    #: Dimensions of the original image.
    dimensions: "ImageDimensions"
    #: Custom label for the image.
    label: typing.Optional[str]

    def __init__(
        self,
        *,
        url: str,
        dimensions: "ImageDimensions",
        label: typing.Optional[str] = None
    ):
        self.url = url
        self.dimensions = dimensions
        self.label = label

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "Image":
        from ._schemas.common import ImageSchema

        return ImageSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import ImageSchema

        return ImageSchema().dump(self)


class ImageDimensions(_BaseType):
    #: Width of the image.
    w: int
    #: Height of the image.
    h: int

    def __init__(self, *, w: int, h: int):
        self.w = w
        self.h = h

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ImageDimensions":
        from ._schemas.common import ImageDimensionsSchema

        return ImageDimensionsSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import ImageDimensionsSchema

        return ImageDimensionsSchema().dump(self)


class KeyReference(_BaseType):
    """A KeyReference represents a loose reference to another resource in the same Project identified by the resource's `key` field. If available, the `key` is immutable and mandatory. KeyReferences do not support [Reference Expansion](/general-concepts#reference-expansion)."""

    #: Type of referenced resource.
    type_id: "ReferenceTypeId"
    #: User-defined unique and immutable key of the referenced resource.
    key: str

    def __init__(self, *, type_id: "ReferenceTypeId", key: str):
        self.type_id = type_id
        self.key = key

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "KeyReference":
        if data["typeId"] == "associate-role":
            from ._schemas.associate_role import AssociateRoleKeyReferenceSchema

            return AssociateRoleKeyReferenceSchema().load(data)
        if data["typeId"] == "business-unit":
            from ._schemas.business_unit import BusinessUnitKeyReferenceSchema

            return BusinessUnitKeyReferenceSchema().load(data)
        if data["typeId"] == "store":
            from ._schemas.store import StoreKeyReferenceSchema

            return StoreKeyReferenceSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import KeyReferenceSchema

        return KeyReferenceSchema().dump(self)


class LastModifiedBy(ClientLogging):
    """Present on resources modified after 1 February 2019 except for [events not tracked](/../api/general-concepts#events-tracked)."""

    def __init__(
        self,
        *,
        client_id: typing.Optional[str] = None,
        external_user_id: typing.Optional[str] = None,
        customer: typing.Optional["CustomerReference"] = None,
        anonymous_id: typing.Optional[str] = None,
        associate: typing.Optional["CustomerReference"] = None
    ):

        super().__init__(
            client_id=client_id,
            external_user_id=external_user_id,
            customer=customer,
            anonymous_id=anonymous_id,
            associate=associate,
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "LastModifiedBy":
        from ._schemas.common import LastModifiedBySchema

        return LastModifiedBySchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import LastModifiedBySchema

        return LastModifiedBySchema().dump(self)


class LocalizedString(typing.Dict[str, str]):
    pass


class Money(_BaseType):
    """Draft type that stores amounts only in cent precision for the specified currency."""

    #: Amount in the smallest indivisible unit of a currency, such as:
    #:
    #: * Cents for EUR and USD, pence for GBP, or centime for CHF (5 CHF is specified as `500`).
    #: * The value in the major unit for currencies without minor units, like JPY (5 JPY is specified as `5`).
    cent_amount: int
    #: Currency code compliant to [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217).
    currency_code: str

    def __init__(self, *, cent_amount: int, currency_code: str):
        self.cent_amount = cent_amount
        self.currency_code = currency_code

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "Money":
        from ._schemas.common import MoneySchema

        return MoneySchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import MoneySchema

        return MoneySchema().dump(self)


class MoneyType(enum.Enum):
    """Determines the type of money used."""

    CENT_PRECISION = "centPrecision"
    HIGH_PRECISION = "highPrecision"


class Price(_BaseType):
    """The representation for prices embedded in [LineItems](ctp:api:type:LineItem) and in [ProductVariants](ctp:api:type:ProductVariant) when the [ProductPriceMode](ctp:api:type:ProductPriceModeEnum) is `Embedded`.
    For the `Standalone` ProductPriceMode refer to [StandalonePrice](ctp:api:type:StandalonePrice).
    """

    #: Unique identifier of this Price.
    id: str
    #: User-defined identifier of the Price. It is unique per [ProductVariant](ctp:api:type:ProductVariant).
    key: typing.Optional[str]
    #: Money value of this Price.
    value: "TypedMoney"
    #: Country for which this Price is valid.
    country: typing.Optional[str]
    #: [CustomerGroup](ctp:api:type:CustomerGroup) for which this Price is valid.
    customer_group: typing.Optional["CustomerGroupReference"]
    #: `ProductDistribution` [Channel](ctp:api:type:Channel) for which this Price is valid.
    channel: typing.Optional["ChannelReference"]
    #: Date and time from which this Price is valid.
    valid_from: typing.Optional[datetime.datetime]
    #: Date and time until this Price is valid. Prices that are no longer valid are not automatically removed, but they can be [removed](ctp:api:type:ProductRemovePriceAction) if necessary.
    valid_until: typing.Optional[datetime.datetime]
    #: Is set if a [ProductDiscount](ctp:api:type:ProductDiscount) has been applied.
    #: If set, the API uses the DiscountedPrice value for the [Line Item Price selection](ctp:api:type:LineItemPriceSelection).
    #: When a [relative discount](ctp:api:type:ProductDiscountValueRelative) has been applied and the fraction part of the DiscountedPrice `value` is 0.5, the `value` is rounded in favor of the customer with [half-down rounding](https://en.wikipedia.org/wiki/Rounding#Round_half_down).
    discounted: typing.Optional["DiscountedPrice"]
    #: Present if different Prices for certain [LineItem](ctp:api:type:LineItem) quantities have been specified.
    #:
    #: If `discounted` is present, the tiered Price is ignored for a Product Variant.
    tiers: typing.Optional[typing.List["PriceTier"]]
    #: Custom Fields defined for the Price.
    custom: typing.Optional["CustomFields"]

    def __init__(
        self,
        *,
        id: str,
        key: typing.Optional[str] = None,
        value: "TypedMoney",
        country: typing.Optional[str] = None,
        customer_group: typing.Optional["CustomerGroupReference"] = None,
        channel: typing.Optional["ChannelReference"] = None,
        valid_from: typing.Optional[datetime.datetime] = None,
        valid_until: typing.Optional[datetime.datetime] = None,
        discounted: typing.Optional["DiscountedPrice"] = None,
        tiers: typing.Optional[typing.List["PriceTier"]] = None,
        custom: typing.Optional["CustomFields"] = None
    ):
        self.id = id
        self.key = key
        self.value = value
        self.country = country
        self.customer_group = customer_group
        self.channel = channel
        self.valid_from = valid_from
        self.valid_until = valid_until
        self.discounted = discounted
        self.tiers = tiers
        self.custom = custom

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "Price":
        from ._schemas.common import PriceSchema

        return PriceSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import PriceSchema

        return PriceSchema().dump(self)


class PriceDraft(_BaseType):
    """The draft representation for prices to be embedded into [ProductVariantDrafts](ctp:api:type:ProductVariantDraft) when the [ProductPriceMode](ctp:api:type:ProductPriceModeEnum) is `Embedded`. For the `Standalone` ProductPriceMode use [StandalonePriceDraft](ctp:api:type:StandalonePriceDraft)."""

    #: User-defined identifier for the Price. It must be unique per [ProductVariant](ctp:api:type:ProductVariant).
    key: typing.Optional[str]
    #: Money value of this Price.
    value: "Money"
    #: Set this field if this Price is only valid for the specified country.
    country: typing.Optional[str]
    #: Set this field if this Price is only valid for the referenced [CustomerGroup](ctp:api:type:CustomerGroup).
    customer_group: typing.Optional["CustomerGroupResourceIdentifier"]
    #: Set this field if this Price is only valid for the referenced `ProductDistribution` [Channel](ctp:api:type:Channel).
    channel: typing.Optional["ChannelResourceIdentifier"]
    #: Set this field if this Price is only valid from the specified date and time. Must be at least 1 ms earlier than `validUntil`.
    valid_from: typing.Optional[datetime.datetime]
    #: Set this field if this Price is only valid until the specified date and time. Must be at least 1 ms later than `validFrom`. Prices that are no longer valid are not automatically removed, but they can be [removed](ctp:api:type:ProductRemovePriceAction) if necessary.
    valid_until: typing.Optional[datetime.datetime]
    #: Set this field to add a DiscountedPrice from an **external service**.
    #:
    #: Otherwise, Composable Commerce sets this field automatically if at least one [ProductDiscount](ctp:api:type:ProductDiscount) applies.
    #: The DiscountedPrice must reference a ProductDiscount with:
    #:
    #: * The `isActive` flag set to `true`.
    #: * A [ProductDiscountValue](ctp:api:type:ProductDiscountValueExternal) of type `external`.
    #: * A `predicate` that matches the [ProductVariant](ctp:api:type:ProductVariant) the Price is referenced from.
    discounted: typing.Optional["DiscountedPriceDraft"]
    #: Set this field to specify different Prices for certain [LineItem](ctp:api:type:LineItem) quantities.
    #:
    #: If `discounted` is set, the tiered Price is ignored for a Product Variant.
    tiers: typing.Optional[typing.List["PriceTierDraft"]]
    #: Custom Fields for the Price.
    custom: typing.Optional["CustomFieldsDraft"]

    def __init__(
        self,
        *,
        key: typing.Optional[str] = None,
        value: "Money",
        country: typing.Optional[str] = None,
        customer_group: typing.Optional["CustomerGroupResourceIdentifier"] = None,
        channel: typing.Optional["ChannelResourceIdentifier"] = None,
        valid_from: typing.Optional[datetime.datetime] = None,
        valid_until: typing.Optional[datetime.datetime] = None,
        discounted: typing.Optional["DiscountedPriceDraft"] = None,
        tiers: typing.Optional[typing.List["PriceTierDraft"]] = None,
        custom: typing.Optional["CustomFieldsDraft"] = None
    ):
        self.key = key
        self.value = value
        self.country = country
        self.customer_group = customer_group
        self.channel = channel
        self.valid_from = valid_from
        self.valid_until = valid_until
        self.discounted = discounted
        self.tiers = tiers
        self.custom = custom

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "PriceDraft":
        from ._schemas.common import PriceDraftSchema

        return PriceDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import PriceDraftSchema

        return PriceDraftSchema().dump(self)


class PriceTier(_BaseType):
    """A Price tier is selected instead of the default Price when a certain quantity of the [ProductVariant](ctp:api:type:ProductVariant) is [added to a Cart](/projects/carts#add-lineitem) and ordered.
    _For example: the Price can be lower if more than 10 items are ordered._
    If no Price tier is found for the Order quantity, the base Price is used.
    A Price tier is applied for the entire quantity of a Product Variant put as [LineItem](/projects/carts#lineitem) in a Cart as soon as the minimum quantity for the Price tier is reached.
    The Price tier is applied per Line Item of the Product Variant. If, for example, the same Product Variant appears in the same Cart as several Line Items, (what can be achieved by different values of a Custom Field on the Line Items) for each Line Item the minimum quantity must be reached to get the Price tier.

    """

    #: Minimum quantity this Price tier is valid for.
    #:
    #: The minimum quantity is always greater than or equal to 2. The base Price is interpreted as valid for a minimum quantity equal to 1.
    #: A [Price](ctp:api:type:Price) or [StandalonePrice](ctp:api:type:StandalonePrice) cannot contain more than one tier with the same `minimumQuantity`.
    minimum_quantity: int
    #: Money value that applies when the `minimumQuantity` is greater than or equal to the [LineItem](ctp:api:type:LineItem) `quantity`.
    #:
    #: The `currencyCode` of a Price tier is always the same as the `currencyCode` in the `value` of the related Price.
    value: "TypedMoney"

    def __init__(self, *, minimum_quantity: int, value: "TypedMoney"):
        self.minimum_quantity = minimum_quantity
        self.value = value

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "PriceTier":
        from ._schemas.common import PriceTierSchema

        return PriceTierSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import PriceTierSchema

        return PriceTierSchema().dump(self)


class PriceTierDraft(_BaseType):
    """Specifies a Price tier that applies when the minimum quantity for the [LineItem](ctp:api:type:LineItem) of a ProductVariant with the related Price is reached in a Cart."""

    #: Minimum quantity this Price tier is valid for.
    #:
    #: The minimum quantity is always greater than or equal to 2. The base Price is interpreted as valid for a minimum quantity equal to 1.
    #: A [Price](ctp:api:type:Price) or [StandalonePrice](ctp:api:type:StandalonePrice) cannot contain more than one tier with the same `minimumQuantity`.
    #: In the case one of the constraint is not met an [InvalidField](ctp:api:type:InvalidFieldError) is returned.
    minimum_quantity: int
    #: Money value that applies when the `minimumQuantity` is greater than or equal to the [LineItem](ctp:api:type:LineItem) `quantity`.
    #:
    #: The `currencyCode` of a Price tier must be the same as the `currencyCode` in the `value` of the related Price.
    value: "Money"

    def __init__(self, *, minimum_quantity: int, value: "Money"):
        self.minimum_quantity = minimum_quantity
        self.value = value

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "PriceTierDraft":
        from ._schemas.common import PriceTierDraftSchema

        return PriceTierDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import PriceTierDraftSchema

        return PriceTierDraftSchema().dump(self)


class QueryPrice(_BaseType):
    #: Unique identifier of the given Price.
    id: typing.Optional[str]
    #: Money value of the given Price.
    value: "Money"
    #: Country for which the given Price is valid.
    country: typing.Optional[str]
    #: [CustomerGroup](ctp:api:type:CustomerGroup) for which the given Price is valid.
    customer_group: typing.Optional["CustomerGroupReference"]
    #: `ProductDistribution` [Channel](ctp:api:type:Channel) for which the given Price is valid.
    channel: typing.Optional["ChannelReference"]
    #: Date from which the given Price is valid.
    valid_from: typing.Optional[datetime.datetime]
    #: Date until which the given Price is valid.
    valid_until: typing.Optional[datetime.datetime]
    #: [DiscountedPrice](ctp:api:type:DiscountedPrice) you specify for the given Price.
    discounted: typing.Optional["DiscountedPriceDraft"]
    #: Custom Fields for the Price.
    custom: typing.Optional["CustomFields"]
    #: Price tier applied when the minimum quantity for the [LineItem](ctp:api:type:LineItem) of a ProductVariant with the related Price is reached in a Cart.
    #:
    #: If `discounted` is specified, the tiered Price is ignored for a Product Variant.
    tiers: typing.Optional[typing.List["PriceTierDraft"]]

    def __init__(
        self,
        *,
        id: typing.Optional[str] = None,
        value: "Money",
        country: typing.Optional[str] = None,
        customer_group: typing.Optional["CustomerGroupReference"] = None,
        channel: typing.Optional["ChannelReference"] = None,
        valid_from: typing.Optional[datetime.datetime] = None,
        valid_until: typing.Optional[datetime.datetime] = None,
        discounted: typing.Optional["DiscountedPriceDraft"] = None,
        custom: typing.Optional["CustomFields"] = None,
        tiers: typing.Optional[typing.List["PriceTierDraft"]] = None
    ):
        self.id = id
        self.value = value
        self.country = country
        self.customer_group = customer_group
        self.channel = channel
        self.valid_from = valid_from
        self.valid_until = valid_until
        self.discounted = discounted
        self.custom = custom
        self.tiers = tiers

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "QueryPrice":
        from ._schemas.common import QueryPriceSchema

        return QueryPriceSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import QueryPriceSchema

        return QueryPriceSchema().dump(self)


class Reference(_BaseType):
    """A Reference represents a loose reference to another resource in the same Project identified by its `id`. The `typeId` indicates the type of the referenced resource. Each resource type has its corresponding Reference type, like [ChannelReference](ctp:api:type:ChannelReference).  A referenced resource can be embedded through [Reference Expansion](/general-concepts#reference-expansion). The expanded reference is the value of an additional `obj` field then."""

    #: Type of referenced resource.
    type_id: "ReferenceTypeId"
    #: Unique ID of the referenced resource.
    id: str

    def __init__(self, *, type_id: "ReferenceTypeId", id: str):
        self.type_id = type_id
        self.id = id

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "Reference":
        if data["typeId"] == "associate-role":
            from ._schemas.associate_role import AssociateRoleReferenceSchema

            return AssociateRoleReferenceSchema().load(data)
        if data["typeId"] == "attribute-group":
            from ._schemas.attribute_group import AttributeGroupReferenceSchema

            return AttributeGroupReferenceSchema().load(data)
        if data["typeId"] == "business-unit":
            from ._schemas.business_unit import BusinessUnitReferenceSchema

            return BusinessUnitReferenceSchema().load(data)
        if data["typeId"] == "cart-discount":
            from ._schemas.cart_discount import CartDiscountReferenceSchema

            return CartDiscountReferenceSchema().load(data)
        if data["typeId"] == "cart":
            from ._schemas.cart import CartReferenceSchema

            return CartReferenceSchema().load(data)
        if data["typeId"] == "direct-discount":
            from ._schemas.cart import DirectDiscountReferenceSchema

            return DirectDiscountReferenceSchema().load(data)
        if data["typeId"] == "category":
            from ._schemas.category import CategoryReferenceSchema

            return CategoryReferenceSchema().load(data)
        if data["typeId"] == "channel":
            from ._schemas.channel import ChannelReferenceSchema

            return ChannelReferenceSchema().load(data)
        if data["typeId"] == "key-value-document":
            from ._schemas.custom_object import CustomObjectReferenceSchema

            return CustomObjectReferenceSchema().load(data)
        if data["typeId"] == "customer-group":
            from ._schemas.customer_group import CustomerGroupReferenceSchema

            return CustomerGroupReferenceSchema().load(data)
        if data["typeId"] == "customer-email-token":
            from ._schemas.customer import CustomerEmailTokenReferenceSchema

            return CustomerEmailTokenReferenceSchema().load(data)
        if data["typeId"] == "customer-password-token":
            from ._schemas.customer import CustomerPasswordTokenReferenceSchema

            return CustomerPasswordTokenReferenceSchema().load(data)
        if data["typeId"] == "customer":
            from ._schemas.customer import CustomerReferenceSchema

            return CustomerReferenceSchema().load(data)
        if data["typeId"] == "discount-code":
            from ._schemas.discount_code import DiscountCodeReferenceSchema

            return DiscountCodeReferenceSchema().load(data)
        if data["typeId"] == "inventory-entry":
            from ._schemas.inventory import InventoryEntryReferenceSchema

            return InventoryEntryReferenceSchema().load(data)
        if data["typeId"] == "order-edit":
            from ._schemas.order_edit import OrderEditReferenceSchema

            return OrderEditReferenceSchema().load(data)
        if data["typeId"] == "order":
            from ._schemas.order import OrderReferenceSchema

            return OrderReferenceSchema().load(data)
        if data["typeId"] == "payment":
            from ._schemas.payment import PaymentReferenceSchema

            return PaymentReferenceSchema().load(data)
        if data["typeId"] == "product-discount":
            from ._schemas.product_discount import ProductDiscountReferenceSchema

            return ProductDiscountReferenceSchema().load(data)
        if data["typeId"] == "product-selection":
            from ._schemas.product_selection import ProductSelectionReferenceSchema

            return ProductSelectionReferenceSchema().load(data)
        if data["typeId"] == "product-tailoring":
            from ._schemas.product_tailoring import ProductTailoringReferenceSchema

            return ProductTailoringReferenceSchema().load(data)
        if data["typeId"] == "product-type":
            from ._schemas.product_type import ProductTypeReferenceSchema

            return ProductTypeReferenceSchema().load(data)
        if data["typeId"] == "product":
            from ._schemas.product import ProductReferenceSchema

            return ProductReferenceSchema().load(data)
        if data["typeId"] == "quote-request":
            from ._schemas.quote_request import QuoteRequestReferenceSchema

            return QuoteRequestReferenceSchema().load(data)
        if data["typeId"] == "quote":
            from ._schemas.quote import QuoteReferenceSchema

            return QuoteReferenceSchema().load(data)
        if data["typeId"] == "review":
            from ._schemas.review import ReviewReferenceSchema

            return ReviewReferenceSchema().load(data)
        if data["typeId"] == "shipping-method":
            from ._schemas.shipping_method import ShippingMethodReferenceSchema

            return ShippingMethodReferenceSchema().load(data)
        if data["typeId"] == "shopping-list":
            from ._schemas.shopping_list import ShoppingListReferenceSchema

            return ShoppingListReferenceSchema().load(data)
        if data["typeId"] == "staged-quote":
            from ._schemas.staged_quote import StagedQuoteReferenceSchema

            return StagedQuoteReferenceSchema().load(data)
        if data["typeId"] == "standalone-price":
            from ._schemas.standalone_price import StandalonePriceReferenceSchema

            return StandalonePriceReferenceSchema().load(data)
        if data["typeId"] == "state":
            from ._schemas.state import StateReferenceSchema

            return StateReferenceSchema().load(data)
        if data["typeId"] == "store":
            from ._schemas.store import StoreReferenceSchema

            return StoreReferenceSchema().load(data)
        if data["typeId"] == "tax-category":
            from ._schemas.tax_category import TaxCategoryReferenceSchema

            return TaxCategoryReferenceSchema().load(data)
        if data["typeId"] == "type":
            from ._schemas.type import TypeReferenceSchema

            return TypeReferenceSchema().load(data)
        if data["typeId"] == "zone":
            from ._schemas.zone import ZoneReferenceSchema

            return ZoneReferenceSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import ReferenceSchema

        return ReferenceSchema().dump(self)


class ReferenceTypeId(enum.Enum):
    """Type of resource the value should reference. Supported resource type identifiers are:"""

    APPROVAL_FLOW = "approval-flow"
    APPROVAL_RULE = "approval-rule"
    ASSOCIATE_ROLE = "associate-role"
    ATTRIBUTE_GROUP = "attribute-group"
    BUSINESS_UNIT = "business-unit"
    CART = "cart"
    CART_DISCOUNT = "cart-discount"
    CATEGORY = "category"
    CHANNEL = "channel"
    CUSTOMER = "customer"
    CUSTOMER_EMAIL_TOKEN = "customer-email-token"
    CUSTOMER_GROUP = "customer-group"
    CUSTOMER_PASSWORD_TOKEN = "customer-password-token"
    DIRECT_DISCOUNT = "direct-discount"
    DISCOUNT_CODE = "discount-code"
    EXTENSION = "extension"
    INVENTORY_ENTRY = "inventory-entry"
    KEY_VALUE_DOCUMENT = "key-value-document"
    ORDER = "order"
    ORDER_EDIT = "order-edit"
    PAYMENT = "payment"
    PRODUCT = "product"
    PRODUCT_DISCOUNT = "product-discount"
    PRODUCT_PRICE = "product-price"
    PRODUCT_SELECTION = "product-selection"
    PRODUCT_TAILORING = "product-tailoring"
    PRODUCT_TYPE = "product-type"
    QUOTE = "quote"
    QUOTE_REQUEST = "quote-request"
    REVIEW = "review"
    SHIPPING_METHOD = "shipping-method"
    SHOPPING_LIST = "shopping-list"
    STAGED_QUOTE = "staged-quote"
    STANDALONE_PRICE = "standalone-price"
    STATE = "state"
    STORE = "store"
    SUBSCRIPTION = "subscription"
    TAX_CATEGORY = "tax-category"
    TYPE = "type"
    ZONE = "zone"


class ResourceIdentifier(_BaseType):
    """Draft type to create a [Reference](ctp:api:type:Reference) or a [KeyReference](ctp:api:type:KeyReference) to a resource. Provide either the `id` or (wherever supported) the `key` of the resource to reference, but depending on the API endpoint the response returns either a Reference or a KeyReference. For example, the field `parent` of a [CategoryDraft](ctp:api:type:CategoryDraft) takes a ResourceIdentifier for its value while the value of the corresponding field of a [Category](ctp:api:type:Category) is a Reference.

    Each resource type has its corresponding ResourceIdentifier, like [ChannelResourceIdentifier](ctp:api:type:ChannelResourceIdentifier).

    """

    #: Type of referenced resource. If given, it must match the expected [ReferenceTypeId](ctp:api:type:ReferenceTypeId) of the referenced resource.
    type_id: typing.Optional["ReferenceTypeId"]
    #: Unique identifier of the referenced resource. Required if `key` is absent.
    id: typing.Optional[str]
    #: User-defined unique identifier of the referenced resource. Required if `id` is absent.
    key: typing.Optional[str]

    def __init__(
        self,
        *,
        type_id: typing.Optional["ReferenceTypeId"] = None,
        id: typing.Optional[str] = None,
        key: typing.Optional[str] = None
    ):
        self.type_id = type_id
        self.id = id
        self.key = key

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ResourceIdentifier":
        if data["typeId"] == "associate-role":
            from ._schemas.associate_role import AssociateRoleResourceIdentifierSchema

            return AssociateRoleResourceIdentifierSchema().load(data)
        if data["typeId"] == "attribute-group":
            from ._schemas.attribute_group import AttributeGroupResourceIdentifierSchema

            return AttributeGroupResourceIdentifierSchema().load(data)
        if data["typeId"] == "business-unit":
            from ._schemas.business_unit import BusinessUnitResourceIdentifierSchema

            return BusinessUnitResourceIdentifierSchema().load(data)
        if data["typeId"] == "cart-discount":
            from ._schemas.cart_discount import CartDiscountResourceIdentifierSchema

            return CartDiscountResourceIdentifierSchema().load(data)
        if data["typeId"] == "cart":
            from ._schemas.cart import CartResourceIdentifierSchema

            return CartResourceIdentifierSchema().load(data)
        if data["typeId"] == "category":
            from ._schemas.category import CategoryResourceIdentifierSchema

            return CategoryResourceIdentifierSchema().load(data)
        if data["typeId"] == "channel":
            from ._schemas.channel import ChannelResourceIdentifierSchema

            return ChannelResourceIdentifierSchema().load(data)
        if data["typeId"] == "customer-group":
            from ._schemas.customer_group import CustomerGroupResourceIdentifierSchema

            return CustomerGroupResourceIdentifierSchema().load(data)
        if data["typeId"] == "customer":
            from ._schemas.customer import CustomerResourceIdentifierSchema

            return CustomerResourceIdentifierSchema().load(data)
        if data["typeId"] == "discount-code":
            from ._schemas.discount_code import DiscountCodeResourceIdentifierSchema

            return DiscountCodeResourceIdentifierSchema().load(data)
        if data["typeId"] == "inventory-entry":
            from ._schemas.inventory import InventoryEntryResourceIdentifierSchema

            return InventoryEntryResourceIdentifierSchema().load(data)
        if data["typeId"] == "order-edit":
            from ._schemas.order_edit import OrderEditResourceIdentifierSchema

            return OrderEditResourceIdentifierSchema().load(data)
        if data["typeId"] == "payment":
            from ._schemas.payment import PaymentResourceIdentifierSchema

            return PaymentResourceIdentifierSchema().load(data)
        if data["typeId"] == "product-discount":
            from ._schemas.product_discount import (
                ProductDiscountResourceIdentifierSchema,
            )

            return ProductDiscountResourceIdentifierSchema().load(data)
        if data["typeId"] == "product-selection":
            from ._schemas.product_selection import (
                ProductSelectionResourceIdentifierSchema,
            )

            return ProductSelectionResourceIdentifierSchema().load(data)
        if data["typeId"] == "product-tailoring":
            from ._schemas.product_tailoring import (
                ProductTailoringResourceIdentifierSchema,
            )

            return ProductTailoringResourceIdentifierSchema().load(data)
        if data["typeId"] == "product-type":
            from ._schemas.product_type import ProductTypeResourceIdentifierSchema

            return ProductTypeResourceIdentifierSchema().load(data)
        if data["typeId"] == "product":
            from ._schemas.product import ProductResourceIdentifierSchema

            return ProductResourceIdentifierSchema().load(data)
        if data["typeId"] == "quote-request":
            from ._schemas.quote_request import QuoteRequestResourceIdentifierSchema

            return QuoteRequestResourceIdentifierSchema().load(data)
        if data["typeId"] == "quote":
            from ._schemas.quote import QuoteResourceIdentifierSchema

            return QuoteResourceIdentifierSchema().load(data)
        if data["typeId"] == "review":
            from ._schemas.review import ReviewResourceIdentifierSchema

            return ReviewResourceIdentifierSchema().load(data)
        if data["typeId"] == "shipping-method":
            from ._schemas.shipping_method import ShippingMethodResourceIdentifierSchema

            return ShippingMethodResourceIdentifierSchema().load(data)
        if data["typeId"] == "shopping-list":
            from ._schemas.shopping_list import ShoppingListResourceIdentifierSchema

            return ShoppingListResourceIdentifierSchema().load(data)
        if data["typeId"] == "staged-quote":
            from ._schemas.staged_quote import StagedQuoteResourceIdentifierSchema

            return StagedQuoteResourceIdentifierSchema().load(data)
        if data["typeId"] == "standalone-price":
            from ._schemas.standalone_price import (
                StandalonePriceResourceIdentifierSchema,
            )

            return StandalonePriceResourceIdentifierSchema().load(data)
        if data["typeId"] == "state":
            from ._schemas.state import StateResourceIdentifierSchema

            return StateResourceIdentifierSchema().load(data)
        if data["typeId"] == "store":
            from ._schemas.store import StoreResourceIdentifierSchema

            return StoreResourceIdentifierSchema().load(data)
        if data["typeId"] == "tax-category":
            from ._schemas.tax_category import TaxCategoryResourceIdentifierSchema

            return TaxCategoryResourceIdentifierSchema().load(data)
        if data["typeId"] == "type":
            from ._schemas.type import TypeResourceIdentifierSchema

            return TypeResourceIdentifierSchema().load(data)
        if data["typeId"] == "zone":
            from ._schemas.zone import ZoneResourceIdentifierSchema

            return ZoneResourceIdentifierSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import ResourceIdentifierSchema

        return ResourceIdentifierSchema().dump(self)


class ScopedPrice(_BaseType):
    """Scoped Price is contained in a [ProductVariant](ctp:api:type:ProductVariant) which is returned in response to a
    [Product Projection Search](ctp:api:type:ProductProjectionSearchFilterScopedPrice) request when [Scoped Price Search](ctp:api:type:ScopedPriceSearch) is used.

    """

    #: Platform-generated unique identifier of the Price.
    id: str
    #: Original value of the Price.
    value: "TypedMoney"
    #: If available, either the original price `value` or `discounted` value.
    current_value: "TypedMoney"
    #: Country code of the geographic location.
    country: typing.Optional[str]
    #: Reference to a CustomerGroup.
    customer_group: typing.Optional["CustomerGroupReference"]
    #: Reference to a Channel.
    channel: typing.Optional["ChannelReference"]
    #: Date and time from which the Price is valid.
    valid_from: typing.Optional[datetime.datetime]
    #: Date and time until which the Price is valid.
    valid_until: typing.Optional[datetime.datetime]
    #: Is set when a matching [ProductDiscount](ctp:api:type:ProductDiscount) exists. If set, the [Cart](ctp:api:type:Cart) uses the discounted value for the [Cart Price calculation](ctp:api:type:CartAddLineItemAction).
    #:
    #: When a [relative Product Discount](ctp:api:type:ProductDiscountValueRelative) is applied and the fractional part of the discounted Price is 0.5, the discounted Price is [rounded half down](https://en.wikipedia.org/wiki/Rounding#Round_half_down) in favor of the Customer.
    discounted: typing.Optional["DiscountedPrice"]
    #: Custom Fields for the Price.
    custom: typing.Optional["CustomFields"]

    def __init__(
        self,
        *,
        id: str,
        value: "TypedMoney",
        current_value: "TypedMoney",
        country: typing.Optional[str] = None,
        customer_group: typing.Optional["CustomerGroupReference"] = None,
        channel: typing.Optional["ChannelReference"] = None,
        valid_from: typing.Optional[datetime.datetime] = None,
        valid_until: typing.Optional[datetime.datetime] = None,
        discounted: typing.Optional["DiscountedPrice"] = None,
        custom: typing.Optional["CustomFields"] = None
    ):
        self.id = id
        self.value = value
        self.current_value = current_value
        self.country = country
        self.customer_group = customer_group
        self.channel = channel
        self.valid_from = valid_from
        self.valid_until = valid_until
        self.discounted = discounted
        self.custom = custom

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ScopedPrice":
        from ._schemas.common import ScopedPriceSchema

        return ScopedPriceSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import ScopedPriceSchema

        return ScopedPriceSchema().dump(self)


class TypedMoney(Money):
    """Base polymorphic read-only money type that stores currency in cent precision or high precision, that is in sub-cents."""

    #: Type of money used.
    type: "MoneyType"
    #: Number of digits after the decimal separator.
    #:
    #: * For [CentPrecisionMoney](ctp:api:type:CentPrecisionMoney), it is equal to the default number of fraction digits for a currency.
    #: * For [HighPrecisionMoney](ctp:api:type:HighPrecisionMoney), it is greater than the default number of fraction digits for a currency.
    fraction_digits: int

    def __init__(
        self,
        *,
        cent_amount: int,
        currency_code: str,
        type: "MoneyType",
        fraction_digits: int
    ):
        self.type = type
        self.fraction_digits = fraction_digits

        super().__init__(cent_amount=cent_amount, currency_code=currency_code)

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "TypedMoney":
        if data["type"] == "centPrecision":
            from ._schemas.common import CentPrecisionMoneySchema

            return CentPrecisionMoneySchema().load(data)
        if data["type"] == "highPrecision":
            from ._schemas.common import HighPrecisionMoneySchema

            return HighPrecisionMoneySchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import TypedMoneySchema

        return TypedMoneySchema().dump(self)


class CentPrecisionMoney(TypedMoney):
    """Object that stores cent amounts in a specific currency."""

    def __init__(self, *, cent_amount: int, currency_code: str, fraction_digits: int):

        super().__init__(
            cent_amount=cent_amount,
            currency_code=currency_code,
            fraction_digits=fraction_digits,
            type=MoneyType.CENT_PRECISION,
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CentPrecisionMoney":
        from ._schemas.common import CentPrecisionMoneySchema

        return CentPrecisionMoneySchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import CentPrecisionMoneySchema

        return CentPrecisionMoneySchema().dump(self)


class HighPrecisionMoney(TypedMoney):
    """Money object that stores an amount of a fraction of the smallest indivisible unit of the specified currency."""

    #: Amount in 1 / (10 ^ `fractionDigits`) of a currency.
    precise_amount: int

    def __init__(
        self,
        *,
        cent_amount: int,
        currency_code: str,
        fraction_digits: int,
        precise_amount: int
    ):
        self.precise_amount = precise_amount

        super().__init__(
            cent_amount=cent_amount,
            currency_code=currency_code,
            fraction_digits=fraction_digits,
            type=MoneyType.HIGH_PRECISION,
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "HighPrecisionMoney":
        from ._schemas.common import HighPrecisionMoneySchema

        return HighPrecisionMoneySchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import HighPrecisionMoneySchema

        return HighPrecisionMoneySchema().dump(self)


class TypedMoneyDraft(Money):
    """Base polymorphic money type containing common fields for [Money](ctp:api:type:Money) and [HighPrecisionMoneyDraft](ctp:api:type:HighPrecisionMoneyDraft).

    - To set money in cent precision, use [Money](ctp:api:type:Money).
    - To set money in high precision, use [HighPrecisionMoneyDraft](ctp:api:type:HighPrecisionMoneyDraft).

    """

    #: Determines the type of money used.
    type: typing.Optional["MoneyType"]
    #: Number of fraction digits for a specified money.
    fraction_digits: typing.Optional[int]

    def __init__(
        self,
        *,
        cent_amount: typing.Optional[int] = None,
        currency_code: str,
        type: typing.Optional["MoneyType"] = None,
        fraction_digits: typing.Optional[int] = None
    ):
        self.type = type
        self.fraction_digits = fraction_digits

        super().__init__(cent_amount=cent_amount, currency_code=currency_code)

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "TypedMoneyDraft":
        if data["type"] == "centPrecision":
            from ._schemas.common import CentPrecisionMoneyDraftSchema

            return CentPrecisionMoneyDraftSchema().load(data)
        if data["type"] == "highPrecision":
            from ._schemas.common import HighPrecisionMoneyDraftSchema

            return HighPrecisionMoneyDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import TypedMoneyDraftSchema

        return TypedMoneyDraftSchema().dump(self)


class CentPrecisionMoneyDraft(TypedMoneyDraft):
    """This draft type is the alternative to [Money](ctp:api:type:Money)."""

    def __init__(
        self,
        *,
        cent_amount: typing.Optional[int] = None,
        currency_code: str,
        fraction_digits: typing.Optional[int] = None
    ):

        super().__init__(
            cent_amount=cent_amount,
            currency_code=currency_code,
            fraction_digits=fraction_digits,
            type=MoneyType.CENT_PRECISION,
        )

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CentPrecisionMoneyDraft":
        from ._schemas.common import CentPrecisionMoneyDraftSchema

        return CentPrecisionMoneyDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import CentPrecisionMoneyDraftSchema

        return CentPrecisionMoneyDraftSchema().dump(self)


class HighPrecisionMoneyDraft(TypedMoneyDraft):
    """Money draft object to store an amount of a fraction of the smallest indivisible unit of the specified currency."""

    #: Amount in 1 / (10 ^ `fractionDigits`) of a currency.
    precise_amount: int

    def __init__(
        self,
        *,
        cent_amount: typing.Optional[int] = None,
        currency_code: str,
        fraction_digits: int,
        precise_amount: int
    ):
        self.precise_amount = precise_amount

        super().__init__(
            cent_amount=cent_amount,
            currency_code=currency_code,
            fraction_digits=fraction_digits,
            type=MoneyType.HIGH_PRECISION,
        )

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "HighPrecisionMoneyDraft":
        from ._schemas.common import HighPrecisionMoneyDraftSchema

        return HighPrecisionMoneyDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.common import HighPrecisionMoneyDraftSchema

        return HighPrecisionMoneyDraftSchema().dump(self)
