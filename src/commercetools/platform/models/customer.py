# This file is automatically generated by the rmf-codegen project.
#
# The Python code generator is maintained by Lab Digital. If you want to
# contribute to this project then please do not edit this file directly
# but send a pull request to the Lab Digital fork of rmf-codegen at
# https://github.com/labd/rmf-codegen

import datetime
import enum
import typing

from ._abstract import _BaseType
from .common import BaseResource, Reference, ReferenceTypeId, ResourceIdentifier

if typing.TYPE_CHECKING:
    from .cart import Cart, CartResourceIdentifier
    from .common import Address, BaseAddress, CreatedBy, LastModifiedBy, ReferenceTypeId
    from .customer_group import CustomerGroupReference, CustomerGroupResourceIdentifier
    from .store import StoreKeyReference, StoreResourceIdentifier
    from .type import (
        CustomFields,
        CustomFieldsDraft,
        FieldContainer,
        TypeResourceIdentifier,
    )

__all__ = [
    "AnonymousCartSignInMode",
    "AuthenticationMode",
    "Customer",
    "CustomerAddAddressAction",
    "CustomerAddBillingAddressIdAction",
    "CustomerAddShippingAddressIdAction",
    "CustomerAddStoreAction",
    "CustomerChangeAddressAction",
    "CustomerChangeEmailAction",
    "CustomerChangePassword",
    "CustomerCreateEmailToken",
    "CustomerCreatePasswordResetToken",
    "CustomerDraft",
    "CustomerEmailTokenReference",
    "CustomerEmailVerify",
    "CustomerPagedQueryResponse",
    "CustomerPasswordTokenReference",
    "CustomerReference",
    "CustomerRemoveAddressAction",
    "CustomerRemoveBillingAddressIdAction",
    "CustomerRemoveShippingAddressIdAction",
    "CustomerRemoveStoreAction",
    "CustomerResetPassword",
    "CustomerResourceIdentifier",
    "CustomerSetAddressCustomFieldAction",
    "CustomerSetAddressCustomTypeAction",
    "CustomerSetAuthenticationModeAction",
    "CustomerSetCompanyNameAction",
    "CustomerSetCustomFieldAction",
    "CustomerSetCustomTypeAction",
    "CustomerSetCustomerGroupAction",
    "CustomerSetCustomerNumberAction",
    "CustomerSetDateOfBirthAction",
    "CustomerSetDefaultBillingAddressAction",
    "CustomerSetDefaultShippingAddressAction",
    "CustomerSetExternalIdAction",
    "CustomerSetFirstNameAction",
    "CustomerSetKeyAction",
    "CustomerSetLastNameAction",
    "CustomerSetLocaleAction",
    "CustomerSetMiddleNameAction",
    "CustomerSetSalutationAction",
    "CustomerSetStoresAction",
    "CustomerSetTitleAction",
    "CustomerSetVatIdAction",
    "CustomerSignInResult",
    "CustomerSignin",
    "CustomerToken",
    "CustomerUpdate",
    "CustomerUpdateAction",
    "MyCustomerChangePassword",
    "MyCustomerEmailVerify",
    "MyCustomerResetPassword",
    "MyCustomerSignin",
]


class AnonymousCartSignInMode(enum.Enum):
    MERGE_WITH_EXISTING_CUSTOMER_CART = "MergeWithExistingCustomerCart"
    USE_AS_NEW_ACTIVE_CUSTOMER_CART = "UseAsNewActiveCustomerCart"


class AuthenticationMode(enum.Enum):
    PASSWORD = "Password"
    EXTERNAL_AUTH = "ExternalAuth"


class Customer(BaseResource):
    """If `stores` is not empty, the Customer is specific to those Stores."""

    #: User-defined unique identifier of the Customer.
    key: typing.Optional[str]
    #: User-defined unique identifier of the Customer.
    #:
    #: Can be used to refer to a Customer in a human-readable way (in emails, invoices, and other correspondence).
    customer_number: typing.Optional[str]
    #: Optional identifier for use in external systems like customer relationship management (CRM) or enterprise resource planning (ERP).
    external_id: typing.Optional[str]
    #: Present on resources created after 1 February 2019 except for [events not tracked](/../api/general-concepts#events-tracked).
    last_modified_by: typing.Optional["LastModifiedBy"]
    #: Present on resources created after 1 February 2019 except for [events not tracked](/../api/general-concepts#events-tracked).
    created_by: typing.Optional["CreatedBy"]
    #: Email address of the Customer that is [unique](/../api/customers-overview#customer-uniqueness) for an entire Project or to a Store the Customer is assigned to.
    #: It is the mandatory unique identifier of a Customer.
    email: str
    #: Present only when `authenticationMode` is set to `Password`.
    password: typing.Optional[str]
    #: Given name (first name) of the Customer.
    first_name: typing.Optional[str]
    #: Family name (last name) of the Customer.
    last_name: typing.Optional[str]
    #: Middle name of the Customer.
    middle_name: typing.Optional[str]
    #: Title of the Customer, for example, 'Dr.'.
    title: typing.Optional[str]
    #: Date of birth of the Customer.
    date_of_birth: typing.Optional[datetime.date]
    #: Company name of the Customer.
    company_name: typing.Optional[str]
    #: Individual VAT ID of the Customer.
    vat_id: typing.Optional[str]
    #: Addresses used by the Customer.
    addresses: typing.List["Address"]
    #: ID of the address in `addresses` used as the default shipping address.
    default_shipping_address_id: typing.Optional[str]
    #: IDs of addresses in `addresses` used as shipping addresses.
    shipping_address_ids: typing.Optional[typing.List["str"]]
    #: ID of the address in `addresses` used as the default billing address.
    default_billing_address_id: typing.Optional[str]
    #: IDs of addresses in `addresses` used as billing addresses.
    billing_address_ids: typing.Optional[typing.List["str"]]
    #: Indicates whether the email address of the Customer is [verified](#email-verification-of-customer).
    is_email_verified: bool
    #: [CustomerGroup](ctp:api:type:CustomerGroup) to which the Customer belongs.
    customer_group: typing.Optional["CustomerGroupReference"]
    #: Custom Fields for the Customer.
    custom: typing.Optional["CustomFields"]
    #: Preferred language of the Customer.
    locale: typing.Optional[str]
    #: Salutation of the Customer, for example, 'Mr.' or 'Mrs.'.
    salutation: typing.Optional[str]
    #: [Stores](ctp:api:type:Store) to which the Customer is assigned to.
    #:
    #: - If no Stores are specified, the Customer is a global customer, and can log in using the [Password Flow for global Customers](/../api/authorization#password-flow-for-global-customers).
    #: - If any Stores are specified, the Customer can only log in using the [Password Flow for Customers in a Store](/../api/authorization#password-flow-for-customers-in-a-store) for those specific Stores.
    stores: typing.Optional[typing.List["StoreKeyReference"]]
    #: Indicates whether the `password` is required for the Customer.
    authentication_mode: "AuthenticationMode"

    def __init__(
        self,
        *,
        id: str,
        version: int,
        created_at: datetime.datetime,
        last_modified_at: datetime.datetime,
        key: typing.Optional[str] = None,
        customer_number: typing.Optional[str] = None,
        external_id: typing.Optional[str] = None,
        last_modified_by: typing.Optional["LastModifiedBy"] = None,
        created_by: typing.Optional["CreatedBy"] = None,
        email: str,
        password: typing.Optional[str] = None,
        first_name: typing.Optional[str] = None,
        last_name: typing.Optional[str] = None,
        middle_name: typing.Optional[str] = None,
        title: typing.Optional[str] = None,
        date_of_birth: typing.Optional[datetime.date] = None,
        company_name: typing.Optional[str] = None,
        vat_id: typing.Optional[str] = None,
        addresses: typing.List["Address"],
        default_shipping_address_id: typing.Optional[str] = None,
        shipping_address_ids: typing.Optional[typing.List["str"]] = None,
        default_billing_address_id: typing.Optional[str] = None,
        billing_address_ids: typing.Optional[typing.List["str"]] = None,
        is_email_verified: bool,
        customer_group: typing.Optional["CustomerGroupReference"] = None,
        custom: typing.Optional["CustomFields"] = None,
        locale: typing.Optional[str] = None,
        salutation: typing.Optional[str] = None,
        stores: typing.Optional[typing.List["StoreKeyReference"]] = None,
        authentication_mode: "AuthenticationMode"
    ):
        self.key = key
        self.customer_number = customer_number
        self.external_id = external_id
        self.last_modified_by = last_modified_by
        self.created_by = created_by
        self.email = email
        self.password = password
        self.first_name = first_name
        self.last_name = last_name
        self.middle_name = middle_name
        self.title = title
        self.date_of_birth = date_of_birth
        self.company_name = company_name
        self.vat_id = vat_id
        self.addresses = addresses
        self.default_shipping_address_id = default_shipping_address_id
        self.shipping_address_ids = shipping_address_ids
        self.default_billing_address_id = default_billing_address_id
        self.billing_address_ids = billing_address_ids
        self.is_email_verified = is_email_verified
        self.customer_group = customer_group
        self.custom = custom
        self.locale = locale
        self.salutation = salutation
        self.stores = stores
        self.authentication_mode = authentication_mode

        super().__init__(
            id=id,
            version=version,
            created_at=created_at,
            last_modified_at=last_modified_at,
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "Customer":
        from ._schemas.customer import CustomerSchema

        return CustomerSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.customer import CustomerSchema

        return CustomerSchema().dump(self)


class CustomerChangePassword(_BaseType):
    #: Unique identifier of the Customer.
    id: str
    #: Expected version of the Customer on which the changes should be applied.
    version: int
    #: Current password of the Customer.
    #:
    #: If the current password does not match, an [InvalidCurrentPassword](ctp:api:type:InvalidCurrentPasswordError) error is returned.
    current_password: str
    #: New password to be set.
    new_password: str

    def __init__(
        self, *, id: str, version: int, current_password: str, new_password: str
    ):
        self.id = id
        self.version = version
        self.current_password = current_password
        self.new_password = new_password

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CustomerChangePassword":
        from ._schemas.customer import CustomerChangePasswordSchema

        return CustomerChangePasswordSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.customer import CustomerChangePasswordSchema

        return CustomerChangePasswordSchema().dump(self)


class CustomerCreateEmailToken(_BaseType):
    #: Unique identifier of the Customer.
    id: str
    #: Expected version of the Customer.
    version: typing.Optional[int]
    #: Validity period of the generated token in minutes.
    ttl_minutes: int

    def __init__(
        self, *, id: str, version: typing.Optional[int] = None, ttl_minutes: int
    ):
        self.id = id
        self.version = version
        self.ttl_minutes = ttl_minutes

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CustomerCreateEmailToken":
        from ._schemas.customer import CustomerCreateEmailTokenSchema

        return CustomerCreateEmailTokenSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.customer import CustomerCreateEmailTokenSchema

        return CustomerCreateEmailTokenSchema().dump(self)


class CustomerCreatePasswordResetToken(_BaseType):
    #: Email address of the Customer treated as [case-insensitive](/../api/customers-overview#email-case-insensitivity).
    email: str
    #: Validity period of the generated token in minutes.
    ttl_minutes: typing.Optional[int]

    def __init__(self, *, email: str, ttl_minutes: typing.Optional[int] = None):
        self.email = email
        self.ttl_minutes = ttl_minutes

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CustomerCreatePasswordResetToken":
        from ._schemas.customer import CustomerCreatePasswordResetTokenSchema

        return CustomerCreatePasswordResetTokenSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.customer import CustomerCreatePasswordResetTokenSchema

        return CustomerCreatePasswordResetTokenSchema().dump(self)


class CustomerDraft(_BaseType):
    #: User-defined unique identifier for the Customer.
    #: The `key` field is preferred over `customerNumber` as it is mutable and provides more flexibility.
    key: typing.Optional[str]
    #: User-defined unique identifier for a Customer.
    #: Once set, it cannot be changed.
    #:
    #: Can be used to refer to a Customer in a human-readable way (in emails, invoices, and other correspondence).
    customer_number: typing.Optional[str]
    #: Optional identifier for use in external systems like customer relationship management (CRM) or enterprise resource planning (ERP).
    external_id: typing.Optional[str]
    #: Email address of the Customer that must be [unique](/../api/customers-overview#customer-uniqueness) for an entire Project or to a Store the Customer is assigned to.
    #: It is the mandatory unique identifier of a Customer.
    email: str
    #: Required when `authenticationMode` is set to `Password`.
    #: Provide the Customer's password in plain text. The API stores passwords in an encrypted format.
    password: typing.Optional[str]
    #: Given name (first name) of the Customer.
    first_name: typing.Optional[str]
    #: Family name (last name) of the Customer.
    last_name: typing.Optional[str]
    #: Middle name of the Customer.
    middle_name: typing.Optional[str]
    #: Title of the Customer, for example, 'Dr.'.
    title: typing.Optional[str]
    #: Deprecated since an anonymous [Cart](ctp:api:type:Cart) can be identified by its `id` or external `key`.
    anonymous_cart_id: typing.Optional[str]
    #: Identifies a [Cart](ctp:api:type:Cart) that will be assigned to the new Customer.
    anonymous_cart: typing.Optional["CartResourceIdentifier"]
    #: Identifies Carts and Orders belonging to an anonymous session that will be assigned to the new Customer.
    anonymous_id: typing.Optional[str]
    #: Date of birth of the Customer.
    date_of_birth: typing.Optional[datetime.date]
    #: Company name of the Customer. When representing a company as a Customer, [Business Units](ctp:api:type:BusinessUnit) provide extended funtionality.
    company_name: typing.Optional[str]
    #: Individual VAT ID of the Customer.
    vat_id: typing.Optional[str]
    #: Addresses of the Customer.
    addresses: typing.Optional[typing.List["BaseAddress"]]
    #: Index of the address in the `addresses` array to use as the default shipping address.
    #: The `defaultShippingAddressId` of the Customer will be set to the `id` of that address.
    default_shipping_address: typing.Optional[int]
    #: Indices of the shipping addresses in the `addresses` array.
    #: The `shippingAddressIds` of the Customer will be set to the IDs of these addresses.
    shipping_addresses: typing.Optional[typing.List["int"]]
    #: Index of the address in the `addresses` array to use as the default billing address.
    #: The `defaultBillingAddressId` of the Customer will be set to the `id` of that address.
    default_billing_address: typing.Optional[int]
    #: Indices of the billing addresses in the `addresses` array.
    #: The `billingAddressIds` of the Customer will be set to the IDs of these addresses.
    billing_addresses: typing.Optional[typing.List["int"]]
    #: Set to `true` if the email address of the Customer has been verified already.
    #: The intended use is to leave this field unset upon sign-up of the Customer and initiate the [email verification](#email-verification-of-customer) afterwards.
    is_email_verified: typing.Optional[bool]
    #: Sets the [CustomerGroup](ctp:api:type:CustomerGroup) for the Customer.
    customer_group: typing.Optional["CustomerGroupResourceIdentifier"]
    #: Custom Fields for the Customer.
    custom: typing.Optional["CustomFieldsDraft"]
    #: Preferred language of the Customer.
    #: Must be one of the languages supported by the [Project](ctp:api:type:Project).
    locale: typing.Optional[str]
    #: Salutation of the Customer, for example, 'Mr.' or 'Mrs.'.
    salutation: typing.Optional[str]
    #: Sets the [Stores](ctp:api:type:Store) for the Customer.
    #:
    #: - If no Stores are specified, the Customer is a global customer, and can log in using the [Password Flow for global Customers](/../api/authorization#password-flow-for-global-customers).
    #: - If any Stores are specified, the Customer can only log in using the [Password Flow for Customers in a Store](/../api/authorization#password-flow-for-customers-in-a-store) for those specific Stores.
    stores: typing.Optional[typing.List["StoreResourceIdentifier"]]
    #: - Set to `Password` to make the `password` field required for the Customer.
    #: - Set to `ExternalAuth` when the password is not required for the Customer.
    authentication_mode: typing.Optional["AuthenticationMode"]

    def __init__(
        self,
        *,
        key: typing.Optional[str] = None,
        customer_number: typing.Optional[str] = None,
        external_id: typing.Optional[str] = None,
        email: str,
        password: typing.Optional[str] = None,
        first_name: typing.Optional[str] = None,
        last_name: typing.Optional[str] = None,
        middle_name: typing.Optional[str] = None,
        title: typing.Optional[str] = None,
        anonymous_cart_id: typing.Optional[str] = None,
        anonymous_cart: typing.Optional["CartResourceIdentifier"] = None,
        anonymous_id: typing.Optional[str] = None,
        date_of_birth: typing.Optional[datetime.date] = None,
        company_name: typing.Optional[str] = None,
        vat_id: typing.Optional[str] = None,
        addresses: typing.Optional[typing.List["BaseAddress"]] = None,
        default_shipping_address: typing.Optional[int] = None,
        shipping_addresses: typing.Optional[typing.List["int"]] = None,
        default_billing_address: typing.Optional[int] = None,
        billing_addresses: typing.Optional[typing.List["int"]] = None,
        is_email_verified: typing.Optional[bool] = None,
        customer_group: typing.Optional["CustomerGroupResourceIdentifier"] = None,
        custom: typing.Optional["CustomFieldsDraft"] = None,
        locale: typing.Optional[str] = None,
        salutation: typing.Optional[str] = None,
        stores: typing.Optional[typing.List["StoreResourceIdentifier"]] = None,
        authentication_mode: typing.Optional["AuthenticationMode"] = None
    ):
        self.key = key
        self.customer_number = customer_number
        self.external_id = external_id
        self.email = email
        self.password = password
        self.first_name = first_name
        self.last_name = last_name
        self.middle_name = middle_name
        self.title = title
        self.anonymous_cart_id = anonymous_cart_id
        self.anonymous_cart = anonymous_cart
        self.anonymous_id = anonymous_id
        self.date_of_birth = date_of_birth
        self.company_name = company_name
        self.vat_id = vat_id
        self.addresses = addresses
        self.default_shipping_address = default_shipping_address
        self.shipping_addresses = shipping_addresses
        self.default_billing_address = default_billing_address
        self.billing_addresses = billing_addresses
        self.is_email_verified = is_email_verified
        self.customer_group = customer_group
        self.custom = custom
        self.locale = locale
        self.salutation = salutation
        self.stores = stores
        self.authentication_mode = authentication_mode

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CustomerDraft":
        from ._schemas.customer import CustomerDraftSchema

        return CustomerDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.customer import CustomerDraftSchema

        return CustomerDraftSchema().dump(self)


class CustomerEmailTokenReference(Reference):
    """[Reference](ctp:api:type:Reference) to a [CustomerToken](ctp:api:type:CustomerToken) for email verification."""

    def __init__(self, *, id: str):

        super().__init__(id=id, type_id=ReferenceTypeId.CUSTOMER_EMAIL_TOKEN)

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CustomerEmailTokenReference":
        from ._schemas.customer import CustomerEmailTokenReferenceSchema

        return CustomerEmailTokenReferenceSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.customer import CustomerEmailTokenReferenceSchema

        return CustomerEmailTokenReferenceSchema().dump(self)


class CustomerEmailVerify(_BaseType):
    #: Expected version of the Customer.
    version: typing.Optional[int]
    #: Value of the token to verify Customer email.
    token_value: str

    def __init__(self, *, version: typing.Optional[int] = None, token_value: str):
        self.version = version
        self.token_value = token_value

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CustomerEmailVerify":
        from ._schemas.customer import CustomerEmailVerifySchema

        return CustomerEmailVerifySchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.customer import CustomerEmailVerifySchema

        return CustomerEmailVerifySchema().dump(self)


class CustomerPagedQueryResponse(_BaseType):
    """[PagedQueryResult](/../api/general-concepts#pagedqueryresult) with results containing an array of [Customer](ctp:api:type:Customer)."""

    #: Number of [results requested](/../api/general-concepts#limit).
    limit: int
    #: Number of [elements skipped](/../api/general-concepts#offset).
    offset: int
    #: Actual number of results returned.
    count: int
    #: Total number of results matching the query.
    #: This number is an estimation that is not [strongly consistent](/../api/general-concepts#strong-consistency).
    #: This field is returned by default.
    #: For improved performance, calculating this field can be deactivated by using the query parameter `withTotal=false`.
    #: When the results are filtered with a [Query Predicate](/../api/predicates/query), `total` is subject to a [limit](/../api/limits#queries).
    total: typing.Optional[int]
    #: [Customers](ctp:api:type:Customer) matching the query.
    results: typing.List["Customer"]

    def __init__(
        self,
        *,
        limit: int,
        offset: int,
        count: int,
        total: typing.Optional[int] = None,
        results: typing.List["Customer"]
    ):
        self.limit = limit
        self.offset = offset
        self.count = count
        self.total = total
        self.results = results

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CustomerPagedQueryResponse":
        from ._schemas.customer import CustomerPagedQueryResponseSchema

        return CustomerPagedQueryResponseSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.customer import CustomerPagedQueryResponseSchema

        return CustomerPagedQueryResponseSchema().dump(self)


class CustomerPasswordTokenReference(Reference):
    """[Reference](ctp:api:type:Reference) to a [CustomerToken](ctp:api:type:CustomerToken) for password reset."""

    def __init__(self, *, id: str):

        super().__init__(id=id, type_id=ReferenceTypeId.CUSTOMER_PASSWORD_TOKEN)

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CustomerPasswordTokenReference":
        from ._schemas.customer import CustomerPasswordTokenReferenceSchema

        return CustomerPasswordTokenReferenceSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.customer import CustomerPasswordTokenReferenceSchema

        return CustomerPasswordTokenReferenceSchema().dump(self)


class CustomerReference(Reference):
    """[Reference](ctp:api:type:Reference) to a [Customer](ctp:api:type:Customer)."""

    #: Contains the representation of the expanded Customer. Only present in responses to requests with [Reference Expansion](ctp:api:type:Expansion) for Customers.
    obj: typing.Optional["Customer"]

    def __init__(self, *, id: str, obj: typing.Optional["Customer"] = None):
        self.obj = obj

        super().__init__(id=id, type_id=ReferenceTypeId.CUSTOMER)

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CustomerReference":
        from ._schemas.customer import CustomerReferenceSchema

        return CustomerReferenceSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.customer import CustomerReferenceSchema

        return CustomerReferenceSchema().dump(self)


class CustomerResetPassword(_BaseType):
    #: Value of the token to reset the Customer password.
    token_value: str
    #: New password to be set.
    new_password: str
    #: Expected version of the Customer.
    version: typing.Optional[int]

    def __init__(
        self,
        *,
        token_value: str,
        new_password: str,
        version: typing.Optional[int] = None
    ):
        self.token_value = token_value
        self.new_password = new_password
        self.version = version

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CustomerResetPassword":
        from ._schemas.customer import CustomerResetPasswordSchema

        return CustomerResetPasswordSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.customer import CustomerResetPasswordSchema

        return CustomerResetPasswordSchema().dump(self)


class CustomerResourceIdentifier(ResourceIdentifier):
    """[ResourceIdentifier](ctp:api:type:ResourceIdentifier) to a [Customer](ctp:api:type:Customer). Either `id` or `key` is required. If both are set, an [InvalidJsonInput](/../api/errors#invalidjsoninput) error is returned."""

    def __init__(
        self, *, id: typing.Optional[str] = None, key: typing.Optional[str] = None
    ):

        super().__init__(id=id, key=key, type_id=ReferenceTypeId.CUSTOMER)

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CustomerResourceIdentifier":
        from ._schemas.customer import CustomerResourceIdentifierSchema

        return CustomerResourceIdentifierSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.customer import CustomerResourceIdentifierSchema

        return CustomerResourceIdentifierSchema().dump(self)


class CustomerSignInResult(_BaseType):
    #: Customer [signed up](ctp:api:endpoint:/{projectKey}/customers:POST) or [signed in](ctp:api:endpoint:/{projectKey}/login:POST) after authentication.
    customer: "Customer"
    #: Cart associated with the Customer.
    #: If empty, the Customer does not have a Cart assigned.
    cart: typing.Optional["Cart"]

    def __init__(self, *, customer: "Customer", cart: typing.Optional["Cart"] = None):
        self.customer = customer
        self.cart = cart

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CustomerSignInResult":
        from ._schemas.customer import CustomerSignInResultSchema

        return CustomerSignInResultSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.customer import CustomerSignInResultSchema

        return CustomerSignInResultSchema().dump(self)


class CustomerSignin(_BaseType):
    #: Email address of the Customer treated as [case-insensitive](/../api/customers-overview#email-case-insensitivity).
    email: str
    #: Password of the Customer.
    password: str
    #: Deprecated since it is now possible to identify an anonymous cart by using its `id` or external `key`.
    anonymous_cart_id: typing.Optional[str]
    #: Identifies a [Cart](ctp:api:type:Cart) that will be assigned to the Customer.
    anonymous_cart: typing.Optional["CartResourceIdentifier"]
    #: - Set to `MergeWithExistingCustomerCart` if [LineItems](ctp:api:type:LineItem) of the anonymous Cart should be merged with the active Customer Cart that has been modified most recently.
    #: - Set to `UseAsNewActiveCustomerCart` if the anonymous Cart should be used as the new active Customer Cart and no [LineItems](ctp:api:type:LineItem) are to be merged.
    anonymous_cart_sign_in_mode: typing.Optional["AnonymousCartSignInMode"]
    #: If both `anonymousCart` and `anonymousId` are provided, the `anonymousId` on the CustomerSignin must match that of the anonymous [Cart](ctp:api:type:Cart).
    #: Otherwise a [400 Bad Request](ctp:api:type:InvalidOperationError) `Invalid Operation` error is returned with the message:
    #: "Cart with the ID cart-id does not have the expected anonymousId.".
    anonymous_id: typing.Optional[str]
    #: - If `true`, the [LineItem](ctp:api:type:LineItem) Product data (`name`, `variant`, and `productType`) of the returned Cart will be updated.
    #: - If `false`, only the prices, discounts, and tax rates will be updated.
    update_product_data: typing.Optional[bool]

    def __init__(
        self,
        *,
        email: str,
        password: str,
        anonymous_cart_id: typing.Optional[str] = None,
        anonymous_cart: typing.Optional["CartResourceIdentifier"] = None,
        anonymous_cart_sign_in_mode: typing.Optional["AnonymousCartSignInMode"] = None,
        anonymous_id: typing.Optional[str] = None,
        update_product_data: typing.Optional[bool] = None
    ):
        self.email = email
        self.password = password
        self.anonymous_cart_id = anonymous_cart_id
        self.anonymous_cart = anonymous_cart
        self.anonymous_cart_sign_in_mode = anonymous_cart_sign_in_mode
        self.anonymous_id = anonymous_id
        self.update_product_data = update_product_data

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CustomerSignin":
        from ._schemas.customer import CustomerSigninSchema

        return CustomerSigninSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.customer import CustomerSigninSchema

        return CustomerSigninSchema().dump(self)


class CustomerToken(_BaseType):
    #: Unique identifier of the token.
    id: str
    #: The `id` of the Customer.
    customer_id: str
    #: Value of the token.
    value: str
    #: Date and time (UTC) the token expires.
    expires_at: datetime.datetime
    #: Date and time (UTC) the token was initially created.
    created_at: datetime.datetime
    #: When the token is created, `lastModifiedAt` is set to `createdAt`.
    last_modified_at: typing.Optional[datetime.datetime]

    def __init__(
        self,
        *,
        id: str,
        customer_id: str,
        value: str,
        expires_at: datetime.datetime,
        created_at: datetime.datetime,
        last_modified_at: typing.Optional[datetime.datetime] = None
    ):
        self.id = id
        self.customer_id = customer_id
        self.value = value
        self.expires_at = expires_at
        self.created_at = created_at
        self.last_modified_at = last_modified_at

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CustomerToken":
        from ._schemas.customer import CustomerTokenSchema

        return CustomerTokenSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.customer import CustomerTokenSchema

        return CustomerTokenSchema().dump(self)


class CustomerUpdate(_BaseType):
    #: Expected version of the Customer on which the changes should be applied.
    #: If the expected version does not match the actual version, a [ConcurrentModification](ctp:api:type:ConcurrentModificationError) error will be returned.
    version: int
    #: Update actions to be performed on the Customer.
    actions: typing.List["CustomerUpdateAction"]

    def __init__(self, *, version: int, actions: typing.List["CustomerUpdateAction"]):
        self.version = version
        self.actions = actions

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CustomerUpdate":
        from ._schemas.customer import CustomerUpdateSchema

        return CustomerUpdateSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.customer import CustomerUpdateSchema

        return CustomerUpdateSchema().dump(self)


class CustomerUpdateAction(_BaseType):
    action: str

    def __init__(self, *, action: str):
        self.action = action

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CustomerUpdateAction":
        if data["action"] == "addAddress":
            from ._schemas.customer import CustomerAddAddressActionSchema

            return CustomerAddAddressActionSchema().load(data)
        if data["action"] == "addBillingAddressId":
            from ._schemas.customer import CustomerAddBillingAddressIdActionSchema

            return CustomerAddBillingAddressIdActionSchema().load(data)
        if data["action"] == "addShippingAddressId":
            from ._schemas.customer import CustomerAddShippingAddressIdActionSchema

            return CustomerAddShippingAddressIdActionSchema().load(data)
        if data["action"] == "addStore":
            from ._schemas.customer import CustomerAddStoreActionSchema

            return CustomerAddStoreActionSchema().load(data)
        if data["action"] == "changeAddress":
            from ._schemas.customer import CustomerChangeAddressActionSchema

            return CustomerChangeAddressActionSchema().load(data)
        if data["action"] == "changeEmail":
            from ._schemas.customer import CustomerChangeEmailActionSchema

            return CustomerChangeEmailActionSchema().load(data)
        if data["action"] == "removeAddress":
            from ._schemas.customer import CustomerRemoveAddressActionSchema

            return CustomerRemoveAddressActionSchema().load(data)
        if data["action"] == "removeBillingAddressId":
            from ._schemas.customer import CustomerRemoveBillingAddressIdActionSchema

            return CustomerRemoveBillingAddressIdActionSchema().load(data)
        if data["action"] == "removeShippingAddressId":
            from ._schemas.customer import CustomerRemoveShippingAddressIdActionSchema

            return CustomerRemoveShippingAddressIdActionSchema().load(data)
        if data["action"] == "removeStore":
            from ._schemas.customer import CustomerRemoveStoreActionSchema

            return CustomerRemoveStoreActionSchema().load(data)
        if data["action"] == "setAddressCustomField":
            from ._schemas.customer import CustomerSetAddressCustomFieldActionSchema

            return CustomerSetAddressCustomFieldActionSchema().load(data)
        if data["action"] == "setAddressCustomType":
            from ._schemas.customer import CustomerSetAddressCustomTypeActionSchema

            return CustomerSetAddressCustomTypeActionSchema().load(data)
        if data["action"] == "setAuthenticationMode":
            from ._schemas.customer import CustomerSetAuthenticationModeActionSchema

            return CustomerSetAuthenticationModeActionSchema().load(data)
        if data["action"] == "setCompanyName":
            from ._schemas.customer import CustomerSetCompanyNameActionSchema

            return CustomerSetCompanyNameActionSchema().load(data)
        if data["action"] == "setCustomField":
            from ._schemas.customer import CustomerSetCustomFieldActionSchema

            return CustomerSetCustomFieldActionSchema().load(data)
        if data["action"] == "setCustomType":
            from ._schemas.customer import CustomerSetCustomTypeActionSchema

            return CustomerSetCustomTypeActionSchema().load(data)
        if data["action"] == "setCustomerGroup":
            from ._schemas.customer import CustomerSetCustomerGroupActionSchema

            return CustomerSetCustomerGroupActionSchema().load(data)
        if data["action"] == "setCustomerNumber":
            from ._schemas.customer import CustomerSetCustomerNumberActionSchema

            return CustomerSetCustomerNumberActionSchema().load(data)
        if data["action"] == "setDateOfBirth":
            from ._schemas.customer import CustomerSetDateOfBirthActionSchema

            return CustomerSetDateOfBirthActionSchema().load(data)
        if data["action"] == "setDefaultBillingAddress":
            from ._schemas.customer import CustomerSetDefaultBillingAddressActionSchema

            return CustomerSetDefaultBillingAddressActionSchema().load(data)
        if data["action"] == "setDefaultShippingAddress":
            from ._schemas.customer import CustomerSetDefaultShippingAddressActionSchema

            return CustomerSetDefaultShippingAddressActionSchema().load(data)
        if data["action"] == "setExternalId":
            from ._schemas.customer import CustomerSetExternalIdActionSchema

            return CustomerSetExternalIdActionSchema().load(data)
        if data["action"] == "setFirstName":
            from ._schemas.customer import CustomerSetFirstNameActionSchema

            return CustomerSetFirstNameActionSchema().load(data)
        if data["action"] == "setKey":
            from ._schemas.customer import CustomerSetKeyActionSchema

            return CustomerSetKeyActionSchema().load(data)
        if data["action"] == "setLastName":
            from ._schemas.customer import CustomerSetLastNameActionSchema

            return CustomerSetLastNameActionSchema().load(data)
        if data["action"] == "setLocale":
            from ._schemas.customer import CustomerSetLocaleActionSchema

            return CustomerSetLocaleActionSchema().load(data)
        if data["action"] == "setMiddleName":
            from ._schemas.customer import CustomerSetMiddleNameActionSchema

            return CustomerSetMiddleNameActionSchema().load(data)
        if data["action"] == "setSalutation":
            from ._schemas.customer import CustomerSetSalutationActionSchema

            return CustomerSetSalutationActionSchema().load(data)
        if data["action"] == "setStores":
            from ._schemas.customer import CustomerSetStoresActionSchema

            return CustomerSetStoresActionSchema().load(data)
        if data["action"] == "setTitle":
            from ._schemas.customer import CustomerSetTitleActionSchema

            return CustomerSetTitleActionSchema().load(data)
        if data["action"] == "setVatId":
            from ._schemas.customer import CustomerSetVatIdActionSchema

            return CustomerSetVatIdActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.customer import CustomerUpdateActionSchema

        return CustomerUpdateActionSchema().dump(self)


class MyCustomerChangePassword(_BaseType):
    #: Expected version of the Customer on which the changes should be applied.
    version: int
    #: Current password of the Customer.
    #:
    #: If the current password does not match, an [InvalidCurrentPassword](ctp:api:type:InvalidCurrentPasswordError) error is returned.
    current_password: str
    #: New password to be set.
    new_password: str

    def __init__(self, *, version: int, current_password: str, new_password: str):
        self.version = version
        self.current_password = current_password
        self.new_password = new_password

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCustomerChangePassword":
        from ._schemas.customer import MyCustomerChangePasswordSchema

        return MyCustomerChangePasswordSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.customer import MyCustomerChangePasswordSchema

        return MyCustomerChangePasswordSchema().dump(self)


class MyCustomerEmailVerify(_BaseType):
    #: Value of the token to verify Customer email.
    token_value: str

    def __init__(self, *, token_value: str):
        self.token_value = token_value

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "MyCustomerEmailVerify":
        from ._schemas.customer import MyCustomerEmailVerifySchema

        return MyCustomerEmailVerifySchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.customer import MyCustomerEmailVerifySchema

        return MyCustomerEmailVerifySchema().dump(self)


class MyCustomerResetPassword(_BaseType):
    #: Value of the token to reset the Customer password.
    token_value: str
    #: New password to be set.
    new_password: str

    def __init__(self, *, token_value: str, new_password: str):
        self.token_value = token_value
        self.new_password = new_password

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCustomerResetPassword":
        from ._schemas.customer import MyCustomerResetPasswordSchema

        return MyCustomerResetPasswordSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.customer import MyCustomerResetPasswordSchema

        return MyCustomerResetPasswordSchema().dump(self)


class MyCustomerSignin(_BaseType):
    #: Email address of the Customer treated as [case-insensitive](/../api/customers-overview#email-case-insensitivity).
    email: str
    #: Password of the Customer.
    password: str
    #: - If `MergeWithExistingCustomerCart`, [LineItems](ctp:api:type:LineItem) of the anonymous Cart are merged with the recently modified active Customer Cart.
    #: - If `UseAsNewActiveCustomerCart`, the anonymous Cart is used as the new active Customer Cart, and no [LineItems](ctp:api:type:LineItem) are merged.
    active_cart_sign_in_mode: typing.Optional["AnonymousCartSignInMode"]
    #: - If `true`, the [LineItem](ctp:api:type:LineItem) Product data (`name`, `variant`, and `productType`) of the returned Cart is updated.
    #: - If `false`, only the prices, discounts, and tax rates are updated.
    update_product_data: typing.Optional[bool]

    def __init__(
        self,
        *,
        email: str,
        password: str,
        active_cart_sign_in_mode: typing.Optional["AnonymousCartSignInMode"] = None,
        update_product_data: typing.Optional[bool] = None
    ):
        self.email = email
        self.password = password
        self.active_cart_sign_in_mode = active_cart_sign_in_mode
        self.update_product_data = update_product_data

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "MyCustomerSignin":
        from ._schemas.customer import MyCustomerSigninSchema

        return MyCustomerSigninSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.customer import MyCustomerSigninSchema

        return MyCustomerSigninSchema().dump(self)


class CustomerAddAddressAction(CustomerUpdateAction):
    """Adding an address to the Customer produces the [CustomerAddressAdded](ctp:api:type:CustomerAddressAddedMessage) Message."""

    #: Value to append to the `addresses` array.
    address: "BaseAddress"

    def __init__(self, *, address: "BaseAddress"):
        self.address = address

        super().__init__(action="addAddress")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CustomerAddAddressAction":
        from ._schemas.customer import CustomerAddAddressActionSchema

        return CustomerAddAddressActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.customer import CustomerAddAddressActionSchema

        return CustomerAddAddressActionSchema().dump(self)


class CustomerAddBillingAddressIdAction(CustomerUpdateAction):
    """Adds an Address from the `addresses` array to `billingAddressIds`. Either `addressId` or `addressKey` is required."""

    #: `id` of the [Address](ctp:api:type:Address) to become a billing address.
    address_id: typing.Optional[str]
    #: `key` of the [Address](ctp:api:type:Address) to become a billing address.
    address_key: typing.Optional[str]

    def __init__(
        self,
        *,
        address_id: typing.Optional[str] = None,
        address_key: typing.Optional[str] = None
    ):
        self.address_id = address_id
        self.address_key = address_key

        super().__init__(action="addBillingAddressId")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CustomerAddBillingAddressIdAction":
        from ._schemas.customer import CustomerAddBillingAddressIdActionSchema

        return CustomerAddBillingAddressIdActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.customer import CustomerAddBillingAddressIdActionSchema

        return CustomerAddBillingAddressIdActionSchema().dump(self)


class CustomerAddShippingAddressIdAction(CustomerUpdateAction):
    """Adds an Address from the `addresses` array to `shippingAddressIds`. Either `addressId` or `addressKey` is required."""

    #: `id` of the [Address](ctp:api:type:Address) to become a shipping address.
    address_id: typing.Optional[str]
    #: `key` of the [Address](ctp:api:type:Address) to become a shipping address.
    address_key: typing.Optional[str]

    def __init__(
        self,
        *,
        address_id: typing.Optional[str] = None,
        address_key: typing.Optional[str] = None
    ):
        self.address_id = address_id
        self.address_key = address_key

        super().__init__(action="addShippingAddressId")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CustomerAddShippingAddressIdAction":
        from ._schemas.customer import CustomerAddShippingAddressIdActionSchema

        return CustomerAddShippingAddressIdActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.customer import CustomerAddShippingAddressIdActionSchema

        return CustomerAddShippingAddressIdActionSchema().dump(self)


class CustomerAddStoreAction(CustomerUpdateAction):
    """Associates the Customer with a Store."""

    #: ResourceIdentifier of the Store to add.
    store: "StoreResourceIdentifier"

    def __init__(self, *, store: "StoreResourceIdentifier"):
        self.store = store

        super().__init__(action="addStore")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CustomerAddStoreAction":
        from ._schemas.customer import CustomerAddStoreActionSchema

        return CustomerAddStoreActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.customer import CustomerAddStoreActionSchema

        return CustomerAddStoreActionSchema().dump(self)


class CustomerChangeAddressAction(CustomerUpdateAction):
    """Changing an address of the Customer produces the [CustomerAddressChanged](ctp:api:type:CustomerAddressChangedMessage) Message.

    Either `addressId` or `addressKey` is required.

    """

    #: `id` of the [Address](ctp:api:type:Address) to change.
    address_id: typing.Optional[str]
    #: `key` of the [Address](ctp:api:type:Address) to change.
    address_key: typing.Optional[str]
    #: Value to set.
    address: "BaseAddress"

    def __init__(
        self,
        *,
        address_id: typing.Optional[str] = None,
        address_key: typing.Optional[str] = None,
        address: "BaseAddress"
    ):
        self.address_id = address_id
        self.address_key = address_key
        self.address = address

        super().__init__(action="changeAddress")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CustomerChangeAddressAction":
        from ._schemas.customer import CustomerChangeAddressActionSchema

        return CustomerChangeAddressActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.customer import CustomerChangeAddressActionSchema

        return CustomerChangeAddressActionSchema().dump(self)


class CustomerChangeEmailAction(CustomerUpdateAction):
    """Changes the `email` of the Customer and sets the `isEmailVerified` property to `false`. This update action generates a [CustomerEmailChanged](ctp:api:type:CustomerEmailChangedMessage) Message."""

    #: Value to set.
    email: str

    def __init__(self, *, email: str):
        self.email = email

        super().__init__(action="changeEmail")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CustomerChangeEmailAction":
        from ._schemas.customer import CustomerChangeEmailActionSchema

        return CustomerChangeEmailActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.customer import CustomerChangeEmailActionSchema

        return CustomerChangeEmailActionSchema().dump(self)


class CustomerRemoveAddressAction(CustomerUpdateAction):
    """Removing an address from the Customer produces the [CustomerAddressRemoved](ctp:api:type:CustomerAddressRemovedMessage) Message.

    Either `addressId` or `addressKey` is required.

    """

    #: `id` of the [Address](ctp:api:type:Address) to remove.
    address_id: typing.Optional[str]
    #: `key` of the [Address](ctp:api:type:Address) to remove.
    address_key: typing.Optional[str]

    def __init__(
        self,
        *,
        address_id: typing.Optional[str] = None,
        address_key: typing.Optional[str] = None
    ):
        self.address_id = address_id
        self.address_key = address_key

        super().__init__(action="removeAddress")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CustomerRemoveAddressAction":
        from ._schemas.customer import CustomerRemoveAddressActionSchema

        return CustomerRemoveAddressActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.customer import CustomerRemoveAddressActionSchema

        return CustomerRemoveAddressActionSchema().dump(self)


class CustomerRemoveBillingAddressIdAction(CustomerUpdateAction):
    """Removes a billing address from `billingAddressesIds`.
    If the billing address is the default billing address, the `defaultBillingAddressId` is unset. Either `addressId` or `addressKey` is required.

    """

    #: `id` of the [Address](ctp:api:type:Address) to remove from `billingAddressesIds`.
    address_id: typing.Optional[str]
    #: `key` of the [Address](ctp:api:type:Address) to remove from `billingAddressesIds`.
    address_key: typing.Optional[str]

    def __init__(
        self,
        *,
        address_id: typing.Optional[str] = None,
        address_key: typing.Optional[str] = None
    ):
        self.address_id = address_id
        self.address_key = address_key

        super().__init__(action="removeBillingAddressId")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CustomerRemoveBillingAddressIdAction":
        from ._schemas.customer import CustomerRemoveBillingAddressIdActionSchema

        return CustomerRemoveBillingAddressIdActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.customer import CustomerRemoveBillingAddressIdActionSchema

        return CustomerRemoveBillingAddressIdActionSchema().dump(self)


class CustomerRemoveShippingAddressIdAction(CustomerUpdateAction):
    """Removes a shipping address from `shippingAddressesIds`.
    If the shipping address is the default shipping address, the `defaultShippingAddressId` is unset. Either `addressId` or `addressKey` is required.

    """

    #: `id` of the [Address](ctp:api:type:Address) to remove from `shippingAddressesIds`.
    address_id: typing.Optional[str]
    #: `key` of the [Address](ctp:api:type:Address) to remove from `shippingAddressesIds`.
    address_key: typing.Optional[str]

    def __init__(
        self,
        *,
        address_id: typing.Optional[str] = None,
        address_key: typing.Optional[str] = None
    ):
        self.address_id = address_id
        self.address_key = address_key

        super().__init__(action="removeShippingAddressId")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CustomerRemoveShippingAddressIdAction":
        from ._schemas.customer import CustomerRemoveShippingAddressIdActionSchema

        return CustomerRemoveShippingAddressIdActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.customer import CustomerRemoveShippingAddressIdActionSchema

        return CustomerRemoveShippingAddressIdActionSchema().dump(self)


class CustomerRemoveStoreAction(CustomerUpdateAction):
    """Removes the association to a Store from the Customer.
    If no more Stores are assigned, the Customer becomes a [global Customer](/../api/customers-overview#global-versus-store-specific-customers).

    """

    #: ResourceIdentifier of the Store to remove.
    store: "StoreResourceIdentifier"

    def __init__(self, *, store: "StoreResourceIdentifier"):
        self.store = store

        super().__init__(action="removeStore")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CustomerRemoveStoreAction":
        from ._schemas.customer import CustomerRemoveStoreActionSchema

        return CustomerRemoveStoreActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.customer import CustomerRemoveStoreActionSchema

        return CustomerRemoveStoreActionSchema().dump(self)


class CustomerSetAddressCustomFieldAction(CustomerUpdateAction):
    """Adding a Custom Field to an Address of a Customer generates the [CustomerAddressCustomFieldAdded](ctp:api:type:CustomerAddressCustomFieldAddedMessage) Message, removing one generates the [CustomerAddressCustomFieldRemoved](ctp:api:type:CustomerAddressCustomFieldRemovedMessage) Message, and updating an existing one generates the [CustomerAddressCustomFieldChanged](ctp:api:type:CustomerAddressCustomFieldChangedMessage) Message."""

    #: User-defined unique identifier of the [Address](ctp:api:type:Address) to be updated.
    address_id: str
    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: If `value` is provided, it is set for the field defined by `name`.
    #: Trying to remove a field that does not exist will fail with an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
    value: typing.Optional[typing.Any]

    def __init__(
        self, *, address_id: str, name: str, value: typing.Optional[typing.Any] = None
    ):
        self.address_id = address_id
        self.name = name
        self.value = value

        super().__init__(action="setAddressCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CustomerSetAddressCustomFieldAction":
        from ._schemas.customer import CustomerSetAddressCustomFieldActionSchema

        return CustomerSetAddressCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.customer import CustomerSetAddressCustomFieldActionSchema

        return CustomerSetAddressCustomFieldActionSchema().dump(self)


class CustomerSetAddressCustomTypeAction(CustomerUpdateAction):
    """Adding or updating a Custom Type on an Address of a Customer generates the [CustomerAddressCustomTypeSet](ctp:api:type:CustomerAddressCustomTypeSetMessage) Message, and removing one generates the [CustomerAddressCustomTypeRemoved](ctp:api:type:CustomerAddressCustomTypeRemovedMessage) Message."""

    #: User-defined unique identifier of the [Address](ctp:api:type:Address) to be updated.
    address_id: str
    #: Defines the [Type](ctp:api:type:Type) that extends the `address` with [Custom Fields](/../api/projects/custom-fields).
    #: If absent, any existing Type and Custom Fields are removed from the `address`.
    type: typing.Optional["TypeResourceIdentifier"]
    #: Sets the [Custom Fields](/../api/projects/custom-fields) fields for the `address`.
    fields: typing.Optional["FieldContainer"]

    def __init__(
        self,
        *,
        address_id: str,
        type: typing.Optional["TypeResourceIdentifier"] = None,
        fields: typing.Optional["FieldContainer"] = None
    ):
        self.address_id = address_id
        self.type = type
        self.fields = fields

        super().__init__(action="setAddressCustomType")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CustomerSetAddressCustomTypeAction":
        from ._schemas.customer import CustomerSetAddressCustomTypeActionSchema

        return CustomerSetAddressCustomTypeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.customer import CustomerSetAddressCustomTypeActionSchema

        return CustomerSetAddressCustomTypeActionSchema().dump(self)


class CustomerSetAuthenticationModeAction(CustomerUpdateAction):
    #: Value to set.
    #: Changing a Customer's `authMode` from `Password` to `ExternalAuth` deletes the Customer's password.
    auth_mode: "AuthenticationMode"
    #: Required when `authMode` is `Password`.
    password: typing.Optional[str]

    def __init__(
        self, *, auth_mode: "AuthenticationMode", password: typing.Optional[str] = None
    ):
        self.auth_mode = auth_mode
        self.password = password

        super().__init__(action="setAuthenticationMode")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CustomerSetAuthenticationModeAction":
        from ._schemas.customer import CustomerSetAuthenticationModeActionSchema

        return CustomerSetAuthenticationModeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.customer import CustomerSetAuthenticationModeActionSchema

        return CustomerSetAuthenticationModeActionSchema().dump(self)


class CustomerSetCompanyNameAction(CustomerUpdateAction):
    """Setting a company name produces the [CustomerCompanyNameSet](ctp:api:type:CustomerCompanyNameSetMessage) Message."""

    #: Value to set.
    #: If empty, any existing value is removed.
    company_name: typing.Optional[str]

    def __init__(self, *, company_name: typing.Optional[str] = None):
        self.company_name = company_name

        super().__init__(action="setCompanyName")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CustomerSetCompanyNameAction":
        from ._schemas.customer import CustomerSetCompanyNameActionSchema

        return CustomerSetCompanyNameActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.customer import CustomerSetCompanyNameActionSchema

        return CustomerSetCompanyNameActionSchema().dump(self)


class CustomerSetCustomFieldAction(CustomerUpdateAction):
    """Adding a Custom Field to a Customer generates the [CustomerCustomFieldAdded](ctp:api:type:CustomerCustomFieldAddedMessage) Message, removing one generates the [CustomerCustomFieldRemoved](ctp:api:type:CustomerCustomFieldRemovedMessage) Message, and updating an existing one generates the [CustomerCustomFieldChanged](ctp:api:type:CustomerCustomFieldChangedMessage) Message."""

    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: If `value` is provided, it is set for the field defined by `name`.
    #: Trying to remove a field that does not exist will fail with an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
    value: typing.Optional[typing.Any]

    def __init__(self, *, name: str, value: typing.Optional[typing.Any] = None):
        self.name = name
        self.value = value

        super().__init__(action="setCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CustomerSetCustomFieldAction":
        from ._schemas.customer import CustomerSetCustomFieldActionSchema

        return CustomerSetCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.customer import CustomerSetCustomFieldActionSchema

        return CustomerSetCustomFieldActionSchema().dump(self)


class CustomerSetCustomTypeAction(CustomerUpdateAction):
    """Adding or updating a Custom Type on a Customer generates the [CustomerCustomTypeSet](ctp:api:type:CustomerCustomTypeSetMessage) Message, removing one generates the [CustomerCustomTypeRemoved](ctp:api:type:CustomerCustomTypeRemovedMessage) Message."""

    #: Defines the [Type](ctp:api:type:Type) that extends the Customer with [Custom Fields](/../api/projects/custom-fields).
    #: If absent, any existing Type and Custom Fields are removed from the Customer.
    type: typing.Optional["TypeResourceIdentifier"]
    #: Sets the [Custom Fields](/../api/projects/custom-fields) fields for the Customer.
    fields: typing.Optional["FieldContainer"]

    def __init__(
        self,
        *,
        type: typing.Optional["TypeResourceIdentifier"] = None,
        fields: typing.Optional["FieldContainer"] = None
    ):
        self.type = type
        self.fields = fields

        super().__init__(action="setCustomType")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CustomerSetCustomTypeAction":
        from ._schemas.customer import CustomerSetCustomTypeActionSchema

        return CustomerSetCustomTypeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.customer import CustomerSetCustomTypeActionSchema

        return CustomerSetCustomTypeActionSchema().dump(self)


class CustomerSetCustomerGroupAction(CustomerUpdateAction):
    """Setting the Customer Group of the Customer produces the [CustomerGroupSet](ctp:api:type:CustomerGroupSetMessage) Message."""

    #: Value to set.
    #: If empty, any existing value is removed.
    customer_group: typing.Optional["CustomerGroupResourceIdentifier"]

    def __init__(
        self,
        *,
        customer_group: typing.Optional["CustomerGroupResourceIdentifier"] = None
    ):
        self.customer_group = customer_group

        super().__init__(action="setCustomerGroup")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CustomerSetCustomerGroupAction":
        from ._schemas.customer import CustomerSetCustomerGroupActionSchema

        return CustomerSetCustomerGroupActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.customer import CustomerSetCustomerGroupActionSchema

        return CustomerSetCustomerGroupActionSchema().dump(self)


class CustomerSetCustomerNumberAction(CustomerUpdateAction):
    """Sets a new ID that can be used to refer to a Customer in a human-reabable way (for use in emails, invoices, etc)."""

    #: Value to set.
    #: Once set, it cannot be changed.
    customer_number: typing.Optional[str]

    def __init__(self, *, customer_number: typing.Optional[str] = None):
        self.customer_number = customer_number

        super().__init__(action="setCustomerNumber")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CustomerSetCustomerNumberAction":
        from ._schemas.customer import CustomerSetCustomerNumberActionSchema

        return CustomerSetCustomerNumberActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.customer import CustomerSetCustomerNumberActionSchema

        return CustomerSetCustomerNumberActionSchema().dump(self)


class CustomerSetDateOfBirthAction(CustomerUpdateAction):
    """Setting the date of birth of the Customer produces the [CustomerDateOfBirthSet](ctp:api:type:CustomerDateOfBirthSetMessage) Message."""

    #: Value to set.
    #: If empty, any existing value is removed.
    date_of_birth: typing.Optional[datetime.date]

    def __init__(self, *, date_of_birth: typing.Optional[datetime.date] = None):
        self.date_of_birth = date_of_birth

        super().__init__(action="setDateOfBirth")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CustomerSetDateOfBirthAction":
        from ._schemas.customer import CustomerSetDateOfBirthActionSchema

        return CustomerSetDateOfBirthActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.customer import CustomerSetDateOfBirthActionSchema

        return CustomerSetDateOfBirthActionSchema().dump(self)


class CustomerSetDefaultBillingAddressAction(CustomerUpdateAction):
    """Sets the default billing address from `addresses`.
    The action adds the `id` of the specified Address to the `billingAddressIds` if not contained already. Either `addressId` or `addressKey` is required.

    """

    #: `id` of the [Address](ctp:api:type:Address) to become the default billing address.
    address_id: typing.Optional[str]
    #: `key` of the [Address](ctp:api:type:Address) to become the default billing address.
    address_key: typing.Optional[str]

    def __init__(
        self,
        *,
        address_id: typing.Optional[str] = None,
        address_key: typing.Optional[str] = None
    ):
        self.address_id = address_id
        self.address_key = address_key

        super().__init__(action="setDefaultBillingAddress")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CustomerSetDefaultBillingAddressAction":
        from ._schemas.customer import CustomerSetDefaultBillingAddressActionSchema

        return CustomerSetDefaultBillingAddressActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.customer import CustomerSetDefaultBillingAddressActionSchema

        return CustomerSetDefaultBillingAddressActionSchema().dump(self)


class CustomerSetDefaultShippingAddressAction(CustomerUpdateAction):
    """Sets the default shipping address from `addresses`.
    The action adds the `id` of the specified address to the `shippingAddressIds` if not contained already. Either `addressId` or `addressKey` is required.

    If the Tax Category of the Cart [ShippingInfo](ctp:api:type:ShippingInfo) is missing the TaxRate matching country and state given in the `shippingAddress` of that Cart, a [MissingTaxRateForCountry](ctp:api:type:MissingTaxRateForCountryError) error is returned.

    """

    #: `id` of the [Address](ctp:api:type:Address) to become the default shipping address.
    address_id: typing.Optional[str]
    #: `key` of the [Address](ctp:api:type:Address) to become the default shipping address.
    address_key: typing.Optional[str]

    def __init__(
        self,
        *,
        address_id: typing.Optional[str] = None,
        address_key: typing.Optional[str] = None
    ):
        self.address_id = address_id
        self.address_key = address_key

        super().__init__(action="setDefaultShippingAddress")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CustomerSetDefaultShippingAddressAction":
        from ._schemas.customer import CustomerSetDefaultShippingAddressActionSchema

        return CustomerSetDefaultShippingAddressActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.customer import CustomerSetDefaultShippingAddressActionSchema

        return CustomerSetDefaultShippingAddressActionSchema().dump(self)


class CustomerSetExternalIdAction(CustomerUpdateAction):
    #: Value to set.
    #: If empty, any existing value is removed.
    external_id: typing.Optional[str]

    def __init__(self, *, external_id: typing.Optional[str] = None):
        self.external_id = external_id

        super().__init__(action="setExternalId")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CustomerSetExternalIdAction":
        from ._schemas.customer import CustomerSetExternalIdActionSchema

        return CustomerSetExternalIdActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.customer import CustomerSetExternalIdActionSchema

        return CustomerSetExternalIdActionSchema().dump(self)


class CustomerSetFirstNameAction(CustomerUpdateAction):
    """Setting the first name of the Customer produces the [CustomeFirstNameSet](ctp:api:type:CustomerFirstNameSetMessage) Message."""

    #: Value to set. If empty, any existing value is removed.
    first_name: typing.Optional[str]

    def __init__(self, *, first_name: typing.Optional[str] = None):
        self.first_name = first_name

        super().__init__(action="setFirstName")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CustomerSetFirstNameAction":
        from ._schemas.customer import CustomerSetFirstNameActionSchema

        return CustomerSetFirstNameActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.customer import CustomerSetFirstNameActionSchema

        return CustomerSetFirstNameActionSchema().dump(self)


class CustomerSetKeyAction(CustomerUpdateAction):
    #: If `key` is absent or `null`, the existing key, if any, will be removed.
    key: typing.Optional[str]

    def __init__(self, *, key: typing.Optional[str] = None):
        self.key = key

        super().__init__(action="setKey")

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CustomerSetKeyAction":
        from ._schemas.customer import CustomerSetKeyActionSchema

        return CustomerSetKeyActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.customer import CustomerSetKeyActionSchema

        return CustomerSetKeyActionSchema().dump(self)


class CustomerSetLastNameAction(CustomerUpdateAction):
    """Setting the last name of the Customer produces the [CustomerLastNameSet](ctp:api:type:CustomerLastNameSetMessage) Message."""

    #: Value to set. If empty, any existing value is removed.
    last_name: typing.Optional[str]

    def __init__(self, *, last_name: typing.Optional[str] = None):
        self.last_name = last_name

        super().__init__(action="setLastName")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CustomerSetLastNameAction":
        from ._schemas.customer import CustomerSetLastNameActionSchema

        return CustomerSetLastNameActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.customer import CustomerSetLastNameActionSchema

        return CustomerSetLastNameActionSchema().dump(self)


class CustomerSetLocaleAction(CustomerUpdateAction):
    #: Value to set.
    #: Must be one of the languages supported by the [Project](ctp:api:type:Project).
    locale: typing.Optional[str]

    def __init__(self, *, locale: typing.Optional[str] = None):
        self.locale = locale

        super().__init__(action="setLocale")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CustomerSetLocaleAction":
        from ._schemas.customer import CustomerSetLocaleActionSchema

        return CustomerSetLocaleActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.customer import CustomerSetLocaleActionSchema

        return CustomerSetLocaleActionSchema().dump(self)


class CustomerSetMiddleNameAction(CustomerUpdateAction):
    #: Value to set. If empty, any existing value is removed.
    middle_name: typing.Optional[str]

    def __init__(self, *, middle_name: typing.Optional[str] = None):
        self.middle_name = middle_name

        super().__init__(action="setMiddleName")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CustomerSetMiddleNameAction":
        from ._schemas.customer import CustomerSetMiddleNameActionSchema

        return CustomerSetMiddleNameActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.customer import CustomerSetMiddleNameActionSchema

        return CustomerSetMiddleNameActionSchema().dump(self)


class CustomerSetSalutationAction(CustomerUpdateAction):
    #: Value to set. If empty, any existing value is removed.
    salutation: typing.Optional[str]

    def __init__(self, *, salutation: typing.Optional[str] = None):
        self.salutation = salutation

        super().__init__(action="setSalutation")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CustomerSetSalutationAction":
        from ._schemas.customer import CustomerSetSalutationActionSchema

        return CustomerSetSalutationActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.customer import CustomerSetSalutationActionSchema

        return CustomerSetSalutationActionSchema().dump(self)


class CustomerSetStoresAction(CustomerUpdateAction):
    """Sets the Stores the Customer account is associated with.
    If no Stores are specified, the Customer becomes a [global Customer](/../api/customers-overview#global-versus-store-specific-customers).

    """

    #: ResourceIdentifier of the Stores to set.
    stores: typing.Optional[typing.List["StoreResourceIdentifier"]]

    def __init__(
        self, *, stores: typing.Optional[typing.List["StoreResourceIdentifier"]] = None
    ):
        self.stores = stores

        super().__init__(action="setStores")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CustomerSetStoresAction":
        from ._schemas.customer import CustomerSetStoresActionSchema

        return CustomerSetStoresActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.customer import CustomerSetStoresActionSchema

        return CustomerSetStoresActionSchema().dump(self)


class CustomerSetTitleAction(CustomerUpdateAction):
    """Setting the title of the Customer produces the [CustomerTitleSet](ctp:api:type:CustomerTitleSetMessage) Message."""

    #: Value to set. If empty, any existing value is removed.
    title: typing.Optional[str]

    def __init__(self, *, title: typing.Optional[str] = None):
        self.title = title

        super().__init__(action="setTitle")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CustomerSetTitleAction":
        from ._schemas.customer import CustomerSetTitleActionSchema

        return CustomerSetTitleActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.customer import CustomerSetTitleActionSchema

        return CustomerSetTitleActionSchema().dump(self)


class CustomerSetVatIdAction(CustomerUpdateAction):
    #: Value to set.
    #: If empty, any existing value is removed.
    vat_id: typing.Optional[str]

    def __init__(self, *, vat_id: typing.Optional[str] = None):
        self.vat_id = vat_id

        super().__init__(action="setVatId")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CustomerSetVatIdAction":
        from ._schemas.customer import CustomerSetVatIdActionSchema

        return CustomerSetVatIdActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.customer import CustomerSetVatIdActionSchema

        return CustomerSetVatIdActionSchema().dump(self)
