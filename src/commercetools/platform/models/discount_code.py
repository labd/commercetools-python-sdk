# This file is automatically generated by the rmf-codegen project.
#
# The Python code generator is maintained by Lab Digital. If you want to
# contribute to this project then please do not edit this file directly
# but send a pull request to the Lab Digital fork of rmf-codegen at
# https://github.com/labd/rmf-codegen

import datetime
import enum
import typing

from ._abstract import _BaseType
from .common import BaseResource, Reference, ReferenceTypeId, ResourceIdentifier

if typing.TYPE_CHECKING:
    from .cart_discount import CartDiscountReference, CartDiscountResourceIdentifier
    from .common import (
        CreatedBy,
        LastModifiedBy,
        LocalizedString,
        Reference,
        ReferenceTypeId,
    )
    from .type import (
        CustomFields,
        CustomFieldsDraft,
        FieldContainer,
        TypeResourceIdentifier,
    )

__all__ = [
    "DiscountCode",
    "DiscountCodeChangeCartDiscountsAction",
    "DiscountCodeChangeGroupsAction",
    "DiscountCodeChangeIsActiveAction",
    "DiscountCodeDraft",
    "DiscountCodePagedQueryResponse",
    "DiscountCodeReference",
    "DiscountCodeResourceIdentifier",
    "DiscountCodeSetCartPredicateAction",
    "DiscountCodeSetCustomFieldAction",
    "DiscountCodeSetCustomTypeAction",
    "DiscountCodeSetDescriptionAction",
    "DiscountCodeSetKeyAction",
    "DiscountCodeSetMaxApplicationsAction",
    "DiscountCodeSetMaxApplicationsPerCustomerAction",
    "DiscountCodeSetNameAction",
    "DiscountCodeSetValidFromAction",
    "DiscountCodeSetValidFromAndUntilAction",
    "DiscountCodeSetValidUntilAction",
    "DiscountCodeUpdate",
    "DiscountCodeUpdateAction",
]


class DiscountCode(BaseResource):
    #: User-defined unique identifier of the DiscountCode.
    key: typing.Optional[str]
    #: IDs and references that last modified the DiscountCode.
    last_modified_by: typing.Optional["LastModifiedBy"]
    #: IDs and references that created the DiscountCode.
    created_by: typing.Optional["CreatedBy"]
    #: Name of the DiscountCode.
    name: typing.Optional["LocalizedString"]
    #: Description of the DiscountCode.
    description: typing.Optional["LocalizedString"]
    #: User-defined unique identifier of the DiscountCode [added to the Cart](/../api/projects/carts#add-discountcode) to apply the related [CartDiscounts](ctp:api:type:CartDiscount).
    code: str
    #: Reference to CartDiscounts that can be applied to the Cart once the DiscountCode is applied.
    cart_discounts: typing.List["CartDiscountReference"]
    #: DiscountCode can only be applied to Carts that match this predicate.
    cart_predicate: typing.Optional[str]
    #: Indicates if the DiscountCode is active and can be applied to the Cart.
    is_active: bool
    #: Array generated from the Cart predicate.
    #: It contains the references of all the resources that are addressed in the predicate.
    references: typing.List["Reference"]
    #: Number of times the DiscountCode can be applied.
    #: DiscountCode application is counted at the time of Order creation or edit. However, Order cancellation or deletion does not decrement the count.
    max_applications: typing.Optional[int]
    #: Number of times the DiscountCode can be applied per Customer (anonymous Carts are not supported).
    #: DiscountCode application is counted at the time of Order creation or edit. However, Order cancellation or deletion does not decrement the count.
    max_applications_per_customer: typing.Optional[int]
    #: Custom Fields of the DiscountCode.
    custom: typing.Optional["CustomFields"]
    #: Groups to which the DiscountCode belongs to.
    groups: typing.List["str"]
    #: Date and time (UTC) from which the DiscountCode is effective.
    valid_from: typing.Optional[datetime.datetime]
    #: Date and time (UTC) until which the DiscountCode is effective.
    valid_until: typing.Optional[datetime.datetime]
    #: Used and managed by the API and must not be used in customer logic.
    #: The value can change at any time due to internal and external factors.
    application_version: typing.Optional[int]

    def __init__(
        self,
        *,
        id: str,
        version: int,
        created_at: datetime.datetime,
        last_modified_at: datetime.datetime,
        key: typing.Optional[str] = None,
        last_modified_by: typing.Optional["LastModifiedBy"] = None,
        created_by: typing.Optional["CreatedBy"] = None,
        name: typing.Optional["LocalizedString"] = None,
        description: typing.Optional["LocalizedString"] = None,
        code: str,
        cart_discounts: typing.List["CartDiscountReference"],
        cart_predicate: typing.Optional[str] = None,
        is_active: bool,
        references: typing.List["Reference"],
        max_applications: typing.Optional[int] = None,
        max_applications_per_customer: typing.Optional[int] = None,
        custom: typing.Optional["CustomFields"] = None,
        groups: typing.List["str"],
        valid_from: typing.Optional[datetime.datetime] = None,
        valid_until: typing.Optional[datetime.datetime] = None,
        application_version: typing.Optional[int] = None
    ):
        self.key = key
        self.last_modified_by = last_modified_by
        self.created_by = created_by
        self.name = name
        self.description = description
        self.code = code
        self.cart_discounts = cart_discounts
        self.cart_predicate = cart_predicate
        self.is_active = is_active
        self.references = references
        self.max_applications = max_applications
        self.max_applications_per_customer = max_applications_per_customer
        self.custom = custom
        self.groups = groups
        self.valid_from = valid_from
        self.valid_until = valid_until
        self.application_version = application_version

        super().__init__(
            id=id,
            version=version,
            created_at=created_at,
            last_modified_at=last_modified_at,
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "DiscountCode":
        from ._schemas.discount_code import DiscountCodeSchema

        return DiscountCodeSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.discount_code import DiscountCodeSchema

        return DiscountCodeSchema().dump(self)


class DiscountCodeDraft(_BaseType):
    #: User-defined unique identifier for the DiscountCode.
    key: typing.Optional[str]
    #: Name of the DiscountCode.
    name: typing.Optional["LocalizedString"]
    #: Description of the DiscountCode.
    description: typing.Optional["LocalizedString"]
    #: User-defined unique identifier for the DiscountCode that can be [added to the Cart](/../api/projects/carts#add-discountcode) to apply the related [CartDiscounts](ctp:api:type:CartDiscount).
    #: It cannot be modified after the DiscountCode is created.
    code: str
    #: Specify what CartDiscounts the API applies when you add the DiscountCode to the Cart.
    cart_discounts: typing.List["CartDiscountResourceIdentifier"]
    #: DiscountCode can only be applied to Carts that match this predicate.
    cart_predicate: typing.Optional[str]
    #: Only active DiscountCodes can be applied to the Cart.
    is_active: typing.Optional[bool]
    #: Number of times the DiscountCode can be applied.
    max_applications: typing.Optional[int]
    #: Number of times the DiscountCode can be applied per Customer.
    max_applications_per_customer: typing.Optional[int]
    #: Custom Fields for the DiscountCode.
    custom: typing.Optional["CustomFieldsDraft"]
    #: Groups to which the DiscountCode will belong to.
    groups: typing.Optional[typing.List["str"]]
    #: Date and time (UTC) from which the DiscountCode is effective. Must be earlier than `validUntil`.
    valid_from: typing.Optional[datetime.datetime]
    #: Date and time (UTC) until which the DiscountCode is effective. Must be later than `validFrom`.
    valid_until: typing.Optional[datetime.datetime]

    def __init__(
        self,
        *,
        key: typing.Optional[str] = None,
        name: typing.Optional["LocalizedString"] = None,
        description: typing.Optional["LocalizedString"] = None,
        code: str,
        cart_discounts: typing.List["CartDiscountResourceIdentifier"],
        cart_predicate: typing.Optional[str] = None,
        is_active: typing.Optional[bool] = None,
        max_applications: typing.Optional[int] = None,
        max_applications_per_customer: typing.Optional[int] = None,
        custom: typing.Optional["CustomFieldsDraft"] = None,
        groups: typing.Optional[typing.List["str"]] = None,
        valid_from: typing.Optional[datetime.datetime] = None,
        valid_until: typing.Optional[datetime.datetime] = None
    ):
        self.key = key
        self.name = name
        self.description = description
        self.code = code
        self.cart_discounts = cart_discounts
        self.cart_predicate = cart_predicate
        self.is_active = is_active
        self.max_applications = max_applications
        self.max_applications_per_customer = max_applications_per_customer
        self.custom = custom
        self.groups = groups
        self.valid_from = valid_from
        self.valid_until = valid_until

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "DiscountCodeDraft":
        from ._schemas.discount_code import DiscountCodeDraftSchema

        return DiscountCodeDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.discount_code import DiscountCodeDraftSchema

        return DiscountCodeDraftSchema().dump(self)


class DiscountCodePagedQueryResponse(_BaseType):
    """[PagedQueryResult](/../api/general-concepts#pagedqueryresult) with `results` containing an array of [DiscountCode](ctp:api:type:DiscountCode)."""

    #: Number of [results requested](/../api/general-concepts#limit).
    limit: int
    #: Number of [elements skipped](/../api/general-concepts#offset).
    offset: int
    #: Actual number of results returned.
    count: int
    #: Total number of results matching the query.
    #: This number is an estimation that is not [strongly consistent](/../api/general-concepts#strong-consistency).
    #: This field is returned by default.
    #: For improved performance, calculating this field can be deactivated by using the query parameter `withTotal=false`.
    #: When the results are filtered with a [Query Predicate](/../api/predicates/query), `total` is subject to a [limit](/../api/limits#queries).
    total: typing.Optional[int]
    #: [DiscountCodes](ctp:api:type:DiscountCode) matching the query.
    results: typing.List["DiscountCode"]

    def __init__(
        self,
        *,
        limit: int,
        offset: int,
        count: int,
        total: typing.Optional[int] = None,
        results: typing.List["DiscountCode"]
    ):
        self.limit = limit
        self.offset = offset
        self.count = count
        self.total = total
        self.results = results

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "DiscountCodePagedQueryResponse":
        from ._schemas.discount_code import DiscountCodePagedQueryResponseSchema

        return DiscountCodePagedQueryResponseSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.discount_code import DiscountCodePagedQueryResponseSchema

        return DiscountCodePagedQueryResponseSchema().dump(self)


class DiscountCodeReference(Reference):
    """[Reference](ctp:api:type:Reference) to a [DiscountCode](ctp:api:type:DiscountCode)."""

    #: Contains the representation of the expanded DiscountCode. Only present in responses to requests with [Reference Expansion](/../api/general-concepts#reference-expansion) for DiscountCodes.
    obj: typing.Optional["DiscountCode"]

    def __init__(self, *, id: str, obj: typing.Optional["DiscountCode"] = None):
        self.obj = obj

        super().__init__(id=id, type_id=ReferenceTypeId.DISCOUNT_CODE)

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "DiscountCodeReference":
        from ._schemas.discount_code import DiscountCodeReferenceSchema

        return DiscountCodeReferenceSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.discount_code import DiscountCodeReferenceSchema

        return DiscountCodeReferenceSchema().dump(self)


class DiscountCodeResourceIdentifier(ResourceIdentifier):
    """[ResourceIdentifier](ctp:api:type:ResourceIdentifier) to a [DiscountCode](ctp:api:type:DiscountCode). Either `id` or `key` is required. If both are set, an [InvalidJsonInput](/../api/errors#invalidjsoninput) error is returned."""

    def __init__(
        self, *, id: typing.Optional[str] = None, key: typing.Optional[str] = None
    ):

        super().__init__(id=id, key=key, type_id=ReferenceTypeId.DISCOUNT_CODE)

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "DiscountCodeResourceIdentifier":
        from ._schemas.discount_code import DiscountCodeResourceIdentifierSchema

        return DiscountCodeResourceIdentifierSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.discount_code import DiscountCodeResourceIdentifierSchema

        return DiscountCodeResourceIdentifierSchema().dump(self)


class DiscountCodeUpdate(_BaseType):
    #: Expected version of the DiscountCode on which the changes should be applied.
    #: If the expected version does not match the actual version, a [ConcurrentModification](ctp:api:type:ConcurrentModificationError) error will be returned.
    version: int
    #: Update actions to be performed on the DiscountCode.
    actions: typing.List["DiscountCodeUpdateAction"]

    def __init__(
        self, *, version: int, actions: typing.List["DiscountCodeUpdateAction"]
    ):
        self.version = version
        self.actions = actions

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "DiscountCodeUpdate":
        from ._schemas.discount_code import DiscountCodeUpdateSchema

        return DiscountCodeUpdateSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.discount_code import DiscountCodeUpdateSchema

        return DiscountCodeUpdateSchema().dump(self)


class DiscountCodeUpdateAction(_BaseType):
    action: str

    def __init__(self, *, action: str):
        self.action = action

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "DiscountCodeUpdateAction":
        if data["action"] == "changeCartDiscounts":
            from ._schemas.discount_code import (
                DiscountCodeChangeCartDiscountsActionSchema,
            )

            return DiscountCodeChangeCartDiscountsActionSchema().load(data)
        if data["action"] == "changeGroups":
            from ._schemas.discount_code import DiscountCodeChangeGroupsActionSchema

            return DiscountCodeChangeGroupsActionSchema().load(data)
        if data["action"] == "changeIsActive":
            from ._schemas.discount_code import DiscountCodeChangeIsActiveActionSchema

            return DiscountCodeChangeIsActiveActionSchema().load(data)
        if data["action"] == "setCartPredicate":
            from ._schemas.discount_code import DiscountCodeSetCartPredicateActionSchema

            return DiscountCodeSetCartPredicateActionSchema().load(data)
        if data["action"] == "setCustomField":
            from ._schemas.discount_code import DiscountCodeSetCustomFieldActionSchema

            return DiscountCodeSetCustomFieldActionSchema().load(data)
        if data["action"] == "setCustomType":
            from ._schemas.discount_code import DiscountCodeSetCustomTypeActionSchema

            return DiscountCodeSetCustomTypeActionSchema().load(data)
        if data["action"] == "setDescription":
            from ._schemas.discount_code import DiscountCodeSetDescriptionActionSchema

            return DiscountCodeSetDescriptionActionSchema().load(data)
        if data["action"] == "setKey":
            from ._schemas.discount_code import DiscountCodeSetKeyActionSchema

            return DiscountCodeSetKeyActionSchema().load(data)
        if data["action"] == "setMaxApplications":
            from ._schemas.discount_code import (
                DiscountCodeSetMaxApplicationsActionSchema,
            )

            return DiscountCodeSetMaxApplicationsActionSchema().load(data)
        if data["action"] == "setMaxApplicationsPerCustomer":
            from ._schemas.discount_code import (
                DiscountCodeSetMaxApplicationsPerCustomerActionSchema,
            )

            return DiscountCodeSetMaxApplicationsPerCustomerActionSchema().load(data)
        if data["action"] == "setName":
            from ._schemas.discount_code import DiscountCodeSetNameActionSchema

            return DiscountCodeSetNameActionSchema().load(data)
        if data["action"] == "setValidFrom":
            from ._schemas.discount_code import DiscountCodeSetValidFromActionSchema

            return DiscountCodeSetValidFromActionSchema().load(data)
        if data["action"] == "setValidFromAndUntil":
            from ._schemas.discount_code import (
                DiscountCodeSetValidFromAndUntilActionSchema,
            )

            return DiscountCodeSetValidFromAndUntilActionSchema().load(data)
        if data["action"] == "setValidUntil":
            from ._schemas.discount_code import DiscountCodeSetValidUntilActionSchema

            return DiscountCodeSetValidUntilActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.discount_code import DiscountCodeUpdateActionSchema

        return DiscountCodeUpdateActionSchema().dump(self)


class DiscountCodeChangeCartDiscountsAction(DiscountCodeUpdateAction):
    #: New value to set.
    cart_discounts: typing.List["CartDiscountResourceIdentifier"]

    def __init__(
        self, *, cart_discounts: typing.List["CartDiscountResourceIdentifier"]
    ):
        self.cart_discounts = cart_discounts

        super().__init__(action="changeCartDiscounts")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "DiscountCodeChangeCartDiscountsAction":
        from ._schemas.discount_code import DiscountCodeChangeCartDiscountsActionSchema

        return DiscountCodeChangeCartDiscountsActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.discount_code import DiscountCodeChangeCartDiscountsActionSchema

        return DiscountCodeChangeCartDiscountsActionSchema().dump(self)


class DiscountCodeChangeGroupsAction(DiscountCodeUpdateAction):
    #: New value to set. An empty array removes the DiscountCode from all groups.
    groups: typing.List["str"]

    def __init__(self, *, groups: typing.List["str"]):
        self.groups = groups

        super().__init__(action="changeGroups")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "DiscountCodeChangeGroupsAction":
        from ._schemas.discount_code import DiscountCodeChangeGroupsActionSchema

        return DiscountCodeChangeGroupsActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.discount_code import DiscountCodeChangeGroupsActionSchema

        return DiscountCodeChangeGroupsActionSchema().dump(self)


class DiscountCodeChangeIsActiveAction(DiscountCodeUpdateAction):
    #: New value to set. Set to `true` to activate the DiscountCode for all matching Discounts.
    is_active: bool

    def __init__(self, *, is_active: bool):
        self.is_active = is_active

        super().__init__(action="changeIsActive")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "DiscountCodeChangeIsActiveAction":
        from ._schemas.discount_code import DiscountCodeChangeIsActiveActionSchema

        return DiscountCodeChangeIsActiveActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.discount_code import DiscountCodeChangeIsActiveActionSchema

        return DiscountCodeChangeIsActiveActionSchema().dump(self)


class DiscountCodeSetCartPredicateAction(DiscountCodeUpdateAction):
    #: Value to set. If empty, any existing value will be removed.
    cart_predicate: typing.Optional[str]

    def __init__(self, *, cart_predicate: typing.Optional[str] = None):
        self.cart_predicate = cart_predicate

        super().__init__(action="setCartPredicate")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "DiscountCodeSetCartPredicateAction":
        from ._schemas.discount_code import DiscountCodeSetCartPredicateActionSchema

        return DiscountCodeSetCartPredicateActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.discount_code import DiscountCodeSetCartPredicateActionSchema

        return DiscountCodeSetCartPredicateActionSchema().dump(self)


class DiscountCodeSetCustomFieldAction(DiscountCodeUpdateAction):
    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: Removing a field that does not exist returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
    #: If `value` is provided, it is set for the field defined by `name`.
    value: typing.Optional[typing.Any]

    def __init__(self, *, name: str, value: typing.Optional[typing.Any] = None):
        self.name = name
        self.value = value

        super().__init__(action="setCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "DiscountCodeSetCustomFieldAction":
        from ._schemas.discount_code import DiscountCodeSetCustomFieldActionSchema

        return DiscountCodeSetCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.discount_code import DiscountCodeSetCustomFieldActionSchema

        return DiscountCodeSetCustomFieldActionSchema().dump(self)


class DiscountCodeSetCustomTypeAction(DiscountCodeUpdateAction):
    #: Defines the [Type](ctp:api:type:Type) that extends the DiscountCode with [Custom Fields](/../api/projects/custom-fields).
    #: If absent, any existing Type and Custom Fields are removed from the DiscountCode.
    type: typing.Optional["TypeResourceIdentifier"]
    #: Sets the [Custom Fields](/../api/projects/custom-fields) fields for the DiscountCode.
    fields: typing.Optional["FieldContainer"]

    def __init__(
        self,
        *,
        type: typing.Optional["TypeResourceIdentifier"] = None,
        fields: typing.Optional["FieldContainer"] = None
    ):
        self.type = type
        self.fields = fields

        super().__init__(action="setCustomType")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "DiscountCodeSetCustomTypeAction":
        from ._schemas.discount_code import DiscountCodeSetCustomTypeActionSchema

        return DiscountCodeSetCustomTypeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.discount_code import DiscountCodeSetCustomTypeActionSchema

        return DiscountCodeSetCustomTypeActionSchema().dump(self)


class DiscountCodeSetDescriptionAction(DiscountCodeUpdateAction):
    #: Value to set. If empty, any existing value will be removed.
    description: typing.Optional["LocalizedString"]

    def __init__(self, *, description: typing.Optional["LocalizedString"] = None):
        self.description = description

        super().__init__(action="setDescription")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "DiscountCodeSetDescriptionAction":
        from ._schemas.discount_code import DiscountCodeSetDescriptionActionSchema

        return DiscountCodeSetDescriptionActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.discount_code import DiscountCodeSetDescriptionActionSchema

        return DiscountCodeSetDescriptionActionSchema().dump(self)


class DiscountCodeSetKeyAction(DiscountCodeUpdateAction):
    """This action generates a [DiscountCodeKeySet](ctp:api:type:DiscountCodeKeySetMessage) Message."""

    #: Unique value to set.
    #: If empty, any existing value will be removed.
    key: typing.Optional[str]

    def __init__(self, *, key: typing.Optional[str] = None):
        self.key = key

        super().__init__(action="setKey")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "DiscountCodeSetKeyAction":
        from ._schemas.discount_code import DiscountCodeSetKeyActionSchema

        return DiscountCodeSetKeyActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.discount_code import DiscountCodeSetKeyActionSchema

        return DiscountCodeSetKeyActionSchema().dump(self)


class DiscountCodeSetMaxApplicationsAction(DiscountCodeUpdateAction):
    #: Value to set. If empty, any existing value will be removed.
    max_applications: typing.Optional[int]

    def __init__(self, *, max_applications: typing.Optional[int] = None):
        self.max_applications = max_applications

        super().__init__(action="setMaxApplications")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "DiscountCodeSetMaxApplicationsAction":
        from ._schemas.discount_code import DiscountCodeSetMaxApplicationsActionSchema

        return DiscountCodeSetMaxApplicationsActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.discount_code import DiscountCodeSetMaxApplicationsActionSchema

        return DiscountCodeSetMaxApplicationsActionSchema().dump(self)


class DiscountCodeSetMaxApplicationsPerCustomerAction(DiscountCodeUpdateAction):
    #: Value to set. If empty, any existing value will be removed.
    max_applications_per_customer: typing.Optional[int]

    def __init__(self, *, max_applications_per_customer: typing.Optional[int] = None):
        self.max_applications_per_customer = max_applications_per_customer

        super().__init__(action="setMaxApplicationsPerCustomer")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "DiscountCodeSetMaxApplicationsPerCustomerAction":
        from ._schemas.discount_code import (
            DiscountCodeSetMaxApplicationsPerCustomerActionSchema,
        )

        return DiscountCodeSetMaxApplicationsPerCustomerActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.discount_code import (
            DiscountCodeSetMaxApplicationsPerCustomerActionSchema,
        )

        return DiscountCodeSetMaxApplicationsPerCustomerActionSchema().dump(self)


class DiscountCodeSetNameAction(DiscountCodeUpdateAction):
    #: Value to set. If empty, any existing value will be removed.
    name: typing.Optional["LocalizedString"]

    def __init__(self, *, name: typing.Optional["LocalizedString"] = None):
        self.name = name

        super().__init__(action="setName")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "DiscountCodeSetNameAction":
        from ._schemas.discount_code import DiscountCodeSetNameActionSchema

        return DiscountCodeSetNameActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.discount_code import DiscountCodeSetNameActionSchema

        return DiscountCodeSetNameActionSchema().dump(self)


class DiscountCodeSetValidFromAction(DiscountCodeUpdateAction):
    #: Value to set that must be earlier than `validUntil`. If empty, any existing value will be removed.
    valid_from: typing.Optional[datetime.datetime]

    def __init__(self, *, valid_from: typing.Optional[datetime.datetime] = None):
        self.valid_from = valid_from

        super().__init__(action="setValidFrom")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "DiscountCodeSetValidFromAction":
        from ._schemas.discount_code import DiscountCodeSetValidFromActionSchema

        return DiscountCodeSetValidFromActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.discount_code import DiscountCodeSetValidFromActionSchema

        return DiscountCodeSetValidFromActionSchema().dump(self)


class DiscountCodeSetValidFromAndUntilAction(DiscountCodeUpdateAction):
    #: Value to set that must be earlier than `validUntil`. If empty, any existing value will be removed.
    valid_from: typing.Optional[datetime.datetime]
    #: Value to set that must be later than `validFrom`. If empty, any existing value will be removed.
    valid_until: typing.Optional[datetime.datetime]

    def __init__(
        self,
        *,
        valid_from: typing.Optional[datetime.datetime] = None,
        valid_until: typing.Optional[datetime.datetime] = None
    ):
        self.valid_from = valid_from
        self.valid_until = valid_until

        super().__init__(action="setValidFromAndUntil")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "DiscountCodeSetValidFromAndUntilAction":
        from ._schemas.discount_code import DiscountCodeSetValidFromAndUntilActionSchema

        return DiscountCodeSetValidFromAndUntilActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.discount_code import DiscountCodeSetValidFromAndUntilActionSchema

        return DiscountCodeSetValidFromAndUntilActionSchema().dump(self)


class DiscountCodeSetValidUntilAction(DiscountCodeUpdateAction):
    #: Value to set that must be later than `validFrom`. If empty, any existing value will be removed.
    valid_until: typing.Optional[datetime.datetime]

    def __init__(self, *, valid_until: typing.Optional[datetime.datetime] = None):
        self.valid_until = valid_until

        super().__init__(action="setValidUntil")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "DiscountCodeSetValidUntilAction":
        from ._schemas.discount_code import DiscountCodeSetValidUntilActionSchema

        return DiscountCodeSetValidUntilActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.discount_code import DiscountCodeSetValidUntilActionSchema

        return DiscountCodeSetValidUntilActionSchema().dump(self)
