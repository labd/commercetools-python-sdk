# This file is automatically generated by the rmf-codegen project.
#
# The Python code generator is maintained by Lab Digital. If you want to
# contribute to this project then please do not edit this file directly
# but send a pull request to the Lab Digital fork of rmf-codegen at
# https://github.com/labd/rmf-codegen

import datetime
import enum
import typing

from ._abstract import _BaseType
from .common import BaseResource

if typing.TYPE_CHECKING:
    from .common import CreatedBy, LastModifiedBy, Reference

__all__ = [
    "AWSLambdaDestination",
    "AuthorizationHeaderAuthentication",
    "AzureFunctionsAuthentication",
    "Extension",
    "ExtensionAction",
    "ExtensionChangeDestinationAction",
    "ExtensionChangeTriggersAction",
    "ExtensionDestination",
    "ExtensionDraft",
    "ExtensionInput",
    "ExtensionPagedQueryResponse",
    "ExtensionResourceTypeId",
    "ExtensionSetKeyAction",
    "ExtensionSetTimeoutInMsAction",
    "ExtensionTrigger",
    "ExtensionUpdate",
    "ExtensionUpdateAction",
    "GoogleCloudFunctionDestination",
    "HttpDestination",
    "HttpDestinationAuthentication",
]


class Extension(BaseResource):
    #: Present on resources created after 1 February 2019 except for [events not tracked](/../api/client-logging#events-tracked).
    last_modified_by: typing.Optional["LastModifiedBy"]
    #: Present on resources created after 1 February 2019 except for [events not tracked](/../api/client-logging#events-tracked).
    created_by: typing.Optional["CreatedBy"]
    #: User-defined unique identifier of the Extension.
    key: typing.Optional[str]
    #: The configuration for the Extension, including its type, location and authentication details.
    destination: "ExtensionDestination"
    #: Describes what triggers the Extension.
    triggers: typing.List["ExtensionTrigger"]
    #: Maximum time (in milliseconds) that the Extension can respond within.
    #: If no timeout is provided, the default value is used for all types of Extensions.
    #: The maximum value is 10000 ms (10 seconds) for `payment` Extensions and 2000 ms (2 seconds) for all other Extensions.
    timeout_in_ms: typing.Optional[int]

    def __init__(
        self,
        *,
        id: str,
        version: int,
        created_at: datetime.datetime,
        last_modified_at: datetime.datetime,
        last_modified_by: typing.Optional["LastModifiedBy"] = None,
        created_by: typing.Optional["CreatedBy"] = None,
        key: typing.Optional[str] = None,
        destination: "ExtensionDestination",
        triggers: typing.List["ExtensionTrigger"],
        timeout_in_ms: typing.Optional[int] = None
    ):
        self.last_modified_by = last_modified_by
        self.created_by = created_by
        self.key = key
        self.destination = destination
        self.triggers = triggers
        self.timeout_in_ms = timeout_in_ms

        super().__init__(
            id=id,
            version=version,
            created_at=created_at,
            last_modified_at=last_modified_at,
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "Extension":
        from ._schemas.extension import ExtensionSchema

        return ExtensionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.extension import ExtensionSchema

        return ExtensionSchema().dump(self)


class ExtensionAction(enum.Enum):
    """An Extension gets called during any of the following requests of an API call, but before the result is persisted."""

    CREATE = "Create"
    UPDATE = "Update"


class ExtensionDestination(_BaseType):
    """Generic type for destinations."""

    type: str

    def __init__(self, *, type: str):
        self.type = type

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ExtensionDestination":
        if data["type"] == "AWSLambda":
            from ._schemas.extension import AWSLambdaDestinationSchema

            return AWSLambdaDestinationSchema().load(data)
        if data["type"] == "GoogleCloudFunction":
            from ._schemas.extension import GoogleCloudFunctionDestinationSchema

            return GoogleCloudFunctionDestinationSchema().load(data)
        if data["type"] == "HTTP":
            from ._schemas.extension import HttpDestinationSchema

            return HttpDestinationSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.extension import ExtensionDestinationSchema

        return ExtensionDestinationSchema().dump(self)


class AWSLambdaDestination(ExtensionDestination):
    """We recommend creating an Identify and Access Management (IAM) user with an `accessKey` and `accessSecret` pair, specifically for each Extension that only has the `lambda:InvokeFunction` permission on this function."""

    #: Amazon Resource Name (ARN) of the Lambda function in the format `arn:aws:lambda:<region>:<accountid>:function:<functionName>`. Use the format `arn:aws:lambda:<region>:<accountid>:function:<functionName>:<functionAlias/version>` to point to a specific version of the function.
    arn: str
    #: Partially hidden on retrieval for security reasons.
    access_key: str
    #: Partially hidden on retrieval for security reasons.
    access_secret: str

    def __init__(self, *, arn: str, access_key: str, access_secret: str):
        self.arn = arn
        self.access_key = access_key
        self.access_secret = access_secret

        super().__init__(type="AWSLambda")

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "AWSLambdaDestination":
        from ._schemas.extension import AWSLambdaDestinationSchema

        return AWSLambdaDestinationSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.extension import AWSLambdaDestinationSchema

        return AWSLambdaDestinationSchema().dump(self)


class ExtensionDraft(_BaseType):
    #: User-defined unique identifier for the Extension.
    key: typing.Optional[str]
    #: Defines where the Extension can be reached.
    destination: "ExtensionDestination"
    #: Describes what triggers the Extension.
    triggers: typing.List["ExtensionTrigger"]
    #: Maximum time (in milliseconds) the Extension can respond within.
    #: If no timeout is provided, the default value is used for all types of Extensions.
    #: The maximum value is 10000 ms (10 seconds) for `payment` Extensions and 2000 ms (2 seconds) for all other Extensions.
    #:
    #: This limit can be increased per Project after we review the performance impact.
    #: Please contact our support via the [Support Portal](https://support.commercetools.com) and provide the Region, Project key, and use case.
    timeout_in_ms: typing.Optional[int]

    def __init__(
        self,
        *,
        key: typing.Optional[str] = None,
        destination: "ExtensionDestination",
        triggers: typing.List["ExtensionTrigger"],
        timeout_in_ms: typing.Optional[int] = None
    ):
        self.key = key
        self.destination = destination
        self.triggers = triggers
        self.timeout_in_ms = timeout_in_ms

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ExtensionDraft":
        from ._schemas.extension import ExtensionDraftSchema

        return ExtensionDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.extension import ExtensionDraftSchema

        return ExtensionDraftSchema().dump(self)


class ExtensionInput(_BaseType):
    #: `Create` or `Update` request.
    action: "ExtensionAction"
    #: Expanded reference to the resource that triggered the Extension.
    resource: "Reference"

    def __init__(self, *, action: "ExtensionAction", resource: "Reference"):
        self.action = action
        self.resource = resource

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ExtensionInput":
        from ._schemas.extension import ExtensionInputSchema

        return ExtensionInputSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.extension import ExtensionInputSchema

        return ExtensionInputSchema().dump(self)


class ExtensionPagedQueryResponse(_BaseType):
    """[PagedQueryResult](/../api/general-concepts#pagedqueryresult) with `results` containing an array of [Extension](ctp:api:type:Extension)."""

    #: Number of [results requested](/../api/general-concepts#limit).
    limit: int
    #: Number of [elements skipped](/../api/general-concepts#offset).
    offset: int
    #: Actual number of results returned.
    count: int
    #: Total number of results matching the query.
    #: This number is an estimation that is not [strongly consistent](/../api/general-concepts#strong-consistency).
    #: This field is returned by default.
    #: For improved performance, calculating this field can be deactivated by using the query parameter `withTotal=false`.
    #: When the results are filtered with a [Query Predicate](/../api/predicates/query), `total` is subject to a [limit](/../api/limits#queries).
    total: typing.Optional[int]
    #: Extensions matching the query.
    results: typing.List["Extension"]

    def __init__(
        self,
        *,
        limit: int,
        offset: int,
        count: int,
        total: typing.Optional[int] = None,
        results: typing.List["Extension"]
    ):
        self.limit = limit
        self.offset = offset
        self.count = count
        self.total = total
        self.results = results

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ExtensionPagedQueryResponse":
        from ._schemas.extension import ExtensionPagedQueryResponseSchema

        return ExtensionPagedQueryResponseSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.extension import ExtensionPagedQueryResponseSchema

        return ExtensionPagedQueryResponseSchema().dump(self)


class ExtensionResourceTypeId(enum.Enum):
    """Extensions are available for:"""

    CART = "cart"
    ORDER = "order"
    PAYMENT = "payment"
    CUSTOMER = "customer"
    QUOTE_REQUEST = "quote-request"
    STAGED_QUOTE = "staged-quote"
    QUOTE = "quote"
    BUSINESS_UNIT = "business-unit"


class ExtensionTrigger(_BaseType):
    #: `cart`, `order`, `payment`, `customer`, `quote-request`, `staged-quote`, `quote`, and `business-unit` are supported.
    resource_type_id: "ExtensionResourceTypeId"
    #: `Create` and `Update` requests are supported.
    actions: typing.List["ExtensionAction"]
    #: Valid [predicate](/../api/predicates/query) that controls the conditions under which the API Extension is called. The Extension is not triggered when the specified condition is not fulfilled.
    condition: typing.Optional[str]

    def __init__(
        self,
        *,
        resource_type_id: "ExtensionResourceTypeId",
        actions: typing.List["ExtensionAction"],
        condition: typing.Optional[str] = None
    ):
        self.resource_type_id = resource_type_id
        self.actions = actions
        self.condition = condition

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ExtensionTrigger":
        from ._schemas.extension import ExtensionTriggerSchema

        return ExtensionTriggerSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.extension import ExtensionTriggerSchema

        return ExtensionTriggerSchema().dump(self)


class ExtensionUpdate(_BaseType):
    #: Expected version of the Extension on which the changes should be applied. If the expected version does not match the actual version, a [ConcurrentModification](ctp:api:type:ConcurrentModificationError) error is returned.
    version: int
    #: Update actions to be performed on the Extension.
    actions: typing.List["ExtensionUpdateAction"]

    def __init__(self, *, version: int, actions: typing.List["ExtensionUpdateAction"]):
        self.version = version
        self.actions = actions

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ExtensionUpdate":
        from ._schemas.extension import ExtensionUpdateSchema

        return ExtensionUpdateSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.extension import ExtensionUpdateSchema

        return ExtensionUpdateSchema().dump(self)


class ExtensionUpdateAction(_BaseType):
    action: str

    def __init__(self, *, action: str):
        self.action = action

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ExtensionUpdateAction":
        if data["action"] == "changeDestination":
            from ._schemas.extension import ExtensionChangeDestinationActionSchema

            return ExtensionChangeDestinationActionSchema().load(data)
        if data["action"] == "changeTriggers":
            from ._schemas.extension import ExtensionChangeTriggersActionSchema

            return ExtensionChangeTriggersActionSchema().load(data)
        if data["action"] == "setKey":
            from ._schemas.extension import ExtensionSetKeyActionSchema

            return ExtensionSetKeyActionSchema().load(data)
        if data["action"] == "setTimeoutInMs":
            from ._schemas.extension import ExtensionSetTimeoutInMsActionSchema

            return ExtensionSetTimeoutInMsActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.extension import ExtensionUpdateActionSchema

        return ExtensionUpdateActionSchema().dump(self)


class GoogleCloudFunctionDestination(ExtensionDestination):
    """For GoogleCloudFunction destinations, you need to grant permissions to the `extensions@commercetools-platform.iam.gserviceaccount.com` service account to invoke your function. If your function's version is 1st gen, grant the service account the IAM role `Cloud Functions Invoker`. For version 2nd gen, assign the IAM role `Cloud Run Invoker` using the Cloud Run console."""

    #: URL to the target function.
    url: str

    def __init__(self, *, url: str):
        self.url = url

        super().__init__(type="GoogleCloudFunction")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "GoogleCloudFunctionDestination":
        from ._schemas.extension import GoogleCloudFunctionDestinationSchema

        return GoogleCloudFunctionDestinationSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.extension import GoogleCloudFunctionDestinationSchema

        return GoogleCloudFunctionDestinationSchema().dump(self)


class HttpDestination(ExtensionDestination):
    """We recommend an encrypted `HTTPS` connection for production setups. However, we also accept unencrypted `HTTP` connections for development purposes. HTTP redirects will not be followed and cache headers will be ignored."""

    #: URL to the target destination. If the Project is hosted in the China (AWS, Ningxia) Region, verify that the URL is not blocked due to firewall restrictions.
    url: str
    #: Authentication methods (such as `Basic` or `Bearer`).
    authentication: typing.Optional["HttpDestinationAuthentication"]

    def __init__(
        self,
        *,
        url: str,
        authentication: typing.Optional["HttpDestinationAuthentication"] = None
    ):
        self.url = url
        self.authentication = authentication

        super().__init__(type="HTTP")

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "HttpDestination":
        from ._schemas.extension import HttpDestinationSchema

        return HttpDestinationSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.extension import HttpDestinationSchema

        return HttpDestinationSchema().dump(self)


class HttpDestinationAuthentication(_BaseType):
    type: str

    def __init__(self, *, type: str):
        self.type = type

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "HttpDestinationAuthentication":
        if data["type"] == "AuthorizationHeader":
            from ._schemas.extension import AuthorizationHeaderAuthenticationSchema

            return AuthorizationHeaderAuthenticationSchema().load(data)
        if data["type"] == "AzureFunctions":
            from ._schemas.extension import AzureFunctionsAuthenticationSchema

            return AzureFunctionsAuthenticationSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.extension import HttpDestinationAuthenticationSchema

        return HttpDestinationAuthenticationSchema().dump(self)


class AuthorizationHeaderAuthentication(HttpDestinationAuthentication):
    """The `Authorization` header will be set to the content of `headerValue`. The authentication scheme (such as `Basic` or `Bearer`) should be included in the `headerValue`.

    For example, the `headerValue` for [Basic Authentication](https://datatracker.ietf.org/doc/html/rfc7617) should be set to `Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==`.

    """

    #: Partially hidden on retrieval for security reasons.
    header_value: str

    def __init__(self, *, header_value: str):
        self.header_value = header_value

        super().__init__(type="AuthorizationHeader")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "AuthorizationHeaderAuthentication":
        from ._schemas.extension import AuthorizationHeaderAuthenticationSchema

        return AuthorizationHeaderAuthenticationSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.extension import AuthorizationHeaderAuthenticationSchema

        return AuthorizationHeaderAuthenticationSchema().dump(self)


class AzureFunctionsAuthentication(HttpDestinationAuthentication):
    """To protect your Azure Function, set its `authLevel` to `function` and provide the function's key to be used inside the `x-functions-key` header. For more information, see the [Azure Functions documentation](https://docs.microsoft.com/en-us/azure/azure-functions/functions-bindings-http-webhook#keys).

    To protect the secret key from being exposed, remove the code parameter and secret key from the URL. For example, use `https://foo.azurewebsites.net/api/bar` instead of
    `https://foo.azurewebsites.net/api/bar?code=secret`.

    """

    #: Partially hidden on retrieval for security reasons.
    key: str

    def __init__(self, *, key: str):
        self.key = key

        super().__init__(type="AzureFunctions")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "AzureFunctionsAuthentication":
        from ._schemas.extension import AzureFunctionsAuthenticationSchema

        return AzureFunctionsAuthenticationSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.extension import AzureFunctionsAuthenticationSchema

        return AzureFunctionsAuthenticationSchema().dump(self)


class ExtensionChangeDestinationAction(ExtensionUpdateAction):
    #: New value to set. Must not be empty.
    destination: "ExtensionDestination"

    def __init__(self, *, destination: "ExtensionDestination"):
        self.destination = destination

        super().__init__(action="changeDestination")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ExtensionChangeDestinationAction":
        from ._schemas.extension import ExtensionChangeDestinationActionSchema

        return ExtensionChangeDestinationActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.extension import ExtensionChangeDestinationActionSchema

        return ExtensionChangeDestinationActionSchema().dump(self)


class ExtensionChangeTriggersAction(ExtensionUpdateAction):
    #: New value to set. Must not be empty.
    triggers: typing.List["ExtensionTrigger"]

    def __init__(self, *, triggers: typing.List["ExtensionTrigger"]):
        self.triggers = triggers

        super().__init__(action="changeTriggers")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ExtensionChangeTriggersAction":
        from ._schemas.extension import ExtensionChangeTriggersActionSchema

        return ExtensionChangeTriggersActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.extension import ExtensionChangeTriggersActionSchema

        return ExtensionChangeTriggersActionSchema().dump(self)


class ExtensionSetKeyAction(ExtensionUpdateAction):
    #: Value to set. If empty, any existing value will be removed.
    key: typing.Optional[str]

    def __init__(self, *, key: typing.Optional[str] = None):
        self.key = key

        super().__init__(action="setKey")

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ExtensionSetKeyAction":
        from ._schemas.extension import ExtensionSetKeyActionSchema

        return ExtensionSetKeyActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.extension import ExtensionSetKeyActionSchema

        return ExtensionSetKeyActionSchema().dump(self)


class ExtensionSetTimeoutInMsAction(ExtensionUpdateAction):
    #: Value to set. If not defined, the maximum value is used.
    #: If no timeout is provided, the default value is used for all types of Extensions.
    #: The maximum value is 10000 ms (10 seconds) for `payment` Extensions and 2000 ms (2 seconds) for all other Extensions.
    #:
    #: This limit can be increased per Project after we review the performance impact.
    #: Please contact our support via the [Support Portal](https://support.commercetools.com/) and provide the Region, Project key, and use case.
    timeout_in_ms: typing.Optional[int]

    def __init__(self, *, timeout_in_ms: typing.Optional[int] = None):
        self.timeout_in_ms = timeout_in_ms

        super().__init__(action="setTimeoutInMs")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ExtensionSetTimeoutInMsAction":
        from ._schemas.extension import ExtensionSetTimeoutInMsActionSchema

        return ExtensionSetTimeoutInMsActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.extension import ExtensionSetTimeoutInMsActionSchema

        return ExtensionSetTimeoutInMsActionSchema().dump(self)
