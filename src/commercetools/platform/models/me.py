# This file is automatically generated by the rmf-codegen project.
#
# The Python code generator is maintained by Lab Digital. If you want to
# contribute to this project then please do not edit this file directly
# but send a pull request to the Lab Digital fork of rmf-codegen at
# https://github.com/labd/rmf-codegen

import datetime
import enum
import typing

from ._abstract import _BaseType
from .business_unit import BusinessUnitType
from .cart import InventoryMode, ShippingMode, TaxMode
from .payment import TransactionType

if typing.TYPE_CHECKING:
    from .business_unit import (
        AssociateDraft,
        AssociateRoleAssignmentDraft,
        BusinessUnitResourceIdentifier,
        BusinessUnitType,
        BusinessUnitUpdateAction,
    )
    from .cart import (
        CartReference,
        ExternalLineItemTotalPrice,
        ExternalTaxRateDraft,
        InventoryMode,
        ItemShippingDetailsDraft,
        ItemShippingTarget,
        ShippingMode,
        TaxMode,
    )
    from .channel import ChannelResourceIdentifier
    from .common import BaseAddress, CentPrecisionMoney, LocalizedString, Money
    from .customer import CustomerReference, CustomerResourceIdentifier
    from .discount_code import DiscountCodeReference
    from .order import OrderReference
    from .payment import (
        PaymentMethodInfo,
        PaymentResourceIdentifier,
        Transaction,
        TransactionDraft,
        TransactionType,
    )
    from .shipping_method import ShippingMethodResourceIdentifier
    from .shopping_list import ShoppingListLineItemDraft, TextLineItemDraft
    from .store import StoreResourceIdentifier
    from .type import (
        CustomFields,
        CustomFieldsDraft,
        FieldContainer,
        TypeResourceIdentifier,
    )

__all__ = [
    "MyBusinessUnitAddAddressAction",
    "MyBusinessUnitAddBillingAddressIdAction",
    "MyBusinessUnitAddShippingAddressIdAction",
    "MyBusinessUnitAssociateDraft",
    "MyBusinessUnitChangeAddressAction",
    "MyBusinessUnitChangeAssociateAction",
    "MyBusinessUnitChangeNameAction",
    "MyBusinessUnitChangeParentUnitAction",
    "MyBusinessUnitDraft",
    "MyBusinessUnitRemoveAddressAction",
    "MyBusinessUnitRemoveAssociateAction",
    "MyBusinessUnitRemoveBillingAddressIdAction",
    "MyBusinessUnitRemoveShippingAddressIdAction",
    "MyBusinessUnitSetAddressCustomFieldAction",
    "MyBusinessUnitSetAddressCustomTypeAction",
    "MyBusinessUnitSetContactEmailAction",
    "MyBusinessUnitSetCustomFieldAction",
    "MyBusinessUnitSetCustomTypeAction",
    "MyBusinessUnitSetDefaultBillingAddressAction",
    "MyBusinessUnitSetDefaultShippingAddressAction",
    "MyBusinessUnitUpdate",
    "MyBusinessUnitUpdateAction",
    "MyCartAddDiscountCodeAction",
    "MyCartAddItemShippingAddressAction",
    "MyCartAddLineItemAction",
    "MyCartAddPaymentAction",
    "MyCartApplyDeltaToLineItemShippingDetailsTargetsAction",
    "MyCartChangeLineItemQuantityAction",
    "MyCartChangeTaxModeAction",
    "MyCartDraft",
    "MyCartRecalculateAction",
    "MyCartRemoveDiscountCodeAction",
    "MyCartRemoveItemShippingAddressAction",
    "MyCartRemoveLineItemAction",
    "MyCartRemovePaymentAction",
    "MyCartSetBillingAddressAction",
    "MyCartSetBusinessUnitAction",
    "MyCartSetCountryAction",
    "MyCartSetCustomFieldAction",
    "MyCartSetCustomTypeAction",
    "MyCartSetCustomerEmailAction",
    "MyCartSetDeleteDaysAfterLastModificationAction",
    "MyCartSetLineItemCustomFieldAction",
    "MyCartSetLineItemCustomTypeAction",
    "MyCartSetLineItemDistributionChannelAction",
    "MyCartSetLineItemShippingDetailsAction",
    "MyCartSetLineItemSupplyChannelAction",
    "MyCartSetLocaleAction",
    "MyCartSetShippingAddressAction",
    "MyCartSetShippingMethodAction",
    "MyCartUpdate",
    "MyCartUpdateAction",
    "MyCartUpdateItemShippingAddressAction",
    "MyCompanyDraft",
    "MyCustomerAddAddressAction",
    "MyCustomerAddBillingAddressIdAction",
    "MyCustomerAddShippingAddressIdAction",
    "MyCustomerChangeAddressAction",
    "MyCustomerChangeEmailAction",
    "MyCustomerDraft",
    "MyCustomerRemoveAddressAction",
    "MyCustomerRemoveBillingAddressIdAction",
    "MyCustomerRemoveShippingAddressIdAction",
    "MyCustomerSetCompanyNameAction",
    "MyCustomerSetCustomFieldAction",
    "MyCustomerSetCustomTypeAction",
    "MyCustomerSetDateOfBirthAction",
    "MyCustomerSetDefaultBillingAddressAction",
    "MyCustomerSetDefaultShippingAddressAction",
    "MyCustomerSetFirstNameAction",
    "MyCustomerSetLastNameAction",
    "MyCustomerSetLocaleAction",
    "MyCustomerSetMiddleNameAction",
    "MyCustomerSetSalutationAction",
    "MyCustomerSetTitleAction",
    "MyCustomerSetVatIdAction",
    "MyCustomerUpdate",
    "MyCustomerUpdateAction",
    "MyDivisionDraft",
    "MyLineItemDraft",
    "MyOrderFromCartDraft",
    "MyOrderFromQuoteDraft",
    "MyPayment",
    "MyPaymentAddTransactionAction",
    "MyPaymentChangeAmountPlannedAction",
    "MyPaymentDraft",
    "MyPaymentPagedQueryResponse",
    "MyPaymentSetCustomFieldAction",
    "MyPaymentSetMethodInfoInterfaceAction",
    "MyPaymentSetMethodInfoMethodAction",
    "MyPaymentSetMethodInfoNameAction",
    "MyPaymentSetTransactionCustomFieldAction",
    "MyPaymentUpdate",
    "MyPaymentUpdateAction",
    "MyQuoteChangeMyQuoteStateAction",
    "MyQuoteRequestCancelAction",
    "MyQuoteRequestDraft",
    "MyQuoteRequestUpdate",
    "MyQuoteRequestUpdateAction",
    "MyQuoteState",
    "MyQuoteUpdate",
    "MyQuoteUpdateAction",
    "MyShoppingListAddLineItemAction",
    "MyShoppingListAddTextLineItemAction",
    "MyShoppingListChangeLineItemQuantityAction",
    "MyShoppingListChangeLineItemsOrderAction",
    "MyShoppingListChangeNameAction",
    "MyShoppingListChangeTextLineItemNameAction",
    "MyShoppingListChangeTextLineItemQuantityAction",
    "MyShoppingListChangeTextLineItemsOrderAction",
    "MyShoppingListDraft",
    "MyShoppingListRemoveLineItemAction",
    "MyShoppingListRemoveTextLineItemAction",
    "MyShoppingListSetCustomFieldAction",
    "MyShoppingListSetCustomTypeAction",
    "MyShoppingListSetDeleteDaysAfterLastModificationAction",
    "MyShoppingListSetDescriptionAction",
    "MyShoppingListSetLineItemCustomFieldAction",
    "MyShoppingListSetLineItemCustomTypeAction",
    "MyShoppingListSetTextLineItemCustomFieldAction",
    "MyShoppingListSetTextLineItemCustomTypeAction",
    "MyShoppingListSetTextLineItemDescriptionAction",
    "MyShoppingListUpdate",
    "MyShoppingListUpdateAction",
    "MyTransactionDraft",
    "ReplicaMyCartDraft",
]


class MyBusinessUnitAssociateDraft(_BaseType):
    #: Expected version of the BusinessUnit on which the changes should be applied.
    #: If the expected version does not match the actual version, a [ConcurrentModification](ctp:api:type:ConcurrentModificationError) error will be returned.
    version: int
    #: [Customer](ctp:api:type:Customer) to create and assign to the Business Unit.
    customer: "MyCustomerDraft"
    #: Roles assigned to the new Associate within a Business Unit. Can only contain [AssociateRoles](ctp:api:type:AssociateRole) with the `buyerAssignable` property set to `true`.
    associate_role_assignments: typing.List["AssociateRoleAssignmentDraft"]

    def __init__(
        self,
        *,
        version: int,
        customer: "MyCustomerDraft",
        associate_role_assignments: typing.List["AssociateRoleAssignmentDraft"]
    ):
        self.version = version
        self.customer = customer
        self.associate_role_assignments = associate_role_assignments

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyBusinessUnitAssociateDraft":
        from ._schemas.me import MyBusinessUnitAssociateDraftSchema

        return MyBusinessUnitAssociateDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyBusinessUnitAssociateDraftSchema

        return MyBusinessUnitAssociateDraftSchema().dump(self)


class MyBusinessUnitDraft(_BaseType):
    #: User-defined unique identifier for the BusinessUnit.
    key: str
    #: Type of the Business Unit indicating its position in a hierarchy.
    unit_type: "BusinessUnitType"
    #: Name of the Business Unit.
    name: str
    #: Email address of the Business Unit.
    contact_email: typing.Optional[str]
    #: Custom Fields for the Business Unit.
    custom: typing.Optional["CustomFields"]
    #: Addresses used by the Business Unit.
    addresses: typing.Optional[typing.List["BaseAddress"]]
    #: Indexes of entries in `addresses` to set as shipping addresses.
    #: The `shippingAddressIds` of the [Customer](ctp:api:type:Customer) will be replaced by these addresses.
    shipping_addresses: typing.Optional[typing.List["int"]]
    #: Index of the entry in `addresses` to set as the default shipping address.
    default_shipping_address: typing.Optional[int]
    #: Indexes of entries in `addresses` to set as billing addresses.
    #: The `billingAddressIds` of the [Customer](ctp:api:type:Customer) will be replaced by these addresses.
    billing_addresses: typing.Optional[typing.List["int"]]
    #: Index of the entry in `addresses` to set as the default billing address.
    default_billing_address: typing.Optional[int]

    def __init__(
        self,
        *,
        key: str,
        unit_type: "BusinessUnitType",
        name: str,
        contact_email: typing.Optional[str] = None,
        custom: typing.Optional["CustomFields"] = None,
        addresses: typing.Optional[typing.List["BaseAddress"]] = None,
        shipping_addresses: typing.Optional[typing.List["int"]] = None,
        default_shipping_address: typing.Optional[int] = None,
        billing_addresses: typing.Optional[typing.List["int"]] = None,
        default_billing_address: typing.Optional[int] = None
    ):
        self.key = key
        self.unit_type = unit_type
        self.name = name
        self.contact_email = contact_email
        self.custom = custom
        self.addresses = addresses
        self.shipping_addresses = shipping_addresses
        self.default_shipping_address = default_shipping_address
        self.billing_addresses = billing_addresses
        self.default_billing_address = default_billing_address

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "MyBusinessUnitDraft":
        if data["unitType"] == "Company":
            from ._schemas.me import MyCompanyDraftSchema

            return MyCompanyDraftSchema().load(data)
        if data["unitType"] == "Division":
            from ._schemas.me import MyDivisionDraftSchema

            return MyDivisionDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyBusinessUnitDraftSchema

        return MyBusinessUnitDraftSchema().dump(self)


class MyBusinessUnitUpdate(_BaseType):
    #: Expected version of the BusinessUnit on which the changes should be applied.
    #: If the expected version does not match the actual version, a [ConcurrentModification](ctp:api:type:ConcurrentModificationError) error will be returned.
    version: int
    #: Update actions to be performed on the BusinessUnit.
    actions: typing.List["BusinessUnitUpdateAction"]

    def __init__(
        self, *, version: int, actions: typing.List["BusinessUnitUpdateAction"]
    ):
        self.version = version
        self.actions = actions

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "MyBusinessUnitUpdate":
        from ._schemas.me import MyBusinessUnitUpdateSchema

        return MyBusinessUnitUpdateSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyBusinessUnitUpdateSchema

        return MyBusinessUnitUpdateSchema().dump(self)


class MyBusinessUnitUpdateAction(_BaseType):
    action: str

    def __init__(self, *, action: str):
        self.action = action

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyBusinessUnitUpdateAction":
        if data["action"] == "addAddress":
            from ._schemas.me import MyBusinessUnitAddAddressActionSchema

            return MyBusinessUnitAddAddressActionSchema().load(data)
        if data["action"] == "addBillingAddressId":
            from ._schemas.me import MyBusinessUnitAddBillingAddressIdActionSchema

            return MyBusinessUnitAddBillingAddressIdActionSchema().load(data)
        if data["action"] == "addShippingAddressId":
            from ._schemas.me import MyBusinessUnitAddShippingAddressIdActionSchema

            return MyBusinessUnitAddShippingAddressIdActionSchema().load(data)
        if data["action"] == "changeAddress":
            from ._schemas.me import MyBusinessUnitChangeAddressActionSchema

            return MyBusinessUnitChangeAddressActionSchema().load(data)
        if data["action"] == "changeAssociate":
            from ._schemas.me import MyBusinessUnitChangeAssociateActionSchema

            return MyBusinessUnitChangeAssociateActionSchema().load(data)
        if data["action"] == "changeName":
            from ._schemas.me import MyBusinessUnitChangeNameActionSchema

            return MyBusinessUnitChangeNameActionSchema().load(data)
        if data["action"] == "changeParentUnit":
            from ._schemas.me import MyBusinessUnitChangeParentUnitActionSchema

            return MyBusinessUnitChangeParentUnitActionSchema().load(data)
        if data["action"] == "removeAddress":
            from ._schemas.me import MyBusinessUnitRemoveAddressActionSchema

            return MyBusinessUnitRemoveAddressActionSchema().load(data)
        if data["action"] == "removeAssociate":
            from ._schemas.me import MyBusinessUnitRemoveAssociateActionSchema

            return MyBusinessUnitRemoveAssociateActionSchema().load(data)
        if data["action"] == "removeBillingAddressId":
            from ._schemas.me import MyBusinessUnitRemoveBillingAddressIdActionSchema

            return MyBusinessUnitRemoveBillingAddressIdActionSchema().load(data)
        if data["action"] == "removeShippingAddressId":
            from ._schemas.me import MyBusinessUnitRemoveShippingAddressIdActionSchema

            return MyBusinessUnitRemoveShippingAddressIdActionSchema().load(data)
        if data["action"] == "setAddressCustomField":
            from ._schemas.me import MyBusinessUnitSetAddressCustomFieldActionSchema

            return MyBusinessUnitSetAddressCustomFieldActionSchema().load(data)
        if data["action"] == "setAddressCustomType":
            from ._schemas.me import MyBusinessUnitSetAddressCustomTypeActionSchema

            return MyBusinessUnitSetAddressCustomTypeActionSchema().load(data)
        if data["action"] == "setContactEmail":
            from ._schemas.me import MyBusinessUnitSetContactEmailActionSchema

            return MyBusinessUnitSetContactEmailActionSchema().load(data)
        if data["action"] == "setCustomField":
            from ._schemas.me import MyBusinessUnitSetCustomFieldActionSchema

            return MyBusinessUnitSetCustomFieldActionSchema().load(data)
        if data["action"] == "setCustomType":
            from ._schemas.me import MyBusinessUnitSetCustomTypeActionSchema

            return MyBusinessUnitSetCustomTypeActionSchema().load(data)
        if data["action"] == "setDefaultBillingAddress":
            from ._schemas.me import MyBusinessUnitSetDefaultBillingAddressActionSchema

            return MyBusinessUnitSetDefaultBillingAddressActionSchema().load(data)
        if data["action"] == "setDefaultShippingAddress":
            from ._schemas.me import MyBusinessUnitSetDefaultShippingAddressActionSchema

            return MyBusinessUnitSetDefaultShippingAddressActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyBusinessUnitUpdateActionSchema

        return MyBusinessUnitUpdateActionSchema().dump(self)


class MyCartDraft(_BaseType):
    """The `customerId` is determined by a [password flow token](/../api/authorization#password-flow) and
    automatically set on the resulting [Cart](ctp:api:type:Cart).
    The `anonymousId` is determined by a [token for an anonymous session](ctp:api:type:AnonymousSession) and
    automatically set on the resulting [Cart](ctp:api:type:Cart).

    """

    #: Currency the Cart uses.
    currency: str
    #: Email address of the Customer the Cart belongs to.
    customer_email: typing.Optional[str]
    #: [ResourceIdentifier](ctp:api:type:ResourceIdentifier) to the Business Unit the Cart should belong to. The [Customer](ctp:api:type:Customer) must be an [Associate](ctp:api:type:Associate) of the Business Unit.
    business_unit: typing.Optional["BusinessUnitResourceIdentifier"]
    #: [ResourceIdentifier](ctp:api:type:ResourceIdentifier) to the Store the Cart should belong to. Once set, it cannot be updated.
    store: typing.Optional["StoreResourceIdentifier"]
    #: [Line Items](ctp:api:type:LineItems) to add to the Cart.
    line_items: typing.Optional[typing.List["MyLineItemDraft"]]
    #: Determines how Tax Rates are set. The `Disabled` TaxMode **cannot** be set.
    tax_mode: typing.Optional["TaxMode"]
    #: Determines how stock quantities are tracked for Line Items in the Cart.
    inventory_mode: typing.Optional["InventoryMode"]
    #: Billing address associated with the Cart.
    billing_address: typing.Optional["BaseAddress"]
    #: Shipping address associated with the Cart. Determines eligible [ShippingMethod](ctp:api:type:ShippingMethod) rates and Tax Rates of Line Items.
    shipping_address: typing.Optional["BaseAddress"]
    #: Shipping Method for the Cart. If the referenced [ShippingMethod](ctp:api:type:ShippingMethod) has a `predicate` that does not match the Cart, an [InvalidOperation](ctp:api:type:InvalidOperationError) error is returned when [creating a Cart](ctp:api:endpoint:/{projectKey}/carts:POST).
    shipping_method: typing.Optional["ShippingMethodResourceIdentifier"]
    #: Multiple shipping addresses of the Cart. Each address must contain a `key` that is unique in this Cart.
    #: The keys are used by [LineItems](ctp:api:type:LineItem) to reference these addresses under their `shippingDetails`.
    #:
    #: Eligible Shipping Methods or applicable Tax Rates are determined by the [Cart](ctp:api:type:Cart) `shippingAddress`, and not `itemShippingAddresses`.
    item_shipping_addresses: typing.Optional[typing.List["BaseAddress"]]
    #: - If set to `Single`, only a single Shipping Method can be added to the Cart.
    #: - If set to `Multiple`, multiple Shipping Methods can be added to the Cart.
    shipping_mode: typing.Optional["ShippingMode"]
    #: `code` of the existing [DiscountCodes](ctp:api:type:DiscountCode) to add to the Cart.
    discount_codes: typing.Optional[typing.List["str"]]
    #: Used for [LineItem Price selection](ctp:api:type:LineItemPriceSelection).
    #: If used for [Create Cart in Store](ctp:api:endpoint:/{projectKey}/in-store/me/carts:POST), the provided country must be one of the [Store's](ctp:api:type:Store) `countries`.
    country: typing.Optional[str]
    #: Languages of the Cart.
    #: Can only contain languages supported by the [Project](ctp:api:type:Project).
    locale: typing.Optional[str]
    #: Number of days after which a Cart with `Active` [CartState](ctp:api:type:CartState) is deleted since its last modification.
    #: If not provided, the default value for this field configured in [Project settings](ctp:api:type:CartsConfiguration) is assigned.
    #:
    #: Create a [ChangeSubscription](ctp:api:type:ChangeSubscription) for Carts to receive a [ResourceDeletedDeliveryPayload](ctp:api:type:ResourceDeletedDeliveryPayload) upon deletion of the Cart.
    delete_days_after_last_modification: typing.Optional[int]
    #: Custom Fields for the Cart.
    custom: typing.Optional["CustomFieldsDraft"]

    def __init__(
        self,
        *,
        currency: str,
        customer_email: typing.Optional[str] = None,
        business_unit: typing.Optional["BusinessUnitResourceIdentifier"] = None,
        store: typing.Optional["StoreResourceIdentifier"] = None,
        line_items: typing.Optional[typing.List["MyLineItemDraft"]] = None,
        tax_mode: typing.Optional["TaxMode"] = None,
        inventory_mode: typing.Optional["InventoryMode"] = None,
        billing_address: typing.Optional["BaseAddress"] = None,
        shipping_address: typing.Optional["BaseAddress"] = None,
        shipping_method: typing.Optional["ShippingMethodResourceIdentifier"] = None,
        item_shipping_addresses: typing.Optional[typing.List["BaseAddress"]] = None,
        shipping_mode: typing.Optional["ShippingMode"] = None,
        discount_codes: typing.Optional[typing.List["str"]] = None,
        country: typing.Optional[str] = None,
        locale: typing.Optional[str] = None,
        delete_days_after_last_modification: typing.Optional[int] = None,
        custom: typing.Optional["CustomFieldsDraft"] = None
    ):
        self.currency = currency
        self.customer_email = customer_email
        self.business_unit = business_unit
        self.store = store
        self.line_items = line_items
        self.tax_mode = tax_mode
        self.inventory_mode = inventory_mode
        self.billing_address = billing_address
        self.shipping_address = shipping_address
        self.shipping_method = shipping_method
        self.item_shipping_addresses = item_shipping_addresses
        self.shipping_mode = shipping_mode
        self.discount_codes = discount_codes
        self.country = country
        self.locale = locale
        self.delete_days_after_last_modification = delete_days_after_last_modification
        self.custom = custom

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "MyCartDraft":
        from ._schemas.me import MyCartDraftSchema

        return MyCartDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCartDraftSchema

        return MyCartDraftSchema().dump(self)


class MyCartUpdate(_BaseType):
    #: Expected version of the Cart on which the changes apply.
    #: If the expected version does not match the actual version, a [ConcurrentModification](ctp:api:type:ConcurrentModificationError) error will be returned.
    version: int
    #: Update actions to be performed on the Cart.
    actions: typing.List["MyCartUpdateAction"]

    def __init__(self, *, version: int, actions: typing.List["MyCartUpdateAction"]):
        self.version = version
        self.actions = actions

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "MyCartUpdate":
        from ._schemas.me import MyCartUpdateSchema

        return MyCartUpdateSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCartUpdateSchema

        return MyCartUpdateSchema().dump(self)


class MyCartUpdateAction(_BaseType):
    action: str

    def __init__(self, *, action: str):
        self.action = action

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "MyCartUpdateAction":
        if data["action"] == "addDiscountCode":
            from ._schemas.me import MyCartAddDiscountCodeActionSchema

            return MyCartAddDiscountCodeActionSchema().load(data)
        if data["action"] == "addItemShippingAddress":
            from ._schemas.me import MyCartAddItemShippingAddressActionSchema

            return MyCartAddItemShippingAddressActionSchema().load(data)
        if data["action"] == "addLineItem":
            from ._schemas.me import MyCartAddLineItemActionSchema

            return MyCartAddLineItemActionSchema().load(data)
        if data["action"] == "addPayment":
            from ._schemas.me import MyCartAddPaymentActionSchema

            return MyCartAddPaymentActionSchema().load(data)
        if data["action"] == "applyDeltaToLineItemShippingDetailsTargets":
            from ._schemas.me import (
                MyCartApplyDeltaToLineItemShippingDetailsTargetsActionSchema,
            )

            return MyCartApplyDeltaToLineItemShippingDetailsTargetsActionSchema().load(
                data
            )
        if data["action"] == "changeLineItemQuantity":
            from ._schemas.me import MyCartChangeLineItemQuantityActionSchema

            return MyCartChangeLineItemQuantityActionSchema().load(data)
        if data["action"] == "changeTaxMode":
            from ._schemas.me import MyCartChangeTaxModeActionSchema

            return MyCartChangeTaxModeActionSchema().load(data)
        if data["action"] == "recalculate":
            from ._schemas.me import MyCartRecalculateActionSchema

            return MyCartRecalculateActionSchema().load(data)
        if data["action"] == "removeDiscountCode":
            from ._schemas.me import MyCartRemoveDiscountCodeActionSchema

            return MyCartRemoveDiscountCodeActionSchema().load(data)
        if data["action"] == "removeItemShippingAddress":
            from ._schemas.me import MyCartRemoveItemShippingAddressActionSchema

            return MyCartRemoveItemShippingAddressActionSchema().load(data)
        if data["action"] == "removeLineItem":
            from ._schemas.me import MyCartRemoveLineItemActionSchema

            return MyCartRemoveLineItemActionSchema().load(data)
        if data["action"] == "removePayment":
            from ._schemas.me import MyCartRemovePaymentActionSchema

            return MyCartRemovePaymentActionSchema().load(data)
        if data["action"] == "setBillingAddress":
            from ._schemas.me import MyCartSetBillingAddressActionSchema

            return MyCartSetBillingAddressActionSchema().load(data)
        if data["action"] == "setBusinessUnit":
            from ._schemas.me import MyCartSetBusinessUnitActionSchema

            return MyCartSetBusinessUnitActionSchema().load(data)
        if data["action"] == "setCountry":
            from ._schemas.me import MyCartSetCountryActionSchema

            return MyCartSetCountryActionSchema().load(data)
        if data["action"] == "setCustomField":
            from ._schemas.me import MyCartSetCustomFieldActionSchema

            return MyCartSetCustomFieldActionSchema().load(data)
        if data["action"] == "setCustomType":
            from ._schemas.me import MyCartSetCustomTypeActionSchema

            return MyCartSetCustomTypeActionSchema().load(data)
        if data["action"] == "setCustomerEmail":
            from ._schemas.me import MyCartSetCustomerEmailActionSchema

            return MyCartSetCustomerEmailActionSchema().load(data)
        if data["action"] == "setDeleteDaysAfterLastModification":
            from ._schemas.me import (
                MyCartSetDeleteDaysAfterLastModificationActionSchema,
            )

            return MyCartSetDeleteDaysAfterLastModificationActionSchema().load(data)
        if data["action"] == "setLineItemCustomField":
            from ._schemas.me import MyCartSetLineItemCustomFieldActionSchema

            return MyCartSetLineItemCustomFieldActionSchema().load(data)
        if data["action"] == "setLineItemCustomType":
            from ._schemas.me import MyCartSetLineItemCustomTypeActionSchema

            return MyCartSetLineItemCustomTypeActionSchema().load(data)
        if data["action"] == "setLineItemDistributionChannel":
            from ._schemas.me import MyCartSetLineItemDistributionChannelActionSchema

            return MyCartSetLineItemDistributionChannelActionSchema().load(data)
        if data["action"] == "setLineItemShippingDetails":
            from ._schemas.me import MyCartSetLineItemShippingDetailsActionSchema

            return MyCartSetLineItemShippingDetailsActionSchema().load(data)
        if data["action"] == "setLineItemSupplyChannel":
            from ._schemas.me import MyCartSetLineItemSupplyChannelActionSchema

            return MyCartSetLineItemSupplyChannelActionSchema().load(data)
        if data["action"] == "setLocale":
            from ._schemas.me import MyCartSetLocaleActionSchema

            return MyCartSetLocaleActionSchema().load(data)
        if data["action"] == "setShippingAddress":
            from ._schemas.me import MyCartSetShippingAddressActionSchema

            return MyCartSetShippingAddressActionSchema().load(data)
        if data["action"] == "setShippingMethod":
            from ._schemas.me import MyCartSetShippingMethodActionSchema

            return MyCartSetShippingMethodActionSchema().load(data)
        if data["action"] == "updateItemShippingAddress":
            from ._schemas.me import MyCartUpdateItemShippingAddressActionSchema

            return MyCartUpdateItemShippingAddressActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCartUpdateActionSchema

        return MyCartUpdateActionSchema().dump(self)


class MyCompanyDraft(MyBusinessUnitDraft):
    """Draft type to represent the top level of a business.
    Contains the fields and values of the generic [MyBusinessUnitDraft](ctp:api:type:BusinessUnitDraft) that are used specifically for creating a [Company](ctp:api:type:Company).

    """

    def __init__(
        self,
        *,
        key: str,
        name: str,
        contact_email: typing.Optional[str] = None,
        custom: typing.Optional["CustomFields"] = None,
        addresses: typing.Optional[typing.List["BaseAddress"]] = None,
        shipping_addresses: typing.Optional[typing.List["int"]] = None,
        default_shipping_address: typing.Optional[int] = None,
        billing_addresses: typing.Optional[typing.List["int"]] = None,
        default_billing_address: typing.Optional[int] = None
    ):

        super().__init__(
            key=key,
            name=name,
            contact_email=contact_email,
            custom=custom,
            addresses=addresses,
            shipping_addresses=shipping_addresses,
            default_shipping_address=default_shipping_address,
            billing_addresses=billing_addresses,
            default_billing_address=default_billing_address,
            unit_type=BusinessUnitType.COMPANY,
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "MyCompanyDraft":
        from ._schemas.me import MyCompanyDraftSchema

        return MyCompanyDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCompanyDraftSchema

        return MyCompanyDraftSchema().dump(self)


class MyCustomerDraft(_BaseType):
    #: Email address of the Customer that is [unique](/../api/customers-overview#customer-uniqueness) for an entire Project or Store the Customer is assigned to.
    #: It is the mandatory unique identifier of a Customer.
    email: str
    #: Password of the Customer.
    password: str
    #: Given name (first name) of the Customer.
    first_name: typing.Optional[str]
    #: Family name (last name) of the Customer.
    last_name: typing.Optional[str]
    #: Middle name of the Customer.
    middle_name: typing.Optional[str]
    #: Title of the Customer, for example, 'Dr.'.
    title: typing.Optional[str]
    #: Salutation of the Customer, for example, 'Mr.' or 'Mrs.'.
    salutation: typing.Optional[str]
    #: Date of birth of the Customer.
    date_of_birth: typing.Optional[datetime.date]
    #: Company name of the Customer.
    company_name: typing.Optional[str]
    #: Individual VAT ID of the Customer.
    vat_id: typing.Optional[str]
    #: Addresses of the Customer.
    addresses: typing.Optional[typing.List["BaseAddress"]]
    #: Index of the address in the `addresses` array to use as the default shipping address.
    #: The `defaultShippingAddressId` of the Customer will be set to the `id` of that address.
    default_shipping_address: typing.Optional[int]
    #: Index of the address in the `addresses` array to use as the default billing address.
    #: The `defaultBillingAddressId` of the Customer will be set to the `id` of that address.
    default_billing_address: typing.Optional[int]
    #: Custom Fields for the Customer.
    custom: typing.Optional["CustomFieldsDraft"]
    #: Preferred language of the Customer. Must be one of the languages supported by the [Project](ctp:api:type:Project).
    locale: typing.Optional[str]
    #: Sets the [Stores](ctp:api:type:Store) for the Customer.
    stores: typing.Optional[typing.List["StoreResourceIdentifier"]]

    def __init__(
        self,
        *,
        email: str,
        password: str,
        first_name: typing.Optional[str] = None,
        last_name: typing.Optional[str] = None,
        middle_name: typing.Optional[str] = None,
        title: typing.Optional[str] = None,
        salutation: typing.Optional[str] = None,
        date_of_birth: typing.Optional[datetime.date] = None,
        company_name: typing.Optional[str] = None,
        vat_id: typing.Optional[str] = None,
        addresses: typing.Optional[typing.List["BaseAddress"]] = None,
        default_shipping_address: typing.Optional[int] = None,
        default_billing_address: typing.Optional[int] = None,
        custom: typing.Optional["CustomFieldsDraft"] = None,
        locale: typing.Optional[str] = None,
        stores: typing.Optional[typing.List["StoreResourceIdentifier"]] = None
    ):
        self.email = email
        self.password = password
        self.first_name = first_name
        self.last_name = last_name
        self.middle_name = middle_name
        self.title = title
        self.salutation = salutation
        self.date_of_birth = date_of_birth
        self.company_name = company_name
        self.vat_id = vat_id
        self.addresses = addresses
        self.default_shipping_address = default_shipping_address
        self.default_billing_address = default_billing_address
        self.custom = custom
        self.locale = locale
        self.stores = stores

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "MyCustomerDraft":
        from ._schemas.me import MyCustomerDraftSchema

        return MyCustomerDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCustomerDraftSchema

        return MyCustomerDraftSchema().dump(self)


class MyCustomerUpdate(_BaseType):
    #: Expected version of the Customer on which the changes should be applied.
    #: If the expected version does not match the actual version, a [ConcurrentModification](ctp:api:type:ConcurrentModificationError) error will be returned.
    version: int
    #: Update actions to be performed on the Customer.
    actions: typing.List["MyCustomerUpdateAction"]

    def __init__(self, *, version: int, actions: typing.List["MyCustomerUpdateAction"]):
        self.version = version
        self.actions = actions

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "MyCustomerUpdate":
        from ._schemas.me import MyCustomerUpdateSchema

        return MyCustomerUpdateSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCustomerUpdateSchema

        return MyCustomerUpdateSchema().dump(self)


class MyCustomerUpdateAction(_BaseType):
    action: str

    def __init__(self, *, action: str):
        self.action = action

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCustomerUpdateAction":
        if data["action"] == "addAddress":
            from ._schemas.me import MyCustomerAddAddressActionSchema

            return MyCustomerAddAddressActionSchema().load(data)
        if data["action"] == "addBillingAddressId":
            from ._schemas.me import MyCustomerAddBillingAddressIdActionSchema

            return MyCustomerAddBillingAddressIdActionSchema().load(data)
        if data["action"] == "addShippingAddressId":
            from ._schemas.me import MyCustomerAddShippingAddressIdActionSchema

            return MyCustomerAddShippingAddressIdActionSchema().load(data)
        if data["action"] == "changeAddress":
            from ._schemas.me import MyCustomerChangeAddressActionSchema

            return MyCustomerChangeAddressActionSchema().load(data)
        if data["action"] == "changeEmail":
            from ._schemas.me import MyCustomerChangeEmailActionSchema

            return MyCustomerChangeEmailActionSchema().load(data)
        if data["action"] == "removeAddress":
            from ._schemas.me import MyCustomerRemoveAddressActionSchema

            return MyCustomerRemoveAddressActionSchema().load(data)
        if data["action"] == "removeBillingAddressId":
            from ._schemas.me import MyCustomerRemoveBillingAddressIdActionSchema

            return MyCustomerRemoveBillingAddressIdActionSchema().load(data)
        if data["action"] == "removeShippingAddressId":
            from ._schemas.me import MyCustomerRemoveShippingAddressIdActionSchema

            return MyCustomerRemoveShippingAddressIdActionSchema().load(data)
        if data["action"] == "setCompanyName":
            from ._schemas.me import MyCustomerSetCompanyNameActionSchema

            return MyCustomerSetCompanyNameActionSchema().load(data)
        if data["action"] == "setCustomField":
            from ._schemas.me import MyCustomerSetCustomFieldActionSchema

            return MyCustomerSetCustomFieldActionSchema().load(data)
        if data["action"] == "setCustomType":
            from ._schemas.me import MyCustomerSetCustomTypeActionSchema

            return MyCustomerSetCustomTypeActionSchema().load(data)
        if data["action"] == "setDateOfBirth":
            from ._schemas.me import MyCustomerSetDateOfBirthActionSchema

            return MyCustomerSetDateOfBirthActionSchema().load(data)
        if data["action"] == "setDefaultBillingAddress":
            from ._schemas.me import MyCustomerSetDefaultBillingAddressActionSchema

            return MyCustomerSetDefaultBillingAddressActionSchema().load(data)
        if data["action"] == "setDefaultShippingAddress":
            from ._schemas.me import MyCustomerSetDefaultShippingAddressActionSchema

            return MyCustomerSetDefaultShippingAddressActionSchema().load(data)
        if data["action"] == "setFirstName":
            from ._schemas.me import MyCustomerSetFirstNameActionSchema

            return MyCustomerSetFirstNameActionSchema().load(data)
        if data["action"] == "setLastName":
            from ._schemas.me import MyCustomerSetLastNameActionSchema

            return MyCustomerSetLastNameActionSchema().load(data)
        if data["action"] == "setLocale":
            from ._schemas.me import MyCustomerSetLocaleActionSchema

            return MyCustomerSetLocaleActionSchema().load(data)
        if data["action"] == "setMiddleName":
            from ._schemas.me import MyCustomerSetMiddleNameActionSchema

            return MyCustomerSetMiddleNameActionSchema().load(data)
        if data["action"] == "setSalutation":
            from ._schemas.me import MyCustomerSetSalutationActionSchema

            return MyCustomerSetSalutationActionSchema().load(data)
        if data["action"] == "setTitle":
            from ._schemas.me import MyCustomerSetTitleActionSchema

            return MyCustomerSetTitleActionSchema().load(data)
        if data["action"] == "setVatId":
            from ._schemas.me import MyCustomerSetVatIdActionSchema

            return MyCustomerSetVatIdActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCustomerUpdateActionSchema

        return MyCustomerUpdateActionSchema().dump(self)


class MyDivisionDraft(MyBusinessUnitDraft):
    """Draft type to model divisions that are part of the [Company](ctp:api:type:Company) or a higher-order [Division](ctp:api:type:Division).
    Contains the fields and values of the generic [MyBusinessUnitDraft](ctp:api:type:MyBusinessUnitDraft) that are used specifically for creating a Division.

    """

    #: The parent unit of this Division. Can be a Company or a Division.
    parent_unit: "BusinessUnitResourceIdentifier"

    def __init__(
        self,
        *,
        key: str,
        name: str,
        contact_email: typing.Optional[str] = None,
        custom: typing.Optional["CustomFields"] = None,
        addresses: typing.Optional[typing.List["BaseAddress"]] = None,
        shipping_addresses: typing.Optional[typing.List["int"]] = None,
        default_shipping_address: typing.Optional[int] = None,
        billing_addresses: typing.Optional[typing.List["int"]] = None,
        default_billing_address: typing.Optional[int] = None,
        parent_unit: "BusinessUnitResourceIdentifier"
    ):
        self.parent_unit = parent_unit

        super().__init__(
            key=key,
            name=name,
            contact_email=contact_email,
            custom=custom,
            addresses=addresses,
            shipping_addresses=shipping_addresses,
            default_shipping_address=default_shipping_address,
            billing_addresses=billing_addresses,
            default_billing_address=default_billing_address,
            unit_type=BusinessUnitType.DIVISION,
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "MyDivisionDraft":
        from ._schemas.me import MyDivisionDraftSchema

        return MyDivisionDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyDivisionDraftSchema

        return MyDivisionDraftSchema().dump(self)


class MyLineItemDraft(_BaseType):
    """For Product Variant identification, either the `productId` and `variantId`, or `sku` must be provided."""

    #: User-defined unique identifier of the LineItem.
    key: typing.Optional[str]
    #: `id` of the [Product](ctp:api:type:Product).
    product_id: typing.Optional[str]
    #: `id` of the [ProductVariant](ctp:api:type:ProductVariant) in the Product.
    #: If not provided, the Master Variant is used.
    variant_id: typing.Optional[int]
    #: `sku` of the [ProductVariant](ctp:api:type:ProductVariant).
    sku: typing.Optional[str]
    #: Number of Product Variants to add to the Cart.
    quantity: typing.Optional[int]
    #: Date and time (UTC) the Product Variant is added to the Cart.
    #: If not set, it defaults to the current date and time.
    #:
    #: Optional for backwards compatibility reasons.
    added_at: typing.Optional[datetime.datetime]
    #: Used to identify [Inventory entries](/../api/projects/inventory) that must be reserved.
    #: The Channel must have the `InventorySupply` [ChannelRoleEnum](ctp:api:type:ChannelRoleEnum).
    supply_channel: typing.Optional["ChannelResourceIdentifier"]
    #: Used to [select](ctp:api:type:LineItemPriceSelection) a Product Price.
    #: The Channel must have the `ProductDistribution` [ChannelRoleEnum](ctp:api:type:ChannelRoleEnum).
    #:
    #: If the Cart is bound to a [Store](ctp:api:type:Store) with `distributionChannels` set,
    #: the Channel must match one of the Store's distribution channels.
    distribution_channel: typing.Optional["ChannelResourceIdentifier"]
    #: Container for Line Item-specific addresses.
    shipping_details: typing.Optional["ItemShippingDetailsDraft"]
    #: Custom Fields for the Cart.
    custom: typing.Optional["CustomFieldsDraft"]

    def __init__(
        self,
        *,
        key: typing.Optional[str] = None,
        product_id: typing.Optional[str] = None,
        variant_id: typing.Optional[int] = None,
        sku: typing.Optional[str] = None,
        quantity: typing.Optional[int] = None,
        added_at: typing.Optional[datetime.datetime] = None,
        supply_channel: typing.Optional["ChannelResourceIdentifier"] = None,
        distribution_channel: typing.Optional["ChannelResourceIdentifier"] = None,
        shipping_details: typing.Optional["ItemShippingDetailsDraft"] = None,
        custom: typing.Optional["CustomFieldsDraft"] = None
    ):
        self.key = key
        self.product_id = product_id
        self.variant_id = variant_id
        self.sku = sku
        self.quantity = quantity
        self.added_at = added_at
        self.supply_channel = supply_channel
        self.distribution_channel = distribution_channel
        self.shipping_details = shipping_details
        self.custom = custom

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "MyLineItemDraft":
        from ._schemas.me import MyLineItemDraftSchema

        return MyLineItemDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyLineItemDraftSchema

        return MyLineItemDraftSchema().dump(self)


class MyOrderFromCartDraft(_BaseType):
    #: `id` of the [Cart](ctp:api:type:Cart) from which the Order is created.
    id: str
    #: Current `version` of the [Cart](ctp:api:type:Cart) from which the Order is created.
    version: int

    def __init__(self, *, id: str, version: int):
        self.id = id
        self.version = version

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "MyOrderFromCartDraft":
        from ._schemas.me import MyOrderFromCartDraftSchema

        return MyOrderFromCartDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyOrderFromCartDraftSchema

        return MyOrderFromCartDraftSchema().dump(self)


class MyOrderFromQuoteDraft(_BaseType):
    #: `id` of the [Quote](ctp:api:type:Quote) from which the Order is created.
    id: str
    #: Current `version` of the [Quote](ctp:api:type:Quote) from which the Order is created.
    version: int
    #: Set to `true`, if the `quoteState` of the referenced [Quote](ctp:api:type:Quote) should be set to `Accepted`.
    quote_state_to_accepted: typing.Optional[bool]

    def __init__(
        self,
        *,
        id: str,
        version: int,
        quote_state_to_accepted: typing.Optional[bool] = None
    ):
        self.id = id
        self.version = version
        self.quote_state_to_accepted = quote_state_to_accepted

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "MyOrderFromQuoteDraft":
        from ._schemas.me import MyOrderFromQuoteDraftSchema

        return MyOrderFromQuoteDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyOrderFromQuoteDraftSchema

        return MyOrderFromQuoteDraftSchema().dump(self)


class MyPayment(_BaseType):
    #: Unique identifier of the Payment.
    id: str
    #: Current version of the Payment.
    version: int
    #: Reference to a [Customer](ctp:api:type:Customer) associated with the Payment. Set automatically with a [password flow token](/../api/authorization#password-flow). Either `customer` or `anonymousId` is present.
    customer: typing.Optional["CustomerReference"]
    #: [Anonymous session](ctp:api:type:AnonymousSession) associated with the Payment. Set automatically with a [token for an anonymous session](ctp:api:type:AnonymousSession). Either `customer` or `anonymousId` is present.
    anonymous_id: typing.Optional[str]
    #: Money value the Payment intends to receive from the customer.
    #: The value typically matches the [Cart](ctp:api:type:Cart) or [Order](ctp:api:type:Order) gross total.
    amount_planned: "CentPrecisionMoney"
    #: Information regarding the payment interface (for example, a PSP), and the specific payment method used.
    payment_method_info: "PaymentMethodInfo"
    #: Financial transactions of the Payment. Each Transaction has a [TransactionType](ctp:api:type:TransactionType) and a [TransactionState](ctp:api:type:TransactionState).
    transactions: typing.List["Transaction"]
    #: Custom Fields defined for the Payment.
    custom: typing.Optional["CustomFields"]

    def __init__(
        self,
        *,
        id: str,
        version: int,
        customer: typing.Optional["CustomerReference"] = None,
        anonymous_id: typing.Optional[str] = None,
        amount_planned: "CentPrecisionMoney",
        payment_method_info: "PaymentMethodInfo",
        transactions: typing.List["Transaction"],
        custom: typing.Optional["CustomFields"] = None
    ):
        self.id = id
        self.version = version
        self.customer = customer
        self.anonymous_id = anonymous_id
        self.amount_planned = amount_planned
        self.payment_method_info = payment_method_info
        self.transactions = transactions
        self.custom = custom

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "MyPayment":
        from ._schemas.me import MyPaymentSchema

        return MyPaymentSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyPaymentSchema

        return MyPaymentSchema().dump(self)


class MyPaymentDraft(_BaseType):
    #: Money value the Payment intends to receive from the customer.
    #: The value usually matches the [Cart](ctp:api:type:Cart) or [Order](ctp:api:type:Order) gross total.
    amount_planned: "Money"
    #: Information regarding the payment interface (for example, a PSP), and the specific payment method used.
    payment_method_info: typing.Optional["PaymentMethodInfo"]
    #: Custom Fields for the Payment.
    custom: typing.Optional["CustomFieldsDraft"]
    #: Financial transactions of the [TransactionTypes](ctp:api:type:TransactionType) `Authorization` or `Charge`.
    transaction: typing.Optional["MyTransactionDraft"]

    def __init__(
        self,
        *,
        amount_planned: "Money",
        payment_method_info: typing.Optional["PaymentMethodInfo"] = None,
        custom: typing.Optional["CustomFieldsDraft"] = None,
        transaction: typing.Optional["MyTransactionDraft"] = None
    ):
        self.amount_planned = amount_planned
        self.payment_method_info = payment_method_info
        self.custom = custom
        self.transaction = transaction

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "MyPaymentDraft":
        from ._schemas.me import MyPaymentDraftSchema

        return MyPaymentDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyPaymentDraftSchema

        return MyPaymentDraftSchema().dump(self)


class MyPaymentPagedQueryResponse(_BaseType):
    """[PagedQueryResult](/../api/general-concepts#pagedqueryresult) with `results` containing an array of [MyPayment](ctp:api:type:MyPayment)."""

    #: Number of [results requested](/../api/general-concepts#limit).
    limit: int
    #: Actual number of results returned.
    count: int
    #: Total number of results matching the query.
    #: This number is an estimation that is not [strongly consistent](/../api/general-concepts#strong-consistency).
    #: This field is returned by default.
    #: For improved performance, calculating this field can be deactivated by using the query parameter `withTotal=false`.
    #: When the results are filtered with a [Query Predicate](/../api/predicates/query), `total` is subject to a [limit](/../api/limits#queries).
    total: typing.Optional[int]
    #: Number of [elements skipped](/../api/general-concepts#offset).
    offset: int
    #: [MyPayments](ctp:api:type:MyPayment) matching the query.
    results: typing.List["MyPayment"]

    def __init__(
        self,
        *,
        limit: int,
        count: int,
        total: typing.Optional[int] = None,
        offset: int,
        results: typing.List["MyPayment"]
    ):
        self.limit = limit
        self.count = count
        self.total = total
        self.offset = offset
        self.results = results

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyPaymentPagedQueryResponse":
        from ._schemas.me import MyPaymentPagedQueryResponseSchema

        return MyPaymentPagedQueryResponseSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyPaymentPagedQueryResponseSchema

        return MyPaymentPagedQueryResponseSchema().dump(self)


class MyPaymentUpdate(_BaseType):
    #: Expected version of the Payment on which the changes should be applied.
    #: If the expected version does not match the actual version, a [ConcurrentModification](ctp:api:type:ConcurrentModificationError) error will be returned.
    version: int
    #: Update actions to be performed on the Payment.
    actions: typing.List["MyPaymentUpdateAction"]

    def __init__(self, *, version: int, actions: typing.List["MyPaymentUpdateAction"]):
        self.version = version
        self.actions = actions

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "MyPaymentUpdate":
        from ._schemas.me import MyPaymentUpdateSchema

        return MyPaymentUpdateSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyPaymentUpdateSchema

        return MyPaymentUpdateSchema().dump(self)


class MyPaymentUpdateAction(_BaseType):
    action: str

    def __init__(self, *, action: str):
        self.action = action

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "MyPaymentUpdateAction":
        if data["action"] == "addTransaction":
            from ._schemas.me import MyPaymentAddTransactionActionSchema

            return MyPaymentAddTransactionActionSchema().load(data)
        if data["action"] == "changeAmountPlanned":
            from ._schemas.me import MyPaymentChangeAmountPlannedActionSchema

            return MyPaymentChangeAmountPlannedActionSchema().load(data)
        if data["action"] == "setCustomField":
            from ._schemas.me import MyPaymentSetCustomFieldActionSchema

            return MyPaymentSetCustomFieldActionSchema().load(data)
        if data["action"] == "setMethodInfoInterface":
            from ._schemas.me import MyPaymentSetMethodInfoInterfaceActionSchema

            return MyPaymentSetMethodInfoInterfaceActionSchema().load(data)
        if data["action"] == "setMethodInfoMethod":
            from ._schemas.me import MyPaymentSetMethodInfoMethodActionSchema

            return MyPaymentSetMethodInfoMethodActionSchema().load(data)
        if data["action"] == "setMethodInfoName":
            from ._schemas.me import MyPaymentSetMethodInfoNameActionSchema

            return MyPaymentSetMethodInfoNameActionSchema().load(data)
        if data["action"] == "setTransactionCustomField":
            from ._schemas.me import MyPaymentSetTransactionCustomFieldActionSchema

            return MyPaymentSetTransactionCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyPaymentUpdateActionSchema

        return MyPaymentUpdateActionSchema().dump(self)


class MyQuoteRequestDraft(_BaseType):
    #: `id` of the Cart from which the Quote Request is created.
    cart_id: str
    #: Current version of the Cart.
    cart_version: int
    #: Message from the Buyer included in the Quote Request.
    comment: typing.Optional[str]

    def __init__(
        self, *, cart_id: str, cart_version: int, comment: typing.Optional[str] = None
    ):
        self.cart_id = cart_id
        self.cart_version = cart_version
        self.comment = comment

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "MyQuoteRequestDraft":
        from ._schemas.me import MyQuoteRequestDraftSchema

        return MyQuoteRequestDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyQuoteRequestDraftSchema

        return MyQuoteRequestDraftSchema().dump(self)


class MyQuoteRequestUpdate(_BaseType):
    version: int
    actions: typing.List["MyQuoteRequestUpdateAction"]

    def __init__(
        self, *, version: int, actions: typing.List["MyQuoteRequestUpdateAction"]
    ):
        self.version = version
        self.actions = actions

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "MyQuoteRequestUpdate":
        from ._schemas.me import MyQuoteRequestUpdateSchema

        return MyQuoteRequestUpdateSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyQuoteRequestUpdateSchema

        return MyQuoteRequestUpdateSchema().dump(self)


class MyQuoteRequestUpdateAction(_BaseType):
    action: str

    def __init__(self, *, action: str):
        self.action = action

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyQuoteRequestUpdateAction":
        if data["action"] == "cancelQuoteRequest":
            from ._schemas.me import MyQuoteRequestCancelActionSchema

            return MyQuoteRequestCancelActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyQuoteRequestUpdateActionSchema

        return MyQuoteRequestUpdateActionSchema().dump(self)


class MyQuoteState(enum.Enum):
    """[QuoteStates](ctp:api:type:QuoteState) that can be set using the [Change My Quote State](ctp:api:type:MyQuoteChangeMyQuoteStateAction) update action."""

    DECLINED = "Declined"
    ACCEPTED = "Accepted"


class MyQuoteUpdate(_BaseType):
    #: Expected version of the [Quote](ctp:api:type:Quote) to which the changes should be applied.
    #: If the expected version does not match the actual version, a [ConcurrentModification](ctp:api:type:ConcurrentModificationError) error will be returned.
    version: int
    #: Update actions to be performed on the [Quote](ctp:api:type:Quote).
    actions: typing.List["MyQuoteUpdateAction"]

    def __init__(self, *, version: int, actions: typing.List["MyQuoteUpdateAction"]):
        self.version = version
        self.actions = actions

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "MyQuoteUpdate":
        from ._schemas.me import MyQuoteUpdateSchema

        return MyQuoteUpdateSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyQuoteUpdateSchema

        return MyQuoteUpdateSchema().dump(self)


class MyQuoteUpdateAction(_BaseType):
    action: str

    def __init__(self, *, action: str):
        self.action = action

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "MyQuoteUpdateAction":
        if data["action"] == "changeMyQuoteState":
            from ._schemas.me import MyQuoteChangeMyQuoteStateActionSchema

            return MyQuoteChangeMyQuoteStateActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyQuoteUpdateActionSchema

        return MyQuoteUpdateActionSchema().dump(self)


class MyShoppingListDraft(_BaseType):
    """A [MyShoppingListDraft](ctp:api:type:MyShoppingListDraft) is the object submitted as payload to the [Create MyShoppingList request](ctp:api:endpoint:/{projectKey}/me/shopping-lists:POST).
    The `customer` field of [ShoppingList](ctp:api:type:ShoppingList) is automatically set with
    a [password flow token](/authorization#password-flow).
    The `anonymousId` is automatically set with a [token for an anonymous session](/authorization#tokens-for-anonymous-sessions).
    The `key` and `slug` fields can not be set.

    """

    #: Name of the [ShoppingList](ctp:api:type:ShoppingList).
    name: "LocalizedString"
    #: Description of the ShoppingList.
    description: typing.Optional["LocalizedString"]
    #: [Line Items](ctp:api:type:ShoppingListLineItem) (containing Products) to add to the ShoppingList.
    line_items: typing.Optional[typing.List["ShoppingListLineItemDraft"]]
    #: [Line Items](ctp:api:type:TextLineItem) (containing text values) to add to the ShoppingList.
    text_line_items: typing.Optional[typing.List["TextLineItemDraft"]]
    #: Custom Fields defined for the ShoppingList.
    custom: typing.Optional["CustomFieldsDraft"]
    #: Number of days after which the ShoppingList will be automatically deleted if it has not been modified. If not set, the [default value](ctp:api:type:ShoppingListsConfiguration) configured in the [Project](ctp:api:type:Project) is used.
    delete_days_after_last_modification: typing.Optional[int]
    #: Assigns the new ShoppingList to the [Store](ctp:api:type:Store). The Store assignment can not be modified.
    store: typing.Optional["StoreResourceIdentifier"]

    def __init__(
        self,
        *,
        name: "LocalizedString",
        description: typing.Optional["LocalizedString"] = None,
        line_items: typing.Optional[typing.List["ShoppingListLineItemDraft"]] = None,
        text_line_items: typing.Optional[typing.List["TextLineItemDraft"]] = None,
        custom: typing.Optional["CustomFieldsDraft"] = None,
        delete_days_after_last_modification: typing.Optional[int] = None,
        store: typing.Optional["StoreResourceIdentifier"] = None
    ):
        self.name = name
        self.description = description
        self.line_items = line_items
        self.text_line_items = text_line_items
        self.custom = custom
        self.delete_days_after_last_modification = delete_days_after_last_modification
        self.store = store

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "MyShoppingListDraft":
        from ._schemas.me import MyShoppingListDraftSchema

        return MyShoppingListDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyShoppingListDraftSchema

        return MyShoppingListDraftSchema().dump(self)


class MyShoppingListUpdate(_BaseType):
    #: Expected version of the ShoppingList on which the changes should be applied.
    #: If the expected version does not match the actual version, a [ConcurrentModification](ctp:api:type:ConcurrentModificationError) error will be returned.
    version: int
    #: List of update actions to be performed on the ShoppingList.
    actions: typing.List["MyShoppingListUpdateAction"]

    def __init__(
        self, *, version: int, actions: typing.List["MyShoppingListUpdateAction"]
    ):
        self.version = version
        self.actions = actions

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "MyShoppingListUpdate":
        from ._schemas.me import MyShoppingListUpdateSchema

        return MyShoppingListUpdateSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyShoppingListUpdateSchema

        return MyShoppingListUpdateSchema().dump(self)


class MyShoppingListUpdateAction(_BaseType):
    action: str

    def __init__(self, *, action: str):
        self.action = action

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyShoppingListUpdateAction":
        if data["action"] == "addLineItem":
            from ._schemas.me import MyShoppingListAddLineItemActionSchema

            return MyShoppingListAddLineItemActionSchema().load(data)
        if data["action"] == "addTextLineItem":
            from ._schemas.me import MyShoppingListAddTextLineItemActionSchema

            return MyShoppingListAddTextLineItemActionSchema().load(data)
        if data["action"] == "changeLineItemQuantity":
            from ._schemas.me import MyShoppingListChangeLineItemQuantityActionSchema

            return MyShoppingListChangeLineItemQuantityActionSchema().load(data)
        if data["action"] == "changeLineItemsOrder":
            from ._schemas.me import MyShoppingListChangeLineItemsOrderActionSchema

            return MyShoppingListChangeLineItemsOrderActionSchema().load(data)
        if data["action"] == "changeName":
            from ._schemas.me import MyShoppingListChangeNameActionSchema

            return MyShoppingListChangeNameActionSchema().load(data)
        if data["action"] == "changeTextLineItemName":
            from ._schemas.me import MyShoppingListChangeTextLineItemNameActionSchema

            return MyShoppingListChangeTextLineItemNameActionSchema().load(data)
        if data["action"] == "changeTextLineItemQuantity":
            from ._schemas.me import (
                MyShoppingListChangeTextLineItemQuantityActionSchema,
            )

            return MyShoppingListChangeTextLineItemQuantityActionSchema().load(data)
        if data["action"] == "changeTextLineItemsOrder":
            from ._schemas.me import MyShoppingListChangeTextLineItemsOrderActionSchema

            return MyShoppingListChangeTextLineItemsOrderActionSchema().load(data)
        if data["action"] == "removeLineItem":
            from ._schemas.me import MyShoppingListRemoveLineItemActionSchema

            return MyShoppingListRemoveLineItemActionSchema().load(data)
        if data["action"] == "removeTextLineItem":
            from ._schemas.me import MyShoppingListRemoveTextLineItemActionSchema

            return MyShoppingListRemoveTextLineItemActionSchema().load(data)
        if data["action"] == "setCustomField":
            from ._schemas.me import MyShoppingListSetCustomFieldActionSchema

            return MyShoppingListSetCustomFieldActionSchema().load(data)
        if data["action"] == "setCustomType":
            from ._schemas.me import MyShoppingListSetCustomTypeActionSchema

            return MyShoppingListSetCustomTypeActionSchema().load(data)
        if data["action"] == "setDeleteDaysAfterLastModification":
            from ._schemas.me import (
                MyShoppingListSetDeleteDaysAfterLastModificationActionSchema,
            )

            return MyShoppingListSetDeleteDaysAfterLastModificationActionSchema().load(
                data
            )
        if data["action"] == "setDescription":
            from ._schemas.me import MyShoppingListSetDescriptionActionSchema

            return MyShoppingListSetDescriptionActionSchema().load(data)
        if data["action"] == "setLineItemCustomField":
            from ._schemas.me import MyShoppingListSetLineItemCustomFieldActionSchema

            return MyShoppingListSetLineItemCustomFieldActionSchema().load(data)
        if data["action"] == "setLineItemCustomType":
            from ._schemas.me import MyShoppingListSetLineItemCustomTypeActionSchema

            return MyShoppingListSetLineItemCustomTypeActionSchema().load(data)
        if data["action"] == "setTextLineItemCustomField":
            from ._schemas.me import (
                MyShoppingListSetTextLineItemCustomFieldActionSchema,
            )

            return MyShoppingListSetTextLineItemCustomFieldActionSchema().load(data)
        if data["action"] == "setTextLineItemCustomType":
            from ._schemas.me import MyShoppingListSetTextLineItemCustomTypeActionSchema

            return MyShoppingListSetTextLineItemCustomTypeActionSchema().load(data)
        if data["action"] == "setTextLineItemDescription":
            from ._schemas.me import (
                MyShoppingListSetTextLineItemDescriptionActionSchema,
            )

            return MyShoppingListSetTextLineItemDescriptionActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyShoppingListUpdateActionSchema

        return MyShoppingListUpdateActionSchema().dump(self)


class MyTransactionDraft(_BaseType):
    #: Date and time (UTC) the Transaction took place.
    timestamp: typing.Optional[datetime.datetime]
    #: Type of the Transaction.
    #: Only `Authorization` or `Charge` is allowed.
    type: "TransactionType"
    #: Money value for the Transaction.
    amount: "Money"
    #: Identifier used by the payment service that manages the Transaction.
    #: Can be used to correlate the Transaction to an interface interaction.
    interaction_id: typing.Optional[str]
    #: Custom Fields of the Transaction.
    custom: typing.Optional["CustomFieldsDraft"]

    def __init__(
        self,
        *,
        timestamp: typing.Optional[datetime.datetime] = None,
        type: "TransactionType",
        amount: "Money",
        interaction_id: typing.Optional[str] = None,
        custom: typing.Optional["CustomFieldsDraft"] = None
    ):
        self.timestamp = timestamp
        self.type = type
        self.amount = amount
        self.interaction_id = interaction_id
        self.custom = custom

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "MyTransactionDraft":
        from ._schemas.me import MyTransactionDraftSchema

        return MyTransactionDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyTransactionDraftSchema

        return MyTransactionDraftSchema().dump(self)


class ReplicaMyCartDraft(_BaseType):
    #: [Reference](ctp:api:type:Reference) to a [Cart](ctp:api:type:Cart) or [Order](ctp:api:type:Order) that is replicated.
    reference: typing.Union["CartReference", "OrderReference"]

    def __init__(self, *, reference: typing.Union["CartReference", "OrderReference"]):
        self.reference = reference

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ReplicaMyCartDraft":
        from ._schemas.me import ReplicaMyCartDraftSchema

        return ReplicaMyCartDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import ReplicaMyCartDraftSchema

        return ReplicaMyCartDraftSchema().dump(self)


class MyBusinessUnitAddAddressAction(MyBusinessUnitUpdateAction):
    """Adding an address to a [Business Unit](ctp:api:type:BusinessUnit) generates a [BusinessUnitAddressAdded](ctp:api:type:BusinessUnitAddressAddedMessage) Message."""

    #: The address to add to `addresses`.
    address: "BaseAddress"

    def __init__(self, *, address: "BaseAddress"):
        self.address = address

        super().__init__(action="addAddress")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyBusinessUnitAddAddressAction":
        from ._schemas.me import MyBusinessUnitAddAddressActionSchema

        return MyBusinessUnitAddAddressActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyBusinessUnitAddAddressActionSchema

        return MyBusinessUnitAddAddressActionSchema().dump(self)


class MyBusinessUnitAddBillingAddressIdAction(MyBusinessUnitUpdateAction):
    """Adding a billing address to a [Business Unit](ctp:api:type:BusinessUnit) generates a [BusinessUnitBillingAddressAdded](ctp:api:type:BusinessUnitBillingAddressAddedMessage) Message."""

    #: ID of the address to add as a billing address. Either `addressId` or `addressKey` is required.
    address_id: typing.Optional[str]
    #: Key of the address to add as a billing address. Either `addressId` or `addressKey` is required.
    address_key: typing.Optional[str]

    def __init__(
        self,
        *,
        address_id: typing.Optional[str] = None,
        address_key: typing.Optional[str] = None
    ):
        self.address_id = address_id
        self.address_key = address_key

        super().__init__(action="addBillingAddressId")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyBusinessUnitAddBillingAddressIdAction":
        from ._schemas.me import MyBusinessUnitAddBillingAddressIdActionSchema

        return MyBusinessUnitAddBillingAddressIdActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyBusinessUnitAddBillingAddressIdActionSchema

        return MyBusinessUnitAddBillingAddressIdActionSchema().dump(self)


class MyBusinessUnitAddShippingAddressIdAction(MyBusinessUnitUpdateAction):
    """Adding a shipping address to a [Business Unit](ctp:api:type:BusinessUnit) generates a [BusinessUnitShippingAddressAdded](ctp:api:type:BusinessUnitShippingAddressAddedMessage) Message."""

    #: ID of the address to add as a shipping address. Either `addressId` or `addressKey` is required.
    address_id: typing.Optional[str]
    #: Key of the address to add as a shipping address. Either `addressId` or `addressKey` is required.
    address_key: typing.Optional[str]

    def __init__(
        self,
        *,
        address_id: typing.Optional[str] = None,
        address_key: typing.Optional[str] = None
    ):
        self.address_id = address_id
        self.address_key = address_key

        super().__init__(action="addShippingAddressId")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyBusinessUnitAddShippingAddressIdAction":
        from ._schemas.me import MyBusinessUnitAddShippingAddressIdActionSchema

        return MyBusinessUnitAddShippingAddressIdActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyBusinessUnitAddShippingAddressIdActionSchema

        return MyBusinessUnitAddShippingAddressIdActionSchema().dump(self)


class MyBusinessUnitChangeAddressAction(MyBusinessUnitUpdateAction):
    """Changing the address on a Business Unit generates the [BusinessUnitAddressChanged](ctp:api:type:BusinessUnitAddressChangedMessage) Message."""

    #: ID of the address to change. Either `addressId` or `addressKey` is required.
    address_id: typing.Optional[str]
    #: Key of the address to change. Either `addressId` or `addressKey` is required.
    address_key: typing.Optional[str]
    #: New address to set.
    address: "BaseAddress"

    def __init__(
        self,
        *,
        address_id: typing.Optional[str] = None,
        address_key: typing.Optional[str] = None,
        address: "BaseAddress"
    ):
        self.address_id = address_id
        self.address_key = address_key
        self.address = address

        super().__init__(action="changeAddress")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyBusinessUnitChangeAddressAction":
        from ._schemas.me import MyBusinessUnitChangeAddressActionSchema

        return MyBusinessUnitChangeAddressActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyBusinessUnitChangeAddressActionSchema

        return MyBusinessUnitChangeAddressActionSchema().dump(self)


class MyBusinessUnitChangeAssociateAction(MyBusinessUnitUpdateAction):
    """Updating the [Associate](ctp:api:type:Associate) on a [Business Unit](ctp:api:type:BusinessUnit) generates the [BusinessUnitAssociateChanged](ctp:api:type:BusinessUnitAssociateChangedMessage) Message."""

    #: The Associate to add.
    associate: "AssociateDraft"

    def __init__(self, *, associate: "AssociateDraft"):
        self.associate = associate

        super().__init__(action="changeAssociate")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyBusinessUnitChangeAssociateAction":
        from ._schemas.me import MyBusinessUnitChangeAssociateActionSchema

        return MyBusinessUnitChangeAssociateActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyBusinessUnitChangeAssociateActionSchema

        return MyBusinessUnitChangeAssociateActionSchema().dump(self)


class MyBusinessUnitChangeNameAction(MyBusinessUnitUpdateAction):
    """Updating the name on a [Business Unit](ctp:api:type:BusinessUnit) generates a [BusinessUnitNameChanged](ctp:api:type:BusinessUnitNameChangedMessage) Message."""

    #: New name to set.
    name: str

    def __init__(self, *, name: str):
        self.name = name

        super().__init__(action="changeName")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyBusinessUnitChangeNameAction":
        from ._schemas.me import MyBusinessUnitChangeNameActionSchema

        return MyBusinessUnitChangeNameActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyBusinessUnitChangeNameActionSchema

        return MyBusinessUnitChangeNameActionSchema().dump(self)


class MyBusinessUnitChangeParentUnitAction(MyBusinessUnitUpdateAction):
    """Changing the parent of a [Business Unit](ctp:api:type:BusinessUnit) generates a [BusinessUnitParentChanged](ctp:api:type:BusinessUnitParentChangedMessage) Message."""

    #: New parent unit of the [Business Unit](ctp:api:type:BusinessUnit). The new parent unit must have the same top-level unit as the old parent unit.
    parent_unit: "BusinessUnitResourceIdentifier"

    def __init__(self, *, parent_unit: "BusinessUnitResourceIdentifier"):
        self.parent_unit = parent_unit

        super().__init__(action="changeParentUnit")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyBusinessUnitChangeParentUnitAction":
        from ._schemas.me import MyBusinessUnitChangeParentUnitActionSchema

        return MyBusinessUnitChangeParentUnitActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyBusinessUnitChangeParentUnitActionSchema

        return MyBusinessUnitChangeParentUnitActionSchema().dump(self)


class MyBusinessUnitRemoveAddressAction(MyBusinessUnitUpdateAction):
    """Removing the address from a [Business Unit](ctp:api:type:BusinessUnit) generates the [BusinessUnitAddressRemoved](ctp:api:type:BusinessUnitAddressRemovedMessage) Message."""

    #: ID of the address to be removed. Either `addressId` or `addressKey` is required.
    address_id: typing.Optional[str]
    #: Key of the address to be removed. Either `addressId` or `addressKey` is required.
    address_key: typing.Optional[str]

    def __init__(
        self,
        *,
        address_id: typing.Optional[str] = None,
        address_key: typing.Optional[str] = None
    ):
        self.address_id = address_id
        self.address_key = address_key

        super().__init__(action="removeAddress")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyBusinessUnitRemoveAddressAction":
        from ._schemas.me import MyBusinessUnitRemoveAddressActionSchema

        return MyBusinessUnitRemoveAddressActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyBusinessUnitRemoveAddressActionSchema

        return MyBusinessUnitRemoveAddressActionSchema().dump(self)


class MyBusinessUnitRemoveAssociateAction(MyBusinessUnitUpdateAction):
    """Removing an [Associate](ctp:api:type:Associate) from a [Business Unit](ctp:api:type:BusinessUnit) generates a [BusinessUnitAssociateRemoved](ctp:api:type:BusinessUnitAssociateRemovedMessage) Message."""

    #: [Associate](ctp:api:type:Associate) to remove.
    customer: "CustomerResourceIdentifier"

    def __init__(self, *, customer: "CustomerResourceIdentifier"):
        self.customer = customer

        super().__init__(action="removeAssociate")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyBusinessUnitRemoveAssociateAction":
        from ._schemas.me import MyBusinessUnitRemoveAssociateActionSchema

        return MyBusinessUnitRemoveAssociateActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyBusinessUnitRemoveAssociateActionSchema

        return MyBusinessUnitRemoveAssociateActionSchema().dump(self)


class MyBusinessUnitRemoveBillingAddressIdAction(MyBusinessUnitUpdateAction):
    """Removing a billing address from a [Business Unit](ctp:api:type:BusinessUnit) generates a [BusinessUnitBillingAddressRemoved](ctp:api:type:BusinessUnitBillingAddressRemovedMessage) Message."""

    #: ID of the billing address to be removed. Either `addressId` or `addressKey` is required.
    address_id: typing.Optional[str]
    #: Key of the billing address to be removed. Either `addressId` or `addressKey` is required.
    address_key: typing.Optional[str]

    def __init__(
        self,
        *,
        address_id: typing.Optional[str] = None,
        address_key: typing.Optional[str] = None
    ):
        self.address_id = address_id
        self.address_key = address_key

        super().__init__(action="removeBillingAddressId")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyBusinessUnitRemoveBillingAddressIdAction":
        from ._schemas.me import MyBusinessUnitRemoveBillingAddressIdActionSchema

        return MyBusinessUnitRemoveBillingAddressIdActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyBusinessUnitRemoveBillingAddressIdActionSchema

        return MyBusinessUnitRemoveBillingAddressIdActionSchema().dump(self)


class MyBusinessUnitRemoveShippingAddressIdAction(MyBusinessUnitUpdateAction):
    """Removing a shipping address from a [Business Unit](ctp:api:type:BusinessUnit) generates a [BusinessUnitShippingAddressRemoved](ctp:api:type:BusinessUnitShippingAddressRemovedMessage) Message."""

    #: ID of the shipping address to be removed. Either `addressId` or `addressKey` is required.
    address_id: typing.Optional[str]
    #: Key of the shipping address to be removed. Either `addressId` or `addressKey` is required.
    address_key: typing.Optional[str]

    def __init__(
        self,
        *,
        address_id: typing.Optional[str] = None,
        address_key: typing.Optional[str] = None
    ):
        self.address_id = address_id
        self.address_key = address_key

        super().__init__(action="removeShippingAddressId")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyBusinessUnitRemoveShippingAddressIdAction":
        from ._schemas.me import MyBusinessUnitRemoveShippingAddressIdActionSchema

        return MyBusinessUnitRemoveShippingAddressIdActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyBusinessUnitRemoveShippingAddressIdActionSchema

        return MyBusinessUnitRemoveShippingAddressIdActionSchema().dump(self)


class MyBusinessUnitSetAddressCustomFieldAction(MyBusinessUnitUpdateAction):
    """Adding a Custom Field to an Address of a Business Unit generates the [BusinessUnitAddressCustomFieldAdded](ctp:api:type:BusinessUnitAddressCustomFieldAddedMessage) Message, removing one generates the [BusinessUnitAddressCustomFieldRemoved](ctp:api:type:BusinessUnitAddressCustomFieldRemovedMessage) Message, and updating an existing one generates the [BusinessUnitAddressCustomFieldChanged](ctp:api:type:BusinessUnitAddressCustomFieldChangedMessage) Message."""

    #: ID of the `address` to be extended.
    address_id: str
    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: Trying to remove a field that does not exist will fail with an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
    #: If `value` is provided, it is set for the field defined by `name`.
    value: typing.Optional[typing.Any]

    def __init__(
        self, *, address_id: str, name: str, value: typing.Optional[typing.Any] = None
    ):
        self.address_id = address_id
        self.name = name
        self.value = value

        super().__init__(action="setAddressCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyBusinessUnitSetAddressCustomFieldAction":
        from ._schemas.me import MyBusinessUnitSetAddressCustomFieldActionSchema

        return MyBusinessUnitSetAddressCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyBusinessUnitSetAddressCustomFieldActionSchema

        return MyBusinessUnitSetAddressCustomFieldActionSchema().dump(self)


class MyBusinessUnitSetAddressCustomTypeAction(MyBusinessUnitUpdateAction):
    """Adding or updating a Custom Type to an Address of a Business Unit generates the [BusinessUnitAddressCustomTypeSet](ctp:api:type:BusinessUnitAddressCustomTypeSetMessage) Message, and removing one generates the [BusinessUnitAddressCustomTypeRemoved](ctp:api:type:BusinessUnitAddressCustomTypeRemovedMessage) Message."""

    #: Defines the [Type](ctp:api:type:Type) that extends the `address` with [Custom Fields](/../api/projects/custom-fields).
    #: If absent, any existing Type and Custom Fields are removed from the `address`.
    type: typing.Optional["TypeResourceIdentifier"]
    #: Sets the [Custom Fields](/../api/projects/custom-fields) fields for the `address`.
    fields: typing.Optional["FieldContainer"]
    #: ID of the `address` to be extended.
    address_id: str

    def __init__(
        self,
        *,
        type: typing.Optional["TypeResourceIdentifier"] = None,
        fields: typing.Optional["FieldContainer"] = None,
        address_id: str
    ):
        self.type = type
        self.fields = fields
        self.address_id = address_id

        super().__init__(action="setAddressCustomType")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyBusinessUnitSetAddressCustomTypeAction":
        from ._schemas.me import MyBusinessUnitSetAddressCustomTypeActionSchema

        return MyBusinessUnitSetAddressCustomTypeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyBusinessUnitSetAddressCustomTypeActionSchema

        return MyBusinessUnitSetAddressCustomTypeActionSchema().dump(self)


class MyBusinessUnitSetContactEmailAction(MyBusinessUnitUpdateAction):
    """Setting the contact email on a [Business Unit](ctp:api:type:BusinessUnit) generates a [BusinessUnitContactEmailSet](ctp:api:type:BusinessUnitContactEmailSetMessage) Message."""

    #: Email to set.
    #: If `contactEmail` is absent or `null`, the existing contact email, if any, will be removed.
    contact_email: typing.Optional[str]

    def __init__(self, *, contact_email: typing.Optional[str] = None):
        self.contact_email = contact_email

        super().__init__(action="setContactEmail")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyBusinessUnitSetContactEmailAction":
        from ._schemas.me import MyBusinessUnitSetContactEmailActionSchema

        return MyBusinessUnitSetContactEmailActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyBusinessUnitSetContactEmailActionSchema

        return MyBusinessUnitSetContactEmailActionSchema().dump(self)


class MyBusinessUnitSetCustomFieldAction(MyBusinessUnitUpdateAction):
    """Adding a Custom Field to a Business Unit generates the [BusinessUnitCustomFieldAdded](ctp:api:type:BusinessUnitCustomFieldAddedMessage) Message, removing one generates the [BusinessUnitCustomFieldRemoved](ctp:api:type:BusinessUnitCustomFieldRemovedMessage) Message, and updating an existing one generates the [BusinessUnitCustomFieldChanged](ctp:api:type:BusinessUnitCustomFieldChangedMessage) Message."""

    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: Trying to remove a field that does not exist will fail with an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
    #: If `value` is provided, it is set for the field defined by `name`.
    value: typing.Optional[typing.Any]

    def __init__(self, *, name: str, value: typing.Optional[typing.Any] = None):
        self.name = name
        self.value = value

        super().__init__(action="setCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyBusinessUnitSetCustomFieldAction":
        from ._schemas.me import MyBusinessUnitSetCustomFieldActionSchema

        return MyBusinessUnitSetCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyBusinessUnitSetCustomFieldActionSchema

        return MyBusinessUnitSetCustomFieldActionSchema().dump(self)


class MyBusinessUnitSetCustomTypeAction(MyBusinessUnitUpdateAction):
    """Adding or updating a Custom Type on a Business Unit generates the [BusinessUnitCustomTypeSet](ctp:api:type:BusinessUnitCustomTypeSetMessage) Message, removing one generates the [BusinessUnitCustomTypeRemoved](ctp:api:type:BusinessUnitCustomTypeRemovedMessage) Message."""

    #: Defines the [Type](ctp:api:type:Type) that extends the BusinessUnit with [Custom Fields](/../api/projects/custom-fields).
    #: If absent, any existing Type and Custom Fields are removed from the BusinessUnit.
    type: typing.Optional["TypeResourceIdentifier"]
    #: Sets the [Custom Fields](/../api/projects/custom-fields) for the BusinessUnit.
    fields: typing.Optional["FieldContainer"]

    def __init__(
        self,
        *,
        type: typing.Optional["TypeResourceIdentifier"] = None,
        fields: typing.Optional["FieldContainer"] = None
    ):
        self.type = type
        self.fields = fields

        super().__init__(action="setCustomType")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyBusinessUnitSetCustomTypeAction":
        from ._schemas.me import MyBusinessUnitSetCustomTypeActionSchema

        return MyBusinessUnitSetCustomTypeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyBusinessUnitSetCustomTypeActionSchema

        return MyBusinessUnitSetCustomTypeActionSchema().dump(self)


class MyBusinessUnitSetDefaultBillingAddressAction(MyBusinessUnitUpdateAction):
    """Setting the default billing address on a [Business Unit](ctp:api:type:BusinessUnit) generates the [BusinessUnitDefaultBillingAddressSet](ctp:api:type:BusinessUnitDefaultBillingAddressSetMessage) Message."""

    #: ID of the address to add as a billing address. Either `addressId` or `addressKey` is required.
    address_id: typing.Optional[str]
    #: Key of the address to add as a billing address. Either `addressId` or `addressKey` is required.
    address_key: typing.Optional[str]

    def __init__(
        self,
        *,
        address_id: typing.Optional[str] = None,
        address_key: typing.Optional[str] = None
    ):
        self.address_id = address_id
        self.address_key = address_key

        super().__init__(action="setDefaultBillingAddress")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyBusinessUnitSetDefaultBillingAddressAction":
        from ._schemas.me import MyBusinessUnitSetDefaultBillingAddressActionSchema

        return MyBusinessUnitSetDefaultBillingAddressActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyBusinessUnitSetDefaultBillingAddressActionSchema

        return MyBusinessUnitSetDefaultBillingAddressActionSchema().dump(self)


class MyBusinessUnitSetDefaultShippingAddressAction(MyBusinessUnitUpdateAction):
    """Setting the default shipping address on a [Business Unit](ctp:api:type:BusinessUnit) generates a [BusinessUnitDefaultShippingAddressSet](ctp:api:type:BusinessUnitDefaultShippingAddressSetMessage) Message."""

    #: ID of the address to add as a shipping address. Either `addressId` or `addressKey` is required.
    address_id: typing.Optional[str]
    #: Key of the address to add as a shipping address. Either `addressId` or `addressKey` is required.
    address_key: typing.Optional[str]

    def __init__(
        self,
        *,
        address_id: typing.Optional[str] = None,
        address_key: typing.Optional[str] = None
    ):
        self.address_id = address_id
        self.address_key = address_key

        super().__init__(action="setDefaultShippingAddress")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyBusinessUnitSetDefaultShippingAddressAction":
        from ._schemas.me import MyBusinessUnitSetDefaultShippingAddressActionSchema

        return MyBusinessUnitSetDefaultShippingAddressActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyBusinessUnitSetDefaultShippingAddressActionSchema

        return MyBusinessUnitSetDefaultShippingAddressActionSchema().dump(self)


class MyCartAddDiscountCodeAction(MyCartUpdateAction):
    """Adds a [DiscountCode](ctp:api:type:DiscountCode) to the Cart to activate the related [CartDiscounts](/../api/projects/cartDiscounts).
    Adding a Discount Code is only possible if no [DirectDiscount](ctp:api:type:DirectDiscount) has been applied to the Cart.
    Discount Codes can be added to [frozen Carts](ctp:api:type:FrozenCarts), but their [DiscountCodeState](ctp:api:type:DiscountCodeState) is then `DoesNotMatchCart`.

    The maximum number of Discount Codes in a Cart is restricted by a [limit](/../api/limits#carts).

    Specific Error Code: [MatchingPriceNotFound](ctp:api:type:MatchingPriceNotFoundError)

    """

    #: `code` of a [DiscountCode](ctp:api:type:DiscountCode).
    code: str

    def __init__(self, *, code: str):
        self.code = code

        super().__init__(action="addDiscountCode")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCartAddDiscountCodeAction":
        from ._schemas.me import MyCartAddDiscountCodeActionSchema

        return MyCartAddDiscountCodeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCartAddDiscountCodeActionSchema

        return MyCartAddDiscountCodeActionSchema().dump(self)


class MyCartAddItemShippingAddressAction(MyCartUpdateAction):
    """Adds an address to a Cart when shipping to multiple addresses is desired."""

    #: Address to append to `itemShippingAddresses`.
    #:
    #: The new address must have a key that is unique accross this Cart.
    address: "BaseAddress"

    def __init__(self, *, address: "BaseAddress"):
        self.address = address

        super().__init__(action="addItemShippingAddress")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCartAddItemShippingAddressAction":
        from ._schemas.me import MyCartAddItemShippingAddressActionSchema

        return MyCartAddItemShippingAddressActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCartAddItemShippingAddressActionSchema

        return MyCartAddItemShippingAddressActionSchema().dump(self)


class MyCartAddLineItemAction(MyCartUpdateAction):
    """If the Cart contains a [LineItem](ctp:api:type:LineItem) for a Product Variant with the same [LineItemMode](ctp:api:type:LineItemMode), [Custom Fields](/../api/projects/custom-fields), supply and distribution channel, then only the quantity of the existing Line Item is increased.
    If [LineItem](ctp:api:type:LineItem) `shippingDetails` is set, it is merged. All addresses will be present afterwards and, for address keys present in both shipping details, the quantity will be summed up.
    The [LineItem](ctp:api:type:LineItem) price is set as described in [LineItem Price selection](ctp:api:type:LineItemPriceSelection).

    If the Tax Rate is not set, a [MissingTaxRateForCountry](ctp:api:type:MissingTaxRateForCountryError) error is returned.

    If the Line Items do not have a Price according to the [Product](ctp:api:type:Product) `priceMode` value for a selected currency and/or country, Customer Group, or Channel, a [MatchingPriceNotFound](ctp:api:type:MatchingPriceNotFoundError) error is returned.

    """

    #: User-defined unique identifier of the LineItem.
    key: typing.Optional[str]
    #: `id` of the [Product](ctp:api:type:Product).
    #:
    #: Either the `productId` and `variantId`, or `sku` must be provided.
    product_id: typing.Optional[str]
    #: `id` of the [ProductVariant](ctp:api:type:ProductVariant) in the Product.
    #:
    #: If not given, the Master Variant is used.
    #:
    #: Either the `productId` and `variantId`, or `sku` must be provided.
    variant_id: typing.Optional[int]
    #: `sku` of the [ProductVariant](ctp:api:type:ProductVariant).
    #:
    #: Either the `productId` and `variantId`, or `sku` must be provided.
    sku: typing.Optional[str]
    #: Number of Line Items to add to the Cart.
    quantity: typing.Optional[int]
    #: Date and time (UTC) the Line Item was added to the Cart.
    #: If not set, it defaults to the current date and time.
    #:
    #: Optional for backwards compatibility reasons.
    added_at: typing.Optional[datetime.datetime]
    #: Used to [select](ctp:api:type:LineItemPriceSelection) a Product Price.
    #: The Channel must have the `ProductDistribution` [ChannelRoleEnum](ctp:api:type:ChannelRoleEnum).
    #: If the Cart is bound to a [Store](ctp:api:type:Store) with `distributionChannels` set, the Channel must match one of the Store's distribution channels.
    distribution_channel: typing.Optional["ChannelResourceIdentifier"]
    #: Used to identify [Inventory entries](/../api/projects/inventory) that must be reserved.
    #: The Channel must have the `InventorySupply` [ChannelRoleEnum](ctp:api:type:ChannelRoleEnum).
    supply_channel: typing.Optional["ChannelResourceIdentifier"]
    #: Container for Line Item-specific addresses.
    shipping_details: typing.Optional["ItemShippingDetailsDraft"]
    #: Custom Fields for the Line Item.
    custom: typing.Optional["CustomFieldsDraft"]

    def __init__(
        self,
        *,
        key: typing.Optional[str] = None,
        product_id: typing.Optional[str] = None,
        variant_id: typing.Optional[int] = None,
        sku: typing.Optional[str] = None,
        quantity: typing.Optional[int] = None,
        added_at: typing.Optional[datetime.datetime] = None,
        distribution_channel: typing.Optional["ChannelResourceIdentifier"] = None,
        supply_channel: typing.Optional["ChannelResourceIdentifier"] = None,
        shipping_details: typing.Optional["ItemShippingDetailsDraft"] = None,
        custom: typing.Optional["CustomFieldsDraft"] = None
    ):
        self.key = key
        self.product_id = product_id
        self.variant_id = variant_id
        self.sku = sku
        self.quantity = quantity
        self.added_at = added_at
        self.distribution_channel = distribution_channel
        self.supply_channel = supply_channel
        self.shipping_details = shipping_details
        self.custom = custom

        super().__init__(action="addLineItem")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCartAddLineItemAction":
        from ._schemas.me import MyCartAddLineItemActionSchema

        return MyCartAddLineItemActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCartAddLineItemActionSchema

        return MyCartAddLineItemActionSchema().dump(self)


class MyCartAddPaymentAction(MyCartUpdateAction):
    #: Payment to add to the Cart.
    #: Must not be assigned to another Order or active Cart already.
    payment: "PaymentResourceIdentifier"

    def __init__(self, *, payment: "PaymentResourceIdentifier"):
        self.payment = payment

        super().__init__(action="addPayment")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCartAddPaymentAction":
        from ._schemas.me import MyCartAddPaymentActionSchema

        return MyCartAddPaymentActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCartAddPaymentActionSchema

        return MyCartAddPaymentActionSchema().dump(self)


class MyCartApplyDeltaToLineItemShippingDetailsTargetsAction(MyCartUpdateAction):
    """To override the shipping details, see [Set LineItem ShippingDetails](ctp:api:type:MyCartSetLineItemShippingDetailsAction)."""

    #: `id` of the [LineItem](ctp:api:type:LineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    line_item_id: typing.Optional[str]
    #: `key` of the [LineItem](ctp:api:type:LineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    line_item_key: typing.Optional[str]
    #: Using positive or negative quantities increases or decreases the number of items shipped to an address.
    targets_delta: typing.List["ItemShippingTarget"]

    def __init__(
        self,
        *,
        line_item_id: typing.Optional[str] = None,
        line_item_key: typing.Optional[str] = None,
        targets_delta: typing.List["ItemShippingTarget"]
    ):
        self.line_item_id = line_item_id
        self.line_item_key = line_item_key
        self.targets_delta = targets_delta

        super().__init__(action="applyDeltaToLineItemShippingDetailsTargets")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCartApplyDeltaToLineItemShippingDetailsTargetsAction":
        from ._schemas.me import (
            MyCartApplyDeltaToLineItemShippingDetailsTargetsActionSchema,
        )

        return MyCartApplyDeltaToLineItemShippingDetailsTargetsActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import (
            MyCartApplyDeltaToLineItemShippingDetailsTargetsActionSchema,
        )

        return MyCartApplyDeltaToLineItemShippingDetailsTargetsActionSchema().dump(self)


class MyCartChangeLineItemQuantityAction(MyCartUpdateAction):
    """When multiple shipping addresses are set for a Line Item,
    use the [Remove LineItem](ctp:api:type:CartRemoveLineItemAction) and [Add LineItem](ctp:api:type:CartAddLineItemAction) update action
    to change the shipping details.
    Since it is not possible for the API to infer how the overall change in the Line Item quantity should be distributed over the sub-quantities,
    the `shippingDetails` field is kept in its current state to avoid data loss.

    To change the Line Item quantity and shipping details together,
    use this update action in combination with the [Set LineItem ShippingDetails](ctp:api:type:CartSetLineItemShippingDetailsAction) update action
    in a single Cart update command.

    When the action applies to [LineItems](ctp:api:type:LineItem) with `ExternalTotal` [LineItemPriceMode](ctp:api:type:LineItemPriceMode),
    it will be changed to `ExternalPrice` and the existing `externalPrice` value, i.e. `LineItem.price`, will be retained.
    The LineItem total will be calculated by the system instead, so that the `externalTotalPrice` will be dropped.

    """

    #: `id` of the [LineItem](ctp:api:type:LineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    line_item_id: typing.Optional[str]
    #: `key` of the [LineItem](ctp:api:type:LineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    line_item_key: typing.Optional[str]
    #: New value to set.
    #:
    #: If `0`, the Line Item is removed from the Cart.
    quantity: int
    #: Deprecated. Will be ignored.
    external_price: typing.Optional["Money"]
    #: Deprecated. Will be ignored.
    external_total_price: typing.Optional["ExternalLineItemTotalPrice"]

    def __init__(
        self,
        *,
        line_item_id: typing.Optional[str] = None,
        line_item_key: typing.Optional[str] = None,
        quantity: int,
        external_price: typing.Optional["Money"] = None,
        external_total_price: typing.Optional["ExternalLineItemTotalPrice"] = None
    ):
        self.line_item_id = line_item_id
        self.line_item_key = line_item_key
        self.quantity = quantity
        self.external_price = external_price
        self.external_total_price = external_total_price

        super().__init__(action="changeLineItemQuantity")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCartChangeLineItemQuantityAction":
        from ._schemas.me import MyCartChangeLineItemQuantityActionSchema

        return MyCartChangeLineItemQuantityActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCartChangeLineItemQuantityActionSchema

        return MyCartChangeLineItemQuantityActionSchema().dump(self)


class MyCartChangeTaxModeAction(MyCartUpdateAction):
    """- When `External` [TaxMode](ctp:api:type:TaxMode) is changed to `Platform` or `Disabled`, all previously set external Tax Rates are removed.
    - When set to `Platform`, Line Items, Custom Line Items, and Shipping Method require a Tax Category with a Tax Rate for the Cart's `shippingAddress`.

    """

    #: The new TaxMode.
    tax_mode: "TaxMode"

    def __init__(self, *, tax_mode: "TaxMode"):
        self.tax_mode = tax_mode

        super().__init__(action="changeTaxMode")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCartChangeTaxModeAction":
        from ._schemas.me import MyCartChangeTaxModeActionSchema

        return MyCartChangeTaxModeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCartChangeTaxModeActionSchema

        return MyCartChangeTaxModeActionSchema().dump(self)


class MyCartRecalculateAction(MyCartUpdateAction):
    """This update action does not set any Cart field in particular, but it triggers several [Cart updates](/../api/carts-orders-overview#cart-updates)
    to bring prices and discounts to the latest state. Those can become stale over time when no Cart updates have been performed for a while and
    prices on related Products have changed in the meanwhile.

    If the `priceMode` of the [Product](ctp:api:type:Product) related to a Line Item is of `Embedded` [ProductPriceMode](ctp:api:type:ProductPriceModeEnum),
    the updated `price` of that [LineItem](ctp:api:type:LineItem) may not correspond to a Price in the `variant.prices` anymore.

    """

    #: - Leave empty or set to `false` to only update the Prices and TaxRates of the Line Items.
    #: - Set to `true` to update the Line Items' product data (like `name`, `variant` and `productType`) also.
    update_product_data: typing.Optional[bool]

    def __init__(self, *, update_product_data: typing.Optional[bool] = None):
        self.update_product_data = update_product_data

        super().__init__(action="recalculate")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCartRecalculateAction":
        from ._schemas.me import MyCartRecalculateActionSchema

        return MyCartRecalculateActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCartRecalculateActionSchema

        return MyCartRecalculateActionSchema().dump(self)


class MyCartRemoveDiscountCodeAction(MyCartUpdateAction):
    #: Discount Code to remove from the Cart.
    discount_code: "DiscountCodeReference"

    def __init__(self, *, discount_code: "DiscountCodeReference"):
        self.discount_code = discount_code

        super().__init__(action="removeDiscountCode")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCartRemoveDiscountCodeAction":
        from ._schemas.me import MyCartRemoveDiscountCodeActionSchema

        return MyCartRemoveDiscountCodeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCartRemoveDiscountCodeActionSchema

        return MyCartRemoveDiscountCodeActionSchema().dump(self)


class MyCartRemoveItemShippingAddressAction(MyCartUpdateAction):
    """An address can only be removed if it is not referenced in any [ItemShippingTarget](ctp:api:type:ItemShippingTarget) of the Cart."""

    #: `key` of the Address to remove from `itemShippingAddresses`.
    address_key: str

    def __init__(self, *, address_key: str):
        self.address_key = address_key

        super().__init__(action="removeItemShippingAddress")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCartRemoveItemShippingAddressAction":
        from ._schemas.me import MyCartRemoveItemShippingAddressActionSchema

        return MyCartRemoveItemShippingAddressActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCartRemoveItemShippingAddressActionSchema

        return MyCartRemoveItemShippingAddressActionSchema().dump(self)


class MyCartRemoveLineItemAction(MyCartUpdateAction):
    """The [LineItem](ctp:api:type:LineItem) price is updated as described in [LineItem Price selection](ctp:api:type:LineItemPriceSelection)."""

    #: `id` of the [LineItem](ctp:api:type:LineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    line_item_id: typing.Optional[str]
    #: `key` of the [LineItem](ctp:api:type:LineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    line_item_key: typing.Optional[str]
    #: Amount to subtract from the LineItem's `quantity`.
    #: If absent, the LineItem is removed from the Cart.
    quantity: typing.Optional[int]
    #: Sets the [LineItem](ctp:api:type:LineItem) `price` to the given value when decreasing the quantity of a Line Item with the `ExternalPrice` [LineItemPriceMode](ctp:api:type:LineItemPriceMode).
    external_price: typing.Optional["Money"]
    #: Sets the [LineItem](ctp:api:type:LineItem) `price` and `totalPrice` to the given value when decreasing the quantity of a Line Item with the `ExternalTotal` [LineItemPriceMode](ctp:api:type:LineItemPriceMode).
    external_total_price: typing.Optional["ExternalLineItemTotalPrice"]
    #: Container for Line Item-specific addresses to remove.
    shipping_details_to_remove: typing.Optional["ItemShippingDetailsDraft"]

    def __init__(
        self,
        *,
        line_item_id: typing.Optional[str] = None,
        line_item_key: typing.Optional[str] = None,
        quantity: typing.Optional[int] = None,
        external_price: typing.Optional["Money"] = None,
        external_total_price: typing.Optional["ExternalLineItemTotalPrice"] = None,
        shipping_details_to_remove: typing.Optional["ItemShippingDetailsDraft"] = None
    ):
        self.line_item_id = line_item_id
        self.line_item_key = line_item_key
        self.quantity = quantity
        self.external_price = external_price
        self.external_total_price = external_total_price
        self.shipping_details_to_remove = shipping_details_to_remove

        super().__init__(action="removeLineItem")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCartRemoveLineItemAction":
        from ._schemas.me import MyCartRemoveLineItemActionSchema

        return MyCartRemoveLineItemActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCartRemoveLineItemActionSchema

        return MyCartRemoveLineItemActionSchema().dump(self)


class MyCartRemovePaymentAction(MyCartUpdateAction):
    #: Payment to remove from the Cart.
    payment: "PaymentResourceIdentifier"

    def __init__(self, *, payment: "PaymentResourceIdentifier"):
        self.payment = payment

        super().__init__(action="removePayment")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCartRemovePaymentAction":
        from ._schemas.me import MyCartRemovePaymentActionSchema

        return MyCartRemovePaymentActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCartRemovePaymentActionSchema

        return MyCartRemovePaymentActionSchema().dump(self)


class MyCartSetBillingAddressAction(MyCartUpdateAction):
    #: Value to set.
    #: If empty, any existing value is removed.
    address: typing.Optional["BaseAddress"]

    def __init__(self, *, address: typing.Optional["BaseAddress"] = None):
        self.address = address

        super().__init__(action="setBillingAddress")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCartSetBillingAddressAction":
        from ._schemas.me import MyCartSetBillingAddressActionSchema

        return MyCartSetBillingAddressActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCartSetBillingAddressActionSchema

        return MyCartSetBillingAddressActionSchema().dump(self)


class MyCartSetBusinessUnitAction(MyCartUpdateAction):
    """Updates the Business Unit on the Cart. The Cart must have an existing Business Unit assigned already."""

    #: New Business Unit to assign to the Cart, which must have access to the [Store](/../api/projects/stores) that is set on the Cart.
    #: Additionally, the authenticated user must be an [Associate](/projects/business-units#associate) in the [Business Unit](/projects/business-units#businessunit).
    business_unit: "BusinessUnitResourceIdentifier"

    def __init__(self, *, business_unit: "BusinessUnitResourceIdentifier"):
        self.business_unit = business_unit

        super().__init__(action="setBusinessUnit")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCartSetBusinessUnitAction":
        from ._schemas.me import MyCartSetBusinessUnitActionSchema

        return MyCartSetBusinessUnitActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCartSetBusinessUnitActionSchema

        return MyCartSetBusinessUnitActionSchema().dump(self)


class MyCartSetCountryAction(MyCartUpdateAction):
    """Setting the country can lead to changes in the [LineItem](ctp:api:type:LineItem) prices."""

    #: Value to set.
    #: If empty, any existing value is removed.
    #:
    #: If the Cart is bound to a `store`, the provided value must be included in the [Store's](ctp:api:type:Store) `countries`.
    #: Otherwise a [CountryNotConfiguredInStore](ctp:api:type:CountryNotConfiguredInStoreError) error is returned.
    country: typing.Optional[str]

    def __init__(self, *, country: typing.Optional[str] = None):
        self.country = country

        super().__init__(action="setCountry")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCartSetCountryAction":
        from ._schemas.me import MyCartSetCountryActionSchema

        return MyCartSetCountryActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCartSetCountryActionSchema

        return MyCartSetCountryActionSchema().dump(self)


class MyCartSetCustomFieldAction(MyCartUpdateAction):
    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: Removing a field that does not exist returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
    #: If `value` is provided, it is set for the field defined by `name`.
    value: typing.Optional[typing.Any]

    def __init__(self, *, name: str, value: typing.Optional[typing.Any] = None):
        self.name = name
        self.value = value

        super().__init__(action="setCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCartSetCustomFieldAction":
        from ._schemas.me import MyCartSetCustomFieldActionSchema

        return MyCartSetCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCartSetCustomFieldActionSchema

        return MyCartSetCustomFieldActionSchema().dump(self)


class MyCartSetCustomTypeAction(MyCartUpdateAction):
    #: Defines the [Type](ctp:api:type:Type) that extends the Cart with [Custom Fields](/../api/projects/custom-fields).
    #: If absent, any existing Type and Custom Fields are removed from the Cart.
    type: typing.Optional["TypeResourceIdentifier"]
    #: Sets the [Custom Fields](/../api/projects/custom-fields) fields for the Cart.
    fields: typing.Optional["FieldContainer"]

    def __init__(
        self,
        *,
        type: typing.Optional["TypeResourceIdentifier"] = None,
        fields: typing.Optional["FieldContainer"] = None
    ):
        self.type = type
        self.fields = fields

        super().__init__(action="setCustomType")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCartSetCustomTypeAction":
        from ._schemas.me import MyCartSetCustomTypeActionSchema

        return MyCartSetCustomTypeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCartSetCustomTypeActionSchema

        return MyCartSetCustomTypeActionSchema().dump(self)


class MyCartSetCustomerEmailAction(MyCartUpdateAction):
    #: Value to set.
    #: If empty, any existing value is removed.
    email: typing.Optional[str]

    def __init__(self, *, email: typing.Optional[str] = None):
        self.email = email

        super().__init__(action="setCustomerEmail")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCartSetCustomerEmailAction":
        from ._schemas.me import MyCartSetCustomerEmailActionSchema

        return MyCartSetCustomerEmailActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCartSetCustomerEmailActionSchema

        return MyCartSetCustomerEmailActionSchema().dump(self)


class MyCartSetDeleteDaysAfterLastModificationAction(MyCartUpdateAction):
    """Number of days after which a Cart with `Active` [CartState](ctp:api:type:CartState) is deleted since its last modification.

    If a [ChangeSubscription](ctp:api:type:ChangeSubscription) exists for Carts, a [ResourceDeletedDeliveryPayload](ctp:api:type:ResourceDeletedDeliveryPayload) is sent.

    """

    #: Value to set.
    #: If not provided, the default value for this field configured in [Project settings](ctp:api:type:CartsConfiguration) is assigned.
    delete_days_after_last_modification: typing.Optional[int]

    def __init__(
        self, *, delete_days_after_last_modification: typing.Optional[int] = None
    ):
        self.delete_days_after_last_modification = delete_days_after_last_modification

        super().__init__(action="setDeleteDaysAfterLastModification")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCartSetDeleteDaysAfterLastModificationAction":
        from ._schemas.me import MyCartSetDeleteDaysAfterLastModificationActionSchema

        return MyCartSetDeleteDaysAfterLastModificationActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCartSetDeleteDaysAfterLastModificationActionSchema

        return MyCartSetDeleteDaysAfterLastModificationActionSchema().dump(self)


class MyCartSetLineItemCustomFieldAction(MyCartUpdateAction):
    #: `id` of the [LineItem](ctp:api:type:LineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    line_item_id: typing.Optional[str]
    #: `key` of the [LineItem](ctp:api:type:LineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    line_item_key: typing.Optional[str]
    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: Removing a field that does not exist returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
    #: If `value` is provided, it is set for the field defined by `name`.
    value: typing.Optional[typing.Any]

    def __init__(
        self,
        *,
        line_item_id: typing.Optional[str] = None,
        line_item_key: typing.Optional[str] = None,
        name: str,
        value: typing.Optional[typing.Any] = None
    ):
        self.line_item_id = line_item_id
        self.line_item_key = line_item_key
        self.name = name
        self.value = value

        super().__init__(action="setLineItemCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCartSetLineItemCustomFieldAction":
        from ._schemas.me import MyCartSetLineItemCustomFieldActionSchema

        return MyCartSetLineItemCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCartSetLineItemCustomFieldActionSchema

        return MyCartSetLineItemCustomFieldActionSchema().dump(self)


class MyCartSetLineItemCustomTypeAction(MyCartUpdateAction):
    #: `id` of the [LineItem](ctp:api:type:LineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    line_item_id: typing.Optional[str]
    #: `key` of the [LineItem](ctp:api:type:LineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    line_item_key: typing.Optional[str]
    #: Defines the [Type](ctp:api:type:Type) that extends the LineItem with [Custom Fields](/../api/projects/custom-fields).
    #: If absent, any existing Type and Custom Fields are removed from the Line Item.
    type: typing.Optional["TypeResourceIdentifier"]
    #: Sets the [Custom Fields](/../api/projects/custom-fields) fields for the Line Item.
    fields: typing.Optional["FieldContainer"]

    def __init__(
        self,
        *,
        line_item_id: typing.Optional[str] = None,
        line_item_key: typing.Optional[str] = None,
        type: typing.Optional["TypeResourceIdentifier"] = None,
        fields: typing.Optional["FieldContainer"] = None
    ):
        self.line_item_id = line_item_id
        self.line_item_key = line_item_key
        self.type = type
        self.fields = fields

        super().__init__(action="setLineItemCustomType")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCartSetLineItemCustomTypeAction":
        from ._schemas.me import MyCartSetLineItemCustomTypeActionSchema

        return MyCartSetLineItemCustomTypeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCartSetLineItemCustomTypeActionSchema

        return MyCartSetLineItemCustomTypeActionSchema().dump(self)


class MyCartSetLineItemDistributionChannelAction(MyCartUpdateAction):
    """Setting a distribution channel for a [LineItem](ctp:api:type:LineItem) can lead to an updated `price` as described in [LineItem Price selection](ctp:api:type:LineItemPriceSelection)."""

    #: `id` of the [LineItem](ctp:api:type:LineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    line_item_id: typing.Optional[str]
    #: `key` of the [LineItem](ctp:api:type:LineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    line_item_key: typing.Optional[str]
    #: - If present, a [Reference](ctp:api:type:Reference) to the Channel is set for the [LineItem](ctp:api:type:LineItem) specified by `lineItemId`.
    #: - If not present, the current [Reference](ctp:api:type:Reference) to a distribution channel is removed from the [LineItem](ctp:api:type:LineItem) specified by `lineItemId`.
    #:   The Channel must have the `ProductDistribution` [ChannelRoleEnum](ctp:api:type:ChannelRoleEnum).
    distribution_channel: typing.Optional["ChannelResourceIdentifier"]

    def __init__(
        self,
        *,
        line_item_id: typing.Optional[str] = None,
        line_item_key: typing.Optional[str] = None,
        distribution_channel: typing.Optional["ChannelResourceIdentifier"] = None
    ):
        self.line_item_id = line_item_id
        self.line_item_key = line_item_key
        self.distribution_channel = distribution_channel

        super().__init__(action="setLineItemDistributionChannel")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCartSetLineItemDistributionChannelAction":
        from ._schemas.me import MyCartSetLineItemDistributionChannelActionSchema

        return MyCartSetLineItemDistributionChannelActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCartSetLineItemDistributionChannelActionSchema

        return MyCartSetLineItemDistributionChannelActionSchema().dump(self)


class MyCartSetLineItemShippingDetailsAction(MyCartUpdateAction):
    #: `id` of the [LineItem](ctp:api:type:LineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    line_item_id: typing.Optional[str]
    #: `key` of the [LineItem](ctp:api:type:LineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    line_item_key: typing.Optional[str]
    #: Value to set.
    #: If empty, the existing value is removed.
    shipping_details: typing.Optional["ItemShippingDetailsDraft"]

    def __init__(
        self,
        *,
        line_item_id: typing.Optional[str] = None,
        line_item_key: typing.Optional[str] = None,
        shipping_details: typing.Optional["ItemShippingDetailsDraft"] = None
    ):
        self.line_item_id = line_item_id
        self.line_item_key = line_item_key
        self.shipping_details = shipping_details

        super().__init__(action="setLineItemShippingDetails")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCartSetLineItemShippingDetailsAction":
        from ._schemas.me import MyCartSetLineItemShippingDetailsActionSchema

        return MyCartSetLineItemShippingDetailsActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCartSetLineItemShippingDetailsActionSchema

        return MyCartSetLineItemShippingDetailsActionSchema().dump(self)


class MyCartSetLineItemSupplyChannelAction(MyCartUpdateAction):
    """Performing this action has no impact on inventory that should be reserved."""

    #: `id` of the [LineItem](ctp:api:type:LineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    line_item_id: typing.Optional[str]
    #: `key` of the [LineItem](ctp:api:type:LineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    line_item_key: typing.Optional[str]
    #: - If present, a [Reference](ctp:api:type:Reference) to the Channel is set for the [LineItem](ctp:api:type:LineItem) specified by `lineItemId`.
    #: - If not present, the current [Reference](ctp:api:type:Reference) to a supply channel will be removed from the [LineItem](ctp:api:type:LineItem) specified by `lineItemId`.
    #:   The Channel must have the `InventorySupply` [ChannelRoleEnum](ctp:api:type:ChannelRoleEnum).
    supply_channel: typing.Optional["ChannelResourceIdentifier"]

    def __init__(
        self,
        *,
        line_item_id: typing.Optional[str] = None,
        line_item_key: typing.Optional[str] = None,
        supply_channel: typing.Optional["ChannelResourceIdentifier"] = None
    ):
        self.line_item_id = line_item_id
        self.line_item_key = line_item_key
        self.supply_channel = supply_channel

        super().__init__(action="setLineItemSupplyChannel")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCartSetLineItemSupplyChannelAction":
        from ._schemas.me import MyCartSetLineItemSupplyChannelActionSchema

        return MyCartSetLineItemSupplyChannelActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCartSetLineItemSupplyChannelActionSchema

        return MyCartSetLineItemSupplyChannelActionSchema().dump(self)


class MyCartSetLocaleAction(MyCartUpdateAction):
    #: Value to set.
    #: Must be one of the [Project](ctp:api:type:Project)'s `languages`.
    #: If empty, any existing value will be removed.
    locale: typing.Optional[str]

    def __init__(self, *, locale: typing.Optional[str] = None):
        self.locale = locale

        super().__init__(action="setLocale")

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "MyCartSetLocaleAction":
        from ._schemas.me import MyCartSetLocaleActionSchema

        return MyCartSetLocaleActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCartSetLocaleActionSchema

        return MyCartSetLocaleActionSchema().dump(self)


class MyCartSetShippingAddressAction(MyCartUpdateAction):
    """Setting the shipping address also sets the [TaxRate](ctp:api:type:TaxRate) of Line Items and calculates the [TaxedPrice](ctp:api:type:TaxedPrice).

    If a matching price cannot be found for the given shipping address during [Line Item Price selection](ctp:api:type:LineItemPriceSelection),
    a [MissingTaxRateForCountry](ctp:api:type:MissingTaxRateForCountryError) error is returned.

    If you want to allow shipping to states inside a country that are not explicitly covered by a TaxRate,
    set the `countryTaxRateFallbackEnabled` field to `true` in the [CartsConfiguration](ctp:api:type:CartsConfiguration) by using
    the [Change CountryTaxRateFallbackEnabled](ctp:api:type:ProjectChangeCountryTaxRateFallbackEnabledAction) update action.

    """

    #: Value to set.
    #: If not set, the shipping address is unset, and the `taxedPrice` and `taxRate` are unset in all Line Items.
    address: typing.Optional["BaseAddress"]

    def __init__(self, *, address: typing.Optional["BaseAddress"] = None):
        self.address = address

        super().__init__(action="setShippingAddress")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCartSetShippingAddressAction":
        from ._schemas.me import MyCartSetShippingAddressActionSchema

        return MyCartSetShippingAddressActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCartSetShippingAddressActionSchema

        return MyCartSetShippingAddressActionSchema().dump(self)


class MyCartSetShippingMethodAction(MyCartUpdateAction):
    """To set the Cart's Shipping Method the Cart must have the `Single` [ShippingMode](ctp:api:type:ShippingMode) and a `shippingAddress`."""

    #: Value to set.
    #: If empty, any existing value is removed.
    #:
    #: If the referenced Shipping Method has a predicate that does not match the Cart, an [InvalidOperation](ctp:api:type:InvalidOperationError) error is returned.
    shipping_method: typing.Optional["ShippingMethodResourceIdentifier"]
    #: An external Tax Rate can be set if the Cart has the `External` [TaxMode](ctp:api:type:TaxMode).
    external_tax_rate: typing.Optional["ExternalTaxRateDraft"]

    def __init__(
        self,
        *,
        shipping_method: typing.Optional["ShippingMethodResourceIdentifier"] = None,
        external_tax_rate: typing.Optional["ExternalTaxRateDraft"] = None
    ):
        self.shipping_method = shipping_method
        self.external_tax_rate = external_tax_rate

        super().__init__(action="setShippingMethod")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCartSetShippingMethodAction":
        from ._schemas.me import MyCartSetShippingMethodActionSchema

        return MyCartSetShippingMethodActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCartSetShippingMethodActionSchema

        return MyCartSetShippingMethodActionSchema().dump(self)


class MyCartUpdateItemShippingAddressAction(MyCartUpdateAction):
    """Updates an address in `itemShippingAddresses` by keeping the Address `key`."""

    #: The new Address with the same `key` as the Address it will replace.
    address: "BaseAddress"

    def __init__(self, *, address: "BaseAddress"):
        self.address = address

        super().__init__(action="updateItemShippingAddress")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCartUpdateItemShippingAddressAction":
        from ._schemas.me import MyCartUpdateItemShippingAddressActionSchema

        return MyCartUpdateItemShippingAddressActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCartUpdateItemShippingAddressActionSchema

        return MyCartUpdateItemShippingAddressActionSchema().dump(self)


class MyCustomerAddAddressAction(MyCustomerUpdateAction):
    """Adding an address to the Customer produces the [CustomerAddressAdded](ctp:api:type:CustomerAddressAddedMessage) Message."""

    #: Value to append to the `addresses` array.
    address: "BaseAddress"

    def __init__(self, *, address: "BaseAddress"):
        self.address = address

        super().__init__(action="addAddress")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCustomerAddAddressAction":
        from ._schemas.me import MyCustomerAddAddressActionSchema

        return MyCustomerAddAddressActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCustomerAddAddressActionSchema

        return MyCustomerAddAddressActionSchema().dump(self)


class MyCustomerAddBillingAddressIdAction(MyCustomerUpdateAction):
    """Adds an address from the `addresses` array to `billingAddressIds`. Either `addressId` or `addressKey` is required."""

    #: `id` of the [Address](ctp:api:type:Address) to become a billing address.
    address_id: typing.Optional[str]
    #: `key` of the [Address](ctp:api:type:Address) to become a billing address.
    address_key: typing.Optional[str]

    def __init__(
        self,
        *,
        address_id: typing.Optional[str] = None,
        address_key: typing.Optional[str] = None
    ):
        self.address_id = address_id
        self.address_key = address_key

        super().__init__(action="addBillingAddressId")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCustomerAddBillingAddressIdAction":
        from ._schemas.me import MyCustomerAddBillingAddressIdActionSchema

        return MyCustomerAddBillingAddressIdActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCustomerAddBillingAddressIdActionSchema

        return MyCustomerAddBillingAddressIdActionSchema().dump(self)


class MyCustomerAddShippingAddressIdAction(MyCustomerUpdateAction):
    """Adds an address from the `addresses` array to `shippingAddressIds`. Either `addressId` or `addressKey` is required."""

    #: `id` of the [Address](ctp:api:type:Address) to become a shipping address.
    address_id: typing.Optional[str]
    #: `key` of the [Address](ctp:api:type:Address) to become a shipping address.
    address_key: typing.Optional[str]

    def __init__(
        self,
        *,
        address_id: typing.Optional[str] = None,
        address_key: typing.Optional[str] = None
    ):
        self.address_id = address_id
        self.address_key = address_key

        super().__init__(action="addShippingAddressId")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCustomerAddShippingAddressIdAction":
        from ._schemas.me import MyCustomerAddShippingAddressIdActionSchema

        return MyCustomerAddShippingAddressIdActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCustomerAddShippingAddressIdActionSchema

        return MyCustomerAddShippingAddressIdActionSchema().dump(self)


class MyCustomerChangeAddressAction(MyCustomerUpdateAction):
    """Changing an address of the Customer produces the [CustomerAddressChanged](ctp:api:type:CustomerAddressChangedMessage) Message.

    Either `addressId` or `addressKey` is required.

    """

    #: `id` of the [Address](ctp:api:type:Address) to change.
    address_id: typing.Optional[str]
    #: `key` of the [Address](ctp:api:type:Address) to change.
    address_key: typing.Optional[str]
    #: Value to set.
    address: "BaseAddress"

    def __init__(
        self,
        *,
        address_id: typing.Optional[str] = None,
        address_key: typing.Optional[str] = None,
        address: "BaseAddress"
    ):
        self.address_id = address_id
        self.address_key = address_key
        self.address = address

        super().__init__(action="changeAddress")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCustomerChangeAddressAction":
        from ._schemas.me import MyCustomerChangeAddressActionSchema

        return MyCustomerChangeAddressActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCustomerChangeAddressActionSchema

        return MyCustomerChangeAddressActionSchema().dump(self)


class MyCustomerChangeEmailAction(MyCustomerUpdateAction):
    """Changing the email of the Customer produces the [CustomerEmailChanged](ctp:api:type:CustomerEmailChangedMessage) Message."""

    #: New value to set.
    email: str

    def __init__(self, *, email: str):
        self.email = email

        super().__init__(action="changeEmail")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCustomerChangeEmailAction":
        from ._schemas.me import MyCustomerChangeEmailActionSchema

        return MyCustomerChangeEmailActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCustomerChangeEmailActionSchema

        return MyCustomerChangeEmailActionSchema().dump(self)


class MyCustomerRemoveAddressAction(MyCustomerUpdateAction):
    """Removing an address of the Customer produces the [CustomerAddressRemoved](ctp:api:type:CustomerAddressRemovedMessage) Message.

    Either `addressId` or `addressKey` is required.

    """

    #: `id` of the [Address](ctp:api:type:Address) to remove.
    address_id: typing.Optional[str]
    #: `key` of the [Address](ctp:api:type:Address) to remove.
    address_key: typing.Optional[str]

    def __init__(
        self,
        *,
        address_id: typing.Optional[str] = None,
        address_key: typing.Optional[str] = None
    ):
        self.address_id = address_id
        self.address_key = address_key

        super().__init__(action="removeAddress")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCustomerRemoveAddressAction":
        from ._schemas.me import MyCustomerRemoveAddressActionSchema

        return MyCustomerRemoveAddressActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCustomerRemoveAddressActionSchema

        return MyCustomerRemoveAddressActionSchema().dump(self)


class MyCustomerRemoveBillingAddressIdAction(MyCustomerUpdateAction):
    """Removes an existing billing address from `billingAddressesIds`.
    If the billing address is the default billing address, the `defaultBillingAddressId` is unset. Either `addressId` or `addressKey` is required.

    """

    #: `id` of the [Address](ctp:api:type:Address) to remove from `billingAddressesIds`.
    address_id: typing.Optional[str]
    #: `key` of the [Address](ctp:api:type:Address) to remove from `billingAddressesIds`.
    address_key: typing.Optional[str]

    def __init__(
        self,
        *,
        address_id: typing.Optional[str] = None,
        address_key: typing.Optional[str] = None
    ):
        self.address_id = address_id
        self.address_key = address_key

        super().__init__(action="removeBillingAddressId")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCustomerRemoveBillingAddressIdAction":
        from ._schemas.me import MyCustomerRemoveBillingAddressIdActionSchema

        return MyCustomerRemoveBillingAddressIdActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCustomerRemoveBillingAddressIdActionSchema

        return MyCustomerRemoveBillingAddressIdActionSchema().dump(self)


class MyCustomerRemoveShippingAddressIdAction(MyCustomerUpdateAction):
    """Removes an existing shipping address from `shippingAddressesIds`.
    If the shipping address is the default shipping address, the `defaultShippingAddressId` is unset. Either `addressId` or `addressKey` is required.

    """

    #: `id` of the [Address](ctp:api:type:Address) to remove from `shippingAddressesIds`.
    address_id: typing.Optional[str]
    #: `key` of the [Address](ctp:api:type:Address) to remove from `shippingAddressesIds`.
    address_key: typing.Optional[str]

    def __init__(
        self,
        *,
        address_id: typing.Optional[str] = None,
        address_key: typing.Optional[str] = None
    ):
        self.address_id = address_id
        self.address_key = address_key

        super().__init__(action="removeShippingAddressId")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCustomerRemoveShippingAddressIdAction":
        from ._schemas.me import MyCustomerRemoveShippingAddressIdActionSchema

        return MyCustomerRemoveShippingAddressIdActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCustomerRemoveShippingAddressIdActionSchema

        return MyCustomerRemoveShippingAddressIdActionSchema().dump(self)


class MyCustomerSetCompanyNameAction(MyCustomerUpdateAction):
    """Setting the `companyName` field on the Customer produces the [CustomerCompanyNameSet](ctp:api:type:CustomerCompanyNameSetMessage) Message."""

    #: Value to set.
    #: If empty, any existing value is removed.
    company_name: typing.Optional[str]

    def __init__(self, *, company_name: typing.Optional[str] = None):
        self.company_name = company_name

        super().__init__(action="setCompanyName")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCustomerSetCompanyNameAction":
        from ._schemas.me import MyCustomerSetCompanyNameActionSchema

        return MyCustomerSetCompanyNameActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCustomerSetCompanyNameActionSchema

        return MyCustomerSetCompanyNameActionSchema().dump(self)


class MyCustomerSetCustomFieldAction(MyCustomerUpdateAction):
    """Adding a Custom Field to a Customer generates the [CustomerCustomFieldAdded](ctp:api:type:CustomerCustomFieldAddedMessage) Message, removing one generates the [CustomerCustomFieldRemoved](ctp:api:type:CustomerCustomFieldRemovedMessage) Message, and updating an existing one generates the [CustomerCustomFieldChanged](ctp:api:type:CustomerCustomFieldChangedMessage) Message."""

    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: If `value` is provided, it is set for the field defined by `name`.
    #: Trying to remove a field that does not exist will fail with an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
    value: typing.Optional[typing.Any]

    def __init__(self, *, name: str, value: typing.Optional[typing.Any] = None):
        self.name = name
        self.value = value

        super().__init__(action="setCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCustomerSetCustomFieldAction":
        from ._schemas.me import MyCustomerSetCustomFieldActionSchema

        return MyCustomerSetCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCustomerSetCustomFieldActionSchema

        return MyCustomerSetCustomFieldActionSchema().dump(self)


class MyCustomerSetCustomTypeAction(MyCustomerUpdateAction):
    """Adding or updating a Custom Type on a Customer generates the [CustomerCustomTypeSet](ctp:api:type:CustomerCustomTypeSetMessage) Message, removing one generates the [CustomerCustomTypeRemoved](ctp:api:type:CustomerCustomTypeRemovedMessage) Message."""

    #: Defines the [Type](ctp:api:type:Type) that extends the MyCustomer with [Custom Fields](/../api/projects/custom-fields).
    #: If absent, any existing Type and Custom Fields are removed from the MyCustomer.
    type: typing.Optional["TypeResourceIdentifier"]
    #: Sets the [Custom Fields](/../api/projects/custom-fields) fields for the MyCustomer.
    fields: typing.Optional["FieldContainer"]

    def __init__(
        self,
        *,
        type: typing.Optional["TypeResourceIdentifier"] = None,
        fields: typing.Optional["FieldContainer"] = None
    ):
        self.type = type
        self.fields = fields

        super().__init__(action="setCustomType")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCustomerSetCustomTypeAction":
        from ._schemas.me import MyCustomerSetCustomTypeActionSchema

        return MyCustomerSetCustomTypeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCustomerSetCustomTypeActionSchema

        return MyCustomerSetCustomTypeActionSchema().dump(self)


class MyCustomerSetDateOfBirthAction(MyCustomerUpdateAction):
    """Setting the date of birth of the Customer produces the [CustomerDateOfBirthSet](ctp:api:type:CustomerDateOfBirthSetMessage) Message."""

    #: Value to set.
    #: If empty, any existing value is removed.
    date_of_birth: typing.Optional[datetime.date]

    def __init__(self, *, date_of_birth: typing.Optional[datetime.date] = None):
        self.date_of_birth = date_of_birth

        super().__init__(action="setDateOfBirth")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCustomerSetDateOfBirthAction":
        from ._schemas.me import MyCustomerSetDateOfBirthActionSchema

        return MyCustomerSetDateOfBirthActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCustomerSetDateOfBirthActionSchema

        return MyCustomerSetDateOfBirthActionSchema().dump(self)


class MyCustomerSetDefaultBillingAddressAction(MyCustomerUpdateAction):
    """Sets the default billing address from `addresses`.
    If the address is not currently a billing address, it is added to `billingAddressIds`. Either `addressId` or `addressKey` is required.

    """

    #: `id` of the [Address](ctp:api:type:Address) to become the default billing address.
    address_id: typing.Optional[str]
    #: `key` of the [Address](ctp:api:type:Address) to become the default billing address.
    address_key: typing.Optional[str]

    def __init__(
        self,
        *,
        address_id: typing.Optional[str] = None,
        address_key: typing.Optional[str] = None
    ):
        self.address_id = address_id
        self.address_key = address_key

        super().__init__(action="setDefaultBillingAddress")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCustomerSetDefaultBillingAddressAction":
        from ._schemas.me import MyCustomerSetDefaultBillingAddressActionSchema

        return MyCustomerSetDefaultBillingAddressActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCustomerSetDefaultBillingAddressActionSchema

        return MyCustomerSetDefaultBillingAddressActionSchema().dump(self)


class MyCustomerSetDefaultShippingAddressAction(MyCustomerUpdateAction):
    """Sets the default shipping address from `addresses`.
    If the address is not currently a shipping address, it is added to `shippingAddressIds`. Either `addressId` or `addressKey` is required.

    """

    #: `id` of the [Address](ctp:api:type:Address) to become the default shipping address.
    address_id: typing.Optional[str]
    #: `key` of the [Address](ctp:api:type:Address) to become the default shipping address.
    address_key: typing.Optional[str]

    def __init__(
        self,
        *,
        address_id: typing.Optional[str] = None,
        address_key: typing.Optional[str] = None
    ):
        self.address_id = address_id
        self.address_key = address_key

        super().__init__(action="setDefaultShippingAddress")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCustomerSetDefaultShippingAddressAction":
        from ._schemas.me import MyCustomerSetDefaultShippingAddressActionSchema

        return MyCustomerSetDefaultShippingAddressActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCustomerSetDefaultShippingAddressActionSchema

        return MyCustomerSetDefaultShippingAddressActionSchema().dump(self)


class MyCustomerSetFirstNameAction(MyCustomerUpdateAction):
    """Setting the first name of the Customer produces the [CustomerFirstNameSet](ctp:api:type:CustomerFirstNameSetMessage) Message."""

    #: Value to set.
    #: If empty, any existing value is removed.
    first_name: typing.Optional[str]

    def __init__(self, *, first_name: typing.Optional[str] = None):
        self.first_name = first_name

        super().__init__(action="setFirstName")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCustomerSetFirstNameAction":
        from ._schemas.me import MyCustomerSetFirstNameActionSchema

        return MyCustomerSetFirstNameActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCustomerSetFirstNameActionSchema

        return MyCustomerSetFirstNameActionSchema().dump(self)


class MyCustomerSetLastNameAction(MyCustomerUpdateAction):
    """Setting the last name of the Customer produces the [CustomerLastNameSet](ctp:api:type:CustomerLastNameSetMessage) Message."""

    #: Value to set.
    #: If empty, any existing value is removed.
    last_name: typing.Optional[str]

    def __init__(self, *, last_name: typing.Optional[str] = None):
        self.last_name = last_name

        super().__init__(action="setLastName")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCustomerSetLastNameAction":
        from ._schemas.me import MyCustomerSetLastNameActionSchema

        return MyCustomerSetLastNameActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCustomerSetLastNameActionSchema

        return MyCustomerSetLastNameActionSchema().dump(self)


class MyCustomerSetLocaleAction(MyCustomerUpdateAction):
    #: Value to set.
    #: Must be one of the languages supported by the [Project](ctp:api:type:Project).
    locale: typing.Optional[str]

    def __init__(self, *, locale: typing.Optional[str] = None):
        self.locale = locale

        super().__init__(action="setLocale")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCustomerSetLocaleAction":
        from ._schemas.me import MyCustomerSetLocaleActionSchema

        return MyCustomerSetLocaleActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCustomerSetLocaleActionSchema

        return MyCustomerSetLocaleActionSchema().dump(self)


class MyCustomerSetMiddleNameAction(MyCustomerUpdateAction):
    #: Value to set.
    #: If empty, any existing value is removed.
    middle_name: typing.Optional[str]

    def __init__(self, *, middle_name: typing.Optional[str] = None):
        self.middle_name = middle_name

        super().__init__(action="setMiddleName")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCustomerSetMiddleNameAction":
        from ._schemas.me import MyCustomerSetMiddleNameActionSchema

        return MyCustomerSetMiddleNameActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCustomerSetMiddleNameActionSchema

        return MyCustomerSetMiddleNameActionSchema().dump(self)


class MyCustomerSetSalutationAction(MyCustomerUpdateAction):
    #: Value to set.
    #: If empty, any existing value is removed.
    salutation: typing.Optional[str]

    def __init__(self, *, salutation: typing.Optional[str] = None):
        self.salutation = salutation

        super().__init__(action="setSalutation")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCustomerSetSalutationAction":
        from ._schemas.me import MyCustomerSetSalutationActionSchema

        return MyCustomerSetSalutationActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCustomerSetSalutationActionSchema

        return MyCustomerSetSalutationActionSchema().dump(self)


class MyCustomerSetTitleAction(MyCustomerUpdateAction):
    """Setting the title of the Customer produces the [CustomerTitleSetMessage](ctp:api:type:CustomerTitleSetMessage)."""

    #: Value to set.
    #: If empty, any existing value is removed.
    title: typing.Optional[str]

    def __init__(self, *, title: typing.Optional[str] = None):
        self.title = title

        super().__init__(action="setTitle")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCustomerSetTitleAction":
        from ._schemas.me import MyCustomerSetTitleActionSchema

        return MyCustomerSetTitleActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCustomerSetTitleActionSchema

        return MyCustomerSetTitleActionSchema().dump(self)


class MyCustomerSetVatIdAction(MyCustomerUpdateAction):
    #: Value to set.
    #: If empty, any existing value is removed.
    vat_id: typing.Optional[str]

    def __init__(self, *, vat_id: typing.Optional[str] = None):
        self.vat_id = vat_id

        super().__init__(action="setVatId")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyCustomerSetVatIdAction":
        from ._schemas.me import MyCustomerSetVatIdActionSchema

        return MyCustomerSetVatIdActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyCustomerSetVatIdActionSchema

        return MyCustomerSetVatIdActionSchema().dump(self)


class MyPaymentAddTransactionAction(MyPaymentUpdateAction):
    """Adding a Transaction to a Payment generates the [PaymentTransactionAdded](ctp:api:type:PaymentTransactionAddedMessage) Message.
    Once a Transaction is added to the Payment, it can no longer be updated or deleted using the My Payments API.

    """

    #: Transaction to add to the Payment.
    transaction: "TransactionDraft"

    def __init__(self, *, transaction: "TransactionDraft"):
        self.transaction = transaction

        super().__init__(action="addTransaction")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyPaymentAddTransactionAction":
        from ._schemas.me import MyPaymentAddTransactionActionSchema

        return MyPaymentAddTransactionActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyPaymentAddTransactionActionSchema

        return MyPaymentAddTransactionActionSchema().dump(self)


class MyPaymentChangeAmountPlannedAction(MyPaymentUpdateAction):
    """Can be used to update the Payment if a customer changes the [Cart](ctp:api:type:Cart), or adds or removes a [CartDiscount](ctp:api:type:CartDiscount) during checkout."""

    #: New value to set.
    amount: "Money"

    def __init__(self, *, amount: "Money"):
        self.amount = amount

        super().__init__(action="changeAmountPlanned")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyPaymentChangeAmountPlannedAction":
        from ._schemas.me import MyPaymentChangeAmountPlannedActionSchema

        return MyPaymentChangeAmountPlannedActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyPaymentChangeAmountPlannedActionSchema

        return MyPaymentChangeAmountPlannedActionSchema().dump(self)


class MyPaymentSetCustomFieldAction(MyPaymentUpdateAction):
    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: Removing a field that does not exist returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
    #: If `value` is provided, it is set for the field defined by `name`.
    value: typing.Optional[typing.Any]

    def __init__(self, *, name: str, value: typing.Optional[typing.Any] = None):
        self.name = name
        self.value = value

        super().__init__(action="setCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyPaymentSetCustomFieldAction":
        from ._schemas.me import MyPaymentSetCustomFieldActionSchema

        return MyPaymentSetCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyPaymentSetCustomFieldActionSchema

        return MyPaymentSetCustomFieldActionSchema().dump(self)


class MyPaymentSetMethodInfoInterfaceAction(MyPaymentUpdateAction):
    #: Value to set.
    #: Once set, the `paymentInterface` of the `paymentMethodInfo` cannot be changed.
    interface: str

    def __init__(self, *, interface: str):
        self.interface = interface

        super().__init__(action="setMethodInfoInterface")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyPaymentSetMethodInfoInterfaceAction":
        from ._schemas.me import MyPaymentSetMethodInfoInterfaceActionSchema

        return MyPaymentSetMethodInfoInterfaceActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyPaymentSetMethodInfoInterfaceActionSchema

        return MyPaymentSetMethodInfoInterfaceActionSchema().dump(self)


class MyPaymentSetMethodInfoMethodAction(MyPaymentUpdateAction):
    #: Value to set.
    #: If empty, any existing value will be removed.
    method: typing.Optional[str]

    def __init__(self, *, method: typing.Optional[str] = None):
        self.method = method

        super().__init__(action="setMethodInfoMethod")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyPaymentSetMethodInfoMethodAction":
        from ._schemas.me import MyPaymentSetMethodInfoMethodActionSchema

        return MyPaymentSetMethodInfoMethodActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyPaymentSetMethodInfoMethodActionSchema

        return MyPaymentSetMethodInfoMethodActionSchema().dump(self)


class MyPaymentSetMethodInfoNameAction(MyPaymentUpdateAction):
    #: Value to set.
    #: If empty, any existing value will be removed.
    name: typing.Optional["LocalizedString"]

    def __init__(self, *, name: typing.Optional["LocalizedString"] = None):
        self.name = name

        super().__init__(action="setMethodInfoName")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyPaymentSetMethodInfoNameAction":
        from ._schemas.me import MyPaymentSetMethodInfoNameActionSchema

        return MyPaymentSetMethodInfoNameActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyPaymentSetMethodInfoNameActionSchema

        return MyPaymentSetMethodInfoNameActionSchema().dump(self)


class MyPaymentSetTransactionCustomFieldAction(MyPaymentUpdateAction):
    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: Removing a field that does not exist returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
    #: If `value` is provided, it is set for the field defined by `name`.
    value: typing.Optional[typing.Any]

    def __init__(self, *, name: str, value: typing.Optional[typing.Any] = None):
        self.name = name
        self.value = value

        super().__init__(action="setTransactionCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyPaymentSetTransactionCustomFieldAction":
        from ._schemas.me import MyPaymentSetTransactionCustomFieldActionSchema

        return MyPaymentSetTransactionCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyPaymentSetTransactionCustomFieldActionSchema

        return MyPaymentSetTransactionCustomFieldActionSchema().dump(self)


class MyQuoteChangeMyQuoteStateAction(MyQuoteUpdateAction):
    """When accepting, declining, or renegotiating [B2B Quotes](/../api/associates-overview#b2b-resources), the Customer must have the `AcceptMyQuotes`, `DeclineMyQuotes`, or `RenegotiateMyQuotes` [Permission](ctp:api:type:Permission), respectively. If the required [Permission](/projects/associate-roles#permission) is missing, an [AssociateMissingPermission](/errors#associatemissingpermission) error is returned."""

    #: New state to be set for the Quote.
    quote_state: "MyQuoteState"

    def __init__(self, *, quote_state: "MyQuoteState"):
        self.quote_state = quote_state

        super().__init__(action="changeMyQuoteState")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyQuoteChangeMyQuoteStateAction":
        from ._schemas.me import MyQuoteChangeMyQuoteStateActionSchema

        return MyQuoteChangeMyQuoteStateActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyQuoteChangeMyQuoteStateActionSchema

        return MyQuoteChangeMyQuoteStateActionSchema().dump(self)


class MyQuoteRequestCancelAction(MyQuoteRequestUpdateAction):
    """Transitions the `quoteRequestState` of the Quote Request to `Cancelled`. Can only be used when the Quote Request is in state `Submitted`."""

    def __init__(self):

        super().__init__(action="cancelQuoteRequest")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyQuoteRequestCancelAction":
        from ._schemas.me import MyQuoteRequestCancelActionSchema

        return MyQuoteRequestCancelActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyQuoteRequestCancelActionSchema

        return MyQuoteRequestCancelActionSchema().dump(self)


class MyShoppingListAddLineItemAction(MyShoppingListUpdateAction):
    #: User-defined identifier of the ShoppingListLineItem. Must be unique per [ShoppingList](ctp:api:type:ShoppingList).
    key: typing.Optional[str]
    #: `sku` of the [ProductVariant](ctp:api:type:ProductVariant).
    sku: typing.Optional[str]
    #: Unique identifier of a [Product](ctp:api:type:Product).
    product_id: typing.Optional[str]
    #: `id` of the [ProductVariant](ctp:api:type:ProductVariant). If not set, the ShoppingListLineItem refers to the Master Variant.
    variant_id: typing.Optional[int]
    #: Number of Products in the [ShoppingListLineItem](ctp:api:type:ShoppingListLineItem).
    quantity: typing.Optional[int]
    #: Date and time the TextLineItem is added to the [ShoppingList](ctp:api:type:ShoppingList). If not set, the current date and time (UTC) is used.
    added_at: typing.Optional[datetime.datetime]
    #: Custom Fields defined for the ShoppingListLineItem.
    custom: typing.Optional["CustomFieldsDraft"]

    def __init__(
        self,
        *,
        key: typing.Optional[str] = None,
        sku: typing.Optional[str] = None,
        product_id: typing.Optional[str] = None,
        variant_id: typing.Optional[int] = None,
        quantity: typing.Optional[int] = None,
        added_at: typing.Optional[datetime.datetime] = None,
        custom: typing.Optional["CustomFieldsDraft"] = None
    ):
        self.key = key
        self.sku = sku
        self.product_id = product_id
        self.variant_id = variant_id
        self.quantity = quantity
        self.added_at = added_at
        self.custom = custom

        super().__init__(action="addLineItem")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyShoppingListAddLineItemAction":
        from ._schemas.me import MyShoppingListAddLineItemActionSchema

        return MyShoppingListAddLineItemActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyShoppingListAddLineItemActionSchema

        return MyShoppingListAddLineItemActionSchema().dump(self)


class MyShoppingListAddTextLineItemAction(MyShoppingListUpdateAction):
    #: Name of the [TextLineItem](ctp:api:type:TextLineItem).
    name: "LocalizedString"
    #: User-defined identifier of the TextLineItem. Must be unique per [ShoppingList](ctp:api:type:ShoppingList).
    key: typing.Optional[str]
    #: Description of the TextLineItem.
    description: typing.Optional["LocalizedString"]
    #: Number of entries in the TextLineItem.
    quantity: typing.Optional[int]
    #: Date and time the TextLineItem is added to the [ShoppingList](ctp:api:type:ShoppingList). If not set, the current date and time (UTC) is used.
    added_at: typing.Optional[datetime.datetime]
    #: Custom Fields defined for the TextLineItem.
    custom: typing.Optional["CustomFieldsDraft"]

    def __init__(
        self,
        *,
        name: "LocalizedString",
        key: typing.Optional[str] = None,
        description: typing.Optional["LocalizedString"] = None,
        quantity: typing.Optional[int] = None,
        added_at: typing.Optional[datetime.datetime] = None,
        custom: typing.Optional["CustomFieldsDraft"] = None
    ):
        self.name = name
        self.key = key
        self.description = description
        self.quantity = quantity
        self.added_at = added_at
        self.custom = custom

        super().__init__(action="addTextLineItem")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyShoppingListAddTextLineItemAction":
        from ._schemas.me import MyShoppingListAddTextLineItemActionSchema

        return MyShoppingListAddTextLineItemActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyShoppingListAddTextLineItemActionSchema

        return MyShoppingListAddTextLineItemActionSchema().dump(self)


class MyShoppingListChangeLineItemQuantityAction(MyShoppingListUpdateAction):
    #: `id` of the ShoppingListLineItem to update. Either `lineItemId` or `lineItemKey` is required.
    line_item_id: typing.Optional[str]
    #: `key` of the ShoppingListLineItem to update. Either `lineItemId` or `lineItemKey` is required.
    line_item_key: typing.Optional[str]
    #: New value to set. If `0`, the ShoppingListLineItem is removed from the ShoppingList.
    quantity: int

    def __init__(
        self,
        *,
        line_item_id: typing.Optional[str] = None,
        line_item_key: typing.Optional[str] = None,
        quantity: int
    ):
        self.line_item_id = line_item_id
        self.line_item_key = line_item_key
        self.quantity = quantity

        super().__init__(action="changeLineItemQuantity")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyShoppingListChangeLineItemQuantityAction":
        from ._schemas.me import MyShoppingListChangeLineItemQuantityActionSchema

        return MyShoppingListChangeLineItemQuantityActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyShoppingListChangeLineItemQuantityActionSchema

        return MyShoppingListChangeLineItemQuantityActionSchema().dump(self)


class MyShoppingListChangeLineItemsOrderAction(MyShoppingListUpdateAction):
    #: All existing [ShoppingListLineItem](ctp:api:type:ShoppingListLineItem) `id`s of the [ShoppingList](ctp:api:type:ShoppingList) in the desired new order.
    line_item_order: typing.List["str"]

    def __init__(self, *, line_item_order: typing.List["str"]):
        self.line_item_order = line_item_order

        super().__init__(action="changeLineItemsOrder")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyShoppingListChangeLineItemsOrderAction":
        from ._schemas.me import MyShoppingListChangeLineItemsOrderActionSchema

        return MyShoppingListChangeLineItemsOrderActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyShoppingListChangeLineItemsOrderActionSchema

        return MyShoppingListChangeLineItemsOrderActionSchema().dump(self)


class MyShoppingListChangeNameAction(MyShoppingListUpdateAction):
    #: New value to set. Must not be empty.
    name: "LocalizedString"

    def __init__(self, *, name: "LocalizedString"):
        self.name = name

        super().__init__(action="changeName")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyShoppingListChangeNameAction":
        from ._schemas.me import MyShoppingListChangeNameActionSchema

        return MyShoppingListChangeNameActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyShoppingListChangeNameActionSchema

        return MyShoppingListChangeNameActionSchema().dump(self)


class MyShoppingListChangeTextLineItemNameAction(MyShoppingListUpdateAction):
    #: The `id` of the [TextLineItem](ctp:api:type:TextLineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    text_line_item_id: typing.Optional[str]
    #: The `key` of the [TextLineItem](ctp:api:type:TextLineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    text_line_item_key: typing.Optional[str]
    #: New value to set. Must not be empty.
    name: "LocalizedString"

    def __init__(
        self,
        *,
        text_line_item_id: typing.Optional[str] = None,
        text_line_item_key: typing.Optional[str] = None,
        name: "LocalizedString"
    ):
        self.text_line_item_id = text_line_item_id
        self.text_line_item_key = text_line_item_key
        self.name = name

        super().__init__(action="changeTextLineItemName")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyShoppingListChangeTextLineItemNameAction":
        from ._schemas.me import MyShoppingListChangeTextLineItemNameActionSchema

        return MyShoppingListChangeTextLineItemNameActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyShoppingListChangeTextLineItemNameActionSchema

        return MyShoppingListChangeTextLineItemNameActionSchema().dump(self)


class MyShoppingListChangeTextLineItemQuantityAction(MyShoppingListUpdateAction):
    #: The `id` of the [TextLineItem](ctp:api:type:TextLineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    text_line_item_id: typing.Optional[str]
    #: The `key` of the [TextLineItem](ctp:api:type:TextLineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    text_line_item_key: typing.Optional[str]
    #: New value to set. If `0`, the TextLineItem is removed from the ShoppingList.
    quantity: int

    def __init__(
        self,
        *,
        text_line_item_id: typing.Optional[str] = None,
        text_line_item_key: typing.Optional[str] = None,
        quantity: int
    ):
        self.text_line_item_id = text_line_item_id
        self.text_line_item_key = text_line_item_key
        self.quantity = quantity

        super().__init__(action="changeTextLineItemQuantity")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyShoppingListChangeTextLineItemQuantityAction":
        from ._schemas.me import MyShoppingListChangeTextLineItemQuantityActionSchema

        return MyShoppingListChangeTextLineItemQuantityActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyShoppingListChangeTextLineItemQuantityActionSchema

        return MyShoppingListChangeTextLineItemQuantityActionSchema().dump(self)


class MyShoppingListChangeTextLineItemsOrderAction(MyShoppingListUpdateAction):
    #: All existing [TextLineItem](ctp:api:type:TextLineItem) `id`s in the desired new order.
    text_line_item_order: typing.List["str"]

    def __init__(self, *, text_line_item_order: typing.List["str"]):
        self.text_line_item_order = text_line_item_order

        super().__init__(action="changeTextLineItemsOrder")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyShoppingListChangeTextLineItemsOrderAction":
        from ._schemas.me import MyShoppingListChangeTextLineItemsOrderActionSchema

        return MyShoppingListChangeTextLineItemsOrderActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyShoppingListChangeTextLineItemsOrderActionSchema

        return MyShoppingListChangeTextLineItemsOrderActionSchema().dump(self)


class MyShoppingListRemoveLineItemAction(MyShoppingListUpdateAction):
    #: The `id` of the [ShoppingListLineItem](ctp:api:type:ShoppingListLineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    line_item_id: typing.Optional[str]
    #: The `key` of the [ShoppingListLineItem](ctp:api:type:ShoppingListLineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    line_item_key: typing.Optional[str]
    #: Amount to remove from the `quantity` of the ShoppingListLineItem. If not set, the ShoppingListLineItem is removed from the ShoppingList. If this value matches or exceeds the current `quantity` of the ShoppingListLineItem, the ShoppingListLineItem is removed from the ShoppingList.
    quantity: typing.Optional[int]

    def __init__(
        self,
        *,
        line_item_id: typing.Optional[str] = None,
        line_item_key: typing.Optional[str] = None,
        quantity: typing.Optional[int] = None
    ):
        self.line_item_id = line_item_id
        self.line_item_key = line_item_key
        self.quantity = quantity

        super().__init__(action="removeLineItem")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyShoppingListRemoveLineItemAction":
        from ._schemas.me import MyShoppingListRemoveLineItemActionSchema

        return MyShoppingListRemoveLineItemActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyShoppingListRemoveLineItemActionSchema

        return MyShoppingListRemoveLineItemActionSchema().dump(self)


class MyShoppingListRemoveTextLineItemAction(MyShoppingListUpdateAction):
    #: The `id` of the [TextLineItem](ctp:api:type:TextLineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    text_line_item_id: typing.Optional[str]
    #: The `key` of the [TextLineItem](ctp:api:type:TextLineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    text_line_item_key: typing.Optional[str]
    #: Amount to remove from the `quantity` of the TextLineItem. If not set, the TextLineItem is removed from the ShoppingList. If this value matches or exceeds the current `quantity` of the TextLineItem, the TextLineItem is removed from the ShoppingList.
    quantity: typing.Optional[int]

    def __init__(
        self,
        *,
        text_line_item_id: typing.Optional[str] = None,
        text_line_item_key: typing.Optional[str] = None,
        quantity: typing.Optional[int] = None
    ):
        self.text_line_item_id = text_line_item_id
        self.text_line_item_key = text_line_item_key
        self.quantity = quantity

        super().__init__(action="removeTextLineItem")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyShoppingListRemoveTextLineItemAction":
        from ._schemas.me import MyShoppingListRemoveTextLineItemActionSchema

        return MyShoppingListRemoveTextLineItemActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyShoppingListRemoveTextLineItemActionSchema

        return MyShoppingListRemoveTextLineItemActionSchema().dump(self)


class MyShoppingListSetCustomFieldAction(MyShoppingListUpdateAction):
    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: Removing a field that does not exist returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
    #: If `value` is provided, it is set for the field defined by `name`.
    value: typing.Optional[typing.Any]

    def __init__(self, *, name: str, value: typing.Optional[typing.Any] = None):
        self.name = name
        self.value = value

        super().__init__(action="setCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyShoppingListSetCustomFieldAction":
        from ._schemas.me import MyShoppingListSetCustomFieldActionSchema

        return MyShoppingListSetCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyShoppingListSetCustomFieldActionSchema

        return MyShoppingListSetCustomFieldActionSchema().dump(self)


class MyShoppingListSetCustomTypeAction(MyShoppingListUpdateAction):
    #: Defines the [Type](ctp:api:type:Type) that extends the MyShoppingList with [Custom Fields](/../api/projects/custom-fields).
    #: If absent, any existing Type and Custom Fields are removed from the MyShoppingList.
    type: typing.Optional["TypeResourceIdentifier"]
    #: Sets the [Custom Fields](/../api/projects/custom-fields) fields for the MyShoppingList.
    fields: typing.Optional["FieldContainer"]

    def __init__(
        self,
        *,
        type: typing.Optional["TypeResourceIdentifier"] = None,
        fields: typing.Optional["FieldContainer"] = None
    ):
        self.type = type
        self.fields = fields

        super().__init__(action="setCustomType")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyShoppingListSetCustomTypeAction":
        from ._schemas.me import MyShoppingListSetCustomTypeActionSchema

        return MyShoppingListSetCustomTypeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyShoppingListSetCustomTypeActionSchema

        return MyShoppingListSetCustomTypeActionSchema().dump(self)


class MyShoppingListSetDeleteDaysAfterLastModificationAction(
    MyShoppingListUpdateAction
):
    #: Value to set. If empty, any existing value will be removed.
    delete_days_after_last_modification: typing.Optional[int]

    def __init__(
        self, *, delete_days_after_last_modification: typing.Optional[int] = None
    ):
        self.delete_days_after_last_modification = delete_days_after_last_modification

        super().__init__(action="setDeleteDaysAfterLastModification")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyShoppingListSetDeleteDaysAfterLastModificationAction":
        from ._schemas.me import (
            MyShoppingListSetDeleteDaysAfterLastModificationActionSchema,
        )

        return MyShoppingListSetDeleteDaysAfterLastModificationActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import (
            MyShoppingListSetDeleteDaysAfterLastModificationActionSchema,
        )

        return MyShoppingListSetDeleteDaysAfterLastModificationActionSchema().dump(self)


class MyShoppingListSetDescriptionAction(MyShoppingListUpdateAction):
    #: Value to set. If empty, any existing value will be removed.
    description: typing.Optional["LocalizedString"]

    def __init__(self, *, description: typing.Optional["LocalizedString"] = None):
        self.description = description

        super().__init__(action="setDescription")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyShoppingListSetDescriptionAction":
        from ._schemas.me import MyShoppingListSetDescriptionActionSchema

        return MyShoppingListSetDescriptionActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyShoppingListSetDescriptionActionSchema

        return MyShoppingListSetDescriptionActionSchema().dump(self)


class MyShoppingListSetLineItemCustomFieldAction(MyShoppingListUpdateAction):
    #: Unique identifier of an the [ShoppingListLineItem](ctp:api:type:ShoppingListLineItem). Either `lineItemId` or `lineItemKey` is required.
    line_item_id: typing.Optional[str]
    #: The `key` of the [ShoppingListLineItem](ctp:api:type:ShoppingListLineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    line_item_key: typing.Optional[str]
    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: Removing a field that does not exist returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
    #: If `value` is provided, it is set for the field defined by `name`.
    value: typing.Optional[typing.Any]

    def __init__(
        self,
        *,
        line_item_id: typing.Optional[str] = None,
        line_item_key: typing.Optional[str] = None,
        name: str,
        value: typing.Optional[typing.Any] = None
    ):
        self.line_item_id = line_item_id
        self.line_item_key = line_item_key
        self.name = name
        self.value = value

        super().__init__(action="setLineItemCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyShoppingListSetLineItemCustomFieldAction":
        from ._schemas.me import MyShoppingListSetLineItemCustomFieldActionSchema

        return MyShoppingListSetLineItemCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyShoppingListSetLineItemCustomFieldActionSchema

        return MyShoppingListSetLineItemCustomFieldActionSchema().dump(self)


class MyShoppingListSetLineItemCustomTypeAction(MyShoppingListUpdateAction):
    #: Unique identifier of an existing [ShoppingListLineItem](ctp:api:type:ShoppingListLineItem) in the [ShoppingList](ctp:api:type:ShoppingList).
    line_item_id: str
    #: Defines the [Type](ctp:api:type:Type) that extends the ShoppingListLineItem with [Custom Fields](/../api/projects/custom-fields).
    #: If absent, any existing Type and Custom Fields are removed from the ShoppingListLineItem.
    type: typing.Optional["TypeResourceIdentifier"]
    #: Sets the [Custom Fields](/../api/projects/custom-fields) fields for the ShoppingListLineItem.
    fields: typing.Optional["FieldContainer"]

    def __init__(
        self,
        *,
        line_item_id: str,
        type: typing.Optional["TypeResourceIdentifier"] = None,
        fields: typing.Optional["FieldContainer"] = None
    ):
        self.line_item_id = line_item_id
        self.type = type
        self.fields = fields

        super().__init__(action="setLineItemCustomType")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyShoppingListSetLineItemCustomTypeAction":
        from ._schemas.me import MyShoppingListSetLineItemCustomTypeActionSchema

        return MyShoppingListSetLineItemCustomTypeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyShoppingListSetLineItemCustomTypeActionSchema

        return MyShoppingListSetLineItemCustomTypeActionSchema().dump(self)


class MyShoppingListSetTextLineItemCustomFieldAction(MyShoppingListUpdateAction):
    #: The `id` of the [TextLineItem](ctp:api:type:TextLineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    text_line_item_id: typing.Optional[str]
    #: The `key` of the [TextLineItem](ctp:api:type:TextLineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    text_line_item_key: typing.Optional[str]
    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: Removing a field that does not exist returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
    #: If `value` is provided, it is set for the field defined by `name`.
    value: typing.Optional[typing.Any]

    def __init__(
        self,
        *,
        text_line_item_id: typing.Optional[str] = None,
        text_line_item_key: typing.Optional[str] = None,
        name: str,
        value: typing.Optional[typing.Any] = None
    ):
        self.text_line_item_id = text_line_item_id
        self.text_line_item_key = text_line_item_key
        self.name = name
        self.value = value

        super().__init__(action="setTextLineItemCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyShoppingListSetTextLineItemCustomFieldAction":
        from ._schemas.me import MyShoppingListSetTextLineItemCustomFieldActionSchema

        return MyShoppingListSetTextLineItemCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyShoppingListSetTextLineItemCustomFieldActionSchema

        return MyShoppingListSetTextLineItemCustomFieldActionSchema().dump(self)


class MyShoppingListSetTextLineItemCustomTypeAction(MyShoppingListUpdateAction):
    #: The `id` of the [TextLineItem](ctp:api:type:TextLineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    text_line_item_id: typing.Optional[str]
    #: The `key` of the [TextLineItem](ctp:api:type:TextLineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    text_line_item_key: typing.Optional[str]
    #: Defines the [Type](ctp:api:type:Type) that extends the TextLineItem with [Custom Fields](/../api/projects/custom-fields).
    #: If absent, any existing Type and Custom Fields are removed from the TextLineItem.
    type: typing.Optional["TypeResourceIdentifier"]
    #: Sets the [Custom Fields](/../api/projects/custom-fields) fields for the TextLineItem.
    fields: typing.Optional["FieldContainer"]

    def __init__(
        self,
        *,
        text_line_item_id: typing.Optional[str] = None,
        text_line_item_key: typing.Optional[str] = None,
        type: typing.Optional["TypeResourceIdentifier"] = None,
        fields: typing.Optional["FieldContainer"] = None
    ):
        self.text_line_item_id = text_line_item_id
        self.text_line_item_key = text_line_item_key
        self.type = type
        self.fields = fields

        super().__init__(action="setTextLineItemCustomType")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyShoppingListSetTextLineItemCustomTypeAction":
        from ._schemas.me import MyShoppingListSetTextLineItemCustomTypeActionSchema

        return MyShoppingListSetTextLineItemCustomTypeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyShoppingListSetTextLineItemCustomTypeActionSchema

        return MyShoppingListSetTextLineItemCustomTypeActionSchema().dump(self)


class MyShoppingListSetTextLineItemDescriptionAction(MyShoppingListUpdateAction):
    #: The `id` of the [TextLineItem](ctp:api:type:TextLineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    text_line_item_id: typing.Optional[str]
    #: The `key` of the [TextLineItem](ctp:api:type:TextLineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    text_line_item_key: typing.Optional[str]
    #: Value to set. If empty, any existing value will be removed.
    description: typing.Optional["LocalizedString"]

    def __init__(
        self,
        *,
        text_line_item_id: typing.Optional[str] = None,
        text_line_item_key: typing.Optional[str] = None,
        description: typing.Optional["LocalizedString"] = None
    ):
        self.text_line_item_id = text_line_item_id
        self.text_line_item_key = text_line_item_key
        self.description = description

        super().__init__(action="setTextLineItemDescription")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "MyShoppingListSetTextLineItemDescriptionAction":
        from ._schemas.me import MyShoppingListSetTextLineItemDescriptionActionSchema

        return MyShoppingListSetTextLineItemDescriptionActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.me import MyShoppingListSetTextLineItemDescriptionActionSchema

        return MyShoppingListSetTextLineItemDescriptionActionSchema().dump(self)
