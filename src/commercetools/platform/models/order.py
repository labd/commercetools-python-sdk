# This file is automatically generated by the rmf-codegen project.
#
# The Python code generator is maintained by Lab Digital. If you want to
# contribute to this project then please do not edit this file directly
# but send a pull request to the Lab Digital fork of rmf-codegen at
# https://github.com/labd/rmf-codegen

import datetime
import enum
import typing

from ._abstract import _BaseType
from .cart import (
    CartOrigin,
    CustomLineItemPriceMode,
    InventoryMode,
    RoundingMode,
    ShippingMethodState,
    ShippingMode,
    TaxCalculationMode,
    TaxMode,
)
from .common import BaseResource, Reference, ReferenceTypeId

if typing.TYPE_CHECKING:
    from .business_unit import BusinessUnitKeyReference, BusinessUnitResourceIdentifier
    from .cart import (
        CartOrigin,
        CartReference,
        CartResourceIdentifier,
        CustomLineItem,
        CustomLineItemPriceMode,
        DirectDiscount,
        DiscountCodeInfo,
        DiscountedLineItemPortionDraft,
        DiscountOnTotalPrice,
        InventoryMode,
        ItemShippingDetailsDraft,
        LineItem,
        RoundingMode,
        Shipping,
        ShippingInfo,
        ShippingMethodState,
        ShippingMode,
        ShippingRateInput,
        TaxCalculationMode,
        TaxedPrice,
        TaxedPriceDraft,
        TaxMode,
    )
    from .cart_discount import CartDiscountReference
    from .channel import ChannelReference, ChannelResourceIdentifier
    from .common import (
        Address,
        AddressDraft,
        BaseAddress,
        CreatedBy,
        Image,
        LastModifiedBy,
        LocalizedString,
        Money,
        PriceDraft,
        ReferenceTypeId,
        TypedMoney,
    )
    from .customer_group import CustomerGroupReference, CustomerGroupResourceIdentifier
    from .payment import PaymentReference, PaymentResourceIdentifier
    from .product import Attribute
    from .quote import QuoteReference, QuoteResourceIdentifier
    from .shipping_method import ShippingMethodResourceIdentifier, ShippingRateDraft
    from .state import StateReference, StateResourceIdentifier
    from .store import StoreKeyReference, StoreResourceIdentifier
    from .tax_category import TaxCategoryResourceIdentifier, TaxRate
    from .type import (
        CustomFields,
        CustomFieldsDraft,
        FieldContainer,
        TypeResourceIdentifier,
    )

__all__ = [
    "CustomLineItemImportDraft",
    "CustomLineItemReturnItem",
    "Delivery",
    "DeliveryDraft",
    "DeliveryItem",
    "DiscountedLineItemPriceDraft",
    "Hit",
    "ItemState",
    "LineItemImportDraft",
    "LineItemReturnItem",
    "Order",
    "OrderAddDeliveryAction",
    "OrderAddItemShippingAddressAction",
    "OrderAddParcelToDeliveryAction",
    "OrderAddPaymentAction",
    "OrderAddReturnInfoAction",
    "OrderChangeOrderStateAction",
    "OrderChangePaymentStateAction",
    "OrderChangeShipmentStateAction",
    "OrderFromCartDraft",
    "OrderFromQuoteDraft",
    "OrderImportCustomLineItemStateAction",
    "OrderImportDraft",
    "OrderImportLineItemStateAction",
    "OrderPagedQueryResponse",
    "OrderPagedSearchResponse",
    "OrderReference",
    "OrderRemoveDeliveryAction",
    "OrderRemoveItemShippingAddressAction",
    "OrderRemoveParcelFromDeliveryAction",
    "OrderRemovePaymentAction",
    "OrderSearchAndExpression",
    "OrderSearchAnyValue",
    "OrderSearchCompoundExpression",
    "OrderSearchDateRangeExpression",
    "OrderSearchDateRangeValue",
    "OrderSearchExactExpression",
    "OrderSearchExistsExpression",
    "OrderSearchFilterExpression",
    "OrderSearchFullTextExpression",
    "OrderSearchFullTextValue",
    "OrderSearchLongRangeExpression",
    "OrderSearchLongRangeValue",
    "OrderSearchMatchType",
    "OrderSearchNotExpression",
    "OrderSearchNumberRangeExpression",
    "OrderSearchNumberRangeValue",
    "OrderSearchOrExpression",
    "OrderSearchPrefixExpression",
    "OrderSearchQuery",
    "OrderSearchQueryExpression",
    "OrderSearchQueryExpressionValue",
    "OrderSearchRequest",
    "OrderSearchSortMode",
    "OrderSearchSortOrder",
    "OrderSearchSorting",
    "OrderSearchStringValue",
    "OrderSearchWildCardExpression",
    "OrderSetBillingAddressAction",
    "OrderSetBillingAddressCustomFieldAction",
    "OrderSetBillingAddressCustomTypeAction",
    "OrderSetCustomFieldAction",
    "OrderSetCustomLineItemCustomFieldAction",
    "OrderSetCustomLineItemCustomTypeAction",
    "OrderSetCustomLineItemShippingDetailsAction",
    "OrderSetCustomTypeAction",
    "OrderSetCustomerEmailAction",
    "OrderSetCustomerIdAction",
    "OrderSetDeliveryAddressAction",
    "OrderSetDeliveryAddressCustomFieldAction",
    "OrderSetDeliveryAddressCustomTypeAction",
    "OrderSetDeliveryCustomFieldAction",
    "OrderSetDeliveryCustomTypeAction",
    "OrderSetDeliveryItemsAction",
    "OrderSetItemShippingAddressCustomFieldAction",
    "OrderSetItemShippingAddressCustomTypeAction",
    "OrderSetLineItemCustomFieldAction",
    "OrderSetLineItemCustomTypeAction",
    "OrderSetLineItemShippingDetailsAction",
    "OrderSetLocaleAction",
    "OrderSetOrderNumberAction",
    "OrderSetParcelCustomFieldAction",
    "OrderSetParcelCustomTypeAction",
    "OrderSetParcelItemsAction",
    "OrderSetParcelMeasurementsAction",
    "OrderSetParcelTrackingDataAction",
    "OrderSetPurchaseOrderNumberAction",
    "OrderSetReturnInfoAction",
    "OrderSetReturnItemCustomFieldAction",
    "OrderSetReturnItemCustomTypeAction",
    "OrderSetReturnPaymentStateAction",
    "OrderSetReturnShipmentStateAction",
    "OrderSetShippingAddressAction",
    "OrderSetShippingAddressCustomFieldAction",
    "OrderSetShippingAddressCustomTypeAction",
    "OrderSetStoreAction",
    "OrderState",
    "OrderTransitionCustomLineItemStateAction",
    "OrderTransitionLineItemStateAction",
    "OrderTransitionStateAction",
    "OrderUpdate",
    "OrderUpdateAction",
    "OrderUpdateItemShippingAddressAction",
    "OrderUpdateSyncInfoAction",
    "Parcel",
    "ParcelDraft",
    "ParcelMeasurements",
    "PaymentInfo",
    "PaymentState",
    "ProductVariantImportDraft",
    "ReturnInfo",
    "ReturnInfoDraft",
    "ReturnItem",
    "ReturnItemDraft",
    "ReturnPaymentState",
    "ReturnShipmentState",
    "ShipmentState",
    "ShippingInfoImportDraft",
    "StagedOrderUpdateAction",
    "SyncInfo",
    "TaxedItemPriceDraft",
    "TrackingData",
]


class StagedOrderUpdateAction(_BaseType):
    action: str

    def __init__(self, *, action: str):
        self.action = action

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderUpdateAction":
        if data["action"] == "addCustomLineItem":
            from ._schemas.order_edit import StagedOrderAddCustomLineItemActionSchema

            return StagedOrderAddCustomLineItemActionSchema().load(data)
        if data["action"] == "addDelivery":
            from ._schemas.order_edit import StagedOrderAddDeliveryActionSchema

            return StagedOrderAddDeliveryActionSchema().load(data)
        if data["action"] == "addDiscountCode":
            from ._schemas.order_edit import StagedOrderAddDiscountCodeActionSchema

            return StagedOrderAddDiscountCodeActionSchema().load(data)
        if data["action"] == "addItemShippingAddress":
            from ._schemas.order_edit import (
                StagedOrderAddItemShippingAddressActionSchema,
            )

            return StagedOrderAddItemShippingAddressActionSchema().load(data)
        if data["action"] == "addLineItem":
            from ._schemas.order_edit import StagedOrderAddLineItemActionSchema

            return StagedOrderAddLineItemActionSchema().load(data)
        if data["action"] == "addParcelToDelivery":
            from ._schemas.order_edit import StagedOrderAddParcelToDeliveryActionSchema

            return StagedOrderAddParcelToDeliveryActionSchema().load(data)
        if data["action"] == "addPayment":
            from ._schemas.order_edit import StagedOrderAddPaymentActionSchema

            return StagedOrderAddPaymentActionSchema().load(data)
        if data["action"] == "addReturnInfo":
            from ._schemas.order_edit import StagedOrderAddReturnInfoActionSchema

            return StagedOrderAddReturnInfoActionSchema().load(data)
        if data["action"] == "addShoppingList":
            from ._schemas.order_edit import StagedOrderAddShoppingListActionSchema

            return StagedOrderAddShoppingListActionSchema().load(data)
        if data["action"] == "changeCustomLineItemMoney":
            from ._schemas.order_edit import (
                StagedOrderChangeCustomLineItemMoneyActionSchema,
            )

            return StagedOrderChangeCustomLineItemMoneyActionSchema().load(data)
        if data["action"] == "changeCustomLineItemQuantity":
            from ._schemas.order_edit import (
                StagedOrderChangeCustomLineItemQuantityActionSchema,
            )

            return StagedOrderChangeCustomLineItemQuantityActionSchema().load(data)
        if data["action"] == "changeLineItemQuantity":
            from ._schemas.order_edit import (
                StagedOrderChangeLineItemQuantityActionSchema,
            )

            return StagedOrderChangeLineItemQuantityActionSchema().load(data)
        if data["action"] == "changeOrderState":
            from ._schemas.order_edit import StagedOrderChangeOrderStateActionSchema

            return StagedOrderChangeOrderStateActionSchema().load(data)
        if data["action"] == "changePaymentState":
            from ._schemas.order_edit import StagedOrderChangePaymentStateActionSchema

            return StagedOrderChangePaymentStateActionSchema().load(data)
        if data["action"] == "changeShipmentState":
            from ._schemas.order_edit import StagedOrderChangeShipmentStateActionSchema

            return StagedOrderChangeShipmentStateActionSchema().load(data)
        if data["action"] == "changeTaxCalculationMode":
            from ._schemas.order_edit import (
                StagedOrderChangeTaxCalculationModeActionSchema,
            )

            return StagedOrderChangeTaxCalculationModeActionSchema().load(data)
        if data["action"] == "changeTaxMode":
            from ._schemas.order_edit import StagedOrderChangeTaxModeActionSchema

            return StagedOrderChangeTaxModeActionSchema().load(data)
        if data["action"] == "changeTaxRoundingMode":
            from ._schemas.order_edit import (
                StagedOrderChangeTaxRoundingModeActionSchema,
            )

            return StagedOrderChangeTaxRoundingModeActionSchema().load(data)
        if data["action"] == "importCustomLineItemState":
            from ._schemas.order_edit import (
                StagedOrderImportCustomLineItemStateActionSchema,
            )

            return StagedOrderImportCustomLineItemStateActionSchema().load(data)
        if data["action"] == "importLineItemState":
            from ._schemas.order_edit import StagedOrderImportLineItemStateActionSchema

            return StagedOrderImportLineItemStateActionSchema().load(data)
        if data["action"] == "removeCustomLineItem":
            from ._schemas.order_edit import StagedOrderRemoveCustomLineItemActionSchema

            return StagedOrderRemoveCustomLineItemActionSchema().load(data)
        if data["action"] == "removeDelivery":
            from ._schemas.order_edit import StagedOrderRemoveDeliveryActionSchema

            return StagedOrderRemoveDeliveryActionSchema().load(data)
        if data["action"] == "removeDiscountCode":
            from ._schemas.order_edit import StagedOrderRemoveDiscountCodeActionSchema

            return StagedOrderRemoveDiscountCodeActionSchema().load(data)
        if data["action"] == "removeItemShippingAddress":
            from ._schemas.order_edit import (
                StagedOrderRemoveItemShippingAddressActionSchema,
            )

            return StagedOrderRemoveItemShippingAddressActionSchema().load(data)
        if data["action"] == "removeLineItem":
            from ._schemas.order_edit import StagedOrderRemoveLineItemActionSchema

            return StagedOrderRemoveLineItemActionSchema().load(data)
        if data["action"] == "removeParcelFromDelivery":
            from ._schemas.order_edit import (
                StagedOrderRemoveParcelFromDeliveryActionSchema,
            )

            return StagedOrderRemoveParcelFromDeliveryActionSchema().load(data)
        if data["action"] == "removePayment":
            from ._schemas.order_edit import StagedOrderRemovePaymentActionSchema

            return StagedOrderRemovePaymentActionSchema().load(data)
        if data["action"] == "setBillingAddress":
            from ._schemas.order_edit import StagedOrderSetBillingAddressActionSchema

            return StagedOrderSetBillingAddressActionSchema().load(data)
        if data["action"] == "setBillingAddressCustomField":
            from ._schemas.order_edit import (
                StagedOrderSetBillingAddressCustomFieldActionSchema,
            )

            return StagedOrderSetBillingAddressCustomFieldActionSchema().load(data)
        if data["action"] == "setBillingAddressCustomType":
            from ._schemas.order_edit import (
                StagedOrderSetBillingAddressCustomTypeActionSchema,
            )

            return StagedOrderSetBillingAddressCustomTypeActionSchema().load(data)
        if data["action"] == "setCountry":
            from ._schemas.order_edit import StagedOrderSetCountryActionSchema

            return StagedOrderSetCountryActionSchema().load(data)
        if data["action"] == "setCustomField":
            from ._schemas.order_edit import StagedOrderSetCustomFieldActionSchema

            return StagedOrderSetCustomFieldActionSchema().load(data)
        if data["action"] == "setCustomLineItemCustomField":
            from ._schemas.order_edit import (
                StagedOrderSetCustomLineItemCustomFieldActionSchema,
            )

            return StagedOrderSetCustomLineItemCustomFieldActionSchema().load(data)
        if data["action"] == "setCustomLineItemCustomType":
            from ._schemas.order_edit import (
                StagedOrderSetCustomLineItemCustomTypeActionSchema,
            )

            return StagedOrderSetCustomLineItemCustomTypeActionSchema().load(data)
        if data["action"] == "setCustomLineItemShippingDetails":
            from ._schemas.order_edit import (
                StagedOrderSetCustomLineItemShippingDetailsActionSchema,
            )

            return StagedOrderSetCustomLineItemShippingDetailsActionSchema().load(data)
        if data["action"] == "setCustomLineItemTaxAmount":
            from ._schemas.order_edit import (
                StagedOrderSetCustomLineItemTaxAmountActionSchema,
            )

            return StagedOrderSetCustomLineItemTaxAmountActionSchema().load(data)
        if data["action"] == "setCustomLineItemTaxRate":
            from ._schemas.order_edit import (
                StagedOrderSetCustomLineItemTaxRateActionSchema,
            )

            return StagedOrderSetCustomLineItemTaxRateActionSchema().load(data)
        if data["action"] == "setCustomShippingMethod":
            from ._schemas.order_edit import (
                StagedOrderSetCustomShippingMethodActionSchema,
            )

            return StagedOrderSetCustomShippingMethodActionSchema().load(data)
        if data["action"] == "setCustomType":
            from ._schemas.order_edit import StagedOrderSetCustomTypeActionSchema

            return StagedOrderSetCustomTypeActionSchema().load(data)
        if data["action"] == "setCustomerEmail":
            from ._schemas.order_edit import StagedOrderSetCustomerEmailActionSchema

            return StagedOrderSetCustomerEmailActionSchema().load(data)
        if data["action"] == "setCustomerGroup":
            from ._schemas.order_edit import StagedOrderSetCustomerGroupActionSchema

            return StagedOrderSetCustomerGroupActionSchema().load(data)
        if data["action"] == "setCustomerId":
            from ._schemas.order_edit import StagedOrderSetCustomerIdActionSchema

            return StagedOrderSetCustomerIdActionSchema().load(data)
        if data["action"] == "setDeliveryAddress":
            from ._schemas.order_edit import StagedOrderSetDeliveryAddressActionSchema

            return StagedOrderSetDeliveryAddressActionSchema().load(data)
        if data["action"] == "setDeliveryAddressCustomField":
            from ._schemas.order_edit import (
                StagedOrderSetDeliveryAddressCustomFieldActionSchema,
            )

            return StagedOrderSetDeliveryAddressCustomFieldActionSchema().load(data)
        if data["action"] == "setDeliveryAddressCustomType":
            from ._schemas.order_edit import (
                StagedOrderSetDeliveryAddressCustomTypeActionSchema,
            )

            return StagedOrderSetDeliveryAddressCustomTypeActionSchema().load(data)
        if data["action"] == "setDeliveryCustomField":
            from ._schemas.order_edit import (
                StagedOrderSetDeliveryCustomFieldActionSchema,
            )

            return StagedOrderSetDeliveryCustomFieldActionSchema().load(data)
        if data["action"] == "setDeliveryCustomType":
            from ._schemas.order_edit import (
                StagedOrderSetDeliveryCustomTypeActionSchema,
            )

            return StagedOrderSetDeliveryCustomTypeActionSchema().load(data)
        if data["action"] == "setDeliveryItems":
            from ._schemas.order_edit import StagedOrderSetDeliveryItemsActionSchema

            return StagedOrderSetDeliveryItemsActionSchema().load(data)
        if data["action"] == "setDirectDiscounts":
            from ._schemas.order_edit import StagedOrderSetDirectDiscountsActionSchema

            return StagedOrderSetDirectDiscountsActionSchema().load(data)
        if data["action"] == "setItemShippingAddressCustomField":
            from ._schemas.order_edit import (
                StagedOrderSetItemShippingAddressCustomFieldActionSchema,
            )

            return StagedOrderSetItemShippingAddressCustomFieldActionSchema().load(data)
        if data["action"] == "setItemShippingAddressCustomType":
            from ._schemas.order_edit import (
                StagedOrderSetItemShippingAddressCustomTypeActionSchema,
            )

            return StagedOrderSetItemShippingAddressCustomTypeActionSchema().load(data)
        if data["action"] == "setLineItemCustomField":
            from ._schemas.order_edit import (
                StagedOrderSetLineItemCustomFieldActionSchema,
            )

            return StagedOrderSetLineItemCustomFieldActionSchema().load(data)
        if data["action"] == "setLineItemCustomType":
            from ._schemas.order_edit import (
                StagedOrderSetLineItemCustomTypeActionSchema,
            )

            return StagedOrderSetLineItemCustomTypeActionSchema().load(data)
        if data["action"] == "setLineItemDistributionChannel":
            from ._schemas.order_edit import (
                StagedOrderSetLineItemDistributionChannelActionSchema,
            )

            return StagedOrderSetLineItemDistributionChannelActionSchema().load(data)
        if data["action"] == "setLineItemPrice":
            from ._schemas.order_edit import StagedOrderSetLineItemPriceActionSchema

            return StagedOrderSetLineItemPriceActionSchema().load(data)
        if data["action"] == "setLineItemShippingDetails":
            from ._schemas.order_edit import (
                StagedOrderSetLineItemShippingDetailsActionSchema,
            )

            return StagedOrderSetLineItemShippingDetailsActionSchema().load(data)
        if data["action"] == "setLineItemTaxAmount":
            from ._schemas.order_edit import StagedOrderSetLineItemTaxAmountActionSchema

            return StagedOrderSetLineItemTaxAmountActionSchema().load(data)
        if data["action"] == "setLineItemTaxRate":
            from ._schemas.order_edit import StagedOrderSetLineItemTaxRateActionSchema

            return StagedOrderSetLineItemTaxRateActionSchema().load(data)
        if data["action"] == "setLineItemTotalPrice":
            from ._schemas.order_edit import (
                StagedOrderSetLineItemTotalPriceActionSchema,
            )

            return StagedOrderSetLineItemTotalPriceActionSchema().load(data)
        if data["action"] == "setLocale":
            from ._schemas.order_edit import StagedOrderSetLocaleActionSchema

            return StagedOrderSetLocaleActionSchema().load(data)
        if data["action"] == "setOrderNumber":
            from ._schemas.order_edit import StagedOrderSetOrderNumberActionSchema

            return StagedOrderSetOrderNumberActionSchema().load(data)
        if data["action"] == "setOrderTotalTax":
            from ._schemas.order_edit import StagedOrderSetOrderTotalTaxActionSchema

            return StagedOrderSetOrderTotalTaxActionSchema().load(data)
        if data["action"] == "setParcelCustomField":
            from ._schemas.order_edit import StagedOrderSetParcelCustomFieldActionSchema

            return StagedOrderSetParcelCustomFieldActionSchema().load(data)
        if data["action"] == "setParcelCustomType":
            from ._schemas.order_edit import StagedOrderSetParcelCustomTypeActionSchema

            return StagedOrderSetParcelCustomTypeActionSchema().load(data)
        if data["action"] == "setParcelItems":
            from ._schemas.order_edit import StagedOrderSetParcelItemsActionSchema

            return StagedOrderSetParcelItemsActionSchema().load(data)
        if data["action"] == "setParcelMeasurements":
            from ._schemas.order_edit import (
                StagedOrderSetParcelMeasurementsActionSchema,
            )

            return StagedOrderSetParcelMeasurementsActionSchema().load(data)
        if data["action"] == "setParcelTrackingData":
            from ._schemas.order_edit import (
                StagedOrderSetParcelTrackingDataActionSchema,
            )

            return StagedOrderSetParcelTrackingDataActionSchema().load(data)
        if data["action"] == "setPurchaseOrderNumber":
            from ._schemas.order_edit import (
                StagedOrderSetPurchaseOrderNumberActionSchema,
            )

            return StagedOrderSetPurchaseOrderNumberActionSchema().load(data)
        if data["action"] == "setReturnInfo":
            from ._schemas.order_edit import StagedOrderSetReturnInfoActionSchema

            return StagedOrderSetReturnInfoActionSchema().load(data)
        if data["action"] == "setReturnItemCustomField":
            from ._schemas.order_edit import (
                StagedOrderSetReturnItemCustomFieldActionSchema,
            )

            return StagedOrderSetReturnItemCustomFieldActionSchema().load(data)
        if data["action"] == "setReturnItemCustomType":
            from ._schemas.order_edit import (
                StagedOrderSetReturnItemCustomTypeActionSchema,
            )

            return StagedOrderSetReturnItemCustomTypeActionSchema().load(data)
        if data["action"] == "setReturnPaymentState":
            from ._schemas.order_edit import (
                StagedOrderSetReturnPaymentStateActionSchema,
            )

            return StagedOrderSetReturnPaymentStateActionSchema().load(data)
        if data["action"] == "setReturnShipmentState":
            from ._schemas.order_edit import (
                StagedOrderSetReturnShipmentStateActionSchema,
            )

            return StagedOrderSetReturnShipmentStateActionSchema().load(data)
        if data["action"] == "setShippingAddress":
            from ._schemas.order_edit import StagedOrderSetShippingAddressActionSchema

            return StagedOrderSetShippingAddressActionSchema().load(data)
        if data["action"] == "setShippingAddressAndCustomShippingMethod":
            from ._schemas.order_edit import (
                StagedOrderSetShippingAddressAndCustomShippingMethodActionSchema,
            )

            return (
                StagedOrderSetShippingAddressAndCustomShippingMethodActionSchema().load(
                    data
                )
            )
        if data["action"] == "setShippingAddressAndShippingMethod":
            from ._schemas.order_edit import (
                StagedOrderSetShippingAddressAndShippingMethodActionSchema,
            )

            return StagedOrderSetShippingAddressAndShippingMethodActionSchema().load(
                data
            )
        if data["action"] == "setShippingAddressCustomField":
            from ._schemas.order_edit import (
                StagedOrderSetShippingAddressCustomFieldActionSchema,
            )

            return StagedOrderSetShippingAddressCustomFieldActionSchema().load(data)
        if data["action"] == "setShippingAddressCustomType":
            from ._schemas.order_edit import (
                StagedOrderSetShippingAddressCustomTypeActionSchema,
            )

            return StagedOrderSetShippingAddressCustomTypeActionSchema().load(data)
        if data["action"] == "setShippingMethod":
            from ._schemas.order_edit import StagedOrderSetShippingMethodActionSchema

            return StagedOrderSetShippingMethodActionSchema().load(data)
        if data["action"] == "setShippingMethodTaxAmount":
            from ._schemas.order_edit import (
                StagedOrderSetShippingMethodTaxAmountActionSchema,
            )

            return StagedOrderSetShippingMethodTaxAmountActionSchema().load(data)
        if data["action"] == "setShippingMethodTaxRate":
            from ._schemas.order_edit import (
                StagedOrderSetShippingMethodTaxRateActionSchema,
            )

            return StagedOrderSetShippingMethodTaxRateActionSchema().load(data)
        if data["action"] == "setShippingRateInput":
            from ._schemas.order_edit import StagedOrderSetShippingRateInputActionSchema

            return StagedOrderSetShippingRateInputActionSchema().load(data)
        if data["action"] == "setStore":
            from ._schemas.order_edit import StagedOrderSetStoreActionSchema

            return StagedOrderSetStoreActionSchema().load(data)
        if data["action"] == "transitionCustomLineItemState":
            from ._schemas.order_edit import (
                StagedOrderTransitionCustomLineItemStateActionSchema,
            )

            return StagedOrderTransitionCustomLineItemStateActionSchema().load(data)
        if data["action"] == "transitionLineItemState":
            from ._schemas.order_edit import (
                StagedOrderTransitionLineItemStateActionSchema,
            )

            return StagedOrderTransitionLineItemStateActionSchema().load(data)
        if data["action"] == "transitionState":
            from ._schemas.order_edit import StagedOrderTransitionStateActionSchema

            return StagedOrderTransitionStateActionSchema().load(data)
        if data["action"] == "updateItemShippingAddress":
            from ._schemas.order_edit import (
                StagedOrderUpdateItemShippingAddressActionSchema,
            )

            return StagedOrderUpdateItemShippingAddressActionSchema().load(data)
        if data["action"] == "updateSyncInfo":
            from ._schemas.order_edit import StagedOrderUpdateSyncInfoActionSchema

            return StagedOrderUpdateSyncInfoActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import StagedOrderUpdateActionSchema

        return StagedOrderUpdateActionSchema().dump(self)


class Hit(_BaseType):
    #: Unique identifier of the Order.
    id: str
    #: Current version of the Order.
    version: int
    #: The higher the value is, the more relevant the hit is for the search request.
    relevance: typing.Optional[float]

    def __init__(
        self, *, id: str, version: int, relevance: typing.Optional[float] = None
    ):
        self.id = id
        self.version = version
        self.relevance = relevance

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "Hit":
        from ._schemas.order import HitSchema

        return HitSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import HitSchema

        return HitSchema().dump(self)


class OrderPagedSearchResponse(_BaseType):
    #: Total number of results matching the query.
    total: int
    #: Number of [elements skipped](/../api/general-concepts#offset).
    offset: typing.Optional[int]
    #: Number of [results requested](/../api/general-concepts#limit).
    limit: typing.Optional[int]
    #: Actual results.
    hits: typing.List["Hit"]

    def __init__(
        self,
        *,
        total: int,
        offset: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        hits: typing.List["Hit"]
    ):
        self.total = total
        self.offset = offset
        self.limit = limit
        self.hits = hits

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderPagedSearchResponse":
        from ._schemas.order import OrderPagedSearchResponseSchema

        return OrderPagedSearchResponseSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderPagedSearchResponseSchema

        return OrderPagedSearchResponseSchema().dump(self)


class OrderSearchMatchType(enum.Enum):
    ANY = "any"
    ALL = "all"


class OrderSearchQueryExpressionValue(_BaseType):
    field: str
    boost: typing.Optional[int]
    custom_type: typing.Optional[str]

    def __init__(
        self,
        *,
        field: str,
        boost: typing.Optional[int] = None,
        custom_type: typing.Optional[str] = None
    ):
        self.field = field
        self.boost = boost
        self.custom_type = custom_type

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderSearchQueryExpressionValue":
        from ._schemas.order import OrderSearchQueryExpressionValueSchema

        return OrderSearchQueryExpressionValueSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderSearchQueryExpressionValueSchema

        return OrderSearchQueryExpressionValueSchema().dump(self)


class OrderSearchAnyValue(OrderSearchQueryExpressionValue):
    value: typing.Any
    language: typing.Optional[str]
    case_insensitive: typing.Optional[bool]

    def __init__(
        self,
        *,
        field: str,
        boost: typing.Optional[int] = None,
        custom_type: typing.Optional[str] = None,
        value: typing.Any,
        language: typing.Optional[str] = None,
        case_insensitive: typing.Optional[bool] = None
    ):
        self.value = value
        self.language = language
        self.case_insensitive = case_insensitive

        super().__init__(field=field, boost=boost, custom_type=custom_type)

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "OrderSearchAnyValue":
        from ._schemas.order import OrderSearchAnyValueSchema

        return OrderSearchAnyValueSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderSearchAnyValueSchema

        return OrderSearchAnyValueSchema().dump(self)


class OrderSearchDateRangeValue(OrderSearchQueryExpressionValue):
    gte: typing.Optional[datetime.datetime]
    lte: typing.Optional[datetime.datetime]

    def __init__(
        self,
        *,
        field: str,
        boost: typing.Optional[int] = None,
        custom_type: typing.Optional[str] = None,
        gte: typing.Optional[datetime.datetime] = None,
        lte: typing.Optional[datetime.datetime] = None
    ):
        self.gte = gte
        self.lte = lte

        super().__init__(field=field, boost=boost, custom_type=custom_type)

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderSearchDateRangeValue":
        from ._schemas.order import OrderSearchDateRangeValueSchema

        return OrderSearchDateRangeValueSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderSearchDateRangeValueSchema

        return OrderSearchDateRangeValueSchema().dump(self)


class OrderSearchFullTextValue(OrderSearchQueryExpressionValue):
    value: str
    language: typing.Optional[str]
    must_match: typing.Optional["OrderSearchMatchType"]

    def __init__(
        self,
        *,
        field: str,
        boost: typing.Optional[int] = None,
        custom_type: typing.Optional[str] = None,
        value: str,
        language: typing.Optional[str] = None,
        must_match: typing.Optional["OrderSearchMatchType"] = None
    ):
        self.value = value
        self.language = language
        self.must_match = must_match

        super().__init__(field=field, boost=boost, custom_type=custom_type)

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderSearchFullTextValue":
        from ._schemas.order import OrderSearchFullTextValueSchema

        return OrderSearchFullTextValueSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderSearchFullTextValueSchema

        return OrderSearchFullTextValueSchema().dump(self)


class OrderSearchLongRangeValue(OrderSearchQueryExpressionValue):
    gte: typing.Optional[int]
    lte: typing.Optional[int]

    def __init__(
        self,
        *,
        field: str,
        boost: typing.Optional[int] = None,
        custom_type: typing.Optional[str] = None,
        gte: typing.Optional[int] = None,
        lte: typing.Optional[int] = None
    ):
        self.gte = gte
        self.lte = lte

        super().__init__(field=field, boost=boost, custom_type=custom_type)

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderSearchLongRangeValue":
        from ._schemas.order import OrderSearchLongRangeValueSchema

        return OrderSearchLongRangeValueSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderSearchLongRangeValueSchema

        return OrderSearchLongRangeValueSchema().dump(self)


class OrderSearchNumberRangeValue(OrderSearchQueryExpressionValue):
    gte: typing.Optional[float]
    lte: typing.Optional[float]

    def __init__(
        self,
        *,
        field: str,
        boost: typing.Optional[int] = None,
        custom_type: typing.Optional[str] = None,
        gte: typing.Optional[float] = None,
        lte: typing.Optional[float] = None
    ):
        self.gte = gte
        self.lte = lte

        super().__init__(field=field, boost=boost, custom_type=custom_type)

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderSearchNumberRangeValue":
        from ._schemas.order import OrderSearchNumberRangeValueSchema

        return OrderSearchNumberRangeValueSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderSearchNumberRangeValueSchema

        return OrderSearchNumberRangeValueSchema().dump(self)


class OrderSearchSortMode(enum.Enum):
    MIN = "min"
    MAX = "max"
    AVG = "avg"
    SUM = "sum"


class OrderSearchSortOrder(enum.Enum):
    ASC = "asc"
    DESC = "desc"


class OrderSearchStringValue(OrderSearchQueryExpressionValue):
    value: str
    language: typing.Optional[str]
    case_insensitive: typing.Optional[bool]

    def __init__(
        self,
        *,
        field: str,
        boost: typing.Optional[int] = None,
        custom_type: typing.Optional[str] = None,
        value: str,
        language: typing.Optional[str] = None,
        case_insensitive: typing.Optional[bool] = None
    ):
        self.value = value
        self.language = language
        self.case_insensitive = case_insensitive

        super().__init__(field=field, boost=boost, custom_type=custom_type)

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderSearchStringValue":
        from ._schemas.order import OrderSearchStringValueSchema

        return OrderSearchStringValueSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderSearchStringValueSchema

        return OrderSearchStringValueSchema().dump(self)


class CustomLineItemImportDraft(_BaseType):
    """Custom Line Items contain generic user-defined items that are not linked to Products."""

    #: Name of the Custom Line Item.
    name: "LocalizedString"
    #: User-defined unique identifier of the Custom Line Item.
    key: typing.Optional[str]
    #: User-defined identifier used in a deep-link URL for the Custom Line Item. This value should match the pattern `[a-zA-Z0-9_-]{2,256}`.
    slug: str
    #: The number of items in the Custom Line Item. Can be a negative value.
    quantity: int
    #: The cost of individual items in the Custom Line Item. The amount can be negative.
    money: "Money"
    #: The tax rate used to calculate the `taxedPrice` of the Order.
    tax_rate: typing.Optional["TaxRate"]
    #: Include a value to associate a Tax Category with the Custom Line Item.
    tax_category: typing.Optional["TaxCategoryResourceIdentifier"]
    #: - If `Standard`, Cart Discounts with a matching [CartDiscountCustomLineItemsTarget](ctp:api:type:CartDiscountCustomLineItemsTarget)
    #: are applied to the Custom Line Item.
    #: - If `External`, Cart Discounts are not considered on the Custom Line Item.
    price_mode: typing.Optional["CustomLineItemPriceMode"]
    #: Container for Custom Line Item-specific addresses.
    shipping_details: typing.Optional["ItemShippingDetailsDraft"]
    #: State of the Custom Line Items.
    state: typing.Optional[typing.List["ItemState"]]
    #: Custom Fields of the CustomLineItem.
    custom: typing.Optional["CustomFieldsDraft"]

    def __init__(
        self,
        *,
        name: "LocalizedString",
        key: typing.Optional[str] = None,
        slug: str,
        quantity: int,
        money: "Money",
        tax_rate: typing.Optional["TaxRate"] = None,
        tax_category: typing.Optional["TaxCategoryResourceIdentifier"] = None,
        price_mode: typing.Optional["CustomLineItemPriceMode"] = None,
        shipping_details: typing.Optional["ItemShippingDetailsDraft"] = None,
        state: typing.Optional[typing.List["ItemState"]] = None,
        custom: typing.Optional["CustomFieldsDraft"] = None
    ):
        self.name = name
        self.key = key
        self.slug = slug
        self.quantity = quantity
        self.money = money
        self.tax_rate = tax_rate
        self.tax_category = tax_category
        self.price_mode = price_mode
        self.shipping_details = shipping_details
        self.state = state
        self.custom = custom

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CustomLineItemImportDraft":
        from ._schemas.order import CustomLineItemImportDraftSchema

        return CustomLineItemImportDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import CustomLineItemImportDraftSchema

        return CustomLineItemImportDraftSchema().dump(self)


class Delivery(_BaseType):
    """Contains information on how items are shipped to Customers, for example, a delivery note."""

    #: Unique identifier of the Delivery.
    id: str
    #: User-defined unique identifier of the Delivery.
    key: typing.Optional[str]
    #: Date and time (UTC) the Delivery was created.
    created_at: datetime.datetime
    #: Line Items or Custom Line Items that are delivered.
    items: typing.List["DeliveryItem"]
    #: Information regarding the appearance, content, and shipment of a Parcel.
    parcels: typing.List["Parcel"]
    #: Address to which Parcels are delivered.
    address: typing.Optional["Address"]
    #: Custom Fields of the Delivery.
    custom: typing.Optional["CustomFields"]

    def __init__(
        self,
        *,
        id: str,
        key: typing.Optional[str] = None,
        created_at: datetime.datetime,
        items: typing.List["DeliveryItem"],
        parcels: typing.List["Parcel"],
        address: typing.Optional["Address"] = None,
        custom: typing.Optional["CustomFields"] = None
    ):
        self.id = id
        self.key = key
        self.created_at = created_at
        self.items = items
        self.parcels = parcels
        self.address = address
        self.custom = custom

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "Delivery":
        from ._schemas.order import DeliverySchema

        return DeliverySchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import DeliverySchema

        return DeliverySchema().dump(self)


class DeliveryDraft(_BaseType):
    #: User-defined unique identifier of the Delivery.
    key: typing.Optional[str]
    #: Line Items or Custom Line Items to deliver.
    #: It can also be specified individually for each [Parcel](ctp:api:type:Parcel).
    items: typing.Optional[typing.List["DeliveryItem"]]
    #: Information regarding the appearance, content, and shipment of a parcel.
    parcels: typing.Optional[typing.List["ParcelDraft"]]
    #: Address to which the Parcels are delivered.
    address: typing.Optional["AddressDraft"]
    #: Custom Fields for the Delivery.
    custom: typing.Optional["CustomFieldsDraft"]

    def __init__(
        self,
        *,
        key: typing.Optional[str] = None,
        items: typing.Optional[typing.List["DeliveryItem"]] = None,
        parcels: typing.Optional[typing.List["ParcelDraft"]] = None,
        address: typing.Optional["AddressDraft"] = None,
        custom: typing.Optional["CustomFieldsDraft"] = None
    ):
        self.key = key
        self.items = items
        self.parcels = parcels
        self.address = address
        self.custom = custom

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "DeliveryDraft":
        from ._schemas.order import DeliveryDraftSchema

        return DeliveryDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import DeliveryDraftSchema

        return DeliveryDraftSchema().dump(self)


class DeliveryItem(_BaseType):
    #: `id` of the [LineItem](ctp:api:type:LineItem) or [CustomLineItem](ctp:api:type:CustomLineItem) delivered.
    id: str
    #: Number of Line Items or Custom Line Items delivered.
    quantity: int

    def __init__(self, *, id: str, quantity: int):
        self.id = id
        self.quantity = quantity

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "DeliveryItem":
        from ._schemas.order import DeliveryItemSchema

        return DeliveryItemSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import DeliveryItemSchema

        return DeliveryItemSchema().dump(self)


class DiscountedLineItemPriceDraft(_BaseType):
    #: Discounted money value.
    value: "Money"
    #: Discounts to be applied.
    included_discounts: typing.List["DiscountedLineItemPortionDraft"]

    def __init__(
        self,
        *,
        value: "Money",
        included_discounts: typing.List["DiscountedLineItemPortionDraft"]
    ):
        self.value = value
        self.included_discounts = included_discounts

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "DiscountedLineItemPriceDraft":
        from ._schemas.order import DiscountedLineItemPriceDraftSchema

        return DiscountedLineItemPriceDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import DiscountedLineItemPriceDraftSchema

        return DiscountedLineItemPriceDraftSchema().dump(self)


class ItemState(_BaseType):
    #: Number of Line Items or Custom Line Items in this State.
    quantity: int
    #: State of the Line Items or Custom Line Items in a custom workflow.
    state: "StateReference"

    def __init__(self, *, quantity: int, state: "StateReference"):
        self.quantity = quantity
        self.state = state

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ItemState":
        from ._schemas.order import ItemStateSchema

        return ItemStateSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import ItemStateSchema

        return ItemStateSchema().dump(self)


class LineItemImportDraft(_BaseType):
    """Represents a snapshot of a Product Variant at the time it was imported with the Order. The Product Variant can be specified by providing a `productId` and `variant.id`, or by providing a `variant.sku`."""

    #: Name of the Line Item.
    name: "LocalizedString"
    #: User-defined unique identifier of the Line Item.
    key: typing.Optional[str]
    #: The Product Variant to use as a [Line Item](ctp:api:type:LineItem).
    variant: "ProductVariantImportDraft"
    #: `id` of the [Product](ctp:api:type:Product) the Product Variant belongs to.
    #:
    #: If provided, you must also set `variant.id`.
    product_id: typing.Optional[str]
    #: The number of Product Variants in the LineItem. Can be a negative value.
    quantity: int
    #: The Line Item price for `quantity` = `1`. The amount can be negative.
    price: "PriceDraft"
    #: The tax rate used to calculate the `taxedPrice` of the Order.
    tax_rate: typing.Optional["TaxRate"]
    #: The Channel used to [select a Price](ctp:api:type:LineItemPriceSelection).
    #: This Channel must have the `ProductDistribution` role.
    distribution_channel: typing.Optional["ChannelResourceIdentifier"]
    #: The Channel used to supply Line Items.
    #: By providing supply Channel information, you can uniquely identify [Inventory entries](ctp:api:type:InventoryEntry) that should be reserved.
    #: This Channel must have the `InventorySupply` role.
    supply_channel: typing.Optional["ChannelResourceIdentifier"]
    #: Inventory mode specific to the LineItem, valid for the entire `quantity` of the LineItem.
    #: Set only if Inventory mode should be different from the `inventoryMode` specified on the [OrderImportDraft](ctp:api:type:OrderImportDraft).
    inventory_mode: typing.Optional["InventoryMode"]
    #: Container for Line Item-specific addresses.
    shipping_details: typing.Optional["ItemShippingDetailsDraft"]
    #: States of the Line Item.
    state: typing.Optional[typing.List["ItemState"]]
    #: Custom Fields of the LineItem.
    custom: typing.Optional["CustomFieldsDraft"]

    def __init__(
        self,
        *,
        name: "LocalizedString",
        key: typing.Optional[str] = None,
        variant: "ProductVariantImportDraft",
        product_id: typing.Optional[str] = None,
        quantity: int,
        price: "PriceDraft",
        tax_rate: typing.Optional["TaxRate"] = None,
        distribution_channel: typing.Optional["ChannelResourceIdentifier"] = None,
        supply_channel: typing.Optional["ChannelResourceIdentifier"] = None,
        inventory_mode: typing.Optional["InventoryMode"] = None,
        shipping_details: typing.Optional["ItemShippingDetailsDraft"] = None,
        state: typing.Optional[typing.List["ItemState"]] = None,
        custom: typing.Optional["CustomFieldsDraft"] = None
    ):
        self.name = name
        self.key = key
        self.variant = variant
        self.product_id = product_id
        self.quantity = quantity
        self.price = price
        self.tax_rate = tax_rate
        self.distribution_channel = distribution_channel
        self.supply_channel = supply_channel
        self.inventory_mode = inventory_mode
        self.shipping_details = shipping_details
        self.state = state
        self.custom = custom

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "LineItemImportDraft":
        from ._schemas.order import LineItemImportDraftSchema

        return LineItemImportDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import LineItemImportDraftSchema

        return LineItemImportDraftSchema().dump(self)


class Order(BaseResource):
    #: User-defined identifier of the Order that is unique across a Project.
    order_number: typing.Optional[str]
    #: User-defined identifier of a purchase Order.
    #:
    #: It is typically set by the [Buyer](ctp:api:type:Buyer) and can be used with [Quotes](/quotes-overview) to track the purchase Order during the [quote and order flow](/../api/quotes-overview#intended-workflow).
    purchase_order_number: typing.Optional[str]
    #: `id` of the [Customer](ctp:api:type:Customer) that the Order belongs to.
    customer_id: typing.Optional[str]
    #: Email address of the Customer that the Order belongs to.
    customer_email: typing.Optional[str]
    #: [Reference](ctp:api:type:Reference) to the Customer Group of the Customer that the Order belongs to.
    #: Used for [LineItem Price selection](ctp:api:type:LineItemPriceSelection).
    customer_group: typing.Optional["CustomerGroupReference"]
    #: [Anonymous session](ctp:api:type:AnonymousSession) associated with the Order.
    anonymous_id: typing.Optional[str]
    #: [Reference](ctp:api:type:Reference) to a Business Unit the Order belongs to.
    business_unit: typing.Optional["BusinessUnitKeyReference"]
    #: [Reference](ctp:api:type:Reference) to a Store the Order belongs to.
    store: typing.Optional["StoreKeyReference"]
    #: [Line Items](ctp:api:type:LineItems) that are part of the Order.
    line_items: typing.List["LineItem"]
    #: [Custom Line Items](ctp:api:type:CustomLineItems) that are part of the Order.
    custom_line_items: typing.List["CustomLineItem"]
    #: Sum of the `totalPrice` field of all [LineItems](ctp:api:type:LineItem) and [CustomLineItems](ctp:api:type:CustomLineItem), and if available, the `price` field of [ShippingInfo](ctp:api:type:ShippingInfo).
    #: If a discount applies on `totalPrice`, this field holds the discounted value.
    #:
    #: Taxes are included if [TaxRate](ctp:api:type:TaxRate) `includedInPrice` is `true` for each price.
    total_price: "TypedMoney"
    #: - For `Platform` [TaxMode](ctp:api:type:TaxMode), it is automatically set when a [shipping address is set](ctp:api:type:OrderSetShippingAddressAction).
    #: - For `External` [TaxMode](ctp:api:type:TaxMode), it is automatically set when `shippingAddress` and external Tax Rates for all Line Items, Custom Line Items, and Shipping Methods in the Cart are set.
    #:
    #: If a discount applies on `totalPrice`, this field holds the discounted values.
    taxed_price: typing.Optional["TaxedPrice"]
    #: Sum of the `taxedPrice` field of [ShippingInfo](ctp:api:type:ShippingInfo) across all Shipping Methods.
    taxed_shipping_price: typing.Optional["TaxedPrice"]
    #: Discounts that apply on the total price of the Order.
    discount_on_total_price: typing.Optional["DiscountOnTotalPrice"]
    #: Indicates how Tax Rates are set.
    tax_mode: typing.Optional["TaxMode"]
    #: Indicates how monetary values are rounded when calculating taxes for `taxedPrice`.
    tax_rounding_mode: typing.Optional["RoundingMode"]
    #: Indicates how taxes are calculated when calculating taxes for `taxedPrice`.
    tax_calculation_mode: typing.Optional["TaxCalculationMode"]
    #: Indicates how stock quantities are tracked for Line Items in the Order.
    inventory_mode: typing.Optional["InventoryMode"]
    #: Billing address associated with the Order.
    billing_address: typing.Optional["Address"]
    #: Shipping address associated with the Order.
    #: Determines eligible [ShippingMethod](ctp:api:type:ShippingMethod) rates and Tax Rates of Line Items.
    shipping_address: typing.Optional["Address"]
    #: Indicates whether there can be one or multiple Shipping Methods.
    shipping_mode: "ShippingMode"
    #: `key` of the [ShippingMethod](ctp:api:type:ShippingMethod) for `Single` [ShippingMode](ctp:api:type:ShippingMode).
    shipping_key: typing.Optional[str]
    #: Shipping-related information for `Single` [ShippingMode](ctp:api:type:ShippingMode).
    #: Automatically set when a [Shipping Method is set](ctp:api:type:StagedOrderSetShippingMethodAction).
    shipping_info: typing.Optional["ShippingInfo"]
    #: Input used to select a [ShippingRatePriceTier](ctp:api:type:ShippingRatePriceTier).
    #: The data type of this field depends on the `shippingRateInputType.type` configured in the [Project](ctp:api:type:Project):
    #:
    #: - If `CartClassification`, it is [ClassificationShippingRateInput](ctp:api:type:ClassificationShippingRateInput).
    #: - If `CartScore`, it is [ScoreShippingRateInput](ctp:api:type:ScoreShippingRateInput).
    #: - If `CartValue`, it cannot be used.
    shipping_rate_input: typing.Optional["ShippingRateInput"]
    #: Custom Fields of the Shipping Method for `Single` [ShippingMode](ctp:api:type:ShippingMode).
    shipping_custom_fields: typing.Optional["CustomFields"]
    #: Shipping-related information for `Multiple` [ShippingMode](ctp:api:type:ShippingMode).
    #: Updated automatically each time a new [Shipping Method is added](ctp:api:type:CartAddShippingMethodAction).
    shipping: typing.List["Shipping"]
    #: Additional shipping addresses of the Order as specified by [LineItems](ctp:api:type:LineItem) using the `shippingDetails` field.
    #: Eligible Shipping Methods or applicable Tax Rates are determined by the address in `shippingAddress`, and not `itemShippingAddresses`.
    item_shipping_addresses: typing.Optional[typing.List["Address"]]
    #: Discount Codes added to the Order.
    #: An Order that has `directDiscounts` cannot have `discountCodes`.
    discount_codes: typing.Optional[typing.List["DiscountCodeInfo"]]
    #: Direct Discounts added to the Order.
    #: An Order that has `discountCodes` cannot have `directDiscounts`.
    direct_discounts: typing.Optional[typing.List["DirectDiscount"]]
    #: Automatically set when a Line Item with `GiftLineItem` [LineItemMode](ctp:api:type:LineItemMode) is [removed](ctp:api:type:StagedOrderRemoveLineItemAction) from the Order.
    refused_gifts: typing.List["CartDiscountReference"]
    #: Payment information related to the Order.
    payment_info: typing.Optional["PaymentInfo"]
    #: Used for [LineItem Price selection](ctp:api:type:LineItemPriceSelection).
    country: typing.Optional[str]
    #: Languages of the Order.
    #: Can only contain languages supported by the [Project](ctp:api:type:Project).
    locale: typing.Optional[str]
    #: Indicates the origin of the Cart from which the Order was created.
    origin: "CartOrigin"
    #: [Reference](ctp:api:type:Reference) to the Cart for an [Order created from Cart](ctp:api:endpoint:/{projectKey}/orders:POST).
    #: The referenced Cart will have the `Ordered` [CartState](ctp:api:type:CartState).
    cart: typing.Optional["CartReference"]
    #: [Reference](ctp:api:type:Reference) to the Quote for an [Order created from Quote](ctp:api:endpoint:/{projectKey}/orders/quotes:POST).
    quote: typing.Optional["QuoteReference"]
    #: Current status of the Order.
    order_state: "OrderState"
    #: Shipment status of the Order.
    shipment_state: typing.Optional["ShipmentState"]
    #: Payment status of the Order.
    payment_state: typing.Optional["PaymentState"]
    #: [State](ctp:api:type:State) of the Order.
    #: This reference can point to a State in a custom workflow.
    state: typing.Optional["StateReference"]
    #: Contains synchronization activity information of the Order (like export or import).
    #: Can only be set with [Update SyncInfo](ctp:api:type:OrderUpdateSyncInfoAction) update action.
    sync_info: typing.List["SyncInfo"]
    #: Contains information regarding the returns associated with the Order.
    return_info: typing.Optional[typing.List["ReturnInfo"]]
    #: Internal-only field.
    last_message_sequence_number: typing.Optional[int]
    #: Custom Fields of the Order.
    custom: typing.Optional["CustomFields"]
    #: User-defined date and time (UTC) of the Order.
    #: Present only on an Order created using [Order Import](ctp:api:endpoint:/{projectKey}/orders/import:POST).
    completed_at: typing.Optional[datetime.datetime]
    #: IDs and references that last modified the Order.
    last_modified_by: typing.Optional["LastModifiedBy"]
    #: IDs and references that created the Order.
    created_by: typing.Optional["CreatedBy"]

    def __init__(
        self,
        *,
        id: str,
        version: int,
        created_at: datetime.datetime,
        last_modified_at: datetime.datetime,
        order_number: typing.Optional[str] = None,
        purchase_order_number: typing.Optional[str] = None,
        customer_id: typing.Optional[str] = None,
        customer_email: typing.Optional[str] = None,
        customer_group: typing.Optional["CustomerGroupReference"] = None,
        anonymous_id: typing.Optional[str] = None,
        business_unit: typing.Optional["BusinessUnitKeyReference"] = None,
        store: typing.Optional["StoreKeyReference"] = None,
        line_items: typing.List["LineItem"],
        custom_line_items: typing.List["CustomLineItem"],
        total_price: "TypedMoney",
        taxed_price: typing.Optional["TaxedPrice"] = None,
        taxed_shipping_price: typing.Optional["TaxedPrice"] = None,
        discount_on_total_price: typing.Optional["DiscountOnTotalPrice"] = None,
        tax_mode: typing.Optional["TaxMode"] = None,
        tax_rounding_mode: typing.Optional["RoundingMode"] = None,
        tax_calculation_mode: typing.Optional["TaxCalculationMode"] = None,
        inventory_mode: typing.Optional["InventoryMode"] = None,
        billing_address: typing.Optional["Address"] = None,
        shipping_address: typing.Optional["Address"] = None,
        shipping_mode: "ShippingMode",
        shipping_key: typing.Optional[str] = None,
        shipping_info: typing.Optional["ShippingInfo"] = None,
        shipping_rate_input: typing.Optional["ShippingRateInput"] = None,
        shipping_custom_fields: typing.Optional["CustomFields"] = None,
        shipping: typing.List["Shipping"],
        item_shipping_addresses: typing.Optional[typing.List["Address"]] = None,
        discount_codes: typing.Optional[typing.List["DiscountCodeInfo"]] = None,
        direct_discounts: typing.Optional[typing.List["DirectDiscount"]] = None,
        refused_gifts: typing.List["CartDiscountReference"],
        payment_info: typing.Optional["PaymentInfo"] = None,
        country: typing.Optional[str] = None,
        locale: typing.Optional[str] = None,
        origin: "CartOrigin",
        cart: typing.Optional["CartReference"] = None,
        quote: typing.Optional["QuoteReference"] = None,
        order_state: "OrderState",
        shipment_state: typing.Optional["ShipmentState"] = None,
        payment_state: typing.Optional["PaymentState"] = None,
        state: typing.Optional["StateReference"] = None,
        sync_info: typing.List["SyncInfo"],
        return_info: typing.Optional[typing.List["ReturnInfo"]] = None,
        last_message_sequence_number: typing.Optional[int] = None,
        custom: typing.Optional["CustomFields"] = None,
        completed_at: typing.Optional[datetime.datetime] = None,
        last_modified_by: typing.Optional["LastModifiedBy"] = None,
        created_by: typing.Optional["CreatedBy"] = None
    ):
        self.order_number = order_number
        self.purchase_order_number = purchase_order_number
        self.customer_id = customer_id
        self.customer_email = customer_email
        self.customer_group = customer_group
        self.anonymous_id = anonymous_id
        self.business_unit = business_unit
        self.store = store
        self.line_items = line_items
        self.custom_line_items = custom_line_items
        self.total_price = total_price
        self.taxed_price = taxed_price
        self.taxed_shipping_price = taxed_shipping_price
        self.discount_on_total_price = discount_on_total_price
        self.tax_mode = tax_mode
        self.tax_rounding_mode = tax_rounding_mode
        self.tax_calculation_mode = tax_calculation_mode
        self.inventory_mode = inventory_mode
        self.billing_address = billing_address
        self.shipping_address = shipping_address
        self.shipping_mode = shipping_mode
        self.shipping_key = shipping_key
        self.shipping_info = shipping_info
        self.shipping_rate_input = shipping_rate_input
        self.shipping_custom_fields = shipping_custom_fields
        self.shipping = shipping
        self.item_shipping_addresses = item_shipping_addresses
        self.discount_codes = discount_codes
        self.direct_discounts = direct_discounts
        self.refused_gifts = refused_gifts
        self.payment_info = payment_info
        self.country = country
        self.locale = locale
        self.origin = origin
        self.cart = cart
        self.quote = quote
        self.order_state = order_state
        self.shipment_state = shipment_state
        self.payment_state = payment_state
        self.state = state
        self.sync_info = sync_info
        self.return_info = return_info
        self.last_message_sequence_number = last_message_sequence_number
        self.custom = custom
        self.completed_at = completed_at
        self.last_modified_by = last_modified_by
        self.created_by = created_by

        super().__init__(
            id=id,
            version=version,
            created_at=created_at,
            last_modified_at=last_modified_at,
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "Order":
        from ._schemas.order import OrderSchema

        return OrderSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderSchema

        return OrderSchema().dump(self)


class OrderFromCartDraft(_BaseType):
    #: `id` of the [Cart](ctp:api:type:Cart) used to create the Order.
    id: typing.Optional[str]
    #: [ResourceIdentifier](ctp:api:type:ResourceIdentifier) to the Cart from which the Order is created.
    #:
    #: This field is required, but is marked as optional for backwards compatibility reasons.
    cart: typing.Optional["CartResourceIdentifier"]
    #: `version` of the [Cart](ctp:api:type:Cart) from which the Order is created.
    version: int
    #: User-defined identifier for the Order that is unique across a Project.
    #: Once set, the value cannot be changed.
    order_number: typing.Optional[str]
    #: User-defined identifier for a purchase Order.
    #:
    #: It is typically set by the [Buyer](ctp:api:type:Buyer) and can be used with [Quotes](/quotes-overview) to track the purchase Order during the [quote and order flow](/../api/quotes-overview#intended-workflow).
    purchase_order_number: typing.Optional[str]
    #: Payment status for the Order.
    payment_state: typing.Optional["PaymentState"]
    #: Shipment status for the Order.
    shipment_state: typing.Optional["ShipmentState"]
    #: Current status for the Order.
    order_state: typing.Optional["OrderState"]
    #: State for the Order in a custom workflow.
    state: typing.Optional["StateResourceIdentifier"]
    #: Custom Fields for the Order.
    #: The Custom Fields' type must match the Custom Fields' type in the referenced [Cart](ctp:api:type:Cart).
    #:
    #: - If empty, the Custom Fields on the referenced [Cart](ctp:api:type:Cart) are added to the Order automatically.
    #: - If specified, the Custom Fields are merged with the Custom Fields on the referenced [Cart](ctp:api:type:Cart) and added to the Order.
    custom: typing.Optional["CustomFieldsDraft"]

    def __init__(
        self,
        *,
        id: typing.Optional[str] = None,
        cart: typing.Optional["CartResourceIdentifier"] = None,
        version: int,
        order_number: typing.Optional[str] = None,
        purchase_order_number: typing.Optional[str] = None,
        payment_state: typing.Optional["PaymentState"] = None,
        shipment_state: typing.Optional["ShipmentState"] = None,
        order_state: typing.Optional["OrderState"] = None,
        state: typing.Optional["StateResourceIdentifier"] = None,
        custom: typing.Optional["CustomFieldsDraft"] = None
    ):
        self.id = id
        self.cart = cart
        self.version = version
        self.order_number = order_number
        self.purchase_order_number = purchase_order_number
        self.payment_state = payment_state
        self.shipment_state = shipment_state
        self.order_state = order_state
        self.state = state
        self.custom = custom

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "OrderFromCartDraft":
        from ._schemas.order import OrderFromCartDraftSchema

        return OrderFromCartDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderFromCartDraftSchema

        return OrderFromCartDraftSchema().dump(self)


class OrderFromQuoteDraft(_BaseType):
    #: [ResourceIdentifier](ctp:api:type:ResourceIdentifier) to the Quote from which the Order is created.
    #: If the referenced [Quote](ctp:api:type:Quote) has expired (`validTo` check) or its `quoteState` is `Accepted`, `Declined`, or `Withdrawn`, the Order creation will fail.
    quote: "QuoteResourceIdentifier"
    #: `version` of the [Quote](ctp:api:type:Quote) from which the Order is created.
    version: int
    #: If `true`, the `quoteState` of the referenced [Quote](ctp:api:type:Quote) will be set to `Accepted`.
    quote_state_to_accepted: typing.Optional[bool]
    #: User-defined identifier for the Order that is unique across a Project.
    #: Once set, the value cannot be changed.
    order_number: typing.Optional[str]
    #: Payment status for the Order.
    payment_state: typing.Optional["PaymentState"]
    #: Shipment status for the Order.
    shipment_state: typing.Optional["ShipmentState"]
    #: Current status for the Order.
    order_state: typing.Optional["OrderState"]
    #: State of the Order in a custom workflow.
    state: typing.Optional["StateResourceIdentifier"]

    def __init__(
        self,
        *,
        quote: "QuoteResourceIdentifier",
        version: int,
        quote_state_to_accepted: typing.Optional[bool] = None,
        order_number: typing.Optional[str] = None,
        payment_state: typing.Optional["PaymentState"] = None,
        shipment_state: typing.Optional["ShipmentState"] = None,
        order_state: typing.Optional["OrderState"] = None,
        state: typing.Optional["StateResourceIdentifier"] = None
    ):
        self.quote = quote
        self.version = version
        self.quote_state_to_accepted = quote_state_to_accepted
        self.order_number = order_number
        self.payment_state = payment_state
        self.shipment_state = shipment_state
        self.order_state = order_state
        self.state = state

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "OrderFromQuoteDraft":
        from ._schemas.order import OrderFromQuoteDraftSchema

        return OrderFromQuoteDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderFromQuoteDraftSchema

        return OrderFromQuoteDraftSchema().dump(self)


class OrderImportDraft(_BaseType):
    """A snapshot of an Order at the time it was imported."""

    #: User-defined identifier of the Order. Must be unique across a Project.
    #: Once set, the value cannot be changed.
    order_number: typing.Optional[str]
    #: User-defined identifier for a purchase Order.
    purchase_order_number: typing.Optional[str]
    #: The `id` of the [Customer](ctp:api:type:Customer) the Order belongs to.
    customer_id: typing.Optional[str]
    #: The Email address of the Customer the Order belongs to. Can be used instead of `customerId` when no check against existing [Customers](ctp:api:type:Customer) is required.
    customer_email: typing.Optional[str]
    #: The Customer Group of the Customer the Order belongs to.
    customer_group: typing.Optional["CustomerGroupResourceIdentifier"]
    #: [ResourceIdentifier](ctp:api:type:ResourceIdentifier) to the Business Unit the Order should belong to.
    #: When the `customerId` of the Order is also set, the [Customer](ctp:api:type:Customer) must be an [Associate](ctp:api:type:Associate) of the Business Unit.
    business_unit: typing.Optional["BusinessUnitResourceIdentifier"]
    #: The Store the Order belongs to.
    #: Used for [filtering](#filtering).
    #:
    #: If a [LineItemImportDraft](ctp:api:type:LineItemImportDraft) or a [CustomLineItemImportDraft](ctp:api:type:CustomLineItemImportDraft) specifies a `distributionChannel` or a `supplyChannel` that is not defined for the referenced Store, the Order Import gets rejected.
    #: The same applies when the provided `country` is not defined for the referenced Store.
    store: typing.Optional["StoreResourceIdentifier"]
    #: [Line Items](ctp:api:type:LineItems) to add to the Order.
    #:
    #: If not specified, `customLineItems` must not be empty.
    line_items: typing.Optional[typing.List["LineItemImportDraft"]]
    #: [Custom Line Items](ctp:api:type:CustomLineItems) to add to the Cart.
    #:
    #: If not specified, `lineItems` must not be empty.
    custom_line_items: typing.Optional[typing.List["CustomLineItemImportDraft"]]
    #: The total Price of the Order. The amount can be negative.
    total_price: "Money"
    #: Include TaxedPrice information for the Order. If not included, and if you have Tax Rates set for Line Items and Custom Line Items, the Order total will not be recalculated.
    taxed_price: typing.Optional["TaxedPriceDraft"]
    #: Determines how monetary values are rounded when calculating taxes for `taxedPrice`.
    tax_rounding_mode: typing.Optional["RoundingMode"]
    #: Determines how taxes are calculated for `taxedPrice`.
    tax_calculation_mode: typing.Optional["TaxCalculationMode"]
    #: Determines how stock quantities are tracked for Line Items in the Cart.
    inventory_mode: typing.Optional["InventoryMode"]
    #: Billing address associated with the Order.
    billing_address: typing.Optional["BaseAddress"]
    #: Shipping address associated with the Order.
    shipping_address: typing.Optional["BaseAddress"]
    #: Addresses for Orders with multiple shipping addresses. Addresses must include a value for `key`.
    item_shipping_addresses: typing.Optional[typing.List["BaseAddress"]]
    #: Shipping-related information of the Order.
    shipping_info: typing.Optional["ShippingInfoImportDraft"]
    #: Payment information associated with the Order.
    payment_info: typing.Optional["PaymentInfo"]
    #: Payment status of the Order.
    payment_state: typing.Optional["PaymentState"]
    #: Shipment status of the Order.
    shipment_state: typing.Optional["ShipmentState"]
    #: Current status of the Order.
    order_state: typing.Optional["OrderState"]
    #: State of the Order in a custom workflow.
    state: typing.Optional["StateReference"]
    #: Include a value to associate a country with the Order.
    country: typing.Optional[str]
    #: Indicates the origin of the Order.
    origin: typing.Optional["CartOrigin"]
    #: User-defined date and time for the Order. This value does not influence the `createdAt` or `lastModifiedAt` values of the Order created by the Order Import.
    completed_at: typing.Optional[datetime.datetime]
    #: Custom Fields for the Order.
    custom: typing.Optional["CustomFieldsDraft"]

    def __init__(
        self,
        *,
        order_number: typing.Optional[str] = None,
        purchase_order_number: typing.Optional[str] = None,
        customer_id: typing.Optional[str] = None,
        customer_email: typing.Optional[str] = None,
        customer_group: typing.Optional["CustomerGroupResourceIdentifier"] = None,
        business_unit: typing.Optional["BusinessUnitResourceIdentifier"] = None,
        store: typing.Optional["StoreResourceIdentifier"] = None,
        line_items: typing.Optional[typing.List["LineItemImportDraft"]] = None,
        custom_line_items: typing.Optional[
            typing.List["CustomLineItemImportDraft"]
        ] = None,
        total_price: "Money",
        taxed_price: typing.Optional["TaxedPriceDraft"] = None,
        tax_rounding_mode: typing.Optional["RoundingMode"] = None,
        tax_calculation_mode: typing.Optional["TaxCalculationMode"] = None,
        inventory_mode: typing.Optional["InventoryMode"] = None,
        billing_address: typing.Optional["BaseAddress"] = None,
        shipping_address: typing.Optional["BaseAddress"] = None,
        item_shipping_addresses: typing.Optional[typing.List["BaseAddress"]] = None,
        shipping_info: typing.Optional["ShippingInfoImportDraft"] = None,
        payment_info: typing.Optional["PaymentInfo"] = None,
        payment_state: typing.Optional["PaymentState"] = None,
        shipment_state: typing.Optional["ShipmentState"] = None,
        order_state: typing.Optional["OrderState"] = None,
        state: typing.Optional["StateReference"] = None,
        country: typing.Optional[str] = None,
        origin: typing.Optional["CartOrigin"] = None,
        completed_at: typing.Optional[datetime.datetime] = None,
        custom: typing.Optional["CustomFieldsDraft"] = None
    ):
        self.order_number = order_number
        self.purchase_order_number = purchase_order_number
        self.customer_id = customer_id
        self.customer_email = customer_email
        self.customer_group = customer_group
        self.business_unit = business_unit
        self.store = store
        self.line_items = line_items
        self.custom_line_items = custom_line_items
        self.total_price = total_price
        self.taxed_price = taxed_price
        self.tax_rounding_mode = tax_rounding_mode
        self.tax_calculation_mode = tax_calculation_mode
        self.inventory_mode = inventory_mode
        self.billing_address = billing_address
        self.shipping_address = shipping_address
        self.item_shipping_addresses = item_shipping_addresses
        self.shipping_info = shipping_info
        self.payment_info = payment_info
        self.payment_state = payment_state
        self.shipment_state = shipment_state
        self.order_state = order_state
        self.state = state
        self.country = country
        self.origin = origin
        self.completed_at = completed_at
        self.custom = custom

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "OrderImportDraft":
        from ._schemas.order import OrderImportDraftSchema

        return OrderImportDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderImportDraftSchema

        return OrderImportDraftSchema().dump(self)


class OrderPagedQueryResponse(_BaseType):
    """[PagedQueryResult](/../api/general-concepts#pagedqueryresult) with `results` containing an array of [Order](ctp:api:type:Order)."""

    #: Number of [results requested](/../api/general-concepts#limit).
    limit: int
    #: Number of [elements skipped](/../api/general-concepts#offset).
    offset: int
    #: Actual number of results returned.
    count: int
    #: Total number of results matching the query.
    #: This number is an estimation that is not [strongly consistent](/../api/general-concepts#strong-consistency).
    #: This field is returned by default.
    #: For improved performance, calculating this field can be deactivated by using the query parameter `withTotal=false`.
    #: When the results are filtered with a [Query Predicate](ctp:api:type:QueryPredicate), `total` is subject to a [limit](/../api/limits#queries).
    total: typing.Optional[int]
    #: [Orders](ctp:api:type:Order) matching the query.
    results: typing.List["Order"]

    def __init__(
        self,
        *,
        limit: int,
        offset: int,
        count: int,
        total: typing.Optional[int] = None,
        results: typing.List["Order"]
    ):
        self.limit = limit
        self.offset = offset
        self.count = count
        self.total = total
        self.results = results

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderPagedQueryResponse":
        from ._schemas.order import OrderPagedQueryResponseSchema

        return OrderPagedQueryResponseSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderPagedQueryResponseSchema

        return OrderPagedQueryResponseSchema().dump(self)


class OrderReference(Reference):
    """[Reference](ctp:api:type:Reference) to an [Order](ctp:api:type:Order)."""

    #: Contains the representation of the expanded Order. Only present in responses to requests with [Reference Expansion](/../api/general-concepts#reference-expansion) for Orders.
    obj: typing.Optional["Order"]

    def __init__(self, *, id: str, obj: typing.Optional["Order"] = None):
        self.obj = obj

        super().__init__(id=id, type_id=ReferenceTypeId.ORDER)

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "OrderReference":
        from ._schemas.order import OrderReferenceSchema

        return OrderReferenceSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderReferenceSchema

        return OrderReferenceSchema().dump(self)


class OrderSearchQuery(typing.Dict[str, typing.Any]):
    pass


class OrderSearchCompoundExpression(typing.Dict[str, typing.Any]):
    pass


class OrderSearchAndExpression(OrderSearchCompoundExpression):
    and_: typing.List["OrderSearchQuery"]

    def __init__(self, *, and_: typing.List["OrderSearchQuery"]):
        self.and_ = and_

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderSearchAndExpression":
        from ._schemas.order import OrderSearchAndExpressionSchema

        return OrderSearchAndExpressionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderSearchAndExpressionSchema

        return OrderSearchAndExpressionSchema().dump(self)


class OrderSearchFilterExpression(OrderSearchCompoundExpression):
    filter: typing.List["OrderSearchQueryExpression"]

    def __init__(self, *, filter: typing.List["OrderSearchQueryExpression"]):
        self.filter = filter

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderSearchFilterExpression":
        from ._schemas.order import OrderSearchFilterExpressionSchema

        return OrderSearchFilterExpressionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderSearchFilterExpressionSchema

        return OrderSearchFilterExpressionSchema().dump(self)


class OrderSearchNotExpression(OrderSearchCompoundExpression):
    not_: typing.List["OrderSearchQuery"]

    def __init__(self, *, not_: typing.List["OrderSearchQuery"]):
        self.not_ = not_

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderSearchNotExpression":
        from ._schemas.order import OrderSearchNotExpressionSchema

        return OrderSearchNotExpressionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderSearchNotExpressionSchema

        return OrderSearchNotExpressionSchema().dump(self)


class OrderSearchOrExpression(OrderSearchCompoundExpression):
    or_: typing.List["OrderSearchQuery"]

    def __init__(self, *, or_: typing.List["OrderSearchQuery"]):
        self.or_ = or_

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderSearchOrExpression":
        from ._schemas.order import OrderSearchOrExpressionSchema

        return OrderSearchOrExpressionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderSearchOrExpressionSchema

        return OrderSearchOrExpressionSchema().dump(self)


class OrderSearchQueryExpression(typing.Dict[str, typing.Any]):
    pass


class OrderSearchDateRangeExpression(OrderSearchQueryExpression):
    range: "OrderSearchDateRangeValue"

    def __init__(self, *, range: "OrderSearchDateRangeValue"):
        self.range = range

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderSearchDateRangeExpression":
        from ._schemas.order import OrderSearchDateRangeExpressionSchema

        return OrderSearchDateRangeExpressionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderSearchDateRangeExpressionSchema

        return OrderSearchDateRangeExpressionSchema().dump(self)


class OrderSearchExactExpression(OrderSearchQueryExpression):
    exact: "OrderSearchAnyValue"

    def __init__(self, *, exact: "OrderSearchAnyValue"):
        self.exact = exact

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderSearchExactExpression":
        from ._schemas.order import OrderSearchExactExpressionSchema

        return OrderSearchExactExpressionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderSearchExactExpressionSchema

        return OrderSearchExactExpressionSchema().dump(self)


class OrderSearchExistsExpression(OrderSearchQueryExpression):
    exists: "OrderSearchQueryExpressionValue"

    def __init__(self, *, exists: "OrderSearchQueryExpressionValue"):
        self.exists = exists

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderSearchExistsExpression":
        from ._schemas.order import OrderSearchExistsExpressionSchema

        return OrderSearchExistsExpressionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderSearchExistsExpressionSchema

        return OrderSearchExistsExpressionSchema().dump(self)


class OrderSearchFullTextExpression(OrderSearchQueryExpression):
    full_text: "OrderSearchFullTextValue"

    def __init__(self, *, full_text: "OrderSearchFullTextValue"):
        self.full_text = full_text

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderSearchFullTextExpression":
        from ._schemas.order import OrderSearchFullTextExpressionSchema

        return OrderSearchFullTextExpressionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderSearchFullTextExpressionSchema

        return OrderSearchFullTextExpressionSchema().dump(self)


class OrderSearchLongRangeExpression(OrderSearchQueryExpression):
    range: "OrderSearchLongRangeValue"

    def __init__(self, *, range: "OrderSearchLongRangeValue"):
        self.range = range

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderSearchLongRangeExpression":
        from ._schemas.order import OrderSearchLongRangeExpressionSchema

        return OrderSearchLongRangeExpressionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderSearchLongRangeExpressionSchema

        return OrderSearchLongRangeExpressionSchema().dump(self)


class OrderSearchNumberRangeExpression(OrderSearchQueryExpression):
    range: "OrderSearchNumberRangeValue"

    def __init__(self, *, range: "OrderSearchNumberRangeValue"):
        self.range = range

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderSearchNumberRangeExpression":
        from ._schemas.order import OrderSearchNumberRangeExpressionSchema

        return OrderSearchNumberRangeExpressionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderSearchNumberRangeExpressionSchema

        return OrderSearchNumberRangeExpressionSchema().dump(self)


class OrderSearchPrefixExpression(OrderSearchQueryExpression):
    prefix: "OrderSearchStringValue"

    def __init__(self, *, prefix: "OrderSearchStringValue"):
        self.prefix = prefix

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderSearchPrefixExpression":
        from ._schemas.order import OrderSearchPrefixExpressionSchema

        return OrderSearchPrefixExpressionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderSearchPrefixExpressionSchema

        return OrderSearchPrefixExpressionSchema().dump(self)


class OrderSearchWildCardExpression(OrderSearchQueryExpression):
    wildcard: "OrderSearchStringValue"

    def __init__(self, *, wildcard: "OrderSearchStringValue"):
        self.wildcard = wildcard

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderSearchWildCardExpression":
        from ._schemas.order import OrderSearchWildCardExpressionSchema

        return OrderSearchWildCardExpressionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderSearchWildCardExpressionSchema

        return OrderSearchWildCardExpressionSchema().dump(self)


class OrderSearchRequest(_BaseType):
    #: The Order search query.
    query: "OrderSearchQuery"
    #: Controls how results to your query are sorted. If not provided, the results are sorted by relevance in descending order.
    sort: typing.Optional[typing.List["OrderSearchSorting"]]
    #: The maximum number of search results to be returned.
    limit: typing.Optional[int]
    #: The number of search results to be skipped in the response for pagination.
    offset: typing.Optional[int]

    def __init__(
        self,
        *,
        query: "OrderSearchQuery",
        sort: typing.Optional[typing.List["OrderSearchSorting"]] = None,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None
    ):
        self.query = query
        self.sort = sort
        self.limit = limit
        self.offset = offset

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "OrderSearchRequest":
        from ._schemas.order import OrderSearchRequestSchema

        return OrderSearchRequestSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderSearchRequestSchema

        return OrderSearchRequestSchema().dump(self)


class OrderSearchSorting(_BaseType):
    field: str
    language: typing.Optional[str]
    order: typing.Optional["OrderSearchSortOrder"]
    mode: typing.Optional["OrderSearchSortMode"]
    filter: typing.Optional["OrderSearchQueryExpression"]

    def __init__(
        self,
        *,
        field: str,
        language: typing.Optional[str] = None,
        order: typing.Optional["OrderSearchSortOrder"] = None,
        mode: typing.Optional["OrderSearchSortMode"] = None,
        filter: typing.Optional["OrderSearchQueryExpression"] = None
    ):
        self.field = field
        self.language = language
        self.order = order
        self.mode = mode
        self.filter = filter

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "OrderSearchSorting":
        from ._schemas.order import OrderSearchSortingSchema

        return OrderSearchSortingSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderSearchSortingSchema

        return OrderSearchSortingSchema().dump(self)


class OrderState(enum.Enum):
    """Indicates the state of the Order."""

    OPEN = "Open"
    CONFIRMED = "Confirmed"
    COMPLETE = "Complete"
    CANCELLED = "Cancelled"


class OrderUpdate(_BaseType):
    #: Expected version of the Order on which the changes should be applied.
    #: If the expected version does not match the actual version, a [ConcurrentModification](ctp:api:type:ConcurrentModificationError) error will be returned.
    version: int
    #: Update actions to be performed on the Order.
    actions: typing.List["OrderUpdateAction"]

    def __init__(self, *, version: int, actions: typing.List["OrderUpdateAction"]):
        self.version = version
        self.actions = actions

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "OrderUpdate":
        from ._schemas.order import OrderUpdateSchema

        return OrderUpdateSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderUpdateSchema

        return OrderUpdateSchema().dump(self)


class OrderUpdateAction(_BaseType):
    action: str

    def __init__(self, *, action: str):
        self.action = action

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "OrderUpdateAction":
        if data["action"] == "addDelivery":
            from ._schemas.order import OrderAddDeliveryActionSchema

            return OrderAddDeliveryActionSchema().load(data)
        if data["action"] == "addItemShippingAddress":
            from ._schemas.order import OrderAddItemShippingAddressActionSchema

            return OrderAddItemShippingAddressActionSchema().load(data)
        if data["action"] == "addParcelToDelivery":
            from ._schemas.order import OrderAddParcelToDeliveryActionSchema

            return OrderAddParcelToDeliveryActionSchema().load(data)
        if data["action"] == "addPayment":
            from ._schemas.order import OrderAddPaymentActionSchema

            return OrderAddPaymentActionSchema().load(data)
        if data["action"] == "addReturnInfo":
            from ._schemas.order import OrderAddReturnInfoActionSchema

            return OrderAddReturnInfoActionSchema().load(data)
        if data["action"] == "changeOrderState":
            from ._schemas.order import OrderChangeOrderStateActionSchema

            return OrderChangeOrderStateActionSchema().load(data)
        if data["action"] == "changePaymentState":
            from ._schemas.order import OrderChangePaymentStateActionSchema

            return OrderChangePaymentStateActionSchema().load(data)
        if data["action"] == "changeShipmentState":
            from ._schemas.order import OrderChangeShipmentStateActionSchema

            return OrderChangeShipmentStateActionSchema().load(data)
        if data["action"] == "importCustomLineItemState":
            from ._schemas.order import OrderImportCustomLineItemStateActionSchema

            return OrderImportCustomLineItemStateActionSchema().load(data)
        if data["action"] == "importLineItemState":
            from ._schemas.order import OrderImportLineItemStateActionSchema

            return OrderImportLineItemStateActionSchema().load(data)
        if data["action"] == "removeDelivery":
            from ._schemas.order import OrderRemoveDeliveryActionSchema

            return OrderRemoveDeliveryActionSchema().load(data)
        if data["action"] == "removeItemShippingAddress":
            from ._schemas.order import OrderRemoveItemShippingAddressActionSchema

            return OrderRemoveItemShippingAddressActionSchema().load(data)
        if data["action"] == "removeParcelFromDelivery":
            from ._schemas.order import OrderRemoveParcelFromDeliveryActionSchema

            return OrderRemoveParcelFromDeliveryActionSchema().load(data)
        if data["action"] == "removePayment":
            from ._schemas.order import OrderRemovePaymentActionSchema

            return OrderRemovePaymentActionSchema().load(data)
        if data["action"] == "setBillingAddress":
            from ._schemas.order import OrderSetBillingAddressActionSchema

            return OrderSetBillingAddressActionSchema().load(data)
        if data["action"] == "setBillingAddressCustomField":
            from ._schemas.order import OrderSetBillingAddressCustomFieldActionSchema

            return OrderSetBillingAddressCustomFieldActionSchema().load(data)
        if data["action"] == "setBillingAddressCustomType":
            from ._schemas.order import OrderSetBillingAddressCustomTypeActionSchema

            return OrderSetBillingAddressCustomTypeActionSchema().load(data)
        if data["action"] == "setCustomField":
            from ._schemas.order import OrderSetCustomFieldActionSchema

            return OrderSetCustomFieldActionSchema().load(data)
        if data["action"] == "setCustomLineItemCustomField":
            from ._schemas.order import OrderSetCustomLineItemCustomFieldActionSchema

            return OrderSetCustomLineItemCustomFieldActionSchema().load(data)
        if data["action"] == "setCustomLineItemCustomType":
            from ._schemas.order import OrderSetCustomLineItemCustomTypeActionSchema

            return OrderSetCustomLineItemCustomTypeActionSchema().load(data)
        if data["action"] == "setCustomLineItemShippingDetails":
            from ._schemas.order import (
                OrderSetCustomLineItemShippingDetailsActionSchema,
            )

            return OrderSetCustomLineItemShippingDetailsActionSchema().load(data)
        if data["action"] == "setCustomType":
            from ._schemas.order import OrderSetCustomTypeActionSchema

            return OrderSetCustomTypeActionSchema().load(data)
        if data["action"] == "setCustomerEmail":
            from ._schemas.order import OrderSetCustomerEmailActionSchema

            return OrderSetCustomerEmailActionSchema().load(data)
        if data["action"] == "setCustomerId":
            from ._schemas.order import OrderSetCustomerIdActionSchema

            return OrderSetCustomerIdActionSchema().load(data)
        if data["action"] == "setDeliveryAddress":
            from ._schemas.order import OrderSetDeliveryAddressActionSchema

            return OrderSetDeliveryAddressActionSchema().load(data)
        if data["action"] == "setDeliveryAddressCustomField":
            from ._schemas.order import OrderSetDeliveryAddressCustomFieldActionSchema

            return OrderSetDeliveryAddressCustomFieldActionSchema().load(data)
        if data["action"] == "setDeliveryAddressCustomType":
            from ._schemas.order import OrderSetDeliveryAddressCustomTypeActionSchema

            return OrderSetDeliveryAddressCustomTypeActionSchema().load(data)
        if data["action"] == "setDeliveryCustomField":
            from ._schemas.order import OrderSetDeliveryCustomFieldActionSchema

            return OrderSetDeliveryCustomFieldActionSchema().load(data)
        if data["action"] == "setDeliveryCustomType":
            from ._schemas.order import OrderSetDeliveryCustomTypeActionSchema

            return OrderSetDeliveryCustomTypeActionSchema().load(data)
        if data["action"] == "setDeliveryItems":
            from ._schemas.order import OrderSetDeliveryItemsActionSchema

            return OrderSetDeliveryItemsActionSchema().load(data)
        if data["action"] == "setItemShippingAddressCustomField":
            from ._schemas.order import (
                OrderSetItemShippingAddressCustomFieldActionSchema,
            )

            return OrderSetItemShippingAddressCustomFieldActionSchema().load(data)
        if data["action"] == "setItemShippingAddressCustomType":
            from ._schemas.order import (
                OrderSetItemShippingAddressCustomTypeActionSchema,
            )

            return OrderSetItemShippingAddressCustomTypeActionSchema().load(data)
        if data["action"] == "setLineItemCustomField":
            from ._schemas.order import OrderSetLineItemCustomFieldActionSchema

            return OrderSetLineItemCustomFieldActionSchema().load(data)
        if data["action"] == "setLineItemCustomType":
            from ._schemas.order import OrderSetLineItemCustomTypeActionSchema

            return OrderSetLineItemCustomTypeActionSchema().load(data)
        if data["action"] == "setLineItemShippingDetails":
            from ._schemas.order import OrderSetLineItemShippingDetailsActionSchema

            return OrderSetLineItemShippingDetailsActionSchema().load(data)
        if data["action"] == "setLocale":
            from ._schemas.order import OrderSetLocaleActionSchema

            return OrderSetLocaleActionSchema().load(data)
        if data["action"] == "setOrderNumber":
            from ._schemas.order import OrderSetOrderNumberActionSchema

            return OrderSetOrderNumberActionSchema().load(data)
        if data["action"] == "setParcelCustomField":
            from ._schemas.order import OrderSetParcelCustomFieldActionSchema

            return OrderSetParcelCustomFieldActionSchema().load(data)
        if data["action"] == "setParcelCustomType":
            from ._schemas.order import OrderSetParcelCustomTypeActionSchema

            return OrderSetParcelCustomTypeActionSchema().load(data)
        if data["action"] == "setParcelItems":
            from ._schemas.order import OrderSetParcelItemsActionSchema

            return OrderSetParcelItemsActionSchema().load(data)
        if data["action"] == "setParcelMeasurements":
            from ._schemas.order import OrderSetParcelMeasurementsActionSchema

            return OrderSetParcelMeasurementsActionSchema().load(data)
        if data["action"] == "setParcelTrackingData":
            from ._schemas.order import OrderSetParcelTrackingDataActionSchema

            return OrderSetParcelTrackingDataActionSchema().load(data)
        if data["action"] == "setPurchaseOrderNumber":
            from ._schemas.order import OrderSetPurchaseOrderNumberActionSchema

            return OrderSetPurchaseOrderNumberActionSchema().load(data)
        if data["action"] == "setReturnInfo":
            from ._schemas.order import OrderSetReturnInfoActionSchema

            return OrderSetReturnInfoActionSchema().load(data)
        if data["action"] == "setReturnItemCustomField":
            from ._schemas.order import OrderSetReturnItemCustomFieldActionSchema

            return OrderSetReturnItemCustomFieldActionSchema().load(data)
        if data["action"] == "setReturnItemCustomType":
            from ._schemas.order import OrderSetReturnItemCustomTypeActionSchema

            return OrderSetReturnItemCustomTypeActionSchema().load(data)
        if data["action"] == "setReturnPaymentState":
            from ._schemas.order import OrderSetReturnPaymentStateActionSchema

            return OrderSetReturnPaymentStateActionSchema().load(data)
        if data["action"] == "setReturnShipmentState":
            from ._schemas.order import OrderSetReturnShipmentStateActionSchema

            return OrderSetReturnShipmentStateActionSchema().load(data)
        if data["action"] == "setShippingAddress":
            from ._schemas.order import OrderSetShippingAddressActionSchema

            return OrderSetShippingAddressActionSchema().load(data)
        if data["action"] == "setShippingAddressCustomField":
            from ._schemas.order import OrderSetShippingAddressCustomFieldActionSchema

            return OrderSetShippingAddressCustomFieldActionSchema().load(data)
        if data["action"] == "setShippingAddressCustomType":
            from ._schemas.order import OrderSetShippingAddressCustomTypeActionSchema

            return OrderSetShippingAddressCustomTypeActionSchema().load(data)
        if data["action"] == "setStore":
            from ._schemas.order import OrderSetStoreActionSchema

            return OrderSetStoreActionSchema().load(data)
        if data["action"] == "transitionCustomLineItemState":
            from ._schemas.order import OrderTransitionCustomLineItemStateActionSchema

            return OrderTransitionCustomLineItemStateActionSchema().load(data)
        if data["action"] == "transitionLineItemState":
            from ._schemas.order import OrderTransitionLineItemStateActionSchema

            return OrderTransitionLineItemStateActionSchema().load(data)
        if data["action"] == "transitionState":
            from ._schemas.order import OrderTransitionStateActionSchema

            return OrderTransitionStateActionSchema().load(data)
        if data["action"] == "updateItemShippingAddress":
            from ._schemas.order import OrderUpdateItemShippingAddressActionSchema

            return OrderUpdateItemShippingAddressActionSchema().load(data)
        if data["action"] == "updateSyncInfo":
            from ._schemas.order import OrderUpdateSyncInfoActionSchema

            return OrderUpdateSyncInfoActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderUpdateActionSchema

        return OrderUpdateActionSchema().dump(self)


class Parcel(_BaseType):
    """Information regarding the appearance, content, and shipment of a Parcel."""

    #: Unique identifier of the Parcel.
    id: str
    #: User-defined unique identifier of the Parcel.
    key: typing.Optional[str]
    #: Date and time (UTC) the Parcel was created.
    created_at: datetime.datetime
    #: Information about the dimensions of the Parcel.
    measurements: typing.Optional["ParcelMeasurements"]
    #: Shipment tracking information of the Parcel.
    tracking_data: typing.Optional["TrackingData"]
    #: Line Items or Custom Line Items delivered in this Parcel.
    items: typing.Optional[typing.List["DeliveryItem"]]
    #: Custom Fields of the Parcel.
    custom: typing.Optional["CustomFields"]

    def __init__(
        self,
        *,
        id: str,
        key: typing.Optional[str] = None,
        created_at: datetime.datetime,
        measurements: typing.Optional["ParcelMeasurements"] = None,
        tracking_data: typing.Optional["TrackingData"] = None,
        items: typing.Optional[typing.List["DeliveryItem"]] = None,
        custom: typing.Optional["CustomFields"] = None
    ):
        self.id = id
        self.key = key
        self.created_at = created_at
        self.measurements = measurements
        self.tracking_data = tracking_data
        self.items = items
        self.custom = custom

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "Parcel":
        from ._schemas.order import ParcelSchema

        return ParcelSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import ParcelSchema

        return ParcelSchema().dump(self)


class ParcelDraft(_BaseType):
    #: User-defined unique identifier of the Parcel.
    key: typing.Optional[str]
    #: Information about the dimensions for the Parcel.
    measurements: typing.Optional["ParcelMeasurements"]
    #: Shipment tracking information for the Parcel.
    tracking_data: typing.Optional["TrackingData"]
    #: Line Items or Custom Line Items delivered in this Parcel.
    items: typing.Optional[typing.List["DeliveryItem"]]
    #: Custom Fields for the Parcel.
    custom: typing.Optional["CustomFieldsDraft"]

    def __init__(
        self,
        *,
        key: typing.Optional[str] = None,
        measurements: typing.Optional["ParcelMeasurements"] = None,
        tracking_data: typing.Optional["TrackingData"] = None,
        items: typing.Optional[typing.List["DeliveryItem"]] = None,
        custom: typing.Optional["CustomFieldsDraft"] = None
    ):
        self.key = key
        self.measurements = measurements
        self.tracking_data = tracking_data
        self.items = items
        self.custom = custom

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ParcelDraft":
        from ._schemas.order import ParcelDraftSchema

        return ParcelDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import ParcelDraftSchema

        return ParcelDraftSchema().dump(self)


class ParcelMeasurements(_BaseType):
    #: Height of the Parcel.
    height_in_millimeter: typing.Optional[int]
    #: Length of the Parcel.
    length_in_millimeter: typing.Optional[int]
    #: Width of the Parcel.
    width_in_millimeter: typing.Optional[int]
    #: Weight of the Parcel.
    weight_in_gram: typing.Optional[int]

    def __init__(
        self,
        *,
        height_in_millimeter: typing.Optional[int] = None,
        length_in_millimeter: typing.Optional[int] = None,
        width_in_millimeter: typing.Optional[int] = None,
        weight_in_gram: typing.Optional[int] = None
    ):
        self.height_in_millimeter = height_in_millimeter
        self.length_in_millimeter = length_in_millimeter
        self.width_in_millimeter = width_in_millimeter
        self.weight_in_gram = weight_in_gram

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ParcelMeasurements":
        from ._schemas.order import ParcelMeasurementsSchema

        return ParcelMeasurementsSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import ParcelMeasurementsSchema

        return ParcelMeasurementsSchema().dump(self)


class PaymentInfo(_BaseType):
    #: [References](ctp:api:type:Reference) to the Payments associated with the Order.
    payments: typing.List["PaymentReference"]

    def __init__(self, *, payments: typing.List["PaymentReference"]):
        self.payments = payments

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "PaymentInfo":
        from ._schemas.order import PaymentInfoSchema

        return PaymentInfoSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import PaymentInfoSchema

        return PaymentInfoSchema().dump(self)


class PaymentState(enum.Enum):
    """Indicates the payment status for the Order."""

    BALANCE_DUE = "BalanceDue"
    FAILED = "Failed"
    PENDING = "Pending"
    CREDIT_OWED = "CreditOwed"
    PAID = "Paid"


class ProductVariantImportDraft(_BaseType):
    """Contains the Product Variant to be used in the [LineItemImportDraft](ctp:api:type:LineItemImportDraft)."""

    #: The `id` of the [ProductVariant](ctp:api:type:ProductVariant). Required if you do not set a value for `sku`.
    #: If set, you must specify a `productId` in the [LineItemImportDraft](ctp:api:type:LineItemImportDraft) also.
    id: typing.Optional[int]
    #: The `sku` of the [ProductVariant](ctp:api:type:ProductVariant). Required if you do not set a value for `id`.
    sku: typing.Optional[str]
    #: The [Prices](ctp:api:type:Price) of the Product Variant if you want to override the `prices` property in the referenced [ProductVariant](ctp:api:type:ProductVariant).
    #: If not set, the `prices` from the referenced [ProductVariant](ctp:api:type:ProductVariant) are used in the resulting Order.
    #: If set, each Price must have its unique price scope (same `value.currencyCode`, `country`, `customerGroup`, `channel`, `validFrom` and `validUntil`).
    prices: typing.Optional[typing.List["PriceDraft"]]
    #: The [Attributes](ctp:api:type:Attribute) of the Product Variant if you want to override the `attributes` property in the referenced [ProductVariant](ctp:api:type:ProductVariant).
    #: If not set, the `attributes` from the referenced [ProductVariant](ctp:api:type:ProductVariant) are copied to the resulting Order.
    attributes: typing.Optional[typing.List["Attribute"]]
    #: The [Images](ctp:api:type:Image) of the Product Variant if you want to override the `images` property in the referenced [ProductVariant](ctp:api:type:ProductVariant).
    #: If not set, the `images` from the referenced [ProductVariant](ctp:api:type:ProductVariant) are copied to the resulting Order.
    images: typing.Optional[typing.List["Image"]]

    def __init__(
        self,
        *,
        id: typing.Optional[int] = None,
        sku: typing.Optional[str] = None,
        prices: typing.Optional[typing.List["PriceDraft"]] = None,
        attributes: typing.Optional[typing.List["Attribute"]] = None,
        images: typing.Optional[typing.List["Image"]] = None
    ):
        self.id = id
        self.sku = sku
        self.prices = prices
        self.attributes = attributes
        self.images = images

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductVariantImportDraft":
        from ._schemas.order import ProductVariantImportDraftSchema

        return ProductVariantImportDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import ProductVariantImportDraftSchema

        return ProductVariantImportDraftSchema().dump(self)


class ReturnInfo(_BaseType):
    """Stores information about returns connected to an Order."""

    #: Information on the Line Items or Custom Line Items returned.
    items: typing.List["ReturnItem"]
    #: User-defined identifier to track the return.
    return_tracking_id: typing.Optional[str]
    #: Date and time (UTC) the return is initiated.
    return_date: typing.Optional[datetime.datetime]

    def __init__(
        self,
        *,
        items: typing.List["ReturnItem"],
        return_tracking_id: typing.Optional[str] = None,
        return_date: typing.Optional[datetime.datetime] = None
    ):
        self.items = items
        self.return_tracking_id = return_tracking_id
        self.return_date = return_date

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ReturnInfo":
        from ._schemas.order import ReturnInfoSchema

        return ReturnInfoSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import ReturnInfoSchema

        return ReturnInfoSchema().dump(self)


class ReturnInfoDraft(_BaseType):
    #: Information on the Line Items or Custom Line Items returned.
    items: typing.List["ReturnItemDraft"]
    #: User-defined identifier for tracking the return.
    return_tracking_id: typing.Optional[str]
    #: Date and time (UTC) the return is initiated.
    return_date: typing.Optional[datetime.datetime]

    def __init__(
        self,
        *,
        items: typing.List["ReturnItemDraft"],
        return_tracking_id: typing.Optional[str] = None,
        return_date: typing.Optional[datetime.datetime] = None
    ):
        self.items = items
        self.return_tracking_id = return_tracking_id
        self.return_date = return_date

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ReturnInfoDraft":
        from ._schemas.order import ReturnInfoDraftSchema

        return ReturnInfoDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import ReturnInfoDraftSchema

        return ReturnInfoDraftSchema().dump(self)


class ReturnItem(_BaseType):
    #: Unique identifier of the Return Item.
    id: str
    #: User-defined unique identifier of the Return Item.
    key: typing.Optional[str]
    #: Number of Line Items or Custom Line Items returned.
    quantity: int
    type: str
    #: User-defined description for the return.
    comment: typing.Optional[str]
    #: Shipment status of the Return Item.
    shipment_state: "ReturnShipmentState"
    #: Payment status of the Return Item:
    #:
    #: - `NonRefundable`, for items in the `Advised` [ReturnShipmentState](ctp:api:type:ReturnShipmentState)
    #: - `Initial`, for items in the `Returned` [ReturnShipmentState](ctp:api:type:ReturnShipmentState)
    payment_state: "ReturnPaymentState"
    #: Custom Fields of the Return Item.
    custom: typing.Optional["CustomFields"]
    #: Date and time (UTC) the Return Item was last updated.
    last_modified_at: datetime.datetime
    #: Date and time (UTC) the Return Item was intitially created.
    created_at: datetime.datetime

    def __init__(
        self,
        *,
        id: str,
        key: typing.Optional[str] = None,
        quantity: int,
        type: str,
        comment: typing.Optional[str] = None,
        shipment_state: "ReturnShipmentState",
        payment_state: "ReturnPaymentState",
        custom: typing.Optional["CustomFields"] = None,
        last_modified_at: datetime.datetime,
        created_at: datetime.datetime
    ):
        self.id = id
        self.key = key
        self.quantity = quantity
        self.type = type
        self.comment = comment
        self.shipment_state = shipment_state
        self.payment_state = payment_state
        self.custom = custom
        self.last_modified_at = last_modified_at
        self.created_at = created_at

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ReturnItem":
        if data["type"] == "CustomLineItemReturnItem":
            from ._schemas.order import CustomLineItemReturnItemSchema

            return CustomLineItemReturnItemSchema().load(data)
        if data["type"] == "LineItemReturnItem":
            from ._schemas.order import LineItemReturnItemSchema

            return LineItemReturnItemSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import ReturnItemSchema

        return ReturnItemSchema().dump(self)


class CustomLineItemReturnItem(ReturnItem):
    #: `id` of the returned [CustomLineItem](ctp:api:type:CustomLineItem).
    custom_line_item_id: str

    def __init__(
        self,
        *,
        id: str,
        key: typing.Optional[str] = None,
        quantity: int,
        comment: typing.Optional[str] = None,
        shipment_state: "ReturnShipmentState",
        payment_state: "ReturnPaymentState",
        custom: typing.Optional["CustomFields"] = None,
        last_modified_at: datetime.datetime,
        created_at: datetime.datetime,
        custom_line_item_id: str
    ):
        self.custom_line_item_id = custom_line_item_id

        super().__init__(
            id=id,
            key=key,
            quantity=quantity,
            comment=comment,
            shipment_state=shipment_state,
            payment_state=payment_state,
            custom=custom,
            last_modified_at=last_modified_at,
            created_at=created_at,
            type="CustomLineItemReturnItem",
        )

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CustomLineItemReturnItem":
        from ._schemas.order import CustomLineItemReturnItemSchema

        return CustomLineItemReturnItemSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import CustomLineItemReturnItemSchema

        return CustomLineItemReturnItemSchema().dump(self)


class LineItemReturnItem(ReturnItem):
    #: `id` of the returned [LineItem](ctp:api:type:LineItem).
    line_item_id: str

    def __init__(
        self,
        *,
        id: str,
        key: typing.Optional[str] = None,
        quantity: int,
        comment: typing.Optional[str] = None,
        shipment_state: "ReturnShipmentState",
        payment_state: "ReturnPaymentState",
        custom: typing.Optional["CustomFields"] = None,
        last_modified_at: datetime.datetime,
        created_at: datetime.datetime,
        line_item_id: str
    ):
        self.line_item_id = line_item_id

        super().__init__(
            id=id,
            key=key,
            quantity=quantity,
            comment=comment,
            shipment_state=shipment_state,
            payment_state=payment_state,
            custom=custom,
            last_modified_at=last_modified_at,
            created_at=created_at,
            type="LineItemReturnItem",
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "LineItemReturnItem":
        from ._schemas.order import LineItemReturnItemSchema

        return LineItemReturnItemSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import LineItemReturnItemSchema

        return LineItemReturnItemSchema().dump(self)


class ReturnItemDraft(_BaseType):
    #: User-defined unique identifier of the Return Item.
    key: typing.Optional[str]
    #: Number of Line Items or Custom Line Items to return.
    quantity: int
    #: `id` of the [LineItem](ctp:api:type:LineItem) to return.
    #:
    #:  Required if Line Items are returned, to create a [LineItemReturnItem](ctp:api:type:LineItemReturnItem).
    line_item_id: typing.Optional[str]
    #: `id` of the [CustomLineItem](ctp:api:type:CustomLineItem) to return.
    #:
    #:  Required if Custom Line Items are returned, to create a [CustomLineItemReturnItem](ctp:api:type:CustomLineItemReturnItem).
    custom_line_item_id: typing.Optional[str]
    #: User-defined description for the return.
    comment: typing.Optional[str]
    #: Shipment status of the item to be returned.
    #: Can either be `Advised` or `Returned` only.
    shipment_state: "ReturnShipmentState"
    #: Custom Fields for the Return Item.
    custom: typing.Optional["CustomFieldsDraft"]

    def __init__(
        self,
        *,
        key: typing.Optional[str] = None,
        quantity: int,
        line_item_id: typing.Optional[str] = None,
        custom_line_item_id: typing.Optional[str] = None,
        comment: typing.Optional[str] = None,
        shipment_state: "ReturnShipmentState",
        custom: typing.Optional["CustomFieldsDraft"] = None
    ):
        self.key = key
        self.quantity = quantity
        self.line_item_id = line_item_id
        self.custom_line_item_id = custom_line_item_id
        self.comment = comment
        self.shipment_state = shipment_state
        self.custom = custom

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ReturnItemDraft":
        from ._schemas.order import ReturnItemDraftSchema

        return ReturnItemDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import ReturnItemDraftSchema

        return ReturnItemDraftSchema().dump(self)


class ReturnPaymentState(enum.Enum):
    NON_REFUNDABLE = "NonRefundable"
    INITIAL = "Initial"
    REFUNDED = "Refunded"
    NOT_REFUNDED = "NotRefunded"


class ReturnShipmentState(enum.Enum):
    ADVISED = "Advised"
    RETURNED = "Returned"
    BACK_IN_STOCK = "BackInStock"
    UNUSABLE = "Unusable"


class ShipmentState(enum.Enum):
    """Indicates the shipment status of the Order."""

    SHIPPED = "Shipped"
    DELIVERED = "Delivered"
    READY = "Ready"
    PENDING = "Pending"
    DELAYED = "Delayed"
    PARTIAL = "Partial"
    BACKORDER = "Backorder"


class ShippingInfoImportDraft(_BaseType):
    """Becomes the `shippingInfo` of the imported Order."""

    #: Name of the Shipping Method.
    shipping_method_name: str
    #: The base price for the Shipping Method.
    price: "Money"
    #: Shipping rate information for the Order.
    shipping_rate: "ShippingRateDraft"
    #: Include a Tax Rate for the Shipping Method.
    tax_rate: typing.Optional["TaxRate"]
    #: Include a value to associate a Tax Category with the shipping information.
    tax_category: typing.Optional["TaxCategoryResourceIdentifier"]
    #: Include a value to associate a Shipping Method with the Order.
    shipping_method: typing.Optional["ShippingMethodResourceIdentifier"]
    #: Information on how items are to be delivered to customers.
    deliveries: typing.Optional[typing.List["DeliveryDraft"]]
    #: Discounted Price of the Shipping Method.
    discounted_price: typing.Optional["DiscountedLineItemPriceDraft"]
    #: Indicates if the [ShippingMethod](ctp:api:type:ShippingMethod) referenced is allowed for the Order or not.
    shipping_method_state: typing.Optional["ShippingMethodState"]

    def __init__(
        self,
        *,
        shipping_method_name: str,
        price: "Money",
        shipping_rate: "ShippingRateDraft",
        tax_rate: typing.Optional["TaxRate"] = None,
        tax_category: typing.Optional["TaxCategoryResourceIdentifier"] = None,
        shipping_method: typing.Optional["ShippingMethodResourceIdentifier"] = None,
        deliveries: typing.Optional[typing.List["DeliveryDraft"]] = None,
        discounted_price: typing.Optional["DiscountedLineItemPriceDraft"] = None,
        shipping_method_state: typing.Optional["ShippingMethodState"] = None
    ):
        self.shipping_method_name = shipping_method_name
        self.price = price
        self.shipping_rate = shipping_rate
        self.tax_rate = tax_rate
        self.tax_category = tax_category
        self.shipping_method = shipping_method
        self.deliveries = deliveries
        self.discounted_price = discounted_price
        self.shipping_method_state = shipping_method_state

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ShippingInfoImportDraft":
        from ._schemas.order import ShippingInfoImportDraftSchema

        return ShippingInfoImportDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import ShippingInfoImportDraftSchema

        return ShippingInfoImportDraftSchema().dump(self)


class SyncInfo(_BaseType):
    """Contains synchronization activity information of the Order (like export or import)."""

    #: Connection to a synchronization destination.
    channel: "ChannelReference"
    #: Identifier of an external order instance, file, or other resource.
    external_id: typing.Optional[str]
    #: Date and time (UTC) the information was synced.
    synced_at: datetime.datetime

    def __init__(
        self,
        *,
        channel: "ChannelReference",
        external_id: typing.Optional[str] = None,
        synced_at: datetime.datetime
    ):
        self.channel = channel
        self.external_id = external_id
        self.synced_at = synced_at

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "SyncInfo":
        from ._schemas.order import SyncInfoSchema

        return SyncInfoSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import SyncInfoSchema

        return SyncInfoSchema().dump(self)


class TaxedItemPriceDraft(_BaseType):
    #: Draft type that stores amounts only in cent precision for the specified currency.
    total_net: "Money"
    #: Draft type that stores amounts only in cent precision for the specified currency.
    total_gross: "Money"

    def __init__(self, *, total_net: "Money", total_gross: "Money"):
        self.total_net = total_net
        self.total_gross = total_gross

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "TaxedItemPriceDraft":
        from ._schemas.order import TaxedItemPriceDraftSchema

        return TaxedItemPriceDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import TaxedItemPriceDraftSchema

        return TaxedItemPriceDraftSchema().dump(self)


class TrackingData(_BaseType):
    """Information that helps track a Parcel."""

    #: Identifier to track the Parcel.
    tracking_id: typing.Optional[str]
    #: Name of the carrier that delivers the Parcel.
    carrier: typing.Optional[str]
    #: Name of the provider that serves as facade to several carriers.
    provider: typing.Optional[str]
    #: Transaction identifier with the `provider`.
    provider_transaction: typing.Optional[str]
    #: - If `true`, the Parcel is being returned.
    #: - If `false`, the Parcel is being delivered to the customer.
    is_return: typing.Optional[bool]

    def __init__(
        self,
        *,
        tracking_id: typing.Optional[str] = None,
        carrier: typing.Optional[str] = None,
        provider: typing.Optional[str] = None,
        provider_transaction: typing.Optional[str] = None,
        is_return: typing.Optional[bool] = None
    ):
        self.tracking_id = tracking_id
        self.carrier = carrier
        self.provider = provider
        self.provider_transaction = provider_transaction
        self.is_return = is_return

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "TrackingData":
        from ._schemas.order import TrackingDataSchema

        return TrackingDataSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import TrackingDataSchema

        return TrackingDataSchema().dump(self)


class OrderAddDeliveryAction(OrderUpdateAction):
    """A [Delivery](ctp:api:type:Delivery) can only be added to an [Order](ctp:api:type:Order) if
    its `shippingInfo` (for `shippingMode` = `Single`), or its `shipping` (for `shippingMode` = `Multiple`) exists.

    Produces the [Delivery Added](ctp:api:type:DeliveryAddedMessage) Message.

    """

    #: `key` of an existing [Delivery](ctp:api:type:Delivery).
    delivery_key: typing.Optional[str]
    #: `key` of the [ShippingMethod](ctp:api:type:ShippingMethod), required for `Multiple` [ShippingMode](ctp:api:type:ShippingMode).
    shipping_key: typing.Optional[str]
    #: Line Items or Custom Line Items to be included in the Delivery.
    items: typing.Optional[typing.List["DeliveryItem"]]
    #: Address the `parcels` should be delivered to.
    address: typing.Optional["BaseAddress"]
    #: Parcels of the Delivery.
    #:
    #: If provided, this update action produces the [Parcel Added To Delivery](ctp:api:type:ParcelAddedToDeliveryMessage) Message.
    parcels: typing.Optional[typing.List["ParcelDraft"]]
    #: Custom Fields for the Delivery.
    custom: typing.Optional["CustomFieldsDraft"]

    def __init__(
        self,
        *,
        delivery_key: typing.Optional[str] = None,
        shipping_key: typing.Optional[str] = None,
        items: typing.Optional[typing.List["DeliveryItem"]] = None,
        address: typing.Optional["BaseAddress"] = None,
        parcels: typing.Optional[typing.List["ParcelDraft"]] = None,
        custom: typing.Optional["CustomFieldsDraft"] = None
    ):
        self.delivery_key = delivery_key
        self.shipping_key = shipping_key
        self.items = items
        self.address = address
        self.parcels = parcels
        self.custom = custom

        super().__init__(action="addDelivery")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderAddDeliveryAction":
        from ._schemas.order import OrderAddDeliveryActionSchema

        return OrderAddDeliveryActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderAddDeliveryActionSchema

        return OrderAddDeliveryActionSchema().dump(self)


class OrderAddItemShippingAddressAction(OrderUpdateAction):
    """Adds an address to an Order when shipping to multiple addresses is desired."""

    #: Address to append to `itemShippingAddresses`.
    #: The new Address must have a `key` that is unique across this Order.
    address: "BaseAddress"

    def __init__(self, *, address: "BaseAddress"):
        self.address = address

        super().__init__(action="addItemShippingAddress")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderAddItemShippingAddressAction":
        from ._schemas.order import OrderAddItemShippingAddressActionSchema

        return OrderAddItemShippingAddressActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderAddItemShippingAddressActionSchema

        return OrderAddItemShippingAddressActionSchema().dump(self)


class OrderAddParcelToDeliveryAction(OrderUpdateAction):
    """To add a Parcel, at least one [Delivery](ctp:api:type:Delivery) must exist.

    Produces the [Parcel Added To Delivery](ctp:api:type:ParcelAddedToDeliveryMessage) Message.

    """

    #: `id` of an existing [Delivery](ctp:api:type:Delivery).
    #:
    #: Either `deliveryId` or `deliveryKey` must be provided.
    delivery_id: typing.Optional[str]
    #: `key` of an existing [Delivery](ctp:api:type:Delivery).
    #:
    #: Either `deliveryId` or `deliveryKey` must be provided.
    delivery_key: typing.Optional[str]
    #: `key` of an existing [Parcel](ctp:api:type:Parcel).
    parcel_key: typing.Optional[str]
    #: Value to set.
    measurements: typing.Optional["ParcelMeasurements"]
    #: Value to set.
    tracking_data: typing.Optional["TrackingData"]
    #: Value to set.
    items: typing.Optional[typing.List["DeliveryItem"]]
    #: Custom Fields for the Parcel.
    custom: typing.Optional["CustomFieldsDraft"]

    def __init__(
        self,
        *,
        delivery_id: typing.Optional[str] = None,
        delivery_key: typing.Optional[str] = None,
        parcel_key: typing.Optional[str] = None,
        measurements: typing.Optional["ParcelMeasurements"] = None,
        tracking_data: typing.Optional["TrackingData"] = None,
        items: typing.Optional[typing.List["DeliveryItem"]] = None,
        custom: typing.Optional["CustomFieldsDraft"] = None
    ):
        self.delivery_id = delivery_id
        self.delivery_key = delivery_key
        self.parcel_key = parcel_key
        self.measurements = measurements
        self.tracking_data = tracking_data
        self.items = items
        self.custom = custom

        super().__init__(action="addParcelToDelivery")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderAddParcelToDeliveryAction":
        from ._schemas.order import OrderAddParcelToDeliveryActionSchema

        return OrderAddParcelToDeliveryActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderAddParcelToDeliveryActionSchema

        return OrderAddParcelToDeliveryActionSchema().dump(self)


class OrderAddPaymentAction(OrderUpdateAction):
    #: Payment to add to the [PaymentInfo](ctp:api:type:PaymentInfo).
    #: Must not be assigned to another Order or active Cart already.
    payment: "PaymentResourceIdentifier"

    def __init__(self, *, payment: "PaymentResourceIdentifier"):
        self.payment = payment

        super().__init__(action="addPayment")

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "OrderAddPaymentAction":
        from ._schemas.order import OrderAddPaymentActionSchema

        return OrderAddPaymentActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderAddPaymentActionSchema

        return OrderAddPaymentActionSchema().dump(self)


class OrderAddReturnInfoAction(OrderUpdateAction):
    """Produces the [Return Info Added](ctp:api:type:ReturnInfoAddedMessage) Message."""

    #: Value to set.
    return_tracking_id: typing.Optional[str]
    #: Items to be returned.
    #: Must not be empty.
    items: typing.List["ReturnItemDraft"]
    #: Value to set.
    #: If not set, it defaults to the current date and time.
    return_date: typing.Optional[datetime.datetime]

    def __init__(
        self,
        *,
        return_tracking_id: typing.Optional[str] = None,
        items: typing.List["ReturnItemDraft"],
        return_date: typing.Optional[datetime.datetime] = None
    ):
        self.return_tracking_id = return_tracking_id
        self.items = items
        self.return_date = return_date

        super().__init__(action="addReturnInfo")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderAddReturnInfoAction":
        from ._schemas.order import OrderAddReturnInfoActionSchema

        return OrderAddReturnInfoActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderAddReturnInfoActionSchema

        return OrderAddReturnInfoActionSchema().dump(self)


class OrderChangeOrderStateAction(OrderUpdateAction):
    """Produces the [Order State Changed](ctp:api:type:OrderStateChangedMessage) Message."""

    #: New status of the Order.
    order_state: "OrderState"

    def __init__(self, *, order_state: "OrderState"):
        self.order_state = order_state

        super().__init__(action="changeOrderState")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderChangeOrderStateAction":
        from ._schemas.order import OrderChangeOrderStateActionSchema

        return OrderChangeOrderStateActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderChangeOrderStateActionSchema

        return OrderChangeOrderStateActionSchema().dump(self)


class OrderChangePaymentStateAction(OrderUpdateAction):
    """Produces the [Order Payment State Changed](ctp:api:type:OrderPaymentStateChangedMessage) Message."""

    #: New payment status of the Order.
    payment_state: "PaymentState"

    def __init__(self, *, payment_state: "PaymentState"):
        self.payment_state = payment_state

        super().__init__(action="changePaymentState")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderChangePaymentStateAction":
        from ._schemas.order import OrderChangePaymentStateActionSchema

        return OrderChangePaymentStateActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderChangePaymentStateActionSchema

        return OrderChangePaymentStateActionSchema().dump(self)


class OrderChangeShipmentStateAction(OrderUpdateAction):
    """Produces the [Order Shipment State Changed](ctp:api:type:OrderShipmentStateChangedMessage) Message."""

    #: New shipment status of the Order.
    shipment_state: "ShipmentState"

    def __init__(self, *, shipment_state: "ShipmentState"):
        self.shipment_state = shipment_state

        super().__init__(action="changeShipmentState")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderChangeShipmentStateAction":
        from ._schemas.order import OrderChangeShipmentStateActionSchema

        return OrderChangeShipmentStateActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderChangeShipmentStateActionSchema

        return OrderChangeShipmentStateActionSchema().dump(self)


class OrderImportCustomLineItemStateAction(OrderUpdateAction):
    """The import of States does not follow any predefined rules and should be only used if no transitions are defined.
    The `quantity` in the [ItemStates](ctp:api:type:ItemState) must match the sum of all Custom Line Item states' quantities.

    """

    #: `id` of the [CustomLineItem](ctp:api:type:CustomLineItem) to update. Either `customLineItemId` or `customLineItemKey` is required.
    custom_line_item_id: typing.Optional[str]
    #: `key` of the [CustomLineItem](ctp:api:type:CustomLineItem) to update. Either `customLineItemId` or `customLineItemKey` is required.
    custom_line_item_key: typing.Optional[str]
    #: New status of the Custom Line Items.
    state: typing.List["ItemState"]

    def __init__(
        self,
        *,
        custom_line_item_id: typing.Optional[str] = None,
        custom_line_item_key: typing.Optional[str] = None,
        state: typing.List["ItemState"]
    ):
        self.custom_line_item_id = custom_line_item_id
        self.custom_line_item_key = custom_line_item_key
        self.state = state

        super().__init__(action="importCustomLineItemState")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderImportCustomLineItemStateAction":
        from ._schemas.order import OrderImportCustomLineItemStateActionSchema

        return OrderImportCustomLineItemStateActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderImportCustomLineItemStateActionSchema

        return OrderImportCustomLineItemStateActionSchema().dump(self)


class OrderImportLineItemStateAction(OrderUpdateAction):
    """The import of States does not follow any predefined rules and should be only used if no transitions are defined.
    The `quantity` in the [ItemStates](ctp:api:type:ItemState) must match the sum of all Line Items states' quantities.

    """

    #: `id` of the [LineItem](ctp:api:type:LineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    line_item_id: typing.Optional[str]
    #: `key` of the [LineItem](ctp:api:type:LineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    line_item_key: typing.Optional[str]
    #: New status of the Line Items.
    state: typing.List["ItemState"]

    def __init__(
        self,
        *,
        line_item_id: typing.Optional[str] = None,
        line_item_key: typing.Optional[str] = None,
        state: typing.List["ItemState"]
    ):
        self.line_item_id = line_item_id
        self.line_item_key = line_item_key
        self.state = state

        super().__init__(action="importLineItemState")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderImportLineItemStateAction":
        from ._schemas.order import OrderImportLineItemStateActionSchema

        return OrderImportLineItemStateActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderImportLineItemStateActionSchema

        return OrderImportLineItemStateActionSchema().dump(self)


class OrderRemoveDeliveryAction(OrderUpdateAction):
    """Produces the [DeliveryRemoved](ctp:api:type:DeliveryRemovedMessage) Message."""

    #: `id` of an existing [Delivery](ctp:api:type:Delivery).
    #:
    #: Either `deliveryId` or `deliveryKey` must be provided.
    delivery_id: typing.Optional[str]
    #: `key` of an existing [Delivery](ctp:api:type:Delivery).
    #:
    #: Either `deliveryId` or `deliveryKey` must be provided.
    delivery_key: typing.Optional[str]

    def __init__(
        self,
        *,
        delivery_id: typing.Optional[str] = None,
        delivery_key: typing.Optional[str] = None
    ):
        self.delivery_id = delivery_id
        self.delivery_key = delivery_key

        super().__init__(action="removeDelivery")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderRemoveDeliveryAction":
        from ._schemas.order import OrderRemoveDeliveryActionSchema

        return OrderRemoveDeliveryActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderRemoveDeliveryActionSchema

        return OrderRemoveDeliveryActionSchema().dump(self)


class OrderRemoveItemShippingAddressAction(OrderUpdateAction):
    """An address can only be removed if it is not referenced in any [ItemShippingTarget](ctp:api:type:ItemShippingTarget) of the Cart.
    In such case, change the Line Item shipping address to a different `addressKey` first using the [Set LineItemShippingDetails](ctp:api:type:OrderSetLineItemShippingDetailsAction) update action, before you remove the obsolete address.

    """

    #: `key` of the Address to remove from `itemShippingAddresses`.
    address_key: str

    def __init__(self, *, address_key: str):
        self.address_key = address_key

        super().__init__(action="removeItemShippingAddress")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderRemoveItemShippingAddressAction":
        from ._schemas.order import OrderRemoveItemShippingAddressActionSchema

        return OrderRemoveItemShippingAddressActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderRemoveItemShippingAddressActionSchema

        return OrderRemoveItemShippingAddressActionSchema().dump(self)


class OrderRemoveParcelFromDeliveryAction(OrderUpdateAction):
    """Produces the [ParcelRemovedFromDelivery](ctp:api:type:ParcelRemovedFromDeliveryMessage) Message."""

    #: `id` of an existing [Parcel](ctp:api:type:Parcel).
    #:
    #: Either `parcelId` or `parcelKey` must be provided.
    parcel_id: typing.Optional[str]
    #: `key` of an existing [Parcel](ctp:api:type:Parcel).
    #:
    #: Either `parcelId` or `parcelKey` must be provided.
    parcel_key: typing.Optional[str]

    def __init__(
        self,
        *,
        parcel_id: typing.Optional[str] = None,
        parcel_key: typing.Optional[str] = None
    ):
        self.parcel_id = parcel_id
        self.parcel_key = parcel_key

        super().__init__(action="removeParcelFromDelivery")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderRemoveParcelFromDeliveryAction":
        from ._schemas.order import OrderRemoveParcelFromDeliveryActionSchema

        return OrderRemoveParcelFromDeliveryActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderRemoveParcelFromDeliveryActionSchema

        return OrderRemoveParcelFromDeliveryActionSchema().dump(self)


class OrderRemovePaymentAction(OrderUpdateAction):
    #: Payment to remove from the [PaymentInfo](ctp:api:type:PaymentInfo).
    payment: "PaymentResourceIdentifier"

    def __init__(self, *, payment: "PaymentResourceIdentifier"):
        self.payment = payment

        super().__init__(action="removePayment")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderRemovePaymentAction":
        from ._schemas.order import OrderRemovePaymentActionSchema

        return OrderRemovePaymentActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderRemovePaymentActionSchema

        return OrderRemovePaymentActionSchema().dump(self)


class OrderSetBillingAddressAction(OrderUpdateAction):
    """This action updates the `billingAddress` on the Order, but it does not change the billing address on the referenced [Cart](ctp:api:type:Cart) from which the Order is created.

    Produces the [Order Billing Address Set](ctp:api:type:OrderBillingAddressSetMessage) Message.

    """

    #: Value to set.
    #: If empty, any existing value is removed.
    address: typing.Optional["BaseAddress"]

    def __init__(self, *, address: typing.Optional["BaseAddress"] = None):
        self.address = address

        super().__init__(action="setBillingAddress")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderSetBillingAddressAction":
        from ._schemas.order import OrderSetBillingAddressActionSchema

        return OrderSetBillingAddressActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderSetBillingAddressActionSchema

        return OrderSetBillingAddressActionSchema().dump(self)


class OrderSetBillingAddressCustomFieldAction(OrderUpdateAction):
    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: Removing a field that does not exist returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
    #: If `value` is provided, it is set for the field defined by `name`.
    value: typing.Optional[typing.Any]

    def __init__(self, *, name: str, value: typing.Optional[typing.Any] = None):
        self.name = name
        self.value = value

        super().__init__(action="setBillingAddressCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderSetBillingAddressCustomFieldAction":
        from ._schemas.order import OrderSetBillingAddressCustomFieldActionSchema

        return OrderSetBillingAddressCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderSetBillingAddressCustomFieldActionSchema

        return OrderSetBillingAddressCustomFieldActionSchema().dump(self)


class OrderSetBillingAddressCustomTypeAction(OrderUpdateAction):
    #: Defines the [Type](ctp:api:type:Type) that extends the `billingAddress` with [Custom Fields](/../api/projects/custom-fields).
    #: If absent, any existing Type and Custom Fields are removed from the `billingAddress`.
    type: typing.Optional["TypeResourceIdentifier"]
    #: Sets the [Custom Fields](/../api/projects/custom-fields) fields for the `billingAddress`.
    fields: typing.Optional["FieldContainer"]

    def __init__(
        self,
        *,
        type: typing.Optional["TypeResourceIdentifier"] = None,
        fields: typing.Optional["FieldContainer"] = None
    ):
        self.type = type
        self.fields = fields

        super().__init__(action="setBillingAddressCustomType")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderSetBillingAddressCustomTypeAction":
        from ._schemas.order import OrderSetBillingAddressCustomTypeActionSchema

        return OrderSetBillingAddressCustomTypeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderSetBillingAddressCustomTypeActionSchema

        return OrderSetBillingAddressCustomTypeActionSchema().dump(self)


class OrderSetCustomFieldAction(OrderUpdateAction):
    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: Removing a field that does not exist returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
    #: If `value` is provided, it is set for the field defined by `name`.
    value: typing.Optional[typing.Any]

    def __init__(self, *, name: str, value: typing.Optional[typing.Any] = None):
        self.name = name
        self.value = value

        super().__init__(action="setCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderSetCustomFieldAction":
        from ._schemas.order import OrderSetCustomFieldActionSchema

        return OrderSetCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderSetCustomFieldActionSchema

        return OrderSetCustomFieldActionSchema().dump(self)


class OrderSetCustomLineItemCustomFieldAction(OrderUpdateAction):
    #: `id` of the [CustomLineItem](ctp:api:type:CustomLineItem) to update. Either `customLineItemId` or `customLineItemKey` is required.
    custom_line_item_id: typing.Optional[str]
    #: `key` of the [CustomLineItem](ctp:api:type:CustomLineItem) to update. Either `customLineItemId` or `customLineItemKey` is required.
    custom_line_item_key: typing.Optional[str]
    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: Removing a field that does not exist returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
    #: If `value` is provided, it is set for the field defined by `name`.
    value: typing.Optional[typing.Any]

    def __init__(
        self,
        *,
        custom_line_item_id: typing.Optional[str] = None,
        custom_line_item_key: typing.Optional[str] = None,
        name: str,
        value: typing.Optional[typing.Any] = None
    ):
        self.custom_line_item_id = custom_line_item_id
        self.custom_line_item_key = custom_line_item_key
        self.name = name
        self.value = value

        super().__init__(action="setCustomLineItemCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderSetCustomLineItemCustomFieldAction":
        from ._schemas.order import OrderSetCustomLineItemCustomFieldActionSchema

        return OrderSetCustomLineItemCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderSetCustomLineItemCustomFieldActionSchema

        return OrderSetCustomLineItemCustomFieldActionSchema().dump(self)


class OrderSetCustomLineItemCustomTypeAction(OrderUpdateAction):
    #: `id` of the [CustomLineItem](ctp:api:type:CustomLineItem) to update. Either `customLineItemId` or `customLineItemKey` is required.
    custom_line_item_id: typing.Optional[str]
    #: `key` of the [CustomLineItem](ctp:api:type:CustomLineItem) to update. Either `customLineItemId` or `customLineItemKey` is required.
    custom_line_item_key: typing.Optional[str]
    #: Defines the [Type](ctp:api:type:Type) that extends the Custom Line Item with [Custom Fields](/../api/projects/custom-fields).
    #: If absent, any existing Type and Custom Fields are removed from the Custom Line Item.
    type: typing.Optional["TypeResourceIdentifier"]
    #: Sets the [Custom Fields](/../api/projects/custom-fields) fields for the Custom Line Item.
    fields: typing.Optional["FieldContainer"]

    def __init__(
        self,
        *,
        custom_line_item_id: typing.Optional[str] = None,
        custom_line_item_key: typing.Optional[str] = None,
        type: typing.Optional["TypeResourceIdentifier"] = None,
        fields: typing.Optional["FieldContainer"] = None
    ):
        self.custom_line_item_id = custom_line_item_id
        self.custom_line_item_key = custom_line_item_key
        self.type = type
        self.fields = fields

        super().__init__(action="setCustomLineItemCustomType")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderSetCustomLineItemCustomTypeAction":
        from ._schemas.order import OrderSetCustomLineItemCustomTypeActionSchema

        return OrderSetCustomLineItemCustomTypeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderSetCustomLineItemCustomTypeActionSchema

        return OrderSetCustomLineItemCustomTypeActionSchema().dump(self)


class OrderSetCustomLineItemShippingDetailsAction(OrderUpdateAction):
    #: `id` of the [CustomLineItem](ctp:api:type:CustomLineItem) to update. Either `customLineItemId` or `customLineItemKey` is required.
    custom_line_item_id: typing.Optional[str]
    #: `key` of the [CustomLineItem](ctp:api:type:CustomLineItem) to update. Either `customLineItemId` or `customLineItemKey` is required.
    custom_line_item_key: typing.Optional[str]
    #: Value to set.
    #: If empty, any existing value is removed.
    shipping_details: typing.Optional["ItemShippingDetailsDraft"]

    def __init__(
        self,
        *,
        custom_line_item_id: typing.Optional[str] = None,
        custom_line_item_key: typing.Optional[str] = None,
        shipping_details: typing.Optional["ItemShippingDetailsDraft"] = None
    ):
        self.custom_line_item_id = custom_line_item_id
        self.custom_line_item_key = custom_line_item_key
        self.shipping_details = shipping_details

        super().__init__(action="setCustomLineItemShippingDetails")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderSetCustomLineItemShippingDetailsAction":
        from ._schemas.order import OrderSetCustomLineItemShippingDetailsActionSchema

        return OrderSetCustomLineItemShippingDetailsActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderSetCustomLineItemShippingDetailsActionSchema

        return OrderSetCustomLineItemShippingDetailsActionSchema().dump(self)


class OrderSetCustomTypeAction(OrderUpdateAction):
    #: Defines the [Type](ctp:api:type:Type) that extends the Order with [Custom Fields](/../api/projects/custom-fields).
    #: If absent, any existing Type and Custom Fields are removed from the Order.
    type: typing.Optional["TypeResourceIdentifier"]
    #: Sets the [Custom Fields](/../api/projects/custom-fields) fields for the Order.
    fields: typing.Optional["FieldContainer"]

    def __init__(
        self,
        *,
        type: typing.Optional["TypeResourceIdentifier"] = None,
        fields: typing.Optional["FieldContainer"] = None
    ):
        self.type = type
        self.fields = fields

        super().__init__(action="setCustomType")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderSetCustomTypeAction":
        from ._schemas.order import OrderSetCustomTypeActionSchema

        return OrderSetCustomTypeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderSetCustomTypeActionSchema

        return OrderSetCustomTypeActionSchema().dump(self)


class OrderSetCustomerEmailAction(OrderUpdateAction):
    """This action updates the `customerEmail` on the Order, but it does not change the Customer email on the [Cart](ctp:api:type:Cart) the Order has been created from.

    Produces the [Order Customer Email Set](ctp:api:type:OrderCustomerEmailSetMessage) Message.

    """

    #: Value to set.
    #: If empty, any existing value is removed.
    email: typing.Optional[str]

    def __init__(self, *, email: typing.Optional[str] = None):
        self.email = email

        super().__init__(action="setCustomerEmail")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderSetCustomerEmailAction":
        from ._schemas.order import OrderSetCustomerEmailActionSchema

        return OrderSetCustomerEmailActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderSetCustomerEmailActionSchema

        return OrderSetCustomerEmailActionSchema().dump(self)


class OrderSetCustomerIdAction(OrderUpdateAction):
    """Setting the Order's `customerId` does not recalculate prices or discounts on the Order.
    If the Customer belongs to a Customer Group, `customerGroup` on the [Order](ctp:api:type:Order) is updated automatically.

    Produces the [OrderCustomerSet](ctp:api:type:OrderCustomerSetMessage) Message.

    """

    #: `id` of an existing [Customer](ctp:api:type:Customer).
    #: If empty, any existing value is removed.
    customer_id: typing.Optional[str]

    def __init__(self, *, customer_id: typing.Optional[str] = None):
        self.customer_id = customer_id

        super().__init__(action="setCustomerId")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderSetCustomerIdAction":
        from ._schemas.order import OrderSetCustomerIdActionSchema

        return OrderSetCustomerIdActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderSetCustomerIdActionSchema

        return OrderSetCustomerIdActionSchema().dump(self)


class OrderSetDeliveryAddressAction(OrderUpdateAction):
    """Produces the [DeliveryAddressSet](ctp:api:type:DeliveryAddressSetMessage) Message."""

    #: `id` of an existing [Delivery](ctp:api:type:Delivery).
    #:
    #: Either `deliveryId` or `deliveryKey` must be provided.
    delivery_id: typing.Optional[str]
    #: `key` of an existing [Delivery](ctp:api:type:Delivery).
    #:
    #: Either `deliveryId` or `deliveryKey` must be provided.
    delivery_key: typing.Optional[str]
    #: Value to set.
    #: If empty, any existing value is removed.
    address: typing.Optional["BaseAddress"]

    def __init__(
        self,
        *,
        delivery_id: typing.Optional[str] = None,
        delivery_key: typing.Optional[str] = None,
        address: typing.Optional["BaseAddress"] = None
    ):
        self.delivery_id = delivery_id
        self.delivery_key = delivery_key
        self.address = address

        super().__init__(action="setDeliveryAddress")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderSetDeliveryAddressAction":
        from ._schemas.order import OrderSetDeliveryAddressActionSchema

        return OrderSetDeliveryAddressActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderSetDeliveryAddressActionSchema

        return OrderSetDeliveryAddressActionSchema().dump(self)


class OrderSetDeliveryAddressCustomFieldAction(OrderUpdateAction):
    #: `id` of an existing [Delivery](ctp:api:type:Delivery).
    #:
    #: Either `deliveryId` or `deliveryKey` must be provided.
    delivery_id: typing.Optional[str]
    #: `key` of an existing [Delivery](ctp:api:type:Delivery).
    #:
    #: Either `deliveryId` or `deliveryKey` must be provided.
    delivery_key: typing.Optional[str]
    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: Removing a field that does not exist returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
    #: If `value` is provided, it is set for the field defined by `name`.
    value: typing.Optional[typing.Any]

    def __init__(
        self,
        *,
        delivery_id: typing.Optional[str] = None,
        delivery_key: typing.Optional[str] = None,
        name: str,
        value: typing.Optional[typing.Any] = None
    ):
        self.delivery_id = delivery_id
        self.delivery_key = delivery_key
        self.name = name
        self.value = value

        super().__init__(action="setDeliveryAddressCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderSetDeliveryAddressCustomFieldAction":
        from ._schemas.order import OrderSetDeliveryAddressCustomFieldActionSchema

        return OrderSetDeliveryAddressCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderSetDeliveryAddressCustomFieldActionSchema

        return OrderSetDeliveryAddressCustomFieldActionSchema().dump(self)


class OrderSetDeliveryAddressCustomTypeAction(OrderUpdateAction):
    #: `id` of an existing [Delivery](ctp:api:type:Delivery).
    #:
    #: Either `deliveryId` or `deliveryKey` must be provided.
    delivery_id: typing.Optional[str]
    #: `key` of an existing [Delivery](ctp:api:type:Delivery).
    #:
    #: Either `deliveryId` or `deliveryKey` must be provided.
    delivery_key: typing.Optional[str]
    #: Defines the [Type](ctp:api:type:Type) that extends the [Delivery](ctp:api:type:Delivery) `address` with [Custom Fields](/../api/projects/custom-fields).
    #: If absent, any existing Type and Custom Fields are removed from the [Delivery](ctp:api:type:Delivery) `address`.
    type: typing.Optional["TypeResourceIdentifier"]
    #: Sets the [Custom Fields](/../api/projects/custom-fields) fields for the [Delivery](ctp:api:type:Delivery) `address`.
    fields: typing.Optional["FieldContainer"]

    def __init__(
        self,
        *,
        delivery_id: typing.Optional[str] = None,
        delivery_key: typing.Optional[str] = None,
        type: typing.Optional["TypeResourceIdentifier"] = None,
        fields: typing.Optional["FieldContainer"] = None
    ):
        self.delivery_id = delivery_id
        self.delivery_key = delivery_key
        self.type = type
        self.fields = fields

        super().__init__(action="setDeliveryAddressCustomType")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderSetDeliveryAddressCustomTypeAction":
        from ._schemas.order import OrderSetDeliveryAddressCustomTypeActionSchema

        return OrderSetDeliveryAddressCustomTypeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderSetDeliveryAddressCustomTypeActionSchema

        return OrderSetDeliveryAddressCustomTypeActionSchema().dump(self)


class OrderSetDeliveryCustomFieldAction(OrderUpdateAction):
    #: `id` of an existing [Delivery](ctp:api:type:Delivery).
    #:
    #: Either `deliveryId` or `deliveryKey` must be provided.
    delivery_id: typing.Optional[str]
    #: `key` of an existing [Delivery](ctp:api:type:Delivery).
    #:
    #: Either `deliveryId` or `deliveryKey` must be provided.
    delivery_key: typing.Optional[str]
    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: Removing a field that does not exist returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
    #: If `value` is provided, it is set for the field defined by `name`.
    value: typing.Optional[typing.Any]

    def __init__(
        self,
        *,
        delivery_id: typing.Optional[str] = None,
        delivery_key: typing.Optional[str] = None,
        name: str,
        value: typing.Optional[typing.Any] = None
    ):
        self.delivery_id = delivery_id
        self.delivery_key = delivery_key
        self.name = name
        self.value = value

        super().__init__(action="setDeliveryCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderSetDeliveryCustomFieldAction":
        from ._schemas.order import OrderSetDeliveryCustomFieldActionSchema

        return OrderSetDeliveryCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderSetDeliveryCustomFieldActionSchema

        return OrderSetDeliveryCustomFieldActionSchema().dump(self)


class OrderSetDeliveryCustomTypeAction(OrderUpdateAction):
    #: `id` of an existing [Delivery](ctp:api:type:Delivery).
    #:
    #: Either `deliveryId` or `deliveryKey` must be provided.
    delivery_id: typing.Optional[str]
    #: `key` of an existing [Delivery](ctp:api:type:Delivery).
    #:
    #: Either `deliveryId` or `deliveryKey` must be provided.
    delivery_key: typing.Optional[str]
    #: Defines the [Type](ctp:api:type:Type) that extends the Delivery with [Custom Fields](/../api/projects/custom-fields).
    #: If absent, any existing Type and Custom Fields are removed from the Delivery.
    type: typing.Optional["TypeResourceIdentifier"]
    #: Sets the [Custom Fields](/../api/projects/custom-fields) fields for the Delivery.
    fields: typing.Optional["FieldContainer"]

    def __init__(
        self,
        *,
        delivery_id: typing.Optional[str] = None,
        delivery_key: typing.Optional[str] = None,
        type: typing.Optional["TypeResourceIdentifier"] = None,
        fields: typing.Optional["FieldContainer"] = None
    ):
        self.delivery_id = delivery_id
        self.delivery_key = delivery_key
        self.type = type
        self.fields = fields

        super().__init__(action="setDeliveryCustomType")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderSetDeliveryCustomTypeAction":
        from ._schemas.order import OrderSetDeliveryCustomTypeActionSchema

        return OrderSetDeliveryCustomTypeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderSetDeliveryCustomTypeActionSchema

        return OrderSetDeliveryCustomTypeActionSchema().dump(self)


class OrderSetDeliveryItemsAction(OrderUpdateAction):
    """Produces the [Delivery Items Updated](ctp:api:type:DeliveryItemsUpdatedMessage) Message."""

    #: `id` of an existing [Delivery](ctp:api:type:Delivery).
    #:
    #: Either `deliveryId` or `deliveryKey` must be provided.
    delivery_id: typing.Optional[str]
    #: `key` of an existing [Delivery](ctp:api:type:Delivery).
    #:
    #: Either `deliveryId` or `deliveryKey` must be provided.
    delivery_key: typing.Optional[str]
    #: Value to set.
    #: If empty, any existing value is removed.
    items: typing.List["DeliveryItem"]

    def __init__(
        self,
        *,
        delivery_id: typing.Optional[str] = None,
        delivery_key: typing.Optional[str] = None,
        items: typing.List["DeliveryItem"]
    ):
        self.delivery_id = delivery_id
        self.delivery_key = delivery_key
        self.items = items

        super().__init__(action="setDeliveryItems")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderSetDeliveryItemsAction":
        from ._schemas.order import OrderSetDeliveryItemsActionSchema

        return OrderSetDeliveryItemsActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderSetDeliveryItemsActionSchema

        return OrderSetDeliveryItemsActionSchema().dump(self)


class OrderSetItemShippingAddressCustomFieldAction(OrderUpdateAction):
    #: `key` of the [Address](ctp:api:type:Address) in `itemShippingAddresses`.
    address_key: str
    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: Removing a field that does not exist returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
    #: If `value` is provided, it is set for the field defined by `name`.
    value: typing.Optional[typing.Any]

    def __init__(
        self, *, address_key: str, name: str, value: typing.Optional[typing.Any] = None
    ):
        self.address_key = address_key
        self.name = name
        self.value = value

        super().__init__(action="setItemShippingAddressCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderSetItemShippingAddressCustomFieldAction":
        from ._schemas.order import OrderSetItemShippingAddressCustomFieldActionSchema

        return OrderSetItemShippingAddressCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderSetItemShippingAddressCustomFieldActionSchema

        return OrderSetItemShippingAddressCustomFieldActionSchema().dump(self)


class OrderSetItemShippingAddressCustomTypeAction(OrderUpdateAction):
    #: `key` of the [Address](ctp:api:type:Address) in `itemShippingAddresses`.
    address_key: str
    #: Defines the [Type](ctp:api:type:Type) that extends the `itemShippingAddress` with [Custom Fields](/../api/projects/custom-fields).
    #: If absent, any existing Type and Custom Fields are removed from the `itemShippingAddress`.
    type: typing.Optional["TypeResourceIdentifier"]
    #: Sets the [Custom Fields](/../api/projects/custom-fields) fields for the `itemShippingAddress`.
    fields: typing.Optional["FieldContainer"]

    def __init__(
        self,
        *,
        address_key: str,
        type: typing.Optional["TypeResourceIdentifier"] = None,
        fields: typing.Optional["FieldContainer"] = None
    ):
        self.address_key = address_key
        self.type = type
        self.fields = fields

        super().__init__(action="setItemShippingAddressCustomType")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderSetItemShippingAddressCustomTypeAction":
        from ._schemas.order import OrderSetItemShippingAddressCustomTypeActionSchema

        return OrderSetItemShippingAddressCustomTypeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderSetItemShippingAddressCustomTypeActionSchema

        return OrderSetItemShippingAddressCustomTypeActionSchema().dump(self)


class OrderSetLineItemCustomFieldAction(OrderUpdateAction):
    #: `id` of the [LineItem](ctp:api:type:LineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    line_item_id: typing.Optional[str]
    #: `key` of the [LineItem](ctp:api:type:LineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    line_item_key: typing.Optional[str]
    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: Removing a field that does not exist returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
    #: If `value` is provided, it is set for the field defined by `name`.
    value: typing.Optional[typing.Any]

    def __init__(
        self,
        *,
        line_item_id: typing.Optional[str] = None,
        line_item_key: typing.Optional[str] = None,
        name: str,
        value: typing.Optional[typing.Any] = None
    ):
        self.line_item_id = line_item_id
        self.line_item_key = line_item_key
        self.name = name
        self.value = value

        super().__init__(action="setLineItemCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderSetLineItemCustomFieldAction":
        from ._schemas.order import OrderSetLineItemCustomFieldActionSchema

        return OrderSetLineItemCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderSetLineItemCustomFieldActionSchema

        return OrderSetLineItemCustomFieldActionSchema().dump(self)


class OrderSetLineItemCustomTypeAction(OrderUpdateAction):
    #: `id` of the [LineItem](ctp:api:type:LineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    line_item_id: typing.Optional[str]
    #: `key` of the [LineItem](ctp:api:type:LineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    line_item_key: typing.Optional[str]
    #: Defines the [Type](ctp:api:type:Type) that extends the Line Item with [Custom Fields](/../api/projects/custom-fields).
    #: If absent, any existing Type and Custom Fields are removed from the Line Item.
    type: typing.Optional["TypeResourceIdentifier"]
    #: Sets the [Custom Fields](/../api/projects/custom-fields) fields for the Line Item.
    fields: typing.Optional["FieldContainer"]

    def __init__(
        self,
        *,
        line_item_id: typing.Optional[str] = None,
        line_item_key: typing.Optional[str] = None,
        type: typing.Optional["TypeResourceIdentifier"] = None,
        fields: typing.Optional["FieldContainer"] = None
    ):
        self.line_item_id = line_item_id
        self.line_item_key = line_item_key
        self.type = type
        self.fields = fields

        super().__init__(action="setLineItemCustomType")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderSetLineItemCustomTypeAction":
        from ._schemas.order import OrderSetLineItemCustomTypeActionSchema

        return OrderSetLineItemCustomTypeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderSetLineItemCustomTypeActionSchema

        return OrderSetLineItemCustomTypeActionSchema().dump(self)


class OrderSetLineItemShippingDetailsAction(OrderUpdateAction):
    #: `id` of the [LineItem](ctp:api:type:LineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    line_item_id: typing.Optional[str]
    #: `key` of the [LineItem](ctp:api:type:LineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    line_item_key: typing.Optional[str]
    #: Value to set.
    #: If empty, the existing value is removed.
    shipping_details: typing.Optional["ItemShippingDetailsDraft"]

    def __init__(
        self,
        *,
        line_item_id: typing.Optional[str] = None,
        line_item_key: typing.Optional[str] = None,
        shipping_details: typing.Optional["ItemShippingDetailsDraft"] = None
    ):
        self.line_item_id = line_item_id
        self.line_item_key = line_item_key
        self.shipping_details = shipping_details

        super().__init__(action="setLineItemShippingDetails")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderSetLineItemShippingDetailsAction":
        from ._schemas.order import OrderSetLineItemShippingDetailsActionSchema

        return OrderSetLineItemShippingDetailsActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderSetLineItemShippingDetailsActionSchema

        return OrderSetLineItemShippingDetailsActionSchema().dump(self)


class OrderSetLocaleAction(OrderUpdateAction):
    #: Value to set.
    #: Must be one of the [Project](ctp:api:type:Project)'s languages.
    #: If empty, any existing value is removed.
    locale: typing.Optional[str]

    def __init__(self, *, locale: typing.Optional[str] = None):
        self.locale = locale

        super().__init__(action="setLocale")

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "OrderSetLocaleAction":
        from ._schemas.order import OrderSetLocaleActionSchema

        return OrderSetLocaleActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderSetLocaleActionSchema

        return OrderSetLocaleActionSchema().dump(self)


class OrderSetOrderNumberAction(OrderUpdateAction):
    #: Value to set.
    #: Must be unique across a Project.
    #: Once set, the value cannot be changed.
    order_number: typing.Optional[str]

    def __init__(self, *, order_number: typing.Optional[str] = None):
        self.order_number = order_number

        super().__init__(action="setOrderNumber")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderSetOrderNumberAction":
        from ._schemas.order import OrderSetOrderNumberActionSchema

        return OrderSetOrderNumberActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderSetOrderNumberActionSchema

        return OrderSetOrderNumberActionSchema().dump(self)


class OrderSetParcelCustomFieldAction(OrderUpdateAction):
    #: `id` of an existing [Parcel](ctp:api:type:Parcel).
    #:
    #: Either `parcelId` or `parcelKey` must be provided.
    parcel_id: typing.Optional[str]
    #: `key` of an existing [Parcel](ctp:api:type:Parcel).
    #:
    #: Either `parcelId` or `parcelKey` must be provided.
    parcel_key: typing.Optional[str]
    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: Removing a field that does not exist returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
    #: If `value` is provided, it is set for the field defined by `name`.
    value: typing.Optional[typing.Any]

    def __init__(
        self,
        *,
        parcel_id: typing.Optional[str] = None,
        parcel_key: typing.Optional[str] = None,
        name: str,
        value: typing.Optional[typing.Any] = None
    ):
        self.parcel_id = parcel_id
        self.parcel_key = parcel_key
        self.name = name
        self.value = value

        super().__init__(action="setParcelCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderSetParcelCustomFieldAction":
        from ._schemas.order import OrderSetParcelCustomFieldActionSchema

        return OrderSetParcelCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderSetParcelCustomFieldActionSchema

        return OrderSetParcelCustomFieldActionSchema().dump(self)


class OrderSetParcelCustomTypeAction(OrderUpdateAction):
    #: `id` of an existing [Parcel](ctp:api:type:Parcel).
    #:
    #: Either `parcelId` or `parcelKey` must be provided.
    parcel_id: typing.Optional[str]
    #: `key` of an existing [Parcel](ctp:api:type:Parcel).
    #:
    #: Either `parcelId` or `parcelKey` must be provided.
    parcel_key: typing.Optional[str]
    #: Defines the [Type](ctp:api:type:Type) that extends the Parcel with [Custom Fields](/../api/projects/custom-fields).
    #: If absent, any existing Type and Custom Fields are removed from the Parcel.
    type: typing.Optional["TypeResourceIdentifier"]
    #: Sets the [Custom Fields](/../api/projects/custom-fields) fields for the Parcel.
    fields: typing.Optional["FieldContainer"]

    def __init__(
        self,
        *,
        parcel_id: typing.Optional[str] = None,
        parcel_key: typing.Optional[str] = None,
        type: typing.Optional["TypeResourceIdentifier"] = None,
        fields: typing.Optional["FieldContainer"] = None
    ):
        self.parcel_id = parcel_id
        self.parcel_key = parcel_key
        self.type = type
        self.fields = fields

        super().__init__(action="setParcelCustomType")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderSetParcelCustomTypeAction":
        from ._schemas.order import OrderSetParcelCustomTypeActionSchema

        return OrderSetParcelCustomTypeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderSetParcelCustomTypeActionSchema

        return OrderSetParcelCustomTypeActionSchema().dump(self)


class OrderSetParcelItemsAction(OrderUpdateAction):
    """Produces the [ParcelItemsUpdated](ctp:api:type:ParcelItemsUpdatedMessage) Message."""

    #: `id` of an existing [Parcel](ctp:api:type:Parcel).
    #:
    #: Either `parcelId` or `parcelKey` must be provided.
    parcel_id: typing.Optional[str]
    #: `key` of an existing [Parcel](ctp:api:type:Parcel).
    #:
    #: Either `parcelId` or `parcelKey` must be provided.
    parcel_key: typing.Optional[str]
    #: Value to set.
    #: If empty, any existing value is removed.
    items: typing.List["DeliveryItem"]

    def __init__(
        self,
        *,
        parcel_id: typing.Optional[str] = None,
        parcel_key: typing.Optional[str] = None,
        items: typing.List["DeliveryItem"]
    ):
        self.parcel_id = parcel_id
        self.parcel_key = parcel_key
        self.items = items

        super().__init__(action="setParcelItems")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderSetParcelItemsAction":
        from ._schemas.order import OrderSetParcelItemsActionSchema

        return OrderSetParcelItemsActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderSetParcelItemsActionSchema

        return OrderSetParcelItemsActionSchema().dump(self)


class OrderSetParcelMeasurementsAction(OrderUpdateAction):
    """Produces the [ParcelMeasurementsUpdated](ctp:api:type:ParcelMeasurementsUpdatedMessage) Message."""

    #: `id` of an existing [Parcel](ctp:api:type:Parcel).
    #:
    #: Either `parcelId` or `parcelKey` must be provided.
    parcel_id: typing.Optional[str]
    #: `key` of an existing [Parcel](ctp:api:type:Parcel).
    #:
    #: Either `parcelId` or `parcelKey` must be provided.
    parcel_key: typing.Optional[str]
    #: Value to set.
    #: If empty, any existing value is removed.
    measurements: typing.Optional["ParcelMeasurements"]

    def __init__(
        self,
        *,
        parcel_id: typing.Optional[str] = None,
        parcel_key: typing.Optional[str] = None,
        measurements: typing.Optional["ParcelMeasurements"] = None
    ):
        self.parcel_id = parcel_id
        self.parcel_key = parcel_key
        self.measurements = measurements

        super().__init__(action="setParcelMeasurements")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderSetParcelMeasurementsAction":
        from ._schemas.order import OrderSetParcelMeasurementsActionSchema

        return OrderSetParcelMeasurementsActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderSetParcelMeasurementsActionSchema

        return OrderSetParcelMeasurementsActionSchema().dump(self)


class OrderSetParcelTrackingDataAction(OrderUpdateAction):
    """Produces the [ParcelTrackingDataUpdated](ctp:api:type:ParcelTrackingDataUpdatedMessage) Message."""

    #: `id` of an existing [Parcel](ctp:api:type:Parcel).
    #:
    #: Either `parcelId` or `parcelKey` must be provided.
    parcel_id: typing.Optional[str]
    #: `key` of an existing [Parcel](ctp:api:type:Parcel).
    #:
    #: Either `parcelId` or `parcelKey` must be provided.
    parcel_key: typing.Optional[str]
    #: Value to set.
    #: If empty, any existing value is removed.
    tracking_data: typing.Optional["TrackingData"]

    def __init__(
        self,
        *,
        parcel_id: typing.Optional[str] = None,
        parcel_key: typing.Optional[str] = None,
        tracking_data: typing.Optional["TrackingData"] = None
    ):
        self.parcel_id = parcel_id
        self.parcel_key = parcel_key
        self.tracking_data = tracking_data

        super().__init__(action="setParcelTrackingData")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderSetParcelTrackingDataAction":
        from ._schemas.order import OrderSetParcelTrackingDataActionSchema

        return OrderSetParcelTrackingDataActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderSetParcelTrackingDataActionSchema

        return OrderSetParcelTrackingDataActionSchema().dump(self)


class OrderSetPurchaseOrderNumberAction(OrderUpdateAction):
    """Produces the [PurchaseOrderNumberSet](ctp:api:type:OrderPurchaseOrderNumberSetMessage) Message."""

    #: Value to set.
    #: If empty, any existing value is removed.
    purchase_order_number: typing.Optional[str]

    def __init__(self, *, purchase_order_number: typing.Optional[str] = None):
        self.purchase_order_number = purchase_order_number

        super().__init__(action="setPurchaseOrderNumber")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderSetPurchaseOrderNumberAction":
        from ._schemas.order import OrderSetPurchaseOrderNumberActionSchema

        return OrderSetPurchaseOrderNumberActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderSetPurchaseOrderNumberActionSchema

        return OrderSetPurchaseOrderNumberActionSchema().dump(self)


class OrderSetReturnInfoAction(OrderUpdateAction):
    """Produces the [Return Info Set](ctp:api:type:ReturnInfoSetMessage) Message."""

    #: Value to set.
    #: If empty, any existing value is removed.
    items: typing.Optional[typing.List["ReturnInfoDraft"]]

    def __init__(
        self, *, items: typing.Optional[typing.List["ReturnInfoDraft"]] = None
    ):
        self.items = items

        super().__init__(action="setReturnInfo")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderSetReturnInfoAction":
        from ._schemas.order import OrderSetReturnInfoActionSchema

        return OrderSetReturnInfoActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderSetReturnInfoActionSchema

        return OrderSetReturnInfoActionSchema().dump(self)


class OrderSetReturnItemCustomFieldAction(OrderUpdateAction):
    #: `id` of the [ReturnItem](ctp:api:type:ReturnItem) to update. Either `returnItemId` or `returnItemKey` is required.
    return_item_id: typing.Optional[str]
    #: `key` of the [ReturnItem](ctp:api:type:ReturnItem) to update. Either `returnItemId` or `returnItemKey` is required.
    return_item_key: typing.Optional[str]
    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: Removing a field that does not exist returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
    #: If `value` is provided, it is set for the field defined by `name`.
    value: typing.Optional[typing.Any]

    def __init__(
        self,
        *,
        return_item_id: typing.Optional[str] = None,
        return_item_key: typing.Optional[str] = None,
        name: str,
        value: typing.Optional[typing.Any] = None
    ):
        self.return_item_id = return_item_id
        self.return_item_key = return_item_key
        self.name = name
        self.value = value

        super().__init__(action="setReturnItemCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderSetReturnItemCustomFieldAction":
        from ._schemas.order import OrderSetReturnItemCustomFieldActionSchema

        return OrderSetReturnItemCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderSetReturnItemCustomFieldActionSchema

        return OrderSetReturnItemCustomFieldActionSchema().dump(self)


class OrderSetReturnItemCustomTypeAction(OrderUpdateAction):
    #: `id` of the [ReturnItem](ctp:api:type:ReturnItem) to update. Either `returnItemId` or `returnItemKey` is required.
    return_item_id: typing.Optional[str]
    #: `key` of the [ReturnItem](ctp:api:type:ReturnItem) to update. Either `returnItemId` or `returnItemKey` is required.
    return_item_key: typing.Optional[str]
    #: Defines the [Type](ctp:api:type:Type) that extends the Return Item with [Custom Fields](/../api/projects/custom-fields).
    #: If absent, any existing Type and Custom Fields are removed from the Return Item.
    type: typing.Optional["TypeResourceIdentifier"]
    #: Sets the [Custom Fields](/../api/projects/custom-fields) fields for the Return Item.
    fields: typing.Optional["FieldContainer"]

    def __init__(
        self,
        *,
        return_item_id: typing.Optional[str] = None,
        return_item_key: typing.Optional[str] = None,
        type: typing.Optional["TypeResourceIdentifier"] = None,
        fields: typing.Optional["FieldContainer"] = None
    ):
        self.return_item_id = return_item_id
        self.return_item_key = return_item_key
        self.type = type
        self.fields = fields

        super().__init__(action="setReturnItemCustomType")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderSetReturnItemCustomTypeAction":
        from ._schemas.order import OrderSetReturnItemCustomTypeActionSchema

        return OrderSetReturnItemCustomTypeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderSetReturnItemCustomTypeActionSchema

        return OrderSetReturnItemCustomTypeActionSchema().dump(self)


class OrderSetReturnPaymentStateAction(OrderUpdateAction):
    """To set a [ReturnPaymentState](ctp:api:type:ReturnPaymentState), the [Order](ctp:api:type:Order) `returnInfo` must have at least one [ReturnItem](ctp:api:type:ReturnItem)."""

    #: `id` of the [ReturnItem](ctp:api:type:ReturnItem) to update. Either `returnItemId` or `returnItemKey` is required.
    return_item_id: typing.Optional[str]
    #: `key` of the [ReturnItem](ctp:api:type:ReturnItem) to update. Either `returnItemId` or `returnItemKey` is required.
    return_item_key: typing.Optional[str]
    #: New Payment status of the [ReturnItem](ctp:api:type:ReturnItem).
    payment_state: "ReturnPaymentState"

    def __init__(
        self,
        *,
        return_item_id: typing.Optional[str] = None,
        return_item_key: typing.Optional[str] = None,
        payment_state: "ReturnPaymentState"
    ):
        self.return_item_id = return_item_id
        self.return_item_key = return_item_key
        self.payment_state = payment_state

        super().__init__(action="setReturnPaymentState")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderSetReturnPaymentStateAction":
        from ._schemas.order import OrderSetReturnPaymentStateActionSchema

        return OrderSetReturnPaymentStateActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderSetReturnPaymentStateActionSchema

        return OrderSetReturnPaymentStateActionSchema().dump(self)


class OrderSetReturnShipmentStateAction(OrderUpdateAction):
    """To set a `ReturnShipmentState`, the [Order](ctp:api:type:Order) `returnInfo` must have at least one [ReturnItem](ctp:api:type:ReturnItem).

    Produces the [Order Return Shipment State Changed](ctp:api:type:OrderReturnShipmentStateChangedMessage) Message.

    """

    #: `id` of the [ReturnItem](ctp:api:type:ReturnItem) to update. Either `returnItemId` or `returnItemKey` is required.
    return_item_id: typing.Optional[str]
    #: `key` of the [ReturnItem](ctp:api:type:ReturnItem) to update. Either `returnItemId` or `returnItemKey` is required.
    return_item_key: typing.Optional[str]
    #: New shipment state of the [ReturnItem](ctp:api:type:ReturnItem).
    shipment_state: "ReturnShipmentState"

    def __init__(
        self,
        *,
        return_item_id: typing.Optional[str] = None,
        return_item_key: typing.Optional[str] = None,
        shipment_state: "ReturnShipmentState"
    ):
        self.return_item_id = return_item_id
        self.return_item_key = return_item_key
        self.shipment_state = shipment_state

        super().__init__(action="setReturnShipmentState")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderSetReturnShipmentStateAction":
        from ._schemas.order import OrderSetReturnShipmentStateActionSchema

        return OrderSetReturnShipmentStateActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderSetReturnShipmentStateActionSchema

        return OrderSetReturnShipmentStateActionSchema().dump(self)


class OrderSetShippingAddressAction(OrderUpdateAction):
    """This action updates the `shippingAddress` on the Order, but it does not change the shipping address on the referenced [Cart](ctp:api:type:Cart) from which the Order is created.
    Also, it does not recalculate the Cart as taxes may not fit to the shipping address anymore.

    Produces the [Order Shipping Address Set](ctp:api:type:OrderShippingAddressSetMessage) Message.

    """

    #: Value to set.
    #: If empty, any existing value is removed.
    address: typing.Optional["BaseAddress"]

    def __init__(self, *, address: typing.Optional["BaseAddress"] = None):
        self.address = address

        super().__init__(action="setShippingAddress")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderSetShippingAddressAction":
        from ._schemas.order import OrderSetShippingAddressActionSchema

        return OrderSetShippingAddressActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderSetShippingAddressActionSchema

        return OrderSetShippingAddressActionSchema().dump(self)


class OrderSetShippingAddressCustomFieldAction(OrderUpdateAction):
    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: Removing a field that does not exist returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
    #: If `value` is provided, it is set for the field defined by `name`.
    value: typing.Optional[typing.Any]

    def __init__(self, *, name: str, value: typing.Optional[typing.Any] = None):
        self.name = name
        self.value = value

        super().__init__(action="setShippingAddressCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderSetShippingAddressCustomFieldAction":
        from ._schemas.order import OrderSetShippingAddressCustomFieldActionSchema

        return OrderSetShippingAddressCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderSetShippingAddressCustomFieldActionSchema

        return OrderSetShippingAddressCustomFieldActionSchema().dump(self)


class OrderSetShippingAddressCustomTypeAction(OrderUpdateAction):
    #: Defines the [Type](ctp:api:type:Type) that extends the `shippingAddress` with [Custom Fields](/../api/projects/custom-fields).
    #: If absent, any existing Type and Custom Fields are removed from the `shippingAddress`.
    type: typing.Optional["TypeResourceIdentifier"]
    #: Sets the [Custom Fields](/../api/projects/custom-fields) fields for the `shippingAddress`.
    fields: typing.Optional["FieldContainer"]

    def __init__(
        self,
        *,
        type: typing.Optional["TypeResourceIdentifier"] = None,
        fields: typing.Optional["FieldContainer"] = None
    ):
        self.type = type
        self.fields = fields

        super().__init__(action="setShippingAddressCustomType")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderSetShippingAddressCustomTypeAction":
        from ._schemas.order import OrderSetShippingAddressCustomTypeActionSchema

        return OrderSetShippingAddressCustomTypeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderSetShippingAddressCustomTypeActionSchema

        return OrderSetShippingAddressCustomTypeActionSchema().dump(self)


class OrderSetStoreAction(OrderUpdateAction):
    """Sets the [Store](ctp:api:type:Store) the Order is assigned to.
    It should be used to migrate Orders to a new Store.
    No validations are performed (such as that the Customer is allowed to create Orders in the Store).

    Produces the [Order Store Set](ctp:api:type:OrderStoreSetMessage) Message.
    Returns a `400` error if `store` references the same Store the Order is currently assigned to, including if you try to remove the value when no Store is currently assigned.

    """

    #: Value to set.
    #: If empty, any existing value is removed.
    #:
    #: If `store` references the same Store the Order is currently assigned to or if you try to remove the value when no Store is currently assigned, a `400` error is returned.
    store: typing.Optional["StoreResourceIdentifier"]

    def __init__(self, *, store: typing.Optional["StoreResourceIdentifier"] = None):
        self.store = store

        super().__init__(action="setStore")

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "OrderSetStoreAction":
        from ._schemas.order import OrderSetStoreActionSchema

        return OrderSetStoreActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderSetStoreActionSchema

        return OrderSetStoreActionSchema().dump(self)


class OrderTransitionCustomLineItemStateAction(OrderUpdateAction):
    """Produces the [Custom Line Item State Transition](ctp:api:type:CustomLineItemStateTransitionMessage) Message."""

    #: `id` of the [CustomLineItem](ctp:api:type:CustomLineItem) to update. Either `customLineItemId` or `customLineItemKey` is required.
    custom_line_item_id: typing.Optional[str]
    #: `key` of the [CustomLineItem](ctp:api:type:CustomLineItem) to update. Either `customLineItemId` or `customLineItemKey` is required.
    custom_line_item_key: typing.Optional[str]
    #: Number of Custom Line Items that should transition [State](ctp:api:type:State).
    quantity: int
    #: [State](ctp:api:type:State) the Custom Line Item should transition from.
    from_state: "StateResourceIdentifier"
    #: [State](ctp:api:type:State) the Custom Line Item should transition to.
    to_state: "StateResourceIdentifier"
    #: Date and time (UTC) to perform the [State](ctp:api:type:State) transition.
    actual_transition_date: typing.Optional[datetime.datetime]

    def __init__(
        self,
        *,
        custom_line_item_id: typing.Optional[str] = None,
        custom_line_item_key: typing.Optional[str] = None,
        quantity: int,
        from_state: "StateResourceIdentifier",
        to_state: "StateResourceIdentifier",
        actual_transition_date: typing.Optional[datetime.datetime] = None
    ):
        self.custom_line_item_id = custom_line_item_id
        self.custom_line_item_key = custom_line_item_key
        self.quantity = quantity
        self.from_state = from_state
        self.to_state = to_state
        self.actual_transition_date = actual_transition_date

        super().__init__(action="transitionCustomLineItemState")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderTransitionCustomLineItemStateAction":
        from ._schemas.order import OrderTransitionCustomLineItemStateActionSchema

        return OrderTransitionCustomLineItemStateActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderTransitionCustomLineItemStateActionSchema

        return OrderTransitionCustomLineItemStateActionSchema().dump(self)


class OrderTransitionLineItemStateAction(OrderUpdateAction):
    """Produces the [Line Item State Transition](ctp:api:type:LineItemStateTransitionMessage) Message."""

    #: `id` of the [LineItem](ctp:api:type:LineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    line_item_id: typing.Optional[str]
    #: `key` of the [LineItem](ctp:api:type:LineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    line_item_key: typing.Optional[str]
    #: Number of Line Items that should transition [State](ctp:api:type:State).
    quantity: int
    #: [State](ctp:api:type:State) the Line Item should transition from.
    from_state: "StateResourceIdentifier"
    #: [State](ctp:api:type:State) the Line Item should transition to.
    to_state: "StateResourceIdentifier"
    #: Date and time (UTC) to perform the [State](ctp:api:type:State) transition.
    actual_transition_date: typing.Optional[datetime.datetime]

    def __init__(
        self,
        *,
        line_item_id: typing.Optional[str] = None,
        line_item_key: typing.Optional[str] = None,
        quantity: int,
        from_state: "StateResourceIdentifier",
        to_state: "StateResourceIdentifier",
        actual_transition_date: typing.Optional[datetime.datetime] = None
    ):
        self.line_item_id = line_item_id
        self.line_item_key = line_item_key
        self.quantity = quantity
        self.from_state = from_state
        self.to_state = to_state
        self.actual_transition_date = actual_transition_date

        super().__init__(action="transitionLineItemState")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderTransitionLineItemStateAction":
        from ._schemas.order import OrderTransitionLineItemStateActionSchema

        return OrderTransitionLineItemStateActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderTransitionLineItemStateActionSchema

        return OrderTransitionLineItemStateActionSchema().dump(self)


class OrderTransitionStateAction(OrderUpdateAction):
    """If the existing [State](ctp:api:type:State) has set `transitions`, there must be a direct transition to the new State.
    If `transitions` is not set, no validation is performed.

    This update action produces the [Order State Transition](ctp:api:type:OrderStateTransitionMessage) Message.

    """

    #: Value to set.
    #: If there is no State yet, the new State must be an initial State.
    state: "StateResourceIdentifier"
    #: Set to `true` to turn off validation.
    force: typing.Optional[bool]

    def __init__(
        self, *, state: "StateResourceIdentifier", force: typing.Optional[bool] = None
    ):
        self.state = state
        self.force = force

        super().__init__(action="transitionState")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderTransitionStateAction":
        from ._schemas.order import OrderTransitionStateActionSchema

        return OrderTransitionStateActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderTransitionStateActionSchema

        return OrderTransitionStateActionSchema().dump(self)


class OrderUpdateItemShippingAddressAction(OrderUpdateAction):
    """Updates an address in `itemShippingAddresses` by keeping the Address `key`."""

    #: The new Address with the same `key` as the Address it will replace.
    address: "BaseAddress"

    def __init__(self, *, address: "BaseAddress"):
        self.address = address

        super().__init__(action="updateItemShippingAddress")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderUpdateItemShippingAddressAction":
        from ._schemas.order import OrderUpdateItemShippingAddressActionSchema

        return OrderUpdateItemShippingAddressActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderUpdateItemShippingAddressActionSchema

        return OrderUpdateItemShippingAddressActionSchema().dump(self)


class OrderUpdateSyncInfoAction(OrderUpdateAction):
    #: Set this to identify an external order instance, file, or other resource.
    external_id: typing.Optional[str]
    #: The synchronization destination to set. Must not be empty.
    #: The referenced Channel must have the [Channel Role](ctp:api:type:ChannelRoleEnum) `OrderExport` or `OrderImport`.
    #: Otherwise this update action returns an [InvalidInput](ctp:api:type:InvalidInputError) error.
    channel: "ChannelResourceIdentifier"
    #: If not set, it defaults to the current date and time.
    synced_at: typing.Optional[datetime.datetime]

    def __init__(
        self,
        *,
        external_id: typing.Optional[str] = None,
        channel: "ChannelResourceIdentifier",
        synced_at: typing.Optional[datetime.datetime] = None
    ):
        self.external_id = external_id
        self.channel = channel
        self.synced_at = synced_at

        super().__init__(action="updateSyncInfo")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderUpdateSyncInfoAction":
        from ._schemas.order import OrderUpdateSyncInfoActionSchema

        return OrderUpdateSyncInfoActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order import OrderUpdateSyncInfoActionSchema

        return OrderUpdateSyncInfoActionSchema().dump(self)
