# This file is automatically generated by the rmf-codegen project.
#
# The Python code generator is maintained by Lab Digital. If you want to
# contribute to this project then please do not edit this file directly
# but send a pull request to the Lab Digital fork of rmf-codegen at
# https://github.com/labd/rmf-codegen

import datetime
import enum
import typing

from ._abstract import _BaseType
from .cart import (
    CartOrigin,
    CustomLineItemPriceMode,
    InventoryMode,
    RoundingMode,
    ShippingMode,
    TaxCalculationMode,
    TaxMode,
)
from .common import BaseResource, Reference, ReferenceTypeId, ResourceIdentifier
from .order import (
    Order,
    OrderState,
    PaymentState,
    ReturnPaymentState,
    ReturnShipmentState,
    ShipmentState,
    StagedOrderUpdateAction,
)

if typing.TYPE_CHECKING:
    from .business_unit import BusinessUnitKeyReference
    from .cart import (
        CartOrigin,
        CartReference,
        CustomLineItem,
        CustomLineItemPriceMode,
        DirectDiscount,
        DirectDiscountDraft,
        DiscountCodeInfo,
        DiscountOnTotalPrice,
        ExternalLineItemTotalPrice,
        ExternalTaxAmountDraft,
        ExternalTaxRateDraft,
        InventoryMode,
        ItemShippingDetailsDraft,
        LineItem,
        RoundingMode,
        Shipping,
        ShippingInfo,
        ShippingMode,
        ShippingRateInput,
        ShippingRateInputDraft,
        TaxCalculationMode,
        TaxedPrice,
        TaxMode,
        TaxPortionDraft,
    )
    from .cart_discount import CartDiscountReference
    from .channel import ChannelResourceIdentifier
    from .common import (
        Address,
        BaseAddress,
        CreatedBy,
        LastModifiedBy,
        LocalizedString,
        Money,
        ReferenceTypeId,
        TypedMoney,
    )
    from .customer_group import CustomerGroupReference, CustomerGroupResourceIdentifier
    from .discount_code import DiscountCodeReference
    from .error import ErrorObject
    from .message import MessagePayload
    from .order import (
        DeliveryItem,
        ItemState,
        OrderReference,
        OrderState,
        ParcelDraft,
        ParcelMeasurements,
        PaymentInfo,
        PaymentState,
        ReturnInfo,
        ReturnInfoDraft,
        ReturnItemDraft,
        ReturnPaymentState,
        ReturnShipmentState,
        ShipmentState,
        StagedOrderUpdateAction,
        SyncInfo,
        TrackingData,
    )
    from .payment import PaymentResourceIdentifier
    from .quote import QuoteReference
    from .shipping_method import ShippingMethodResourceIdentifier, ShippingRateDraft
    from .shopping_list import ShoppingListResourceIdentifier
    from .state import StateReference, StateResourceIdentifier
    from .store import StoreKeyReference, StoreResourceIdentifier
    from .tax_category import TaxCategoryResourceIdentifier
    from .type import (
        CustomFields,
        CustomFieldsDraft,
        FieldContainer,
        TypeResourceIdentifier,
    )

__all__ = [
    "OrderEdit",
    "OrderEditAddStagedActionAction",
    "OrderEditApplied",
    "OrderEditApply",
    "OrderEditDraft",
    "OrderEditNotProcessed",
    "OrderEditPagedQueryResponse",
    "OrderEditPreviewFailure",
    "OrderEditPreviewSuccess",
    "OrderEditReference",
    "OrderEditResourceIdentifier",
    "OrderEditResult",
    "OrderEditSetCommentAction",
    "OrderEditSetCustomFieldAction",
    "OrderEditSetCustomTypeAction",
    "OrderEditSetKeyAction",
    "OrderEditSetStagedActionsAction",
    "OrderEditUpdate",
    "OrderEditUpdateAction",
    "OrderExcerpt",
    "StagedOrder",
    "StagedOrderAddCustomLineItemAction",
    "StagedOrderAddDeliveryAction",
    "StagedOrderAddDiscountCodeAction",
    "StagedOrderAddItemShippingAddressAction",
    "StagedOrderAddLineItemAction",
    "StagedOrderAddParcelToDeliveryAction",
    "StagedOrderAddPaymentAction",
    "StagedOrderAddReturnInfoAction",
    "StagedOrderAddShoppingListAction",
    "StagedOrderChangeCustomLineItemMoneyAction",
    "StagedOrderChangeCustomLineItemQuantityAction",
    "StagedOrderChangeLineItemQuantityAction",
    "StagedOrderChangeOrderStateAction",
    "StagedOrderChangePaymentStateAction",
    "StagedOrderChangeShipmentStateAction",
    "StagedOrderChangeTaxCalculationModeAction",
    "StagedOrderChangeTaxModeAction",
    "StagedOrderChangeTaxRoundingModeAction",
    "StagedOrderImportCustomLineItemStateAction",
    "StagedOrderImportLineItemStateAction",
    "StagedOrderRemoveCustomLineItemAction",
    "StagedOrderRemoveDeliveryAction",
    "StagedOrderRemoveDiscountCodeAction",
    "StagedOrderRemoveItemShippingAddressAction",
    "StagedOrderRemoveLineItemAction",
    "StagedOrderRemoveParcelFromDeliveryAction",
    "StagedOrderRemovePaymentAction",
    "StagedOrderSetBillingAddressAction",
    "StagedOrderSetBillingAddressCustomFieldAction",
    "StagedOrderSetBillingAddressCustomTypeAction",
    "StagedOrderSetCountryAction",
    "StagedOrderSetCustomFieldAction",
    "StagedOrderSetCustomLineItemCustomFieldAction",
    "StagedOrderSetCustomLineItemCustomTypeAction",
    "StagedOrderSetCustomLineItemShippingDetailsAction",
    "StagedOrderSetCustomLineItemTaxAmountAction",
    "StagedOrderSetCustomLineItemTaxRateAction",
    "StagedOrderSetCustomShippingMethodAction",
    "StagedOrderSetCustomTypeAction",
    "StagedOrderSetCustomerEmailAction",
    "StagedOrderSetCustomerGroupAction",
    "StagedOrderSetCustomerIdAction",
    "StagedOrderSetDeliveryAddressAction",
    "StagedOrderSetDeliveryAddressCustomFieldAction",
    "StagedOrderSetDeliveryAddressCustomTypeAction",
    "StagedOrderSetDeliveryCustomFieldAction",
    "StagedOrderSetDeliveryCustomTypeAction",
    "StagedOrderSetDeliveryItemsAction",
    "StagedOrderSetDirectDiscountsAction",
    "StagedOrderSetItemShippingAddressCustomFieldAction",
    "StagedOrderSetItemShippingAddressCustomTypeAction",
    "StagedOrderSetLineItemCustomFieldAction",
    "StagedOrderSetLineItemCustomTypeAction",
    "StagedOrderSetLineItemDistributionChannelAction",
    "StagedOrderSetLineItemPriceAction",
    "StagedOrderSetLineItemShippingDetailsAction",
    "StagedOrderSetLineItemTaxAmountAction",
    "StagedOrderSetLineItemTaxRateAction",
    "StagedOrderSetLineItemTotalPriceAction",
    "StagedOrderSetLocaleAction",
    "StagedOrderSetOrderNumberAction",
    "StagedOrderSetOrderTotalTaxAction",
    "StagedOrderSetParcelCustomFieldAction",
    "StagedOrderSetParcelCustomTypeAction",
    "StagedOrderSetParcelItemsAction",
    "StagedOrderSetParcelMeasurementsAction",
    "StagedOrderSetParcelTrackingDataAction",
    "StagedOrderSetPurchaseOrderNumberAction",
    "StagedOrderSetReturnInfoAction",
    "StagedOrderSetReturnItemCustomFieldAction",
    "StagedOrderSetReturnItemCustomTypeAction",
    "StagedOrderSetReturnPaymentStateAction",
    "StagedOrderSetReturnShipmentStateAction",
    "StagedOrderSetShippingAddressAction",
    "StagedOrderSetShippingAddressAndCustomShippingMethodAction",
    "StagedOrderSetShippingAddressAndShippingMethodAction",
    "StagedOrderSetShippingAddressCustomFieldAction",
    "StagedOrderSetShippingAddressCustomTypeAction",
    "StagedOrderSetShippingMethodAction",
    "StagedOrderSetShippingMethodTaxAmountAction",
    "StagedOrderSetShippingMethodTaxRateAction",
    "StagedOrderSetShippingRateInputAction",
    "StagedOrderSetStoreAction",
    "StagedOrderTransitionCustomLineItemStateAction",
    "StagedOrderTransitionLineItemStateAction",
    "StagedOrderTransitionStateAction",
    "StagedOrderUpdateItemShippingAddressAction",
    "StagedOrderUpdateSyncInfoAction",
]


class OrderEdit(BaseResource):
    #: User-defined unique identifier of the Order Edit.
    key: typing.Optional[str]
    #: [Reference](ctp:api:type:Reference) to the Order updated with this edit.
    resource: "OrderReference"
    #: Update actions applied to the Order referenced by `resource`.
    staged_actions: typing.List["StagedOrderUpdateAction"]
    #: For applied edits, it's a summary of the changes on the Order.
    #: For unapplied edits, it's a preview of the changes.
    result: "OrderEditResult"
    #: User-defined information regarding the Order Edit.
    comment: typing.Optional[str]
    #: Custom Fields of the Order Edit.
    custom: typing.Optional["CustomFields"]
    #: Present on resources created after 1 February 2019 except for [events not tracked](/../api/general-concepts#events-tracked).
    last_modified_by: typing.Optional["LastModifiedBy"]
    #: Present on resources created after 1 February 2019 except for [events not tracked](/../api/general-concepts#events-tracked).
    created_by: typing.Optional["CreatedBy"]

    def __init__(
        self,
        *,
        id: str,
        version: int,
        created_at: datetime.datetime,
        last_modified_at: datetime.datetime,
        key: typing.Optional[str] = None,
        resource: "OrderReference",
        staged_actions: typing.List["StagedOrderUpdateAction"],
        result: "OrderEditResult",
        comment: typing.Optional[str] = None,
        custom: typing.Optional["CustomFields"] = None,
        last_modified_by: typing.Optional["LastModifiedBy"] = None,
        created_by: typing.Optional["CreatedBy"] = None
    ):
        self.key = key
        self.resource = resource
        self.staged_actions = staged_actions
        self.result = result
        self.comment = comment
        self.custom = custom
        self.last_modified_by = last_modified_by
        self.created_by = created_by

        super().__init__(
            id=id,
            version=version,
            created_at=created_at,
            last_modified_at=last_modified_at,
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "OrderEdit":
        from ._schemas.order_edit import OrderEditSchema

        return OrderEditSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import OrderEditSchema

        return OrderEditSchema().dump(self)


class OrderEditApply(_BaseType):
    """If the `editVersion` and/or `resourceVersion` do not match the actual version, a [ConcurrentModification](ctp:api:type:ConcurrentModificationError) error will be returned."""

    #: Current `version` of the OrderEdit to be applied.
    edit_version: int
    #: Current `version` of the [Order](ctp:api:type:Order) to which the OrderEdit is applied.
    resource_version: int

    def __init__(self, *, edit_version: int, resource_version: int):
        self.edit_version = edit_version
        self.resource_version = resource_version

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "OrderEditApply":
        from ._schemas.order_edit import OrderEditApplySchema

        return OrderEditApplySchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import OrderEditApplySchema

        return OrderEditApplySchema().dump(self)


class OrderEditDraft(_BaseType):
    #: User-defined unique identifier for the Order Edit.
    key: typing.Optional[str]
    #: [Reference](ctp:api:type:Reference) to the Order updated with this edit.
    resource: "OrderReference"
    #: Update actions to apply to the Order referenced in `resource`.
    #: Cannot be updated if the [edit has been applied](ctp:api:endpoint:/{projectKey}/orders/edits/{id}/apply:POST).
    staged_actions: typing.Optional[typing.List["StagedOrderUpdateAction"]]
    #: Custom Fields for the Order Edit.
    custom: typing.Optional["CustomFieldsDraft"]
    #: User-defined description regarding the Order Edit.
    comment: typing.Optional[str]
    #: Set to `true` if you want to [peview](ctp:api:type:OrderEditPreviewSuccess) the edited Order first without persisting it (dry run).
    #: A dry run allows checking for potential [errors](ctp:api:type:OrderEditPreviewFailure) when trying to apply the `stagedActions`.
    #:
    #: Order [API Extensions](/../api/projects/api-extensions), if any, are also called in dry runs.
    dry_run: typing.Optional[bool]

    def __init__(
        self,
        *,
        key: typing.Optional[str] = None,
        resource: "OrderReference",
        staged_actions: typing.Optional[typing.List["StagedOrderUpdateAction"]] = None,
        custom: typing.Optional["CustomFieldsDraft"] = None,
        comment: typing.Optional[str] = None,
        dry_run: typing.Optional[bool] = None
    ):
        self.key = key
        self.resource = resource
        self.staged_actions = staged_actions
        self.custom = custom
        self.comment = comment
        self.dry_run = dry_run

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "OrderEditDraft":
        from ._schemas.order_edit import OrderEditDraftSchema

        return OrderEditDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import OrderEditDraftSchema

        return OrderEditDraftSchema().dump(self)


class OrderEditPagedQueryResponse(_BaseType):
    """[PagedQueryResult](/../api/general-concepts#pagedqueryresult) with `results` containing an array of [OrderEdit](ctp:api:type:OrderEdit)."""

    #: Number of [results requested](/../api/general-concepts#limit).
    limit: int
    #: Number of [elements skipped](/../api/general-concepts#offset).
    offset: int
    #: Actual number of results returned.
    count: int
    #: Total number of results matching the query.
    #: This number is an estimation that is not [strongly consistent](/../api/general-concepts#strong-consistency).
    #: This field is returned by default.
    #: For improved performance, calculating this field can be deactivated by using the query parameter `withTotal=false`.
    #: When the results are filtered with a [Query Predicate](/../api/predicates/query), `total` is subject to a [limit](/../api/limits#queries).
    total: typing.Optional[int]
    #: [OrderEdits](ctp:api:type:OrderEdit) matching the query.
    results: typing.List["OrderEdit"]

    def __init__(
        self,
        *,
        limit: int,
        offset: int,
        count: int,
        total: typing.Optional[int] = None,
        results: typing.List["OrderEdit"]
    ):
        self.limit = limit
        self.offset = offset
        self.count = count
        self.total = total
        self.results = results

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderEditPagedQueryResponse":
        from ._schemas.order_edit import OrderEditPagedQueryResponseSchema

        return OrderEditPagedQueryResponseSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import OrderEditPagedQueryResponseSchema

        return OrderEditPagedQueryResponseSchema().dump(self)


class OrderEditReference(Reference):
    """[Reference](ctp:api:type:Reference) to an [OrderEdit](ctp:api:type:OrderEdit)."""

    #: Contains the representation of the expanded Order Edit. Only present in responses to requests with [Reference Expansion](/../api/general-concepts#reference-expansion) for Order Edits.
    obj: typing.Optional["OrderEdit"]

    def __init__(self, *, id: str, obj: typing.Optional["OrderEdit"] = None):
        self.obj = obj

        super().__init__(id=id, type_id=ReferenceTypeId.ORDER_EDIT)

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "OrderEditReference":
        from ._schemas.order_edit import OrderEditReferenceSchema

        return OrderEditReferenceSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import OrderEditReferenceSchema

        return OrderEditReferenceSchema().dump(self)


class OrderEditResourceIdentifier(ResourceIdentifier):
    """[ResourceIdentifier](ctp:api:type:ResourceIdentifier) to an [OrderEdit](ctp:api:type:OrderEdit). Either `id` or `key` is required. If both are set, an [InvalidJsonInput](/../api/errors#invalidjsoninput) error is returned."""

    def __init__(
        self, *, id: typing.Optional[str] = None, key: typing.Optional[str] = None
    ):

        super().__init__(id=id, key=key, type_id=ReferenceTypeId.ORDER_EDIT)

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderEditResourceIdentifier":
        from ._schemas.order_edit import OrderEditResourceIdentifierSchema

        return OrderEditResourceIdentifierSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import OrderEditResourceIdentifierSchema

        return OrderEditResourceIdentifierSchema().dump(self)


class OrderEditResult(_BaseType):
    type: str

    def __init__(self, *, type: str):
        self.type = type

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "OrderEditResult":
        if data["type"] == "Applied":
            from ._schemas.order_edit import OrderEditAppliedSchema

            return OrderEditAppliedSchema().load(data)
        if data["type"] == "NotProcessed":
            from ._schemas.order_edit import OrderEditNotProcessedSchema

            return OrderEditNotProcessedSchema().load(data)
        if data["type"] == "PreviewFailure":
            from ._schemas.order_edit import OrderEditPreviewFailureSchema

            return OrderEditPreviewFailureSchema().load(data)
        if data["type"] == "PreviewSuccess":
            from ._schemas.order_edit import OrderEditPreviewSuccessSchema

            return OrderEditPreviewSuccessSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import OrderEditResultSchema

        return OrderEditResultSchema().dump(self)


class OrderEditApplied(OrderEditResult):
    """Result of a succesful application of `stagedActions` to the Order."""

    #: Date and time (UTC) the Order was edited.
    applied_at: datetime.datetime
    #: Prices of the Order before the edit.
    excerpt_before_edit: "OrderExcerpt"
    #: Prices of the Order after the edit.
    excerpt_after_edit: "OrderExcerpt"

    def __init__(
        self,
        *,
        applied_at: datetime.datetime,
        excerpt_before_edit: "OrderExcerpt",
        excerpt_after_edit: "OrderExcerpt"
    ):
        self.applied_at = applied_at
        self.excerpt_before_edit = excerpt_before_edit
        self.excerpt_after_edit = excerpt_after_edit

        super().__init__(type="Applied")

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "OrderEditApplied":
        from ._schemas.order_edit import OrderEditAppliedSchema

        return OrderEditAppliedSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import OrderEditAppliedSchema

        return OrderEditAppliedSchema().dump(self)


class OrderEditNotProcessed(OrderEditResult):
    """Indicates that the edit has not been applied or processed in any way."""

    def __init__(self):

        super().__init__(type="NotProcessed")

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "OrderEditNotProcessed":
        from ._schemas.order_edit import OrderEditNotProcessedSchema

        return OrderEditNotProcessedSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import OrderEditNotProcessedSchema

        return OrderEditNotProcessedSchema().dump(self)


class OrderEditPreviewFailure(OrderEditResult):
    """Result of a failed application of `stagedActions` to the Order. The data is calculated on the fly and is not queryable."""

    #: Errors returned.
    errors: typing.List["ErrorObject"]

    def __init__(self, *, errors: typing.List["ErrorObject"]):
        self.errors = errors

        super().__init__(type="PreviewFailure")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderEditPreviewFailure":
        from ._schemas.order_edit import OrderEditPreviewFailureSchema

        return OrderEditPreviewFailureSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import OrderEditPreviewFailureSchema

        return OrderEditPreviewFailureSchema().dump(self)


class OrderEditPreviewSuccess(OrderEditResult):
    """The data is not persisted but is dynamically pulled by dry-running the update actions from `stagedActions` on the current version of the related [Order](ctp:api:type:Order), not from the Order version at the time the OrderEdit was created. Therefore, it cannot be queried."""

    #: A preview of the edited [Order](ctp:api:type:Order) as it will be after all `stagedActions` (incl. optional Order [API Extensions](/../api/projects/api-extensions)) are applied.
    preview: "StagedOrder"
    #: Messages that will be generated if the edit is applied.
    message_payloads: typing.List["MessagePayload"]

    def __init__(
        self, *, preview: "StagedOrder", message_payloads: typing.List["MessagePayload"]
    ):
        self.preview = preview
        self.message_payloads = message_payloads

        super().__init__(type="PreviewSuccess")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderEditPreviewSuccess":
        from ._schemas.order_edit import OrderEditPreviewSuccessSchema

        return OrderEditPreviewSuccessSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import OrderEditPreviewSuccessSchema

        return OrderEditPreviewSuccessSchema().dump(self)


class OrderEditUpdate(_BaseType):
    #: Expected version of the Order Edit on which the changes should be applied.
    #: If the expected version does not match the actual version, a [ConcurrentModification](ctp:api:type:ConcurrentModificationError) error will be returned.
    version: int
    #: Update actions to be performed on the Order Edit.
    actions: typing.List["OrderEditUpdateAction"]
    #: If set to `true`, the Order Edit is applied on the [Order](ctp:api:type:Order) without persisting it.
    dry_run: typing.Optional[bool]

    def __init__(
        self,
        *,
        version: int,
        actions: typing.List["OrderEditUpdateAction"],
        dry_run: typing.Optional[bool] = None
    ):
        self.version = version
        self.actions = actions
        self.dry_run = dry_run

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "OrderEditUpdate":
        from ._schemas.order_edit import OrderEditUpdateSchema

        return OrderEditUpdateSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import OrderEditUpdateSchema

        return OrderEditUpdateSchema().dump(self)


class OrderEditUpdateAction(_BaseType):
    action: str

    def __init__(self, *, action: str):
        self.action = action

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "OrderEditUpdateAction":
        if data["action"] == "addStagedAction":
            from ._schemas.order_edit import OrderEditAddStagedActionActionSchema

            return OrderEditAddStagedActionActionSchema().load(data)
        if data["action"] == "setComment":
            from ._schemas.order_edit import OrderEditSetCommentActionSchema

            return OrderEditSetCommentActionSchema().load(data)
        if data["action"] == "setCustomField":
            from ._schemas.order_edit import OrderEditSetCustomFieldActionSchema

            return OrderEditSetCustomFieldActionSchema().load(data)
        if data["action"] == "setCustomType":
            from ._schemas.order_edit import OrderEditSetCustomTypeActionSchema

            return OrderEditSetCustomTypeActionSchema().load(data)
        if data["action"] == "setKey":
            from ._schemas.order_edit import OrderEditSetKeyActionSchema

            return OrderEditSetKeyActionSchema().load(data)
        if data["action"] == "setStagedActions":
            from ._schemas.order_edit import OrderEditSetStagedActionsActionSchema

            return OrderEditSetStagedActionsActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import OrderEditUpdateActionSchema

        return OrderEditUpdateActionSchema().dump(self)


class OrderExcerpt(_BaseType):
    """Excerpt of the Order extracting the total and the taxed price."""

    #: Total price of the Order.
    total_price: "TypedMoney"
    #: Taxed price of the Order.
    taxed_price: typing.Optional["TaxedPrice"]
    #: Current version of the Order.
    version: int

    def __init__(
        self,
        *,
        total_price: "TypedMoney",
        taxed_price: typing.Optional["TaxedPrice"] = None,
        version: int
    ):
        self.total_price = total_price
        self.taxed_price = taxed_price
        self.version = version

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "OrderExcerpt":
        from ._schemas.order_edit import OrderExcerptSchema

        return OrderExcerptSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import OrderExcerptSchema

        return OrderExcerptSchema().dump(self)


class StagedOrder(Order):

    def __init__(
        self,
        *,
        id: str,
        version: int,
        created_at: datetime.datetime,
        last_modified_at: datetime.datetime,
        order_number: typing.Optional[str] = None,
        purchase_order_number: typing.Optional[str] = None,
        customer_id: typing.Optional[str] = None,
        customer_email: typing.Optional[str] = None,
        customer_group: typing.Optional["CustomerGroupReference"] = None,
        anonymous_id: typing.Optional[str] = None,
        business_unit: typing.Optional["BusinessUnitKeyReference"] = None,
        store: typing.Optional["StoreKeyReference"] = None,
        line_items: typing.List["LineItem"],
        custom_line_items: typing.List["CustomLineItem"],
        total_price: "TypedMoney",
        taxed_price: typing.Optional["TaxedPrice"] = None,
        taxed_shipping_price: typing.Optional["TaxedPrice"] = None,
        discount_on_total_price: typing.Optional["DiscountOnTotalPrice"] = None,
        tax_mode: typing.Optional["TaxMode"] = None,
        tax_rounding_mode: typing.Optional["RoundingMode"] = None,
        tax_calculation_mode: typing.Optional["TaxCalculationMode"] = None,
        inventory_mode: typing.Optional["InventoryMode"] = None,
        billing_address: typing.Optional["Address"] = None,
        shipping_address: typing.Optional["Address"] = None,
        shipping_mode: "ShippingMode",
        shipping_key: typing.Optional[str] = None,
        shipping_info: typing.Optional["ShippingInfo"] = None,
        shipping_rate_input: typing.Optional["ShippingRateInput"] = None,
        shipping_custom_fields: typing.Optional["CustomFields"] = None,
        shipping: typing.List["Shipping"],
        item_shipping_addresses: typing.Optional[typing.List["Address"]] = None,
        discount_codes: typing.Optional[typing.List["DiscountCodeInfo"]] = None,
        direct_discounts: typing.Optional[typing.List["DirectDiscount"]] = None,
        refused_gifts: typing.List["CartDiscountReference"],
        payment_info: typing.Optional["PaymentInfo"] = None,
        country: typing.Optional[str] = None,
        locale: typing.Optional[str] = None,
        origin: "CartOrigin",
        cart: typing.Optional["CartReference"] = None,
        quote: typing.Optional["QuoteReference"] = None,
        order_state: "OrderState",
        shipment_state: typing.Optional["ShipmentState"] = None,
        payment_state: typing.Optional["PaymentState"] = None,
        state: typing.Optional["StateReference"] = None,
        sync_info: typing.List["SyncInfo"],
        return_info: typing.Optional[typing.List["ReturnInfo"]] = None,
        last_message_sequence_number: typing.Optional[int] = None,
        custom: typing.Optional["CustomFields"] = None,
        completed_at: typing.Optional[datetime.datetime] = None,
        last_modified_by: typing.Optional["LastModifiedBy"] = None,
        created_by: typing.Optional["CreatedBy"] = None
    ):

        super().__init__(
            id=id,
            version=version,
            created_at=created_at,
            last_modified_at=last_modified_at,
            order_number=order_number,
            purchase_order_number=purchase_order_number,
            customer_id=customer_id,
            customer_email=customer_email,
            customer_group=customer_group,
            anonymous_id=anonymous_id,
            business_unit=business_unit,
            store=store,
            line_items=line_items,
            custom_line_items=custom_line_items,
            total_price=total_price,
            taxed_price=taxed_price,
            taxed_shipping_price=taxed_shipping_price,
            discount_on_total_price=discount_on_total_price,
            tax_mode=tax_mode,
            tax_rounding_mode=tax_rounding_mode,
            tax_calculation_mode=tax_calculation_mode,
            inventory_mode=inventory_mode,
            billing_address=billing_address,
            shipping_address=shipping_address,
            shipping_mode=shipping_mode,
            shipping_key=shipping_key,
            shipping_info=shipping_info,
            shipping_rate_input=shipping_rate_input,
            shipping_custom_fields=shipping_custom_fields,
            shipping=shipping,
            item_shipping_addresses=item_shipping_addresses,
            discount_codes=discount_codes,
            direct_discounts=direct_discounts,
            refused_gifts=refused_gifts,
            payment_info=payment_info,
            country=country,
            locale=locale,
            origin=origin,
            cart=cart,
            quote=quote,
            order_state=order_state,
            shipment_state=shipment_state,
            payment_state=payment_state,
            state=state,
            sync_info=sync_info,
            return_info=return_info,
            last_message_sequence_number=last_message_sequence_number,
            custom=custom,
            completed_at=completed_at,
            last_modified_by=last_modified_by,
            created_by=created_by,
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "StagedOrder":
        from ._schemas.order_edit import StagedOrderSchema

        return StagedOrderSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderSchema

        return StagedOrderSchema().dump(self)


class OrderEditAddStagedActionAction(OrderEditUpdateAction):
    """If the [edit was applied](ctp:api:endpoint:/{projectKey}/orders/edits/{id}/apply:POST), this cannot be updated."""

    #: Order update action to append to the `stagedActions` array.
    staged_action: "StagedOrderUpdateAction"

    def __init__(self, *, staged_action: "StagedOrderUpdateAction"):
        self.staged_action = staged_action

        super().__init__(action="addStagedAction")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderEditAddStagedActionAction":
        from ._schemas.order_edit import OrderEditAddStagedActionActionSchema

        return OrderEditAddStagedActionActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import OrderEditAddStagedActionActionSchema

        return OrderEditAddStagedActionActionSchema().dump(self)


class OrderEditSetCommentAction(OrderEditUpdateAction):
    #: Value to set.
    #: If empty, any existing value will be removed.
    comment: typing.Optional[str]

    def __init__(self, *, comment: typing.Optional[str] = None):
        self.comment = comment

        super().__init__(action="setComment")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderEditSetCommentAction":
        from ._schemas.order_edit import OrderEditSetCommentActionSchema

        return OrderEditSetCommentActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import OrderEditSetCommentActionSchema

        return OrderEditSetCommentActionSchema().dump(self)


class OrderEditSetCustomFieldAction(OrderEditUpdateAction):
    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: Removing a field that does not exist returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
    #: If `value` is provided, it is set for the field defined by `name`.
    value: typing.Optional[typing.Any]

    def __init__(self, *, name: str, value: typing.Optional[typing.Any] = None):
        self.name = name
        self.value = value

        super().__init__(action="setCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderEditSetCustomFieldAction":
        from ._schemas.order_edit import OrderEditSetCustomFieldActionSchema

        return OrderEditSetCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import OrderEditSetCustomFieldActionSchema

        return OrderEditSetCustomFieldActionSchema().dump(self)


class OrderEditSetCustomTypeAction(OrderEditUpdateAction):
    #: Defines the [Type](ctp:api:type:Type) that extends the Order Edit with [Custom Fields](/../api/projects/custom-fields).
    #: If absent, any existing Type and Custom Fields are removed from the Order Edit.
    type: typing.Optional["TypeResourceIdentifier"]
    #: Sets the [Custom Fields](/../api/projects/custom-fields) fields for the Order Edit.
    fields: typing.Optional["FieldContainer"]

    def __init__(
        self,
        *,
        type: typing.Optional["TypeResourceIdentifier"] = None,
        fields: typing.Optional["FieldContainer"] = None
    ):
        self.type = type
        self.fields = fields

        super().__init__(action="setCustomType")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderEditSetCustomTypeAction":
        from ._schemas.order_edit import OrderEditSetCustomTypeActionSchema

        return OrderEditSetCustomTypeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import OrderEditSetCustomTypeActionSchema

        return OrderEditSetCustomTypeActionSchema().dump(self)


class OrderEditSetKeyAction(OrderEditUpdateAction):
    #: Value to set.
    #: If empty, any existing value will be removed.
    key: typing.Optional[str]

    def __init__(self, *, key: typing.Optional[str] = None):
        self.key = key

        super().__init__(action="setKey")

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "OrderEditSetKeyAction":
        from ._schemas.order_edit import OrderEditSetKeyActionSchema

        return OrderEditSetKeyActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import OrderEditSetKeyActionSchema

        return OrderEditSetKeyActionSchema().dump(self)


class OrderEditSetStagedActionsAction(OrderEditUpdateAction):
    """If the [edit is applied](ctp:api:endpoint:/{projectKey}/orders/edits/{id}/apply:POST), `stagedActions` cannot be updated."""

    #: Value to replace the `stagedActions` of the Order Edit.
    staged_actions: typing.List["StagedOrderUpdateAction"]

    def __init__(self, *, staged_actions: typing.List["StagedOrderUpdateAction"]):
        self.staged_actions = staged_actions

        super().__init__(action="setStagedActions")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "OrderEditSetStagedActionsAction":
        from ._schemas.order_edit import OrderEditSetStagedActionsActionSchema

        return OrderEditSetStagedActionsActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import OrderEditSetStagedActionsActionSchema

        return OrderEditSetStagedActionsActionSchema().dump(self)


class StagedOrderAddCustomLineItemAction(StagedOrderUpdateAction):
    """If the Cart already contains a [CustomLineItem](ctp:api:type:CustomLineItem) with the same `slug`, `name`, `money`, `taxCategory`, `state`,
    and Custom Fields, then only the quantity of the existing Custom Line Item is increased.
    If [CustomLineItem](ctp:api:type:CustomLineItem) `shippingDetails` are set, they are merged with the `targets` that already exist on the
    [ItemShippingDetails](ctp:api:type:ItemShippingDetails) of the Custom Line Item.
    In case of overlapping address keys the [ItemShippingTarget](ctp:api:type:ItemShippingTarget) `quantity` is summed up.

    If the Cart already contains a Custom Line Item with the same slug that is otherwise not identical, an [InvalidOperation](ctp:api:type:InvalidOperationError) error is returned.

    If the Tax Rate is not set, a [MissingTaxRateForCountry](ctp:api:type:MissingTaxRateForCountryError) error is returned.

    """

    #: Money value of the Custom Line Item. The value can be negative.
    money: "Money"
    #: Name of the Custom Line Item.
    name: "LocalizedString"
    #: User-defined unique identifier of the Custom Line Item.
    key: typing.Optional[str]
    #: Number of Custom Line Items to add to the Cart.
    quantity: typing.Optional[int]
    #: User-defined identifier used in a deep-link URL for the Custom Line Item. It must match the pattern `[a-zA-Z0-9_-]{2,256}`.
    slug: str
    #: Used to select a Tax Rate when a Cart has the `Platform` [TaxMode](ctp:api:type:TaxMode).
    #: If [TaxMode](ctp:api:type:TaxMode) is `Platform`, this field must not be empty.
    tax_category: typing.Optional["TaxCategoryResourceIdentifier"]
    #: An external Tax Rate can be set if the Cart has the `External` [TaxMode](ctp:api:type:TaxMode).
    external_tax_rate: typing.Optional["ExternalTaxRateDraft"]
    #: Container for Custom Line Item-specific addresses.
    shipping_details: typing.Optional["ItemShippingDetailsDraft"]
    #: - If `Standard`, Cart Discounts with a matching [CartDiscountCustomLineItemsTarget](ctp:api:type:CartDiscountCustomLineItemsTarget)
    #: are applied to the Custom Line Item.
    #: - If `External`, Cart Discounts are not considered on the Custom Line Item.
    price_mode: typing.Optional["CustomLineItemPriceMode"]
    #: Custom Fields for the Custom Line Item.
    custom: typing.Optional["CustomFieldsDraft"]

    def __init__(
        self,
        *,
        money: "Money",
        name: "LocalizedString",
        key: typing.Optional[str] = None,
        quantity: typing.Optional[int] = None,
        slug: str,
        tax_category: typing.Optional["TaxCategoryResourceIdentifier"] = None,
        external_tax_rate: typing.Optional["ExternalTaxRateDraft"] = None,
        shipping_details: typing.Optional["ItemShippingDetailsDraft"] = None,
        price_mode: typing.Optional["CustomLineItemPriceMode"] = None,
        custom: typing.Optional["CustomFieldsDraft"] = None
    ):
        self.money = money
        self.name = name
        self.key = key
        self.quantity = quantity
        self.slug = slug
        self.tax_category = tax_category
        self.external_tax_rate = external_tax_rate
        self.shipping_details = shipping_details
        self.price_mode = price_mode
        self.custom = custom

        super().__init__(action="addCustomLineItem")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderAddCustomLineItemAction":
        from ._schemas.order_edit import StagedOrderAddCustomLineItemActionSchema

        return StagedOrderAddCustomLineItemActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderAddCustomLineItemActionSchema

        return StagedOrderAddCustomLineItemActionSchema().dump(self)


class StagedOrderAddDeliveryAction(StagedOrderUpdateAction):
    """A [Delivery](ctp:api:type:Delivery) can only be added to an [Order](ctp:api:type:Order) if
    its `shippingInfo` (for `shippingMode` = `Single`), or its `shipping` (for `shippingMode` = `Multiple`) exists.

    Produces the [Delivery Added](ctp:api:type:DeliveryAddedMessage) Message.

    """

    #: `key` of an existing [Delivery](ctp:api:type:Delivery).
    delivery_key: typing.Optional[str]
    #: `key` of the [ShippingMethod](ctp:api:type:ShippingMethod), required for `Multiple` [ShippingMode](ctp:api:type:ShippingMode).
    shipping_key: typing.Optional[str]
    #: Items to be included in the Delivery.
    items: typing.Optional[typing.List["DeliveryItem"]]
    #: Address the `parcels` should be delivered to.
    address: typing.Optional["BaseAddress"]
    #: Parcels of the Delivery.
    #:
    #: If provided, this update action also produces the [Parcel Added To Delivery](ctp:api:type:ParcelAddedToDeliveryMessage) Message.
    parcels: typing.Optional[typing.List["ParcelDraft"]]
    #: Custom Fields for the Delivery.
    custom: typing.Optional["CustomFieldsDraft"]

    def __init__(
        self,
        *,
        delivery_key: typing.Optional[str] = None,
        shipping_key: typing.Optional[str] = None,
        items: typing.Optional[typing.List["DeliveryItem"]] = None,
        address: typing.Optional["BaseAddress"] = None,
        parcels: typing.Optional[typing.List["ParcelDraft"]] = None,
        custom: typing.Optional["CustomFieldsDraft"] = None
    ):
        self.delivery_key = delivery_key
        self.shipping_key = shipping_key
        self.items = items
        self.address = address
        self.parcels = parcels
        self.custom = custom

        super().__init__(action="addDelivery")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderAddDeliveryAction":
        from ._schemas.order_edit import StagedOrderAddDeliveryActionSchema

        return StagedOrderAddDeliveryActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderAddDeliveryActionSchema

        return StagedOrderAddDeliveryActionSchema().dump(self)


class StagedOrderAddDiscountCodeAction(StagedOrderUpdateAction):
    """Adds a [DiscountCode](ctp:api:type:DiscountCode) to the Cart to activate the related [Cart Discounts](/../api/projects/cartDiscounts).
    Adding a Discount Code is only possible if no [DirectDiscount](ctp:api:type:DirectDiscount) has been applied to the Order.

    The maximum number of Discount Codes in a Cart is restricted by a [limit](/../api/limits#carts).

    Specific Error Code: [MatchingPriceNotFound](ctp:api:type:MatchingPriceNotFoundError)

    """

    #: `code` of a [DiscountCode](ctp:api:type:DiscountCode).
    code: str

    def __init__(self, *, code: str):
        self.code = code

        super().__init__(action="addDiscountCode")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderAddDiscountCodeAction":
        from ._schemas.order_edit import StagedOrderAddDiscountCodeActionSchema

        return StagedOrderAddDiscountCodeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderAddDiscountCodeActionSchema

        return StagedOrderAddDiscountCodeActionSchema().dump(self)


class StagedOrderAddItemShippingAddressAction(StagedOrderUpdateAction):
    """Adds an address to an Order when shipping to multiple addresses is desired."""

    #: Address to append to `itemShippingAddresses`.
    #: The new Address must have a `key` that is unique across this Order.
    address: "BaseAddress"

    def __init__(self, *, address: "BaseAddress"):
        self.address = address

        super().__init__(action="addItemShippingAddress")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderAddItemShippingAddressAction":
        from ._schemas.order_edit import StagedOrderAddItemShippingAddressActionSchema

        return StagedOrderAddItemShippingAddressActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderAddItemShippingAddressActionSchema

        return StagedOrderAddItemShippingAddressActionSchema().dump(self)


class StagedOrderAddLineItemAction(StagedOrderUpdateAction):
    """If the Cart contains a [LineItem](ctp:api:type:LineItem) for a Product Variant with the same [LineItemMode](ctp:api:type:LineItemMode), [Custom Fields](/../api/projects/custom-fields), supply and distribution channel, then only the quantity of the existing Line Item is increased.
    If [LineItem](ctp:api:type:LineItem) `shippingDetails` is set, it is merged. All addresses will be present afterwards and, for address keys present in both shipping details, the quantity will be summed up.
    A new Line Item is added when the `externalPrice` or `externalTotalPrice` is set in this update action.
    The [LineItem](ctp:api:type:LineItem) price is set as described in [LineItem Price selection](ctp:api:type:LineItemPriceSelection).

    If the Tax Rate is not set, a [MissingTaxRateForCountry](ctp:api:type:MissingTaxRateForCountryError) error is returned.

    If the Line Items do not have a Price according to the [Product](ctp:api:type:Product) `priceMode` value for a selected currency and/or country, Customer Group, or Channel, a [MatchingPriceNotFound](ctp:api:type:MatchingPriceNotFoundError) error is returned.

    """

    #: User-defined unique identifier of the LineItem.
    key: typing.Optional[str]
    #: `id` of the published [Product](ctp:api:type:Product).
    #:
    #: Either the `productId` and `variantId`, or `sku` must be provided.
    product_id: typing.Optional[str]
    #: `id` of the [ProductVariant](ctp:api:type:ProductVariant) in the Product.
    #: If not provided, the Master Variant is used.
    #:
    #: Either the `productId` and `variantId`, or `sku` must be provided.
    variant_id: typing.Optional[int]
    #: SKU of the [ProductVariant](ctp:api:type:ProductVariant).
    #:
    #: Either the `productId` and `variantId`, or `sku` must be provided.
    sku: typing.Optional[str]
    #: Quantity of the Product Variant to add to the Cart.
    quantity: typing.Optional[int]
    #: Date and time (UTC) the Product Variant is added to the Cart.
    #: If not set, it defaults to the current date and time.
    #:
    #: Optional for backwards compatibility reasons.
    added_at: typing.Optional[datetime.datetime]
    #: Used to [select](/../api/carts-orders-overview#line-item-price-selection) a Product Price.
    #: The Channel must have the `ProductDistribution` [ChannelRoleEnum](ctp:api:type:ChannelRoleEnum).
    #: If the Cart is bound to a [Store](ctp:api:type:Store) with `distributionChannels` set, the Channel must match one of the Store's distribution channels.
    distribution_channel: typing.Optional["ChannelResourceIdentifier"]
    #: Used to identify [Inventory entries](/../api/projects/inventory) that must be reserved.
    #: The Channel must have the `InventorySupply` [ChannelRoleEnum](ctp:api:type:ChannelRoleEnum).
    supply_channel: typing.Optional["ChannelResourceIdentifier"]
    #: Sets the [LineItem](ctp:api:type:LineItem) `price` value, and the `priceMode` to `ExternalPrice` [LineItemPriceMode](ctp:api:type:LineItemPriceMode).
    external_price: typing.Optional["Money"]
    #: Sets the [LineItem](ctp:api:type:LineItem) `price` and `totalPrice` values, and the `priceMode` to `ExternalTotal` [LineItemPriceMode](ctp:api:type:LineItemPriceMode).
    external_total_price: typing.Optional["ExternalLineItemTotalPrice"]
    #: External Tax Rate for the Line Item, if the Cart has the `External` [TaxMode](ctp:api:type:TaxMode).
    external_tax_rate: typing.Optional["ExternalTaxRateDraft"]
    #: Inventory mode specific to the Line Item only, and valid for the entire `quantity` of the Line Item.
    #: Set only if the inventory mode should be different from the `inventoryMode` specified on the [Cart](ctp:api:type:Cart).
    inventory_mode: typing.Optional["InventoryMode"]
    #: Container for Line Item-specific addresses.
    shipping_details: typing.Optional["ItemShippingDetailsDraft"]
    #: Custom Fields for the Line Item.
    custom: typing.Optional["CustomFieldsDraft"]

    def __init__(
        self,
        *,
        key: typing.Optional[str] = None,
        product_id: typing.Optional[str] = None,
        variant_id: typing.Optional[int] = None,
        sku: typing.Optional[str] = None,
        quantity: typing.Optional[int] = None,
        added_at: typing.Optional[datetime.datetime] = None,
        distribution_channel: typing.Optional["ChannelResourceIdentifier"] = None,
        supply_channel: typing.Optional["ChannelResourceIdentifier"] = None,
        external_price: typing.Optional["Money"] = None,
        external_total_price: typing.Optional["ExternalLineItemTotalPrice"] = None,
        external_tax_rate: typing.Optional["ExternalTaxRateDraft"] = None,
        inventory_mode: typing.Optional["InventoryMode"] = None,
        shipping_details: typing.Optional["ItemShippingDetailsDraft"] = None,
        custom: typing.Optional["CustomFieldsDraft"] = None
    ):
        self.key = key
        self.product_id = product_id
        self.variant_id = variant_id
        self.sku = sku
        self.quantity = quantity
        self.added_at = added_at
        self.distribution_channel = distribution_channel
        self.supply_channel = supply_channel
        self.external_price = external_price
        self.external_total_price = external_total_price
        self.external_tax_rate = external_tax_rate
        self.inventory_mode = inventory_mode
        self.shipping_details = shipping_details
        self.custom = custom

        super().__init__(action="addLineItem")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderAddLineItemAction":
        from ._schemas.order_edit import StagedOrderAddLineItemActionSchema

        return StagedOrderAddLineItemActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderAddLineItemActionSchema

        return StagedOrderAddLineItemActionSchema().dump(self)


class StagedOrderAddParcelToDeliveryAction(StagedOrderUpdateAction):
    """To add a Parcel, at least one [Delivery](ctp:api:type:Delivery) must exist.

    Produces the [Parcel Added To Delivery](ctp:api:type:ParcelAddedToDeliveryMessage) Message.

    """

    #: `id` of an existing [Delivery](ctp:api:type:Delivery).
    #:
    #: Either `deliveryId` or `deliveryKey` must be provided.
    delivery_id: typing.Optional[str]
    #: `key` of an existing [Delivery](ctp:api:type:Delivery).
    #:
    #: Either `deliveryId` or `deliveryKey` must be provided.
    delivery_key: typing.Optional[str]
    #: `key` of an existing [Parcel](ctp:api:type:Parcel).
    parcel_key: typing.Optional[str]
    #: Value to set.
    measurements: typing.Optional["ParcelMeasurements"]
    #: Value to set.
    tracking_data: typing.Optional["TrackingData"]
    #: Value to set.
    items: typing.Optional[typing.List["DeliveryItem"]]
    #: Custom Fields for the Parcel.
    custom: typing.Optional["CustomFieldsDraft"]

    def __init__(
        self,
        *,
        delivery_id: typing.Optional[str] = None,
        delivery_key: typing.Optional[str] = None,
        parcel_key: typing.Optional[str] = None,
        measurements: typing.Optional["ParcelMeasurements"] = None,
        tracking_data: typing.Optional["TrackingData"] = None,
        items: typing.Optional[typing.List["DeliveryItem"]] = None,
        custom: typing.Optional["CustomFieldsDraft"] = None
    ):
        self.delivery_id = delivery_id
        self.delivery_key = delivery_key
        self.parcel_key = parcel_key
        self.measurements = measurements
        self.tracking_data = tracking_data
        self.items = items
        self.custom = custom

        super().__init__(action="addParcelToDelivery")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderAddParcelToDeliveryAction":
        from ._schemas.order_edit import StagedOrderAddParcelToDeliveryActionSchema

        return StagedOrderAddParcelToDeliveryActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderAddParcelToDeliveryActionSchema

        return StagedOrderAddParcelToDeliveryActionSchema().dump(self)


class StagedOrderAddPaymentAction(StagedOrderUpdateAction):
    #: Payment to add to the [PaymentInfo](ctp:api:type:PaymentInfo).
    #: Must not be assigned to another Order or active Cart already.
    payment: "PaymentResourceIdentifier"

    def __init__(self, *, payment: "PaymentResourceIdentifier"):
        self.payment = payment

        super().__init__(action="addPayment")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderAddPaymentAction":
        from ._schemas.order_edit import StagedOrderAddPaymentActionSchema

        return StagedOrderAddPaymentActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderAddPaymentActionSchema

        return StagedOrderAddPaymentActionSchema().dump(self)


class StagedOrderAddReturnInfoAction(StagedOrderUpdateAction):
    """Produces the [Return Info Added](ctp:api:type:ReturnInfoAddedMessage) Message."""

    #: Value to set.
    return_tracking_id: typing.Optional[str]
    #: Items to be returned.
    #: Must not be empty.
    items: typing.List["ReturnItemDraft"]
    #: Value to set.
    #: If not set, it defaults to the current date and time.
    return_date: typing.Optional[datetime.datetime]

    def __init__(
        self,
        *,
        return_tracking_id: typing.Optional[str] = None,
        items: typing.List["ReturnItemDraft"],
        return_date: typing.Optional[datetime.datetime] = None
    ):
        self.return_tracking_id = return_tracking_id
        self.items = items
        self.return_date = return_date

        super().__init__(action="addReturnInfo")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderAddReturnInfoAction":
        from ._schemas.order_edit import StagedOrderAddReturnInfoActionSchema

        return StagedOrderAddReturnInfoActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderAddReturnInfoActionSchema

        return StagedOrderAddReturnInfoActionSchema().dump(self)


class StagedOrderAddShoppingListAction(StagedOrderUpdateAction):
    """Adds all [LineItems](ctp:api:type:LineItem) of a [ShoppingList](ctp:api:type:ShoppingList) to the Cart."""

    #: Shopping List that contains the Line Items to be added.
    shopping_list: "ShoppingListResourceIdentifier"
    #: `distributionChannel` to set for all [LineItems](ctp:api:type:LineItem) that are added to the Cart.
    #: The Channel must have the `ProductDistribution` [ChannelRoleEnum](ctp:api:type:ChannelRoleEnum).
    distribution_channel: typing.Optional["ChannelResourceIdentifier"]
    #: `supplyChannel` to set for all [LineItems](ctp:api:type:LineItem) that are added to the Cart.
    #: The Channel must have the `InventorySupply` [ChannelRoleEnum](ctp:api:type:ChannelRoleEnum).
    supply_channel: typing.Optional["ChannelResourceIdentifier"]

    def __init__(
        self,
        *,
        shopping_list: "ShoppingListResourceIdentifier",
        distribution_channel: typing.Optional["ChannelResourceIdentifier"] = None,
        supply_channel: typing.Optional["ChannelResourceIdentifier"] = None
    ):
        self.shopping_list = shopping_list
        self.distribution_channel = distribution_channel
        self.supply_channel = supply_channel

        super().__init__(action="addShoppingList")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderAddShoppingListAction":
        from ._schemas.order_edit import StagedOrderAddShoppingListActionSchema

        return StagedOrderAddShoppingListActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderAddShoppingListActionSchema

        return StagedOrderAddShoppingListActionSchema().dump(self)


class StagedOrderChangeCustomLineItemMoneyAction(StagedOrderUpdateAction):
    #: `id` of the [CustomLineItem](ctp:api:type:CustomLineItem) to update. Either `customLineItemId` or `customLineItemKey` is required.
    custom_line_item_id: typing.Optional[str]
    #: `key` of the [CustomLineItem](ctp:api:type:CustomLineItem) to update. Either `customLineItemId` or `customLineItemKey` is required.
    custom_line_item_key: typing.Optional[str]
    #: Value to set.
    #: Must not be empty.
    #: Can be a negative amount.
    money: "Money"

    def __init__(
        self,
        *,
        custom_line_item_id: typing.Optional[str] = None,
        custom_line_item_key: typing.Optional[str] = None,
        money: "Money"
    ):
        self.custom_line_item_id = custom_line_item_id
        self.custom_line_item_key = custom_line_item_key
        self.money = money

        super().__init__(action="changeCustomLineItemMoney")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderChangeCustomLineItemMoneyAction":
        from ._schemas.order_edit import (
            StagedOrderChangeCustomLineItemMoneyActionSchema,
        )

        return StagedOrderChangeCustomLineItemMoneyActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import (
            StagedOrderChangeCustomLineItemMoneyActionSchema,
        )

        return StagedOrderChangeCustomLineItemMoneyActionSchema().dump(self)


class StagedOrderChangeCustomLineItemQuantityAction(StagedOrderUpdateAction):
    """When multiple shipping addresses are set for a Custom Line Item, use the [Add CustomLineItem](ctp:api:type:StagedOrderAddCustomLineItemAction) update action to change the shipping details. Since it is not possible for the API to infer how the overall change in the Custom Line Item quantity should be distributed over the sub-quantities, the `shippingDetails` field is kept in its current state to avoid data loss.

    To change the Custom Line Item quantity and shipping details together, use this update action in combination with the [Set CustomLineItem ShippingDetails](ctp:api:type:StagedOrderSetCustomLineItemShippingDetailsAction) update action in a single Order update command.

    """

    #: `id` of the [CustomLineItem](ctp:api:type:CustomLineItem) to update. Either `customLineItemId` or `customLineItemKey` is required.
    custom_line_item_id: typing.Optional[str]
    #: `key` of the [CustomLineItem](ctp:api:type:CustomLineItem) to update. Either `customLineItemId` or `customLineItemKey` is required.
    custom_line_item_key: typing.Optional[str]
    #: New value to set.
    #: If `0`, the Custom Line Item is removed from the Order.
    quantity: int

    def __init__(
        self,
        *,
        custom_line_item_id: typing.Optional[str] = None,
        custom_line_item_key: typing.Optional[str] = None,
        quantity: int
    ):
        self.custom_line_item_id = custom_line_item_id
        self.custom_line_item_key = custom_line_item_key
        self.quantity = quantity

        super().__init__(action="changeCustomLineItemQuantity")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderChangeCustomLineItemQuantityAction":
        from ._schemas.order_edit import (
            StagedOrderChangeCustomLineItemQuantityActionSchema,
        )

        return StagedOrderChangeCustomLineItemQuantityActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import (
            StagedOrderChangeCustomLineItemQuantityActionSchema,
        )

        return StagedOrderChangeCustomLineItemQuantityActionSchema().dump(self)


class StagedOrderChangeLineItemQuantityAction(StagedOrderUpdateAction):
    """When multiple shipping addresses are set for a Line Item, use the [Remove LineItem](ctp:api:type:StagedOrderRemoveLineItemAction) and [Add LineItem](ctp:api:type:StagedOrderAddLineItemAction) update action to change the shipping details. Since it is not possible for the API to infer how the overall change in the Line Item quantity should be distributed over the sub-quantities, the `shippingDetails` field is kept in its current state to avoid data loss.

    To change the Line Item quantity and shipping details together, use this update action in combination with the [Set LineItem ShippingDetails](ctp:api:type:StagedOrderSetLineItemShippingDetailsAction) update action in a single Order update command.

    The [LineItem](ctp:api:type:LineItem) price is updated as described in [LineItem Price selection](ctp:api:type:LineItemPriceSelection).

    """

    #: `id` of the [LineItem](ctp:api:type:LineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    line_item_id: typing.Optional[str]
    #: `key` of the [LineItem](ctp:api:type:LineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    line_item_key: typing.Optional[str]
    #: New value to set.
    #: If `0`, the LineItem is removed from the Order.
    quantity: int
    #: Sets the [LineItem](ctp:api:type:LineItem) `price` to the given value when changing the quantity of a Line Item with the `ExternalPrice` [LineItemPriceMode](ctp:api:type:LineItemPriceMode).
    #:
    #: The [LineItem](ctp:api:type:LineItem) price is updated as described in [LineItem Price selection](ctp:api:type:LineItemPriceSelection).
    external_price: typing.Optional["Money"]
    #: Sets the [LineItem](ctp:api:type:LineItem) `price` and `totalPrice` to the given value when changing the quantity of a Line Item with the `ExternalTotal` [LineItemPriceMode](ctp:api:type:LineItemPriceMode).
    external_total_price: typing.Optional["ExternalLineItemTotalPrice"]

    def __init__(
        self,
        *,
        line_item_id: typing.Optional[str] = None,
        line_item_key: typing.Optional[str] = None,
        quantity: int,
        external_price: typing.Optional["Money"] = None,
        external_total_price: typing.Optional["ExternalLineItemTotalPrice"] = None
    ):
        self.line_item_id = line_item_id
        self.line_item_key = line_item_key
        self.quantity = quantity
        self.external_price = external_price
        self.external_total_price = external_total_price

        super().__init__(action="changeLineItemQuantity")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderChangeLineItemQuantityAction":
        from ._schemas.order_edit import StagedOrderChangeLineItemQuantityActionSchema

        return StagedOrderChangeLineItemQuantityActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderChangeLineItemQuantityActionSchema

        return StagedOrderChangeLineItemQuantityActionSchema().dump(self)


class StagedOrderChangeOrderStateAction(StagedOrderUpdateAction):
    """Produces the [Order State Changed](ctp:api:type:OrderStateChangedMessage) Message."""

    #: New status of the Order.
    order_state: "OrderState"

    def __init__(self, *, order_state: "OrderState"):
        self.order_state = order_state

        super().__init__(action="changeOrderState")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderChangeOrderStateAction":
        from ._schemas.order_edit import StagedOrderChangeOrderStateActionSchema

        return StagedOrderChangeOrderStateActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderChangeOrderStateActionSchema

        return StagedOrderChangeOrderStateActionSchema().dump(self)


class StagedOrderChangePaymentStateAction(StagedOrderUpdateAction):
    """Produces the [Order Payment State Changed](ctp:api:type:OrderPaymentStateChangedMessage) Message."""

    #: New payment status of the Order.
    payment_state: "PaymentState"

    def __init__(self, *, payment_state: "PaymentState"):
        self.payment_state = payment_state

        super().__init__(action="changePaymentState")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderChangePaymentStateAction":
        from ._schemas.order_edit import StagedOrderChangePaymentStateActionSchema

        return StagedOrderChangePaymentStateActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderChangePaymentStateActionSchema

        return StagedOrderChangePaymentStateActionSchema().dump(self)


class StagedOrderChangeShipmentStateAction(StagedOrderUpdateAction):
    """Produces the [Order Shipment State Changed](ctp:api:type:OrderShipmentStateChangedMessage) Message."""

    #: New shipment status of the Order.
    shipment_state: "ShipmentState"

    def __init__(self, *, shipment_state: "ShipmentState"):
        self.shipment_state = shipment_state

        super().__init__(action="changeShipmentState")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderChangeShipmentStateAction":
        from ._schemas.order_edit import StagedOrderChangeShipmentStateActionSchema

        return StagedOrderChangeShipmentStateActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderChangeShipmentStateActionSchema

        return StagedOrderChangeShipmentStateActionSchema().dump(self)


class StagedOrderChangeTaxCalculationModeAction(StagedOrderUpdateAction):
    """Changing the tax calculation mode leads to [recalculation of taxes](/../api/carts-orders-overview#cart-tax-calculation)."""

    #: New value to set.
    tax_calculation_mode: "TaxCalculationMode"

    def __init__(self, *, tax_calculation_mode: "TaxCalculationMode"):
        self.tax_calculation_mode = tax_calculation_mode

        super().__init__(action="changeTaxCalculationMode")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderChangeTaxCalculationModeAction":
        from ._schemas.order_edit import StagedOrderChangeTaxCalculationModeActionSchema

        return StagedOrderChangeTaxCalculationModeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderChangeTaxCalculationModeActionSchema

        return StagedOrderChangeTaxCalculationModeActionSchema().dump(self)


class StagedOrderChangeTaxModeAction(StagedOrderUpdateAction):
    """- When `External` [TaxMode](ctp:api:type:TaxMode) is changed to `Platform` or `Disabled`, all previously set external Tax Rates are removed.
    - When set to `Platform`, Line Items, Custom Line Items, and Shipping Method require a Tax Category with a Tax Rate for the Cart's `shippingAddress`.

    """

    #: The new TaxMode.
    tax_mode: "TaxMode"

    def __init__(self, *, tax_mode: "TaxMode"):
        self.tax_mode = tax_mode

        super().__init__(action="changeTaxMode")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderChangeTaxModeAction":
        from ._schemas.order_edit import StagedOrderChangeTaxModeActionSchema

        return StagedOrderChangeTaxModeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderChangeTaxModeActionSchema

        return StagedOrderChangeTaxModeActionSchema().dump(self)


class StagedOrderChangeTaxRoundingModeAction(StagedOrderUpdateAction):
    """Changing the tax rounding mode leads to [recalculation of taxes](/../api/carts-orders-overview#cart-tax-calculation)."""

    #: New value to set.
    tax_rounding_mode: "RoundingMode"

    def __init__(self, *, tax_rounding_mode: "RoundingMode"):
        self.tax_rounding_mode = tax_rounding_mode

        super().__init__(action="changeTaxRoundingMode")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderChangeTaxRoundingModeAction":
        from ._schemas.order_edit import StagedOrderChangeTaxRoundingModeActionSchema

        return StagedOrderChangeTaxRoundingModeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderChangeTaxRoundingModeActionSchema

        return StagedOrderChangeTaxRoundingModeActionSchema().dump(self)


class StagedOrderImportCustomLineItemStateAction(StagedOrderUpdateAction):
    """The import of States does not follow any predefined rules and should be only used if no transitions are defined.
    The `quantity` of the [ItemStates](ctp:api:type:ItemState) must match the sum of all Custom Line Item states' quantities.

    """

    #: `id` of the [CustomLineItem](ctp:api:type:CustomLineItem) to update. Either `customLineItemId` or `customLineItemKey` is required.
    custom_line_item_id: typing.Optional[str]
    #: `key` of the [CustomLineItem](ctp:api:type:CustomLineItem) to update. Either `customLineItemId` or `customLineItemKey` is required.
    custom_line_item_key: typing.Optional[str]
    #: New status of the Custom Line Items.
    state: typing.List["ItemState"]

    def __init__(
        self,
        *,
        custom_line_item_id: typing.Optional[str] = None,
        custom_line_item_key: typing.Optional[str] = None,
        state: typing.List["ItemState"]
    ):
        self.custom_line_item_id = custom_line_item_id
        self.custom_line_item_key = custom_line_item_key
        self.state = state

        super().__init__(action="importCustomLineItemState")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderImportCustomLineItemStateAction":
        from ._schemas.order_edit import (
            StagedOrderImportCustomLineItemStateActionSchema,
        )

        return StagedOrderImportCustomLineItemStateActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import (
            StagedOrderImportCustomLineItemStateActionSchema,
        )

        return StagedOrderImportCustomLineItemStateActionSchema().dump(self)


class StagedOrderImportLineItemStateAction(StagedOrderUpdateAction):
    """The import of States does not follow any predefined rules and should be only used if no transitions are defined.
    The `quantity` in the [ItemStates](ctp:api:type:ItemState) must match the sum of all Line Item states' quantities.

    """

    #: `id` of the [LineItem](ctp:api:type:LineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    line_item_id: typing.Optional[str]
    #: `key` of the [LineItem](ctp:api:type:LineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    line_item_key: typing.Optional[str]
    #: New status of the Line Items.
    state: typing.List["ItemState"]

    def __init__(
        self,
        *,
        line_item_id: typing.Optional[str] = None,
        line_item_key: typing.Optional[str] = None,
        state: typing.List["ItemState"]
    ):
        self.line_item_id = line_item_id
        self.line_item_key = line_item_key
        self.state = state

        super().__init__(action="importLineItemState")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderImportLineItemStateAction":
        from ._schemas.order_edit import StagedOrderImportLineItemStateActionSchema

        return StagedOrderImportLineItemStateActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderImportLineItemStateActionSchema

        return StagedOrderImportLineItemStateActionSchema().dump(self)


class StagedOrderRemoveCustomLineItemAction(StagedOrderUpdateAction):
    """This update action does not support specifying a quantity, unlike the [Remove LineItem](ctp:api:type:StagedOrderRemoveLineItemAction) update action.

    If `shippingDetails` must be partially removed, use the [Change CustomLineItem Quantity](ctp:api:type:StagedOrderChangeCustomLineItemQuantityAction) update action.

    """

    #: `id` of the [CustomLineItem](ctp:api:type:CustomLineItem) to update. Either `customLineItemId` or `customLineItemKey` is required.
    custom_line_item_id: typing.Optional[str]
    #: `key` of the [CustomLineItem](ctp:api:type:CustomLineItem) to update. Either `customLineItemId` or `customLineItemKey` is required.
    custom_line_item_key: typing.Optional[str]

    def __init__(
        self,
        *,
        custom_line_item_id: typing.Optional[str] = None,
        custom_line_item_key: typing.Optional[str] = None
    ):
        self.custom_line_item_id = custom_line_item_id
        self.custom_line_item_key = custom_line_item_key

        super().__init__(action="removeCustomLineItem")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderRemoveCustomLineItemAction":
        from ._schemas.order_edit import StagedOrderRemoveCustomLineItemActionSchema

        return StagedOrderRemoveCustomLineItemActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderRemoveCustomLineItemActionSchema

        return StagedOrderRemoveCustomLineItemActionSchema().dump(self)


class StagedOrderRemoveDeliveryAction(StagedOrderUpdateAction):
    """Produces the [DeliveryRemoved](ctp:api:type:DeliveryRemovedMessage) Message."""

    #: `id` of an existing [Delivery](ctp:api:type:Delivery).
    #:
    #: Either `deliveryId` or `deliveryKey` must be provided.
    delivery_id: typing.Optional[str]
    #: `key` of an existing [Delivery](ctp:api:type:Delivery).
    #:
    #: Either `deliveryId` or `deliveryKey` must be provided.
    delivery_key: typing.Optional[str]

    def __init__(
        self,
        *,
        delivery_id: typing.Optional[str] = None,
        delivery_key: typing.Optional[str] = None
    ):
        self.delivery_id = delivery_id
        self.delivery_key = delivery_key

        super().__init__(action="removeDelivery")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderRemoveDeliveryAction":
        from ._schemas.order_edit import StagedOrderRemoveDeliveryActionSchema

        return StagedOrderRemoveDeliveryActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderRemoveDeliveryActionSchema

        return StagedOrderRemoveDeliveryActionSchema().dump(self)


class StagedOrderRemoveDiscountCodeAction(StagedOrderUpdateAction):
    #: Discount Code to remove from the Cart.
    discount_code: "DiscountCodeReference"

    def __init__(self, *, discount_code: "DiscountCodeReference"):
        self.discount_code = discount_code

        super().__init__(action="removeDiscountCode")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderRemoveDiscountCodeAction":
        from ._schemas.order_edit import StagedOrderRemoveDiscountCodeActionSchema

        return StagedOrderRemoveDiscountCodeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderRemoveDiscountCodeActionSchema

        return StagedOrderRemoveDiscountCodeActionSchema().dump(self)


class StagedOrderRemoveItemShippingAddressAction(StagedOrderUpdateAction):
    """An address can only be removed if it is not referenced in any [ItemShippingTarget](ctp:api:type:ItemShippingTarget) of the Cart."""

    #: `key` of the Address to remove from `itemShippingAddresses`.
    address_key: str

    def __init__(self, *, address_key: str):
        self.address_key = address_key

        super().__init__(action="removeItemShippingAddress")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderRemoveItemShippingAddressAction":
        from ._schemas.order_edit import (
            StagedOrderRemoveItemShippingAddressActionSchema,
        )

        return StagedOrderRemoveItemShippingAddressActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import (
            StagedOrderRemoveItemShippingAddressActionSchema,
        )

        return StagedOrderRemoveItemShippingAddressActionSchema().dump(self)


class StagedOrderRemoveLineItemAction(StagedOrderUpdateAction):
    """The [LineItem](ctp:api:type:LineItem) price is updated as described in [LineItem Price selection](ctp:api:type:LineItemPriceSelection)."""

    #: `id` of the [LineItem](ctp:api:type:LineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    line_item_id: typing.Optional[str]
    #: `key` of the [LineItem](ctp:api:type:LineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    line_item_key: typing.Optional[str]
    #: New value to set.
    #: If absent or `0`, the Line Item is removed from the Cart.
    quantity: typing.Optional[int]
    #: Sets the [LineItem](ctp:api:type:LineItem) `price` to the given value when decreasing the quantity of a Line Item with the `ExternalPrice` [LineItemPriceMode](ctp:api:type:LineItemPriceMode).
    external_price: typing.Optional["Money"]
    #: Sets the [LineItem](ctp:api:type:LineItem) `price` and `totalPrice` to the given value when decreasing the quantity of a Line Item with the `ExternalTotal` [LineItemPriceMode](ctp:api:type:LineItemPriceMode).
    external_total_price: typing.Optional["ExternalLineItemTotalPrice"]
    #: Container for Line Item-specific addresses to remove.
    shipping_details_to_remove: typing.Optional["ItemShippingDetailsDraft"]

    def __init__(
        self,
        *,
        line_item_id: typing.Optional[str] = None,
        line_item_key: typing.Optional[str] = None,
        quantity: typing.Optional[int] = None,
        external_price: typing.Optional["Money"] = None,
        external_total_price: typing.Optional["ExternalLineItemTotalPrice"] = None,
        shipping_details_to_remove: typing.Optional["ItemShippingDetailsDraft"] = None
    ):
        self.line_item_id = line_item_id
        self.line_item_key = line_item_key
        self.quantity = quantity
        self.external_price = external_price
        self.external_total_price = external_total_price
        self.shipping_details_to_remove = shipping_details_to_remove

        super().__init__(action="removeLineItem")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderRemoveLineItemAction":
        from ._schemas.order_edit import StagedOrderRemoveLineItemActionSchema

        return StagedOrderRemoveLineItemActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderRemoveLineItemActionSchema

        return StagedOrderRemoveLineItemActionSchema().dump(self)


class StagedOrderRemoveParcelFromDeliveryAction(StagedOrderUpdateAction):
    """Produces the [ParcelRemovedFromDelivery](ctp:api:type:ParcelRemovedFromDeliveryMessage) Message."""

    #: `id` of an existing [Parcel](ctp:api:type:Parcel).
    #:
    #: Either `parcelId` or `parcelKey` must be provided.
    parcel_id: typing.Optional[str]
    #: `key` of an existing [Parcel](ctp:api:type:Parcel).
    #:
    #: Either `parcelId` or `parcelKey` must be provided.
    parcel_key: typing.Optional[str]

    def __init__(
        self,
        *,
        parcel_id: typing.Optional[str] = None,
        parcel_key: typing.Optional[str] = None
    ):
        self.parcel_id = parcel_id
        self.parcel_key = parcel_key

        super().__init__(action="removeParcelFromDelivery")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderRemoveParcelFromDeliveryAction":
        from ._schemas.order_edit import StagedOrderRemoveParcelFromDeliveryActionSchema

        return StagedOrderRemoveParcelFromDeliveryActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderRemoveParcelFromDeliveryActionSchema

        return StagedOrderRemoveParcelFromDeliveryActionSchema().dump(self)


class StagedOrderRemovePaymentAction(StagedOrderUpdateAction):
    #: Payment to remove from the [PaymentInfo](ctp:api:type:PaymentInfo).
    payment: "PaymentResourceIdentifier"

    def __init__(self, *, payment: "PaymentResourceIdentifier"):
        self.payment = payment

        super().__init__(action="removePayment")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderRemovePaymentAction":
        from ._schemas.order_edit import StagedOrderRemovePaymentActionSchema

        return StagedOrderRemovePaymentActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderRemovePaymentActionSchema

        return StagedOrderRemovePaymentActionSchema().dump(self)


class StagedOrderSetBillingAddressAction(StagedOrderUpdateAction):
    """This action updates the `billingAddress` on the Order, but it does not change the billing address on the referenced [Cart](ctp:api:type:Cart) from which the Order is created.

    Produces the [Order Billing Address Set](ctp:api:type:OrderBillingAddressSetMessage) Message.

    """

    #: Value to set.
    #: If empty, any existing value is removed.
    address: typing.Optional["BaseAddress"]

    def __init__(self, *, address: typing.Optional["BaseAddress"] = None):
        self.address = address

        super().__init__(action="setBillingAddress")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderSetBillingAddressAction":
        from ._schemas.order_edit import StagedOrderSetBillingAddressActionSchema

        return StagedOrderSetBillingAddressActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderSetBillingAddressActionSchema

        return StagedOrderSetBillingAddressActionSchema().dump(self)


class StagedOrderSetBillingAddressCustomFieldAction(StagedOrderUpdateAction):
    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: Removing a field that does not exist returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
    #: If `value` is provided, it is set for the field defined by `name`.
    value: typing.Optional[typing.Any]

    def __init__(self, *, name: str, value: typing.Optional[typing.Any] = None):
        self.name = name
        self.value = value

        super().__init__(action="setBillingAddressCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderSetBillingAddressCustomFieldAction":
        from ._schemas.order_edit import (
            StagedOrderSetBillingAddressCustomFieldActionSchema,
        )

        return StagedOrderSetBillingAddressCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import (
            StagedOrderSetBillingAddressCustomFieldActionSchema,
        )

        return StagedOrderSetBillingAddressCustomFieldActionSchema().dump(self)


class StagedOrderSetBillingAddressCustomTypeAction(StagedOrderUpdateAction):
    #: Defines the [Type](ctp:api:type:Type) that extends the `billingAddress` with [Custom Fields](/../api/projects/custom-fields).
    #: If absent, any existing Type and Custom Fields are removed from the `billingAddress`.
    type: typing.Optional["TypeResourceIdentifier"]
    #: Sets the [Custom Fields](/../api/projects/custom-fields) fields for the `billingAddress`.
    fields: typing.Optional["FieldContainer"]

    def __init__(
        self,
        *,
        type: typing.Optional["TypeResourceIdentifier"] = None,
        fields: typing.Optional["FieldContainer"] = None
    ):
        self.type = type
        self.fields = fields

        super().__init__(action="setBillingAddressCustomType")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderSetBillingAddressCustomTypeAction":
        from ._schemas.order_edit import (
            StagedOrderSetBillingAddressCustomTypeActionSchema,
        )

        return StagedOrderSetBillingAddressCustomTypeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import (
            StagedOrderSetBillingAddressCustomTypeActionSchema,
        )

        return StagedOrderSetBillingAddressCustomTypeActionSchema().dump(self)


class StagedOrderSetCountryAction(StagedOrderUpdateAction):
    """Setting the country can lead to changes in the [LineItem](ctp:api:type:LineItem) prices."""

    #: Value to set.
    #: If empty, any existing value is removed.
    #:
    #: If the Cart is bound to a `store`, the provided value must be included in the [Store](ctp:api:type:Store)'s `countries`.
    #: Otherwise a [CountryNotConfiguredInStore](ctp:api:type:CountryNotConfiguredInStoreError) error is returned.
    country: typing.Optional[str]

    def __init__(self, *, country: typing.Optional[str] = None):
        self.country = country

        super().__init__(action="setCountry")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderSetCountryAction":
        from ._schemas.order_edit import StagedOrderSetCountryActionSchema

        return StagedOrderSetCountryActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderSetCountryActionSchema

        return StagedOrderSetCountryActionSchema().dump(self)


class StagedOrderSetCustomFieldAction(StagedOrderUpdateAction):
    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: Removing a field that does not exist returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
    #: If `value` is provided, it is set for the field defined by `name`.
    value: typing.Optional[typing.Any]

    def __init__(self, *, name: str, value: typing.Optional[typing.Any] = None):
        self.name = name
        self.value = value

        super().__init__(action="setCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderSetCustomFieldAction":
        from ._schemas.order_edit import StagedOrderSetCustomFieldActionSchema

        return StagedOrderSetCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderSetCustomFieldActionSchema

        return StagedOrderSetCustomFieldActionSchema().dump(self)


class StagedOrderSetCustomLineItemCustomFieldAction(StagedOrderUpdateAction):
    #: `id` of the [CustomLineItem](ctp:api:type:CustomLineItem) to update. Either `customLineItemId` or `customLineItemKey` is required.
    custom_line_item_id: typing.Optional[str]
    #: `key` of the [CustomLineItem](ctp:api:type:CustomLineItem) to update. Either `customLineItemId` or `customLineItemKey` is required.
    custom_line_item_key: typing.Optional[str]
    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: Removing a field that does not exist returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
    #: If `value` is provided, it is set for the field defined by `name`.
    value: typing.Optional[typing.Any]

    def __init__(
        self,
        *,
        custom_line_item_id: typing.Optional[str] = None,
        custom_line_item_key: typing.Optional[str] = None,
        name: str,
        value: typing.Optional[typing.Any] = None
    ):
        self.custom_line_item_id = custom_line_item_id
        self.custom_line_item_key = custom_line_item_key
        self.name = name
        self.value = value

        super().__init__(action="setCustomLineItemCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderSetCustomLineItemCustomFieldAction":
        from ._schemas.order_edit import (
            StagedOrderSetCustomLineItemCustomFieldActionSchema,
        )

        return StagedOrderSetCustomLineItemCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import (
            StagedOrderSetCustomLineItemCustomFieldActionSchema,
        )

        return StagedOrderSetCustomLineItemCustomFieldActionSchema().dump(self)


class StagedOrderSetCustomLineItemCustomTypeAction(StagedOrderUpdateAction):
    #: `id` of the [CustomLineItem](ctp:api:type:CustomLineItem) to update. Either `customLineItemId` or `customLineItemKey` is required.
    custom_line_item_id: typing.Optional[str]
    #: `key` of the [CustomLineItem](ctp:api:type:CustomLineItem) to update. Either `customLineItemId` or `customLineItemKey` is required.
    custom_line_item_key: typing.Optional[str]
    #: Defines the [Type](ctp:api:type:Type) that extends the Custom Line Item with [Custom Fields](/../api/projects/custom-fields).
    #: If absent, any existing Type and Custom Fields are removed from the Custom Line Item.
    type: typing.Optional["TypeResourceIdentifier"]
    #: Sets the [Custom Fields](/../api/projects/custom-fields) fields for the Custom Line Item.
    fields: typing.Optional["FieldContainer"]

    def __init__(
        self,
        *,
        custom_line_item_id: typing.Optional[str] = None,
        custom_line_item_key: typing.Optional[str] = None,
        type: typing.Optional["TypeResourceIdentifier"] = None,
        fields: typing.Optional["FieldContainer"] = None
    ):
        self.custom_line_item_id = custom_line_item_id
        self.custom_line_item_key = custom_line_item_key
        self.type = type
        self.fields = fields

        super().__init__(action="setCustomLineItemCustomType")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderSetCustomLineItemCustomTypeAction":
        from ._schemas.order_edit import (
            StagedOrderSetCustomLineItemCustomTypeActionSchema,
        )

        return StagedOrderSetCustomLineItemCustomTypeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import (
            StagedOrderSetCustomLineItemCustomTypeActionSchema,
        )

        return StagedOrderSetCustomLineItemCustomTypeActionSchema().dump(self)


class StagedOrderSetCustomLineItemShippingDetailsAction(StagedOrderUpdateAction):
    #: `id` of the [CustomLineItem](ctp:api:type:CustomLineItem) to update. Either `customLineItemId` or `customLineItemKey` is required.
    custom_line_item_id: typing.Optional[str]
    #: `key` of the [CustomLineItem](ctp:api:type:CustomLineItem) to update. Either `customLineItemId` or `customLineItemKey` is required.
    custom_line_item_key: typing.Optional[str]
    #: Value to set.
    #: If empty, any existing value is removed.
    shipping_details: typing.Optional["ItemShippingDetailsDraft"]

    def __init__(
        self,
        *,
        custom_line_item_id: typing.Optional[str] = None,
        custom_line_item_key: typing.Optional[str] = None,
        shipping_details: typing.Optional["ItemShippingDetailsDraft"] = None
    ):
        self.custom_line_item_id = custom_line_item_id
        self.custom_line_item_key = custom_line_item_key
        self.shipping_details = shipping_details

        super().__init__(action="setCustomLineItemShippingDetails")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderSetCustomLineItemShippingDetailsAction":
        from ._schemas.order_edit import (
            StagedOrderSetCustomLineItemShippingDetailsActionSchema,
        )

        return StagedOrderSetCustomLineItemShippingDetailsActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import (
            StagedOrderSetCustomLineItemShippingDetailsActionSchema,
        )

        return StagedOrderSetCustomLineItemShippingDetailsActionSchema().dump(self)


class StagedOrderSetCustomLineItemTaxAmountAction(StagedOrderUpdateAction):
    """Can be used if the Cart has the `ExternalAmount` [TaxMode](ctp:api:type:TaxMode)."""

    #: `id` of the [CustomLineItem](ctp:api:type:CustomLineItem) to update. Either `customLineItemId` or `customLineItemKey` is required.
    custom_line_item_id: typing.Optional[str]
    #: `key` of the [CustomLineItem](ctp:api:type:CustomLineItem) to update. Either `customLineItemId` or `customLineItemKey` is required.
    custom_line_item_key: typing.Optional[str]
    #: Value to set.
    #: If empty, any existing value is removed.
    external_tax_amount: typing.Optional["ExternalTaxAmountDraft"]
    #: `key` of the [ShippingMethod](ctp:api:type:ShippingMethod) used for this Custom Line Item.
    #: This is required for Carts with `Multiple` [ShippingMode](ctp:api:type:ShippingMode).
    shipping_key: typing.Optional[str]

    def __init__(
        self,
        *,
        custom_line_item_id: typing.Optional[str] = None,
        custom_line_item_key: typing.Optional[str] = None,
        external_tax_amount: typing.Optional["ExternalTaxAmountDraft"] = None,
        shipping_key: typing.Optional[str] = None
    ):
        self.custom_line_item_id = custom_line_item_id
        self.custom_line_item_key = custom_line_item_key
        self.external_tax_amount = external_tax_amount
        self.shipping_key = shipping_key

        super().__init__(action="setCustomLineItemTaxAmount")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderSetCustomLineItemTaxAmountAction":
        from ._schemas.order_edit import (
            StagedOrderSetCustomLineItemTaxAmountActionSchema,
        )

        return StagedOrderSetCustomLineItemTaxAmountActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import (
            StagedOrderSetCustomLineItemTaxAmountActionSchema,
        )

        return StagedOrderSetCustomLineItemTaxAmountActionSchema().dump(self)


class StagedOrderSetCustomLineItemTaxRateAction(StagedOrderUpdateAction):
    """Can be used if the Cart has the `External` [TaxMode](ctp:api:type:TaxMode)."""

    #: `id` of the [CustomLineItem](ctp:api:type:CustomLineItem) to update. Either `customLineItemId` or `customLineItemKey` is required.
    custom_line_item_id: typing.Optional[str]
    #: `key` of the [CustomLineItem](ctp:api:type:CustomLineItem) to update. Either `customLineItemId` or `customLineItemKey` is required.
    custom_line_item_key: typing.Optional[str]
    #: Value to set.
    #: If empty, an existing value is removed.
    external_tax_rate: typing.Optional["ExternalTaxRateDraft"]
    #: `key` of the [ShippingMethod](ctp:api:type:ShippingMethod) used for this Custom Line Item.
    #: This is required for Carts with `Multiple` [ShippingMode](ctp:api:type:ShippingMode).
    shipping_key: typing.Optional[str]

    def __init__(
        self,
        *,
        custom_line_item_id: typing.Optional[str] = None,
        custom_line_item_key: typing.Optional[str] = None,
        external_tax_rate: typing.Optional["ExternalTaxRateDraft"] = None,
        shipping_key: typing.Optional[str] = None
    ):
        self.custom_line_item_id = custom_line_item_id
        self.custom_line_item_key = custom_line_item_key
        self.external_tax_rate = external_tax_rate
        self.shipping_key = shipping_key

        super().__init__(action="setCustomLineItemTaxRate")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderSetCustomLineItemTaxRateAction":
        from ._schemas.order_edit import StagedOrderSetCustomLineItemTaxRateActionSchema

        return StagedOrderSetCustomLineItemTaxRateActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderSetCustomLineItemTaxRateActionSchema

        return StagedOrderSetCustomLineItemTaxRateActionSchema().dump(self)


class StagedOrderSetCustomShippingMethodAction(StagedOrderUpdateAction):
    """To set the Cart's custom Shipping Method (independent of the [ShippingMethods](ctp:api:type:ShippingMethod) managed through the [Shipping Methods API](/../api/projects/shippingMethods)) the Cart must have the `Single` [ShippingMode](ctp:api:type:ShippingMode) and a `shippingAddress`.

    To unset a custom Shipping Method on a Cart, use the [Set ShippingMethod](ctp:api:type:StagedOrderSetShippingMethodAction) update action without the `shippingMethod` field instead.

    """

    #: Name of the custom Shipping Method.
    shipping_method_name: str
    #: Determines the shipping price.
    shipping_rate: "ShippingRateDraft"
    #: Tax Category used to determine the Tax Rate when the Cart has the `Platform` [TaxMode](ctp:api:type:TaxMode).
    tax_category: typing.Optional["TaxCategoryResourceIdentifier"]
    #: External Tax Rate for the `shippingRate` to be set if the Cart has the `External` [TaxMode](ctp:api:type:TaxMode).
    external_tax_rate: typing.Optional["ExternalTaxRateDraft"]

    def __init__(
        self,
        *,
        shipping_method_name: str,
        shipping_rate: "ShippingRateDraft",
        tax_category: typing.Optional["TaxCategoryResourceIdentifier"] = None,
        external_tax_rate: typing.Optional["ExternalTaxRateDraft"] = None
    ):
        self.shipping_method_name = shipping_method_name
        self.shipping_rate = shipping_rate
        self.tax_category = tax_category
        self.external_tax_rate = external_tax_rate

        super().__init__(action="setCustomShippingMethod")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderSetCustomShippingMethodAction":
        from ._schemas.order_edit import StagedOrderSetCustomShippingMethodActionSchema

        return StagedOrderSetCustomShippingMethodActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderSetCustomShippingMethodActionSchema

        return StagedOrderSetCustomShippingMethodActionSchema().dump(self)


class StagedOrderSetCustomTypeAction(StagedOrderUpdateAction):
    #: Defines the [Type](ctp:api:type:Type) that extends the Order Edit with [Custom Fields](/../api/projects/custom-fields).
    #: If absent, any existing Type and Custom Fields are removed from the Order Edit.
    type: typing.Optional["TypeResourceIdentifier"]
    #: Sets the [Custom Fields](/../api/projects/custom-fields) fields for the Order Edit.
    fields: typing.Optional["FieldContainer"]

    def __init__(
        self,
        *,
        type: typing.Optional["TypeResourceIdentifier"] = None,
        fields: typing.Optional["FieldContainer"] = None
    ):
        self.type = type
        self.fields = fields

        super().__init__(action="setCustomType")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderSetCustomTypeAction":
        from ._schemas.order_edit import StagedOrderSetCustomTypeActionSchema

        return StagedOrderSetCustomTypeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderSetCustomTypeActionSchema

        return StagedOrderSetCustomTypeActionSchema().dump(self)


class StagedOrderSetCustomerEmailAction(StagedOrderUpdateAction):
    """This action updates the `customerEmail` on the Order, but it does not change the Customer email on the [Cart](ctp:api:type:Cart) the Order has been created from.

    Produces the [Order Customer Email Set](ctp:api:type:OrderCustomerEmailSetMessage) Message.

    """

    #: Value to set.
    #: If empty, any existing value will be removed.
    email: typing.Optional[str]

    def __init__(self, *, email: typing.Optional[str] = None):
        self.email = email

        super().__init__(action="setCustomerEmail")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderSetCustomerEmailAction":
        from ._schemas.order_edit import StagedOrderSetCustomerEmailActionSchema

        return StagedOrderSetCustomerEmailActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderSetCustomerEmailActionSchema

        return StagedOrderSetCustomerEmailActionSchema().dump(self)


class StagedOrderSetCustomerGroupAction(StagedOrderUpdateAction):
    """This update action can only be used if a Customer is not assigned to a Cart. If a Customer is already assigned, the Cart has the same Customer Group as the assigned Customer.

    Setting the Customer Group also updates the [LineItem](ctp:api:type:LineItem) `prices` according to the Customer Group.

    """

    #: Value to set.
    #: If empty, any existing value is removed.
    customer_group: typing.Optional["CustomerGroupResourceIdentifier"]

    def __init__(
        self,
        *,
        customer_group: typing.Optional["CustomerGroupResourceIdentifier"] = None
    ):
        self.customer_group = customer_group

        super().__init__(action="setCustomerGroup")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderSetCustomerGroupAction":
        from ._schemas.order_edit import StagedOrderSetCustomerGroupActionSchema

        return StagedOrderSetCustomerGroupActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderSetCustomerGroupActionSchema

        return StagedOrderSetCustomerGroupActionSchema().dump(self)


class StagedOrderSetCustomerIdAction(StagedOrderUpdateAction):
    """Setting the Order's `customerId` does not recalculate prices or discounts on the Order.
    If the Customer belongs to a Customer Group, `customerGroup` on the [Order](ctp:api:type:Order) is updated automatically.

    Produces the [OrderCustomerSet](ctp:api:type:OrderCustomerSetMessage) Message.

    """

    #: `id` of an existing [Customer](ctp:api:type:Customer).
    #: If empty, any existing value is removed.
    customer_id: typing.Optional[str]

    def __init__(self, *, customer_id: typing.Optional[str] = None):
        self.customer_id = customer_id

        super().__init__(action="setCustomerId")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderSetCustomerIdAction":
        from ._schemas.order_edit import StagedOrderSetCustomerIdActionSchema

        return StagedOrderSetCustomerIdActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderSetCustomerIdActionSchema

        return StagedOrderSetCustomerIdActionSchema().dump(self)


class StagedOrderSetDeliveryAddressAction(StagedOrderUpdateAction):
    """Produces the [DeliveryAddressSet](ctp:api:type:DeliveryAddressSetMessage) Message."""

    #: `id` of an existing [Delivery](ctp:api:type:Delivery).
    #:
    #: Either `deliveryId` or `deliveryKey` must be provided.
    delivery_id: typing.Optional[str]
    #: `key` of an existing [Delivery](ctp:api:type:Delivery).
    #:
    #: Either `deliveryId` or `deliveryKey` must be provided.
    delivery_key: typing.Optional[str]
    #: Value to set.
    #: If empty, any existing value will be removed.
    address: typing.Optional["BaseAddress"]

    def __init__(
        self,
        *,
        delivery_id: typing.Optional[str] = None,
        delivery_key: typing.Optional[str] = None,
        address: typing.Optional["BaseAddress"] = None
    ):
        self.delivery_id = delivery_id
        self.delivery_key = delivery_key
        self.address = address

        super().__init__(action="setDeliveryAddress")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderSetDeliveryAddressAction":
        from ._schemas.order_edit import StagedOrderSetDeliveryAddressActionSchema

        return StagedOrderSetDeliveryAddressActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderSetDeliveryAddressActionSchema

        return StagedOrderSetDeliveryAddressActionSchema().dump(self)


class StagedOrderSetDeliveryAddressCustomFieldAction(StagedOrderUpdateAction):
    #: `id` of an existing [Delivery](ctp:api:type:Delivery).
    #:
    #: Either `deliveryId` or `deliveryKey` must be provided.
    delivery_id: typing.Optional[str]
    #: `key` of an existing [Delivery](ctp:api:type:Delivery).
    #:
    #: Either `deliveryId` or `deliveryKey` must be provided.
    delivery_key: typing.Optional[str]
    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: Removing a field that does not exist returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
    #: If `value` is provided, it is set for the field defined by `name`.
    value: typing.Optional[typing.Any]

    def __init__(
        self,
        *,
        delivery_id: typing.Optional[str] = None,
        delivery_key: typing.Optional[str] = None,
        name: str,
        value: typing.Optional[typing.Any] = None
    ):
        self.delivery_id = delivery_id
        self.delivery_key = delivery_key
        self.name = name
        self.value = value

        super().__init__(action="setDeliveryAddressCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderSetDeliveryAddressCustomFieldAction":
        from ._schemas.order_edit import (
            StagedOrderSetDeliveryAddressCustomFieldActionSchema,
        )

        return StagedOrderSetDeliveryAddressCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import (
            StagedOrderSetDeliveryAddressCustomFieldActionSchema,
        )

        return StagedOrderSetDeliveryAddressCustomFieldActionSchema().dump(self)


class StagedOrderSetDeliveryAddressCustomTypeAction(StagedOrderUpdateAction):
    #: `id` of an existing [Delivery](ctp:api:type:Delivery).
    #:
    #: Either `deliveryId` or `deliveryKey` must be provided.
    delivery_id: typing.Optional[str]
    #: `key` of an existing [Delivery](ctp:api:type:Delivery).
    #:
    #: Either `deliveryId` or `deliveryKey` must be provided.
    delivery_key: typing.Optional[str]
    #: Defines the [Type](ctp:api:type:Type) that extends the [Delivery](ctp:api:type:Delivery) `address` with [Custom Fields](/../api/projects/custom-fields).
    #: If absent, any existing Type and Custom Fields are removed from the [Delivery](ctp:api:type:Delivery) `address`.
    type: typing.Optional["TypeResourceIdentifier"]
    #: Sets the [Custom Fields](/../api/projects/custom-fields) fields for the [Delivery](ctp:api:type:Delivery) `address`.
    fields: typing.Optional["FieldContainer"]

    def __init__(
        self,
        *,
        delivery_id: typing.Optional[str] = None,
        delivery_key: typing.Optional[str] = None,
        type: typing.Optional["TypeResourceIdentifier"] = None,
        fields: typing.Optional["FieldContainer"] = None
    ):
        self.delivery_id = delivery_id
        self.delivery_key = delivery_key
        self.type = type
        self.fields = fields

        super().__init__(action="setDeliveryAddressCustomType")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderSetDeliveryAddressCustomTypeAction":
        from ._schemas.order_edit import (
            StagedOrderSetDeliveryAddressCustomTypeActionSchema,
        )

        return StagedOrderSetDeliveryAddressCustomTypeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import (
            StagedOrderSetDeliveryAddressCustomTypeActionSchema,
        )

        return StagedOrderSetDeliveryAddressCustomTypeActionSchema().dump(self)


class StagedOrderSetDeliveryCustomFieldAction(StagedOrderUpdateAction):
    #: `id` of an existing [Delivery](ctp:api:type:Delivery).
    #:
    #: Either `deliveryId` or `deliveryKey` must be provided.
    delivery_id: typing.Optional[str]
    #: `key` of an existing [Delivery](ctp:api:type:Delivery).
    #:
    #: Either `deliveryId` or `deliveryKey` must be provided.
    delivery_key: typing.Optional[str]
    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: Removing a field that does not exist returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
    #: If `value` is provided, it is set for the field defined by `name`.
    value: typing.Optional[typing.Any]

    def __init__(
        self,
        *,
        delivery_id: typing.Optional[str] = None,
        delivery_key: typing.Optional[str] = None,
        name: str,
        value: typing.Optional[typing.Any] = None
    ):
        self.delivery_id = delivery_id
        self.delivery_key = delivery_key
        self.name = name
        self.value = value

        super().__init__(action="setDeliveryCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderSetDeliveryCustomFieldAction":
        from ._schemas.order_edit import StagedOrderSetDeliveryCustomFieldActionSchema

        return StagedOrderSetDeliveryCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderSetDeliveryCustomFieldActionSchema

        return StagedOrderSetDeliveryCustomFieldActionSchema().dump(self)


class StagedOrderSetDeliveryCustomTypeAction(StagedOrderUpdateAction):
    #: `id` of an existing [Delivery](ctp:api:type:Delivery).
    #:
    #: Either `deliveryId` or `deliveryKey` must be provided.
    delivery_id: typing.Optional[str]
    #: `key` of an existing [Delivery](ctp:api:type:Delivery).
    #:
    #: Either `deliveryId` or `deliveryKey` must be provided.
    delivery_key: typing.Optional[str]
    #: Defines the [Type](ctp:api:type:Type) that extends the Delivery with [Custom Fields](/../api/projects/custom-fields).
    #: If absent, any existing Type and Custom Fields are removed from the Delivery.
    type: typing.Optional["TypeResourceIdentifier"]
    #: Sets the [Custom Fields](/../api/projects/custom-fields) fields for the Delivery.
    fields: typing.Optional["FieldContainer"]

    def __init__(
        self,
        *,
        delivery_id: typing.Optional[str] = None,
        delivery_key: typing.Optional[str] = None,
        type: typing.Optional["TypeResourceIdentifier"] = None,
        fields: typing.Optional["FieldContainer"] = None
    ):
        self.delivery_id = delivery_id
        self.delivery_key = delivery_key
        self.type = type
        self.fields = fields

        super().__init__(action="setDeliveryCustomType")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderSetDeliveryCustomTypeAction":
        from ._schemas.order_edit import StagedOrderSetDeliveryCustomTypeActionSchema

        return StagedOrderSetDeliveryCustomTypeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderSetDeliveryCustomTypeActionSchema

        return StagedOrderSetDeliveryCustomTypeActionSchema().dump(self)


class StagedOrderSetDeliveryItemsAction(StagedOrderUpdateAction):
    """Produces the [Delivery Items Updated](ctp:api:type:DeliveryItemsUpdatedMessage) Message."""

    #: `id` of an existing [Delivery](ctp:api:type:Delivery).
    #:
    #: Either `deliveryId` or `deliveryKey` must be provided.
    delivery_id: typing.Optional[str]
    #: `key` of an existing [Delivery](ctp:api:type:Delivery).
    #:
    #: Either `deliveryId` or `deliveryKey` must be provided.
    delivery_key: typing.Optional[str]
    #: Value to set.
    #: If empty, any existing value is removed.
    items: typing.List["DeliveryItem"]

    def __init__(
        self,
        *,
        delivery_id: typing.Optional[str] = None,
        delivery_key: typing.Optional[str] = None,
        items: typing.List["DeliveryItem"]
    ):
        self.delivery_id = delivery_id
        self.delivery_key = delivery_key
        self.items = items

        super().__init__(action="setDeliveryItems")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderSetDeliveryItemsAction":
        from ._schemas.order_edit import StagedOrderSetDeliveryItemsActionSchema

        return StagedOrderSetDeliveryItemsActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderSetDeliveryItemsActionSchema

        return StagedOrderSetDeliveryItemsActionSchema().dump(self)


class StagedOrderSetDirectDiscountsAction(StagedOrderUpdateAction):
    """Adds a [DirectDiscount](ctp:api:type:DirectDiscount), but only if no [DiscountCode](ctp:api:type:DiscountCode) has been added to the Order.
    Either a Discount Code or a Direct Discount can exist on a Order at the same time.

    """

    #: - If set, all existing Direct Discounts are replaced.
    #:   The discounts apply in the order they are added to the list.
    #: - If empty, all existing Direct Discounts are removed and all affected prices on the Order are recalculated.
    discounts: typing.List["DirectDiscountDraft"]

    def __init__(self, *, discounts: typing.List["DirectDiscountDraft"]):
        self.discounts = discounts

        super().__init__(action="setDirectDiscounts")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderSetDirectDiscountsAction":
        from ._schemas.order_edit import StagedOrderSetDirectDiscountsActionSchema

        return StagedOrderSetDirectDiscountsActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderSetDirectDiscountsActionSchema

        return StagedOrderSetDirectDiscountsActionSchema().dump(self)


class StagedOrderSetItemShippingAddressCustomFieldAction(StagedOrderUpdateAction):
    #: `key` of the [Address](ctp:api:type:Address) in `itemShippingAddresses`.
    address_key: str
    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: Removing a field that does not exist returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
    #: If `value` is provided, it is set for the field defined by `name`.
    value: typing.Optional[typing.Any]

    def __init__(
        self, *, address_key: str, name: str, value: typing.Optional[typing.Any] = None
    ):
        self.address_key = address_key
        self.name = name
        self.value = value

        super().__init__(action="setItemShippingAddressCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderSetItemShippingAddressCustomFieldAction":
        from ._schemas.order_edit import (
            StagedOrderSetItemShippingAddressCustomFieldActionSchema,
        )

        return StagedOrderSetItemShippingAddressCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import (
            StagedOrderSetItemShippingAddressCustomFieldActionSchema,
        )

        return StagedOrderSetItemShippingAddressCustomFieldActionSchema().dump(self)


class StagedOrderSetItemShippingAddressCustomTypeAction(StagedOrderUpdateAction):
    #: `key` of the [Address](ctp:api:type:Address) in `itemShippingAddresses`.
    address_key: str
    #: Defines the [Type](ctp:api:type:Type) that extends the `itemShippingAddress` with [Custom Fields](/../api/projects/custom-fields).
    #: If absent, any existing Type and Custom Fields are removed from the `itemShippingAddress`.
    type: typing.Optional["TypeResourceIdentifier"]
    #: Sets the [Custom Fields](/../api/projects/custom-fields) fields for the `itemShippingAddress`.
    fields: typing.Optional["FieldContainer"]

    def __init__(
        self,
        *,
        address_key: str,
        type: typing.Optional["TypeResourceIdentifier"] = None,
        fields: typing.Optional["FieldContainer"] = None
    ):
        self.address_key = address_key
        self.type = type
        self.fields = fields

        super().__init__(action="setItemShippingAddressCustomType")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderSetItemShippingAddressCustomTypeAction":
        from ._schemas.order_edit import (
            StagedOrderSetItemShippingAddressCustomTypeActionSchema,
        )

        return StagedOrderSetItemShippingAddressCustomTypeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import (
            StagedOrderSetItemShippingAddressCustomTypeActionSchema,
        )

        return StagedOrderSetItemShippingAddressCustomTypeActionSchema().dump(self)


class StagedOrderSetLineItemCustomFieldAction(StagedOrderUpdateAction):
    #: `id` of the [LineItem](ctp:api:type:LineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    line_item_id: typing.Optional[str]
    #: `key` of the [LineItem](ctp:api:type:LineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    line_item_key: typing.Optional[str]
    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: Removing a field that does not exist returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
    #: If `value` is provided, it is set for the field defined by `name`.
    value: typing.Optional[typing.Any]

    def __init__(
        self,
        *,
        line_item_id: typing.Optional[str] = None,
        line_item_key: typing.Optional[str] = None,
        name: str,
        value: typing.Optional[typing.Any] = None
    ):
        self.line_item_id = line_item_id
        self.line_item_key = line_item_key
        self.name = name
        self.value = value

        super().__init__(action="setLineItemCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderSetLineItemCustomFieldAction":
        from ._schemas.order_edit import StagedOrderSetLineItemCustomFieldActionSchema

        return StagedOrderSetLineItemCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderSetLineItemCustomFieldActionSchema

        return StagedOrderSetLineItemCustomFieldActionSchema().dump(self)


class StagedOrderSetLineItemCustomTypeAction(StagedOrderUpdateAction):
    #: `id` of the [LineItem](ctp:api:type:LineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    line_item_id: typing.Optional[str]
    #: `key` of the [LineItem](ctp:api:type:LineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    line_item_key: typing.Optional[str]
    #: Defines the [Type](ctp:api:type:Type) that extends the Line Item with [Custom Fields](/../api/projects/custom-fields).
    #: If absent, any existing Type and Custom Fields are removed from the Line Item.
    type: typing.Optional["TypeResourceIdentifier"]
    #: Sets the [Custom Fields](/../api/projects/custom-fields) fields for the Line Item.
    fields: typing.Optional["FieldContainer"]

    def __init__(
        self,
        *,
        line_item_id: typing.Optional[str] = None,
        line_item_key: typing.Optional[str] = None,
        type: typing.Optional["TypeResourceIdentifier"] = None,
        fields: typing.Optional["FieldContainer"] = None
    ):
        self.line_item_id = line_item_id
        self.line_item_key = line_item_key
        self.type = type
        self.fields = fields

        super().__init__(action="setLineItemCustomType")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderSetLineItemCustomTypeAction":
        from ._schemas.order_edit import StagedOrderSetLineItemCustomTypeActionSchema

        return StagedOrderSetLineItemCustomTypeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderSetLineItemCustomTypeActionSchema

        return StagedOrderSetLineItemCustomTypeActionSchema().dump(self)


class StagedOrderSetLineItemDistributionChannelAction(StagedOrderUpdateAction):
    """Setting a distribution channel for a [LineItem](ctp:api:type:LineItem) can lead to an updated `price` as described in [LineItem Price selection](ctp:api:type:LineItemPriceSelection).

    Produces the [OrderLineItemDistributionChannelSet](ctp:api:type:OrderLineItemDistributionChannelSetMessage) Message.

    """

    #: `id` of the [LineItem](ctp:api:type:LineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    line_item_id: typing.Optional[str]
    #: `key` of the [LineItem](ctp:api:type:LineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    line_item_key: typing.Optional[str]
    #: - If present, a [Reference](ctp:api:type:Reference) to the Channel is set for the [LineItem](ctp:api:type:LineItem) specified by `lineItemId`.
    #: - If not present, the current [Reference](ctp:api:type:Reference) to a distribution channel is removed from the [LineItem](ctp:api:type:LineItem) specified by `lineItemId`.
    #:   The Channel must have the `ProductDistribution` [ChannelRoleEnum](ctp:api:type:ChannelRoleEnum).
    distribution_channel: typing.Optional["ChannelResourceIdentifier"]

    def __init__(
        self,
        *,
        line_item_id: typing.Optional[str] = None,
        line_item_key: typing.Optional[str] = None,
        distribution_channel: typing.Optional["ChannelResourceIdentifier"] = None
    ):
        self.line_item_id = line_item_id
        self.line_item_key = line_item_key
        self.distribution_channel = distribution_channel

        super().__init__(action="setLineItemDistributionChannel")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderSetLineItemDistributionChannelAction":
        from ._schemas.order_edit import (
            StagedOrderSetLineItemDistributionChannelActionSchema,
        )

        return StagedOrderSetLineItemDistributionChannelActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import (
            StagedOrderSetLineItemDistributionChannelActionSchema,
        )

        return StagedOrderSetLineItemDistributionChannelActionSchema().dump(self)


class StagedOrderSetLineItemPriceAction(StagedOrderUpdateAction):
    """Sets the [LineItem](ctp:api:type:LineItem) `price` and changes the `priceMode` to `ExternalPrice` [LineItemPriceMode](ctp:api:type:LineItemPriceMode)."""

    #: `id` of the [LineItem](ctp:api:type:LineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    line_item_id: typing.Optional[str]
    #: `key` of the [LineItem](ctp:api:type:LineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    line_item_key: typing.Optional[str]
    #: Value to set.
    #: If `externalPrice` is not given and the `priceMode` is `ExternalPrice`, the external price is unset and the `priceMode` is set to `Platform`.
    external_price: typing.Optional["Money"]

    def __init__(
        self,
        *,
        line_item_id: typing.Optional[str] = None,
        line_item_key: typing.Optional[str] = None,
        external_price: typing.Optional["Money"] = None
    ):
        self.line_item_id = line_item_id
        self.line_item_key = line_item_key
        self.external_price = external_price

        super().__init__(action="setLineItemPrice")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderSetLineItemPriceAction":
        from ._schemas.order_edit import StagedOrderSetLineItemPriceActionSchema

        return StagedOrderSetLineItemPriceActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderSetLineItemPriceActionSchema

        return StagedOrderSetLineItemPriceActionSchema().dump(self)


class StagedOrderSetLineItemShippingDetailsAction(StagedOrderUpdateAction):
    #: `id` of the [LineItem](ctp:api:type:LineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    line_item_id: typing.Optional[str]
    #: `key` of the [LineItem](ctp:api:type:LineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    line_item_key: typing.Optional[str]
    #: Value to set.
    #: If empty, the existing value is removed.
    shipping_details: typing.Optional["ItemShippingDetailsDraft"]

    def __init__(
        self,
        *,
        line_item_id: typing.Optional[str] = None,
        line_item_key: typing.Optional[str] = None,
        shipping_details: typing.Optional["ItemShippingDetailsDraft"] = None
    ):
        self.line_item_id = line_item_id
        self.line_item_key = line_item_key
        self.shipping_details = shipping_details

        super().__init__(action="setLineItemShippingDetails")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderSetLineItemShippingDetailsAction":
        from ._schemas.order_edit import (
            StagedOrderSetLineItemShippingDetailsActionSchema,
        )

        return StagedOrderSetLineItemShippingDetailsActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import (
            StagedOrderSetLineItemShippingDetailsActionSchema,
        )

        return StagedOrderSetLineItemShippingDetailsActionSchema().dump(self)


class StagedOrderSetLineItemTaxAmountAction(StagedOrderUpdateAction):
    """Can be used if the Cart has the `ExternalAmount` [TaxMode](ctp:api:type:TaxMode)."""

    #: `id` of the [LineItem](ctp:api:type:LineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    line_item_id: typing.Optional[str]
    #: `key` of the [LineItem](ctp:api:type:LineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    line_item_key: typing.Optional[str]
    #: Value to set.
    #: If empty, any existing value will be removed.
    external_tax_amount: typing.Optional["ExternalTaxAmountDraft"]
    #: `key` of the [ShippingMethod](ctp:api:type:ShippingMethod) used for this Line Item.
    #: This is required for Carts with `Multiple` [ShippingMode](ctp:api:type:ShippingMode).
    shipping_key: typing.Optional[str]

    def __init__(
        self,
        *,
        line_item_id: typing.Optional[str] = None,
        line_item_key: typing.Optional[str] = None,
        external_tax_amount: typing.Optional["ExternalTaxAmountDraft"] = None,
        shipping_key: typing.Optional[str] = None
    ):
        self.line_item_id = line_item_id
        self.line_item_key = line_item_key
        self.external_tax_amount = external_tax_amount
        self.shipping_key = shipping_key

        super().__init__(action="setLineItemTaxAmount")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderSetLineItemTaxAmountAction":
        from ._schemas.order_edit import StagedOrderSetLineItemTaxAmountActionSchema

        return StagedOrderSetLineItemTaxAmountActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderSetLineItemTaxAmountActionSchema

        return StagedOrderSetLineItemTaxAmountActionSchema().dump(self)


class StagedOrderSetLineItemTaxRateAction(StagedOrderUpdateAction):
    """Can be used if the Cart has the `External` [TaxMode](ctp:api:type:TaxMode)."""

    #: `id` of the [LineItem](ctp:api:type:LineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    line_item_id: typing.Optional[str]
    #: `key` of the [LineItem](ctp:api:type:LineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    line_item_key: typing.Optional[str]
    #: Value to set.
    #: If empty, any existing value will be removed.
    external_tax_rate: typing.Optional["ExternalTaxRateDraft"]
    #: `key` of the [ShippingMethod](ctp:api:type:ShippingMethod) used for this Line Item.
    #: This is required for Carts with `Multiple` [ShippingMode](ctp:api:type:ShippingMode).
    shipping_key: typing.Optional[str]

    def __init__(
        self,
        *,
        line_item_id: typing.Optional[str] = None,
        line_item_key: typing.Optional[str] = None,
        external_tax_rate: typing.Optional["ExternalTaxRateDraft"] = None,
        shipping_key: typing.Optional[str] = None
    ):
        self.line_item_id = line_item_id
        self.line_item_key = line_item_key
        self.external_tax_rate = external_tax_rate
        self.shipping_key = shipping_key

        super().__init__(action="setLineItemTaxRate")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderSetLineItemTaxRateAction":
        from ._schemas.order_edit import StagedOrderSetLineItemTaxRateActionSchema

        return StagedOrderSetLineItemTaxRateActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderSetLineItemTaxRateActionSchema

        return StagedOrderSetLineItemTaxRateActionSchema().dump(self)


class StagedOrderSetLineItemTotalPriceAction(StagedOrderUpdateAction):
    """Sets the [LineItem](ctp:api:type:LineItem) `totalPrice` and `price`, and changes the `priceMode` to `ExternalTotal` [LineItemPriceMode](ctp:api:type:LineItemPriceMode)."""

    #: `id` of the [LineItem](ctp:api:type:LineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    line_item_id: typing.Optional[str]
    #: `key` of the [LineItem](ctp:api:type:LineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    line_item_key: typing.Optional[str]
    #: Value to set.
    #: If `externalTotalPrice` is not given and the `priceMode` is `ExternalTotal`, the external price is unset and the `priceMode` is set to `Platform`.
    external_total_price: typing.Optional["ExternalLineItemTotalPrice"]

    def __init__(
        self,
        *,
        line_item_id: typing.Optional[str] = None,
        line_item_key: typing.Optional[str] = None,
        external_total_price: typing.Optional["ExternalLineItemTotalPrice"] = None
    ):
        self.line_item_id = line_item_id
        self.line_item_key = line_item_key
        self.external_total_price = external_total_price

        super().__init__(action="setLineItemTotalPrice")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderSetLineItemTotalPriceAction":
        from ._schemas.order_edit import StagedOrderSetLineItemTotalPriceActionSchema

        return StagedOrderSetLineItemTotalPriceActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderSetLineItemTotalPriceActionSchema

        return StagedOrderSetLineItemTotalPriceActionSchema().dump(self)


class StagedOrderSetLocaleAction(StagedOrderUpdateAction):
    #: Value to set.
    #: Must be one of the [Project](ctp:api:type:Project)'s languages.
    #: If empty, any existing value is removed.
    locale: typing.Optional[str]

    def __init__(self, *, locale: typing.Optional[str] = None):
        self.locale = locale

        super().__init__(action="setLocale")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderSetLocaleAction":
        from ._schemas.order_edit import StagedOrderSetLocaleActionSchema

        return StagedOrderSetLocaleActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderSetLocaleActionSchema

        return StagedOrderSetLocaleActionSchema().dump(self)


class StagedOrderSetOrderNumberAction(StagedOrderUpdateAction):
    #: Value to set. Must be unique across a Project.
    #: Once set, the value cannot be changed.
    order_number: typing.Optional[str]

    def __init__(self, *, order_number: typing.Optional[str] = None):
        self.order_number = order_number

        super().__init__(action="setOrderNumber")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderSetOrderNumberAction":
        from ._schemas.order_edit import StagedOrderSetOrderNumberActionSchema

        return StagedOrderSetOrderNumberActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderSetOrderNumberActionSchema

        return StagedOrderSetOrderNumberActionSchema().dump(self)


class StagedOrderSetOrderTotalTaxAction(StagedOrderUpdateAction):
    """Updates the total tax amount of the Order if it has the `ExternalAmount` [TaxMode](ctp:api:type:TaxMode)."""

    #: Total gross amount of the Order (totalNet + taxes).
    external_total_gross: "Money"
    #: Value to set.
    external_tax_portions: typing.Optional[typing.List["TaxPortionDraft"]]

    def __init__(
        self,
        *,
        external_total_gross: "Money",
        external_tax_portions: typing.Optional[typing.List["TaxPortionDraft"]] = None
    ):
        self.external_total_gross = external_total_gross
        self.external_tax_portions = external_tax_portions

        super().__init__(action="setOrderTotalTax")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderSetOrderTotalTaxAction":
        from ._schemas.order_edit import StagedOrderSetOrderTotalTaxActionSchema

        return StagedOrderSetOrderTotalTaxActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderSetOrderTotalTaxActionSchema

        return StagedOrderSetOrderTotalTaxActionSchema().dump(self)


class StagedOrderSetParcelCustomFieldAction(StagedOrderUpdateAction):
    #: `id` of an existing [Parcel](ctp:api:type:Parcel).
    #:
    #: Either `parcelId` or `parcelKey` must be provided.
    parcel_id: typing.Optional[str]
    #: `key` of an existing [Parcel](ctp:api:type:Parcel).
    #:
    #: Either `parcelId` or `parcelKey` must be provided.
    parcel_key: typing.Optional[str]
    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: Removing a field that does not exist returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
    #: If `value` is provided, it is set for the field defined by `name`.
    value: typing.Optional[typing.Any]

    def __init__(
        self,
        *,
        parcel_id: typing.Optional[str] = None,
        parcel_key: typing.Optional[str] = None,
        name: str,
        value: typing.Optional[typing.Any] = None
    ):
        self.parcel_id = parcel_id
        self.parcel_key = parcel_key
        self.name = name
        self.value = value

        super().__init__(action="setParcelCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderSetParcelCustomFieldAction":
        from ._schemas.order_edit import StagedOrderSetParcelCustomFieldActionSchema

        return StagedOrderSetParcelCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderSetParcelCustomFieldActionSchema

        return StagedOrderSetParcelCustomFieldActionSchema().dump(self)


class StagedOrderSetParcelCustomTypeAction(StagedOrderUpdateAction):
    #: `id` of an existing [Parcel](ctp:api:type:Parcel).
    #:
    #: Either `parcelId` or `parcelKey` must be provided.
    parcel_id: typing.Optional[str]
    #: `key` of an existing [Parcel](ctp:api:type:Parcel).
    #:
    #: Either `parcelId` or `parcelKey` must be provided.
    parcel_key: typing.Optional[str]
    #: Defines the [Type](ctp:api:type:Type) that extends the Parcel with [Custom Fields](/../api/projects/custom-fields).
    #: If absent, any existing Type and Custom Fields are removed from the Parcel.
    type: typing.Optional["TypeResourceIdentifier"]
    #: Sets the [Custom Fields](/../api/projects/custom-fields) fields for the Parcel.
    fields: typing.Optional["FieldContainer"]

    def __init__(
        self,
        *,
        parcel_id: typing.Optional[str] = None,
        parcel_key: typing.Optional[str] = None,
        type: typing.Optional["TypeResourceIdentifier"] = None,
        fields: typing.Optional["FieldContainer"] = None
    ):
        self.parcel_id = parcel_id
        self.parcel_key = parcel_key
        self.type = type
        self.fields = fields

        super().__init__(action="setParcelCustomType")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderSetParcelCustomTypeAction":
        from ._schemas.order_edit import StagedOrderSetParcelCustomTypeActionSchema

        return StagedOrderSetParcelCustomTypeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderSetParcelCustomTypeActionSchema

        return StagedOrderSetParcelCustomTypeActionSchema().dump(self)


class StagedOrderSetParcelItemsAction(StagedOrderUpdateAction):
    """Produces the [ParcelItemsUpdated](ctp:api:type:ParcelItemsUpdatedMessage) Message."""

    #: `id` of an existing [Parcel](ctp:api:type:Parcel).
    #:
    #: Either `parcelId` or `parcelKey` must be provided.
    parcel_id: typing.Optional[str]
    #: `key` of an existing [Parcel](ctp:api:type:Parcel).
    #:
    #: Either `parcelId` or `parcelKey` must be provided.
    parcel_key: typing.Optional[str]
    #: Value to set.
    #: If empty, any existing value will be removed.
    items: typing.List["DeliveryItem"]

    def __init__(
        self,
        *,
        parcel_id: typing.Optional[str] = None,
        parcel_key: typing.Optional[str] = None,
        items: typing.List["DeliveryItem"]
    ):
        self.parcel_id = parcel_id
        self.parcel_key = parcel_key
        self.items = items

        super().__init__(action="setParcelItems")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderSetParcelItemsAction":
        from ._schemas.order_edit import StagedOrderSetParcelItemsActionSchema

        return StagedOrderSetParcelItemsActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderSetParcelItemsActionSchema

        return StagedOrderSetParcelItemsActionSchema().dump(self)


class StagedOrderSetParcelMeasurementsAction(StagedOrderUpdateAction):
    """Produces the [ParcelMeasurementsUpdated](ctp:api:type:ParcelMeasurementsUpdatedMessage) Message."""

    #: `id` of an existing [Parcel](ctp:api:type:Parcel).
    #:
    #: Either `parcelId` or `parcelKey` must be provided.
    parcel_id: typing.Optional[str]
    #: `key` of an existing [Parcel](ctp:api:type:Parcel).
    #:
    #: Either `parcelId` or `parcelKey` must be provided.
    parcel_key: typing.Optional[str]
    #: Value to set.
    #: If empty, any existing value will be removed.
    measurements: typing.Optional["ParcelMeasurements"]

    def __init__(
        self,
        *,
        parcel_id: typing.Optional[str] = None,
        parcel_key: typing.Optional[str] = None,
        measurements: typing.Optional["ParcelMeasurements"] = None
    ):
        self.parcel_id = parcel_id
        self.parcel_key = parcel_key
        self.measurements = measurements

        super().__init__(action="setParcelMeasurements")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderSetParcelMeasurementsAction":
        from ._schemas.order_edit import StagedOrderSetParcelMeasurementsActionSchema

        return StagedOrderSetParcelMeasurementsActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderSetParcelMeasurementsActionSchema

        return StagedOrderSetParcelMeasurementsActionSchema().dump(self)


class StagedOrderSetParcelTrackingDataAction(StagedOrderUpdateAction):
    """Produces the [ParcelTrackingDataUpdated](ctp:api:type:ParcelTrackingDataUpdatedMessage) Message."""

    #: `id` of an existing [Parcel](ctp:api:type:Parcel).
    #:
    #: Either `parcelId` or `parcelKey` must be provided.
    parcel_id: typing.Optional[str]
    #: `key` of an existing [Parcel](ctp:api:type:Parcel).
    #:
    #: Either `parcelId` or `parcelKey` must be provided.
    parcel_key: typing.Optional[str]
    #: Value to set.
    #: If empty, any existing value will be removed.
    tracking_data: typing.Optional["TrackingData"]

    def __init__(
        self,
        *,
        parcel_id: typing.Optional[str] = None,
        parcel_key: typing.Optional[str] = None,
        tracking_data: typing.Optional["TrackingData"] = None
    ):
        self.parcel_id = parcel_id
        self.parcel_key = parcel_key
        self.tracking_data = tracking_data

        super().__init__(action="setParcelTrackingData")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderSetParcelTrackingDataAction":
        from ._schemas.order_edit import StagedOrderSetParcelTrackingDataActionSchema

        return StagedOrderSetParcelTrackingDataActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderSetParcelTrackingDataActionSchema

        return StagedOrderSetParcelTrackingDataActionSchema().dump(self)


class StagedOrderSetPurchaseOrderNumberAction(StagedOrderUpdateAction):
    """Produces the [PurchaseOrderNumberSet](ctp:api:type:OrderPurchaseOrderNumberSetMessage) Message."""

    #: Value to set.
    purchase_order_number: typing.Optional[str]

    def __init__(self, *, purchase_order_number: typing.Optional[str] = None):
        self.purchase_order_number = purchase_order_number

        super().__init__(action="setPurchaseOrderNumber")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderSetPurchaseOrderNumberAction":
        from ._schemas.order_edit import StagedOrderSetPurchaseOrderNumberActionSchema

        return StagedOrderSetPurchaseOrderNumberActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderSetPurchaseOrderNumberActionSchema

        return StagedOrderSetPurchaseOrderNumberActionSchema().dump(self)


class StagedOrderSetReturnInfoAction(StagedOrderUpdateAction):
    """Produces the [Return Info Set](ctp:api:type:ReturnInfoSetMessage) Message."""

    #: Value to set.
    #: If empty, any existing value will be removed.
    items: typing.Optional[typing.List["ReturnInfoDraft"]]

    def __init__(
        self, *, items: typing.Optional[typing.List["ReturnInfoDraft"]] = None
    ):
        self.items = items

        super().__init__(action="setReturnInfo")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderSetReturnInfoAction":
        from ._schemas.order_edit import StagedOrderSetReturnInfoActionSchema

        return StagedOrderSetReturnInfoActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderSetReturnInfoActionSchema

        return StagedOrderSetReturnInfoActionSchema().dump(self)


class StagedOrderSetReturnItemCustomFieldAction(StagedOrderUpdateAction):
    #: `id` of the [ReturnItem](ctp:api:type:ReturnItem) to update. Either `returnItemId` or `returnItemKey` is required.
    return_item_id: typing.Optional[str]
    #: `key` of the [ReturnItem](ctp:api:type:ReturnItem) to update. Either `returnItemId` or `returnItemKey` is required.
    return_item_key: typing.Optional[str]
    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: Removing a field that does not exist returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
    #: If `value` is provided, it is set for the field defined by `name`.
    value: typing.Optional[typing.Any]

    def __init__(
        self,
        *,
        return_item_id: typing.Optional[str] = None,
        return_item_key: typing.Optional[str] = None,
        name: str,
        value: typing.Optional[typing.Any] = None
    ):
        self.return_item_id = return_item_id
        self.return_item_key = return_item_key
        self.name = name
        self.value = value

        super().__init__(action="setReturnItemCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderSetReturnItemCustomFieldAction":
        from ._schemas.order_edit import StagedOrderSetReturnItemCustomFieldActionSchema

        return StagedOrderSetReturnItemCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderSetReturnItemCustomFieldActionSchema

        return StagedOrderSetReturnItemCustomFieldActionSchema().dump(self)


class StagedOrderSetReturnItemCustomTypeAction(StagedOrderUpdateAction):
    #: `id` of the [ReturnItem](ctp:api:type:ReturnItem) to update. Either `returnItemId` or `returnItemKey` is required.
    return_item_id: typing.Optional[str]
    #: `key` of the [ReturnItem](ctp:api:type:ReturnItem) to update. Either `returnItemId` or `returnItemKey` is required.
    return_item_key: typing.Optional[str]
    #: Defines the [Type](ctp:api:type:Type) that extends the Return Item with [Custom Fields](/../api/projects/custom-fields).
    #: If absent, any existing Type and Custom Fields are removed from the Return Item.
    type: typing.Optional["TypeResourceIdentifier"]
    #: Sets the [Custom Fields](/../api/projects/custom-fields) fields for the Return Item.
    fields: typing.Optional["FieldContainer"]

    def __init__(
        self,
        *,
        return_item_id: typing.Optional[str] = None,
        return_item_key: typing.Optional[str] = None,
        type: typing.Optional["TypeResourceIdentifier"] = None,
        fields: typing.Optional["FieldContainer"] = None
    ):
        self.return_item_id = return_item_id
        self.return_item_key = return_item_key
        self.type = type
        self.fields = fields

        super().__init__(action="setReturnItemCustomType")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderSetReturnItemCustomTypeAction":
        from ._schemas.order_edit import StagedOrderSetReturnItemCustomTypeActionSchema

        return StagedOrderSetReturnItemCustomTypeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderSetReturnItemCustomTypeActionSchema

        return StagedOrderSetReturnItemCustomTypeActionSchema().dump(self)


class StagedOrderSetReturnPaymentStateAction(StagedOrderUpdateAction):
    """To set a [ReturnPaymentState](ctp:api:type:ReturnPaymentState), the [Order](ctp:api:type:Order) `returnInfo` must have at least one [ReturnItem](ctp:api:type:ReturnItem)."""

    #: `id` of the [ReturnItem](ctp:api:type:ReturnItem) to update. Either `returnItemId` or `returnItemKey` is required.
    return_item_id: typing.Optional[str]
    #: `key` of the [ReturnItem](ctp:api:type:ReturnItem) to update. Either `returnItemId` or `returnItemKey` is required.
    return_item_key: typing.Optional[str]
    #: New Payment status of the [ReturnItem](ctp:api:type:ReturnItem).
    payment_state: "ReturnPaymentState"

    def __init__(
        self,
        *,
        return_item_id: typing.Optional[str] = None,
        return_item_key: typing.Optional[str] = None,
        payment_state: "ReturnPaymentState"
    ):
        self.return_item_id = return_item_id
        self.return_item_key = return_item_key
        self.payment_state = payment_state

        super().__init__(action="setReturnPaymentState")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderSetReturnPaymentStateAction":
        from ._schemas.order_edit import StagedOrderSetReturnPaymentStateActionSchema

        return StagedOrderSetReturnPaymentStateActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderSetReturnPaymentStateActionSchema

        return StagedOrderSetReturnPaymentStateActionSchema().dump(self)


class StagedOrderSetReturnShipmentStateAction(StagedOrderUpdateAction):
    """To set a `ReturnShipmentState`, the [Order](ctp:api:type:Order) `returnInfo` must have at least one [ReturnItem](ctp:api:type:ReturnItem).

    Produces the [Order Return Shipment State Changed](ctp:api:type:OrderReturnShipmentStateChangedMessage) Message.

    """

    #: `id` of the [ReturnItem](ctp:api:type:ReturnItem) to update. Either `returnItemId` or `returnItemKey` is required.
    return_item_id: typing.Optional[str]
    #: `key` of the [ReturnItem](ctp:api:type:ReturnItem) to update. Either `returnItemId` or `returnItemKey` is required.
    return_item_key: typing.Optional[str]
    #: New shipment state of the [ReturnItem](ctp:api:type:ReturnItem).
    shipment_state: "ReturnShipmentState"

    def __init__(
        self,
        *,
        return_item_id: typing.Optional[str] = None,
        return_item_key: typing.Optional[str] = None,
        shipment_state: "ReturnShipmentState"
    ):
        self.return_item_id = return_item_id
        self.return_item_key = return_item_key
        self.shipment_state = shipment_state

        super().__init__(action="setReturnShipmentState")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderSetReturnShipmentStateAction":
        from ._schemas.order_edit import StagedOrderSetReturnShipmentStateActionSchema

        return StagedOrderSetReturnShipmentStateActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderSetReturnShipmentStateActionSchema

        return StagedOrderSetReturnShipmentStateActionSchema().dump(self)


class StagedOrderSetShippingAddressAction(StagedOrderUpdateAction):
    """This action updates the `shippingAddress` on the Order, but it does not change the shipping address on the referenced [Cart](ctp:api:type:Cart) from which the Order is created.
    Also, it does not recalculate the Cart as taxes may not fit to the shipping address anymore.

    Produces the [Order Shipping Address Set](ctp:api:type:OrderShippingAddressSetMessage) Message.

    """

    #: Value to set.
    #: If empty, any existing value is removed.
    address: typing.Optional["BaseAddress"]

    def __init__(self, *, address: typing.Optional["BaseAddress"] = None):
        self.address = address

        super().__init__(action="setShippingAddress")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderSetShippingAddressAction":
        from ._schemas.order_edit import StagedOrderSetShippingAddressActionSchema

        return StagedOrderSetShippingAddressActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderSetShippingAddressActionSchema

        return StagedOrderSetShippingAddressActionSchema().dump(self)


class StagedOrderSetShippingAddressAndCustomShippingMethodAction(
    StagedOrderUpdateAction
):
    """Sets the shipping address and a custom Shipping Method together to prevent an inconsistent state."""

    #: Value to set for `shippingAddress`.
    address: "BaseAddress"
    #: Value to set.
    shipping_method_name: str
    #: Value to set.
    shipping_rate: "ShippingRateDraft"
    #: Used to select a Tax Rate when the Order has the `Platform` [TaxMode](ctp:api:type:TaxMode).
    tax_category: typing.Optional["TaxCategoryResourceIdentifier"]
    #: An external Tax Rate can be set if the Cart has the `External` [TaxMode](ctp:api:type:TaxMode).
    external_tax_rate: typing.Optional["ExternalTaxRateDraft"]

    def __init__(
        self,
        *,
        address: "BaseAddress",
        shipping_method_name: str,
        shipping_rate: "ShippingRateDraft",
        tax_category: typing.Optional["TaxCategoryResourceIdentifier"] = None,
        external_tax_rate: typing.Optional["ExternalTaxRateDraft"] = None
    ):
        self.address = address
        self.shipping_method_name = shipping_method_name
        self.shipping_rate = shipping_rate
        self.tax_category = tax_category
        self.external_tax_rate = external_tax_rate

        super().__init__(action="setShippingAddressAndCustomShippingMethod")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderSetShippingAddressAndCustomShippingMethodAction":
        from ._schemas.order_edit import (
            StagedOrderSetShippingAddressAndCustomShippingMethodActionSchema,
        )

        return StagedOrderSetShippingAddressAndCustomShippingMethodActionSchema().load(
            data
        )

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import (
            StagedOrderSetShippingAddressAndCustomShippingMethodActionSchema,
        )

        return StagedOrderSetShippingAddressAndCustomShippingMethodActionSchema().dump(
            self
        )


class StagedOrderSetShippingAddressAndShippingMethodAction(StagedOrderUpdateAction):
    """Sets the shipping address and Shipping Method together to prevent an inconsistent state."""

    #: Value to set for `shippingAddress`.
    address: "BaseAddress"
    #: Value to set.
    shipping_method: typing.Optional["ShippingMethodResourceIdentifier"]
    #: An external Tax Rate can be set if the Cart has the `External` [TaxMode](ctp:api:type:TaxMode).
    external_tax_rate: typing.Optional["ExternalTaxRateDraft"]

    def __init__(
        self,
        *,
        address: "BaseAddress",
        shipping_method: typing.Optional["ShippingMethodResourceIdentifier"] = None,
        external_tax_rate: typing.Optional["ExternalTaxRateDraft"] = None
    ):
        self.address = address
        self.shipping_method = shipping_method
        self.external_tax_rate = external_tax_rate

        super().__init__(action="setShippingAddressAndShippingMethod")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderSetShippingAddressAndShippingMethodAction":
        from ._schemas.order_edit import (
            StagedOrderSetShippingAddressAndShippingMethodActionSchema,
        )

        return StagedOrderSetShippingAddressAndShippingMethodActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import (
            StagedOrderSetShippingAddressAndShippingMethodActionSchema,
        )

        return StagedOrderSetShippingAddressAndShippingMethodActionSchema().dump(self)


class StagedOrderSetShippingAddressCustomFieldAction(StagedOrderUpdateAction):
    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: Removing a field that does not exist returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
    #: If `value` is provided, it is set for the field defined by `name`.
    value: typing.Optional[typing.Any]

    def __init__(self, *, name: str, value: typing.Optional[typing.Any] = None):
        self.name = name
        self.value = value

        super().__init__(action="setShippingAddressCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderSetShippingAddressCustomFieldAction":
        from ._schemas.order_edit import (
            StagedOrderSetShippingAddressCustomFieldActionSchema,
        )

        return StagedOrderSetShippingAddressCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import (
            StagedOrderSetShippingAddressCustomFieldActionSchema,
        )

        return StagedOrderSetShippingAddressCustomFieldActionSchema().dump(self)


class StagedOrderSetShippingAddressCustomTypeAction(StagedOrderUpdateAction):
    #: Defines the [Type](ctp:api:type:Type) that extends the `shippingAddress` with [Custom Fields](/../api/projects/custom-fields).
    #: If absent, any existing Type and Custom Fields are removed from the `shippingAddress`.
    type: typing.Optional["TypeResourceIdentifier"]
    #: Sets the [Custom Fields](/../api/projects/custom-fields) fields for the `shippingAddress`.
    fields: typing.Optional["FieldContainer"]

    def __init__(
        self,
        *,
        type: typing.Optional["TypeResourceIdentifier"] = None,
        fields: typing.Optional["FieldContainer"] = None
    ):
        self.type = type
        self.fields = fields

        super().__init__(action="setShippingAddressCustomType")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderSetShippingAddressCustomTypeAction":
        from ._schemas.order_edit import (
            StagedOrderSetShippingAddressCustomTypeActionSchema,
        )

        return StagedOrderSetShippingAddressCustomTypeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import (
            StagedOrderSetShippingAddressCustomTypeActionSchema,
        )

        return StagedOrderSetShippingAddressCustomTypeActionSchema().dump(self)


class StagedOrderSetShippingMethodAction(StagedOrderUpdateAction):
    """To set the Cart's Shipping Method, the Cart must have the `Single` [ShippingMode](ctp:api:type:ShippingMode) and a `shippingAddress`."""

    #: Value to set. If empty, any existing value will be removed.
    #: If the referenced Shipping Method has a predicate that does not match the Cart, an [InvalidOperation](ctp:api:type:InvalidOperationError) error is returned.
    shipping_method: typing.Optional["ShippingMethodResourceIdentifier"]
    #: An external Tax Rate can be set if the Cart has the `External` [TaxMode](ctp:api:type:TaxMode).
    external_tax_rate: typing.Optional["ExternalTaxRateDraft"]

    def __init__(
        self,
        *,
        shipping_method: typing.Optional["ShippingMethodResourceIdentifier"] = None,
        external_tax_rate: typing.Optional["ExternalTaxRateDraft"] = None
    ):
        self.shipping_method = shipping_method
        self.external_tax_rate = external_tax_rate

        super().__init__(action="setShippingMethod")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderSetShippingMethodAction":
        from ._schemas.order_edit import StagedOrderSetShippingMethodActionSchema

        return StagedOrderSetShippingMethodActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderSetShippingMethodActionSchema

        return StagedOrderSetShippingMethodActionSchema().dump(self)


class StagedOrderSetShippingMethodTaxAmountAction(StagedOrderUpdateAction):
    """A Shipping Method tax amount can be set if the Cart has the `ExternalAmount` [TaxMode](ctp:api:type:TaxMode)."""

    #: `key` of the [ShippingMethod](ctp:api:type:ShippingMethod) to update. This is required for Orders with `Multiple` [ShippingMode](ctp:api:type:ShippingMode).
    shipping_key: typing.Optional[str]
    #: Value to set. If empty, any existing value will be removed.
    external_tax_amount: typing.Optional["ExternalTaxAmountDraft"]

    def __init__(
        self,
        *,
        shipping_key: typing.Optional[str] = None,
        external_tax_amount: typing.Optional["ExternalTaxAmountDraft"] = None
    ):
        self.shipping_key = shipping_key
        self.external_tax_amount = external_tax_amount

        super().__init__(action="setShippingMethodTaxAmount")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderSetShippingMethodTaxAmountAction":
        from ._schemas.order_edit import (
            StagedOrderSetShippingMethodTaxAmountActionSchema,
        )

        return StagedOrderSetShippingMethodTaxAmountActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import (
            StagedOrderSetShippingMethodTaxAmountActionSchema,
        )

        return StagedOrderSetShippingMethodTaxAmountActionSchema().dump(self)


class StagedOrderSetShippingMethodTaxRateAction(StagedOrderUpdateAction):
    """A Shipping Method Tax Rate can be set if the Cart has the `External` [TaxMode](ctp:api:type:TaxMode)."""

    #: `key` of the [ShippingMethod](ctp:api:type:ShippingMethod) to update. This is required for Orders with `Multiple` [ShippingMode](ctp:api:type:ShippingMode).
    shipping_key: typing.Optional[str]
    #: Value to set.
    #: If empty, any existing value is removed.
    external_tax_rate: typing.Optional["ExternalTaxRateDraft"]

    def __init__(
        self,
        *,
        shipping_key: typing.Optional[str] = None,
        external_tax_rate: typing.Optional["ExternalTaxRateDraft"] = None
    ):
        self.shipping_key = shipping_key
        self.external_tax_rate = external_tax_rate

        super().__init__(action="setShippingMethodTaxRate")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderSetShippingMethodTaxRateAction":
        from ._schemas.order_edit import StagedOrderSetShippingMethodTaxRateActionSchema

        return StagedOrderSetShippingMethodTaxRateActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderSetShippingMethodTaxRateActionSchema

        return StagedOrderSetShippingMethodTaxRateActionSchema().dump(self)


class StagedOrderSetShippingRateInputAction(StagedOrderUpdateAction):
    """Input used to select a [ShippingRatePriceTier](ctp:api:type:ShippingRatePriceTier). If no matching tier can be found, or the input is not set, the default price for the shipping rate is used."""

    #: The data type of this field depends on the `shippingRateInputType.type` configured in the [Project](ctp:api:type:Project):
    #:
    #: - If `CartClassification`, it must be [ClassificationShippingRateInputDraft](ctp:api:type:ClassificationShippingRateInputDraft).
    #: - If `CartScore`, it must be [ScoreShippingRateInputDraft](ctp:api:type:ScoreShippingRateInputDraft).
    #: - If `CartValue`, it cannot be set.
    shipping_rate_input: typing.Optional["ShippingRateInputDraft"]

    def __init__(
        self, *, shipping_rate_input: typing.Optional["ShippingRateInputDraft"] = None
    ):
        self.shipping_rate_input = shipping_rate_input

        super().__init__(action="setShippingRateInput")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderSetShippingRateInputAction":
        from ._schemas.order_edit import StagedOrderSetShippingRateInputActionSchema

        return StagedOrderSetShippingRateInputActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderSetShippingRateInputActionSchema

        return StagedOrderSetShippingRateInputActionSchema().dump(self)


class StagedOrderSetStoreAction(StagedOrderUpdateAction):
    """Sets the [Store](ctp:api:type:Store) the Order is assigned to.
    It should be used to migrate Orders to a new Store.
    No validations are performed (such as that the Customer is allowed to create Orders in the Store).

    Produces the [Order Store Set](ctp:api:type:OrderStoreSetMessage) Message.
    Returns a `400` error if `store` references the same Store the Order is currently assigned to, including if you try to remove the value when no Store is currently assigned.

    """

    #: Value to set. If empty, any existing value will be removed.
    #:
    #: If `store` references the same Store the Order is currently assigned to or if you try to remove the value when no Store is currently assigned, a `400` error is returned.
    store: typing.Optional["StoreResourceIdentifier"]

    def __init__(self, *, store: typing.Optional["StoreResourceIdentifier"] = None):
        self.store = store

        super().__init__(action="setStore")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderSetStoreAction":
        from ._schemas.order_edit import StagedOrderSetStoreActionSchema

        return StagedOrderSetStoreActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderSetStoreActionSchema

        return StagedOrderSetStoreActionSchema().dump(self)


class StagedOrderTransitionCustomLineItemStateAction(StagedOrderUpdateAction):
    """Produces the [Custom Line Item State Transition](ctp:api:type:CustomLineItemStateTransitionMessage) Message."""

    #: `id` of the [CustomLineItem](ctp:api:type:CustomLineItem) to update. Either `customLineItemId` or `customLineItemKey` is required.
    custom_line_item_id: typing.Optional[str]
    #: `key` of the [CustomLineItem](ctp:api:type:CustomLineItem) to update. Either `customLineItemId` or `customLineItemKey` is required.
    custom_line_item_key: typing.Optional[str]
    #: Number of Custom Line Items that should transition [State](ctp:api:type:State).
    quantity: int
    #: [State](ctp:api:type:State) the Custom Line Item should transition from.
    from_state: "StateResourceIdentifier"
    #: [State](ctp:api:type:State) the Custom Line Item should transition to.
    to_state: "StateResourceIdentifier"
    #: Date and time (UTC) to perform the [State](ctp:api:type:State) transition.
    actual_transition_date: typing.Optional[datetime.datetime]

    def __init__(
        self,
        *,
        custom_line_item_id: typing.Optional[str] = None,
        custom_line_item_key: typing.Optional[str] = None,
        quantity: int,
        from_state: "StateResourceIdentifier",
        to_state: "StateResourceIdentifier",
        actual_transition_date: typing.Optional[datetime.datetime] = None
    ):
        self.custom_line_item_id = custom_line_item_id
        self.custom_line_item_key = custom_line_item_key
        self.quantity = quantity
        self.from_state = from_state
        self.to_state = to_state
        self.actual_transition_date = actual_transition_date

        super().__init__(action="transitionCustomLineItemState")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderTransitionCustomLineItemStateAction":
        from ._schemas.order_edit import (
            StagedOrderTransitionCustomLineItemStateActionSchema,
        )

        return StagedOrderTransitionCustomLineItemStateActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import (
            StagedOrderTransitionCustomLineItemStateActionSchema,
        )

        return StagedOrderTransitionCustomLineItemStateActionSchema().dump(self)


class StagedOrderTransitionLineItemStateAction(StagedOrderUpdateAction):
    """Produces the [Line Item State Transition](ctp:api:type:LineItemStateTransitionMessage) Message."""

    #: `id` of the [LineItem](ctp:api:type:LineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    line_item_id: typing.Optional[str]
    #: `key` of the [LineItem](ctp:api:type:LineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    line_item_key: typing.Optional[str]
    #: Number of Line Items that should transition [State](ctp:api:type:State).
    quantity: int
    #: [State](ctp:api:type:State) the Line Item should transition from.
    from_state: "StateResourceIdentifier"
    #: [State](ctp:api:type:State) the Line Item should transition to.
    to_state: "StateResourceIdentifier"
    #: Date and time (UTC) to perform the [State](ctp:api:type:State) transition.
    actual_transition_date: typing.Optional[datetime.datetime]

    def __init__(
        self,
        *,
        line_item_id: typing.Optional[str] = None,
        line_item_key: typing.Optional[str] = None,
        quantity: int,
        from_state: "StateResourceIdentifier",
        to_state: "StateResourceIdentifier",
        actual_transition_date: typing.Optional[datetime.datetime] = None
    ):
        self.line_item_id = line_item_id
        self.line_item_key = line_item_key
        self.quantity = quantity
        self.from_state = from_state
        self.to_state = to_state
        self.actual_transition_date = actual_transition_date

        super().__init__(action="transitionLineItemState")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderTransitionLineItemStateAction":
        from ._schemas.order_edit import StagedOrderTransitionLineItemStateActionSchema

        return StagedOrderTransitionLineItemStateActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderTransitionLineItemStateActionSchema

        return StagedOrderTransitionLineItemStateActionSchema().dump(self)


class StagedOrderTransitionStateAction(StagedOrderUpdateAction):
    """If the existing [State](ctp:api:type:State) has set `transitions`, there must be a direct transition to the new State. If `transitions` is not set, no validation is performed.

    This update action produces the [Order State Transition](ctp:api:type:OrderStateTransitionMessage) Message.

    """

    #: Value to set.
    #: If there is no State yet, the new State must be an initial State.
    state: "StateResourceIdentifier"
    #: Set to `true` to turn off validation.
    force: typing.Optional[bool]

    def __init__(
        self, *, state: "StateResourceIdentifier", force: typing.Optional[bool] = None
    ):
        self.state = state
        self.force = force

        super().__init__(action="transitionState")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderTransitionStateAction":
        from ._schemas.order_edit import StagedOrderTransitionStateActionSchema

        return StagedOrderTransitionStateActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderTransitionStateActionSchema

        return StagedOrderTransitionStateActionSchema().dump(self)


class StagedOrderUpdateItemShippingAddressAction(StagedOrderUpdateAction):
    """Updates an address in `itemShippingAddresses` by keeping the Address `key`."""

    #: The new Address with the same `key` as the Address it will replace.
    address: "BaseAddress"

    def __init__(self, *, address: "BaseAddress"):
        self.address = address

        super().__init__(action="updateItemShippingAddress")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderUpdateItemShippingAddressAction":
        from ._schemas.order_edit import (
            StagedOrderUpdateItemShippingAddressActionSchema,
        )

        return StagedOrderUpdateItemShippingAddressActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import (
            StagedOrderUpdateItemShippingAddressActionSchema,
        )

        return StagedOrderUpdateItemShippingAddressActionSchema().dump(self)


class StagedOrderUpdateSyncInfoAction(StagedOrderUpdateAction):
    #: Set this to identify an external order instance, file, or other resource.
    external_id: typing.Optional[str]
    #: The synchronization destination to set. Must not be empty.
    #: The referenced Channel must have the [Channel Role](ctp:api:type:ChannelRoleEnum) `OrderExport` or `OrderImport`.
    #: Otherwise this update action returns an [InvalidInput](ctp:api:type:InvalidInputError) error.
    channel: "ChannelResourceIdentifier"
    #: If not set, it defaults to the current date and time.
    synced_at: typing.Optional[datetime.datetime]

    def __init__(
        self,
        *,
        external_id: typing.Optional[str] = None,
        channel: "ChannelResourceIdentifier",
        synced_at: typing.Optional[datetime.datetime] = None
    ):
        self.external_id = external_id
        self.channel = channel
        self.synced_at = synced_at

        super().__init__(action="updateSyncInfo")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StagedOrderUpdateSyncInfoAction":
        from ._schemas.order_edit import StagedOrderUpdateSyncInfoActionSchema

        return StagedOrderUpdateSyncInfoActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.order_edit import StagedOrderUpdateSyncInfoActionSchema

        return StagedOrderUpdateSyncInfoActionSchema().dump(self)
