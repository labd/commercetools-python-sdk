# This file is automatically generated by the rmf-codegen project.
#
# The Python code generator is maintained by Lab Digital. If you want to
# contribute to this project then please do not edit this file directly
# but send a pull request to the Lab Digital fork of rmf-codegen at
# https://github.com/labd/rmf-codegen

import datetime
import enum
import typing

from ._abstract import _BaseType
from .cart import ProductPublishScope
from .common import BaseResource, Reference, ReferenceTypeId, ResourceIdentifier

if typing.TYPE_CHECKING:
    from .cart import ProductPublishScope
    from .category import CategoryReference, CategoryResourceIdentifier
    from .common import (
        Asset,
        AssetDraft,
        AssetSource,
        CreatedBy,
        DiscountedPriceDraft,
        Image,
        LastModifiedBy,
        LocalizedString,
        Price,
        PriceDraft,
        ReferenceTypeId,
        ScopedPrice,
    )
    from .product_type import ProductTypeReference, ProductTypeResourceIdentifier
    from .review import ReviewRatingStatistics
    from .state import StateReference, StateResourceIdentifier
    from .tax_category import TaxCategoryReference, TaxCategoryResourceIdentifier
    from .type import FieldContainer, TypeResourceIdentifier

__all__ = [
    "Attribute",
    "CategoryOrderHints",
    "CustomTokenizer",
    "FacetRange",
    "FacetResult",
    "FacetResults",
    "FacetTerm",
    "FacetTypes",
    "FilteredFacetResult",
    "Product",
    "ProductAddAssetAction",
    "ProductAddExternalImageAction",
    "ProductAddPriceAction",
    "ProductAddToCategoryAction",
    "ProductAddVariantAction",
    "ProductCatalogData",
    "ProductChangeAssetNameAction",
    "ProductChangeAssetOrderAction",
    "ProductChangeMasterVariantAction",
    "ProductChangeNameAction",
    "ProductChangePriceAction",
    "ProductChangeSlugAction",
    "ProductData",
    "ProductDraft",
    "ProductLegacySetSkuAction",
    "ProductMoveImageToPositionAction",
    "ProductPagedQueryResponse",
    "ProductPriceModeEnum",
    "ProductProjection",
    "ProductProjectionPagedQueryResponse",
    "ProductProjectionPagedSearchResponse",
    "ProductPublishAction",
    "ProductReference",
    "ProductRemoveAssetAction",
    "ProductRemoveFromCategoryAction",
    "ProductRemoveImageAction",
    "ProductRemovePriceAction",
    "ProductRemoveVariantAction",
    "ProductResourceIdentifier",
    "ProductRevertStagedChangesAction",
    "ProductRevertStagedVariantChangesAction",
    "ProductSetAssetCustomFieldAction",
    "ProductSetAssetCustomTypeAction",
    "ProductSetAssetDescriptionAction",
    "ProductSetAssetKeyAction",
    "ProductSetAssetSourcesAction",
    "ProductSetAssetTagsAction",
    "ProductSetAttributeAction",
    "ProductSetAttributeInAllVariantsAction",
    "ProductSetCategoryOrderHintAction",
    "ProductSetDescriptionAction",
    "ProductSetDiscountedPriceAction",
    "ProductSetImageLabelAction",
    "ProductSetKeyAction",
    "ProductSetMetaDescriptionAction",
    "ProductSetMetaKeywordsAction",
    "ProductSetMetaTitleAction",
    "ProductSetPriceKeyAction",
    "ProductSetPriceModeAction",
    "ProductSetPricesAction",
    "ProductSetProductPriceCustomFieldAction",
    "ProductSetProductPriceCustomTypeAction",
    "ProductSetProductVariantKeyAction",
    "ProductSetSearchKeywordsAction",
    "ProductSetSkuAction",
    "ProductSetTaxCategoryAction",
    "ProductTransitionStateAction",
    "ProductUnpublishAction",
    "ProductUpdate",
    "ProductUpdateAction",
    "ProductVariant",
    "ProductVariantAvailability",
    "ProductVariantChannelAvailability",
    "ProductVariantChannelAvailabilityMap",
    "ProductVariantDraft",
    "RangeFacetResult",
    "SearchKeyword",
    "SearchKeywords",
    "SuggestTokenizer",
    "Suggestion",
    "SuggestionResult",
    "TermFacetResult",
    "TermFacetResultType",
    "WhitespaceTokenizer",
]


class Attribute(_BaseType):
    #: Name of the Attribute.
    name: str
    #: The [AttributeType](ctp:api:type:AttributeType) determines the format of the Attribute `value` to be provided:
    #:
    #: - For [Enum Type](ctp:api:type:AttributeEnumType) and [Localized Enum Type](ctp:api:type:AttributeLocalizedEnumType),
    #:   use the `key` of the [Plain Enum Value](ctp:api:type:AttributePlainEnumValue) or [Localized Enum Value](ctp:api:type:AttributeLocalizedEnumValue) objects,
    #:   or the complete objects as `value`.
    #: - For [Localizable Text Type](ctp:api:type:AttributeLocalizableTextType), use the [LocalizedString](ctp:api:type:LocalizedString) object as `value`.
    #: - For [Money Type](ctp:api:type:AttributeMoneyType) Attributes, use the [Money](ctp:api:type:Money) object as `value`.
    #: - For [Set Type](ctp:api:type:AttributeSetType) Attributes, use the entire `set` object  as `value`.
    #: - For [Nested Type](ctp:api:type:AttributeNestedType) Attributes, use the list of values of all Attributes of the nested Product as `value`.
    #: - For [Reference Type](ctp:api:type:AttributeReferenceType) Attributes, use the [Reference](ctp:api:type:Reference) object as `value`.
    value: typing.Any

    def __init__(self, *, name: str, value: typing.Any):
        self.name = name
        self.value = value

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "Attribute":
        from ._schemas.product import AttributeSchema

        return AttributeSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import AttributeSchema

        return AttributeSchema().dump(self)


class CategoryOrderHints(typing.Dict[str, str]):
    pass


class FacetRange(_BaseType):
    from_: float
    from_str: str
    to: float
    to_str: str
    count: int
    product_count: typing.Optional[int]
    total: float
    min: float
    max: float
    mean: float

    def __init__(
        self,
        *,
        from_: float,
        from_str: str,
        to: float,
        to_str: str,
        count: int,
        product_count: typing.Optional[int] = None,
        total: float,
        min: float,
        max: float,
        mean: float
    ):
        self.from_ = from_
        self.from_str = from_str
        self.to = to
        self.to_str = to_str
        self.count = count
        self.product_count = product_count
        self.total = total
        self.min = min
        self.max = max
        self.mean = mean

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "FacetRange":
        from ._schemas.product import FacetRangeSchema

        return FacetRangeSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import FacetRangeSchema

        return FacetRangeSchema().dump(self)


class FacetResult(_BaseType):
    type: "FacetTypes"

    def __init__(self, *, type: "FacetTypes"):
        self.type = type

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "FacetResult":
        if data["type"] == "filter":
            from ._schemas.product import FilteredFacetResultSchema

            return FilteredFacetResultSchema().load(data)
        if data["type"] == "range":
            from ._schemas.product import RangeFacetResultSchema

            return RangeFacetResultSchema().load(data)
        if data["type"] == "terms":
            from ._schemas.product import TermFacetResultSchema

            return TermFacetResultSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import FacetResultSchema

        return FacetResultSchema().dump(self)


class FacetResults(typing.Dict[str, "FacetResult"]):
    pass


class FacetTerm(_BaseType):
    term: typing.Any
    count: int
    product_count: typing.Optional[int]

    def __init__(
        self,
        *,
        term: typing.Any,
        count: int,
        product_count: typing.Optional[int] = None
    ):
        self.term = term
        self.count = count
        self.product_count = product_count

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "FacetTerm":
        from ._schemas.product import FacetTermSchema

        return FacetTermSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import FacetTermSchema

        return FacetTermSchema().dump(self)


class FacetTypes(enum.Enum):
    TERMS = "terms"
    RANGE = "range"
    FILTER = "filter"


class FilteredFacetResult(FacetResult):
    count: int
    product_count: typing.Optional[int]

    def __init__(self, *, count: int, product_count: typing.Optional[int] = None):
        self.count = count
        self.product_count = product_count

        super().__init__(type=FacetTypes.FILTER)

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "FilteredFacetResult":
        from ._schemas.product import FilteredFacetResultSchema

        return FilteredFacetResultSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import FilteredFacetResultSchema

        return FilteredFacetResultSchema().dump(self)


class Product(BaseResource):
    """An abstract sellable good with a set of Attributes defined by a Product Type.
    Products themselves are not sellable. Instead, they act as a parent structure for Product Variants.
    Each Product must have at least one Product Variant, which is called the Master Variant.
    A single Product representation contains the _current_ and the _staged_ representation of its product data.

    """

    #: Present on resources created after 1 February 2019 except for [events not tracked](/../api/client-logging#events-tracked).
    last_modified_by: typing.Optional["LastModifiedBy"]
    #: Present on resources created after 1 February 2019 except for [events not tracked](/../api/client-logging#events-tracked).
    created_by: typing.Optional["CreatedBy"]
    #: User-defined unique identifier of the Product.
    #:
    #: This is different from the `key` of a [ProductVariant](ctp:api:type:ProductVariant).
    key: typing.Optional[str]
    #: The Product Type defining the Attributes of the Product. Cannot be changed.
    product_type: "ProductTypeReference"
    #: Contains the current and the staged representation of the product information.
    master_data: "ProductCatalogData"
    #: The [TaxCategory](ctp:api:type:TaxCategory) of the Product.
    tax_category: typing.Optional["TaxCategoryReference"]
    #: [State](ctp:api:type:State) of the Product.
    state: typing.Optional["StateReference"]
    #: Review statistics of the Product.
    review_rating_statistics: typing.Optional["ReviewRatingStatistics"]
    #: Type of Price to be used when looking up a price for the Product.
    price_mode: typing.Optional["ProductPriceModeEnum"]

    def __init__(
        self,
        *,
        id: str,
        version: int,
        created_at: datetime.datetime,
        last_modified_at: datetime.datetime,
        last_modified_by: typing.Optional["LastModifiedBy"] = None,
        created_by: typing.Optional["CreatedBy"] = None,
        key: typing.Optional[str] = None,
        product_type: "ProductTypeReference",
        master_data: "ProductCatalogData",
        tax_category: typing.Optional["TaxCategoryReference"] = None,
        state: typing.Optional["StateReference"] = None,
        review_rating_statistics: typing.Optional["ReviewRatingStatistics"] = None,
        price_mode: typing.Optional["ProductPriceModeEnum"] = None
    ):
        self.last_modified_by = last_modified_by
        self.created_by = created_by
        self.key = key
        self.product_type = product_type
        self.master_data = master_data
        self.tax_category = tax_category
        self.state = state
        self.review_rating_statistics = review_rating_statistics
        self.price_mode = price_mode

        super().__init__(
            id=id,
            version=version,
            created_at=created_at,
            last_modified_at=last_modified_at,
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "Product":
        from ._schemas.product import ProductSchema

        return ProductSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import ProductSchema

        return ProductSchema().dump(self)


class ProductCatalogData(_BaseType):
    """Contains the `current` and `staged` [ProductData](ctp:api:type:ProductData)."""

    #: `true` if the Product is published.
    published: bool
    #: Current (published) data of the Product.
    current: "ProductData"
    #: Staged (unpublished) data of the Product.
    staged: "ProductData"
    #: `true` if the `staged` data is different from the `current` data.
    has_staged_changes: bool

    def __init__(
        self,
        *,
        published: bool,
        current: "ProductData",
        staged: "ProductData",
        has_staged_changes: bool
    ):
        self.published = published
        self.current = current
        self.staged = staged
        self.has_staged_changes = has_staged_changes

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ProductCatalogData":
        from ._schemas.product import ProductCatalogDataSchema

        return ProductCatalogDataSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import ProductCatalogDataSchema

        return ProductCatalogDataSchema().dump(self)


class ProductData(_BaseType):
    """Contains all the data of a Product and its Product Variants."""

    #: Name of the Product.
    name: "LocalizedString"
    #: [Categories](ctp:api:type:Category) assigned to the Product.
    categories: typing.List["CategoryReference"]
    #: Numerical values to allow ordering of Products within a specified Category.
    category_order_hints: typing.Optional["CategoryOrderHints"]
    #: Description of the Product.
    description: typing.Optional["LocalizedString"]
    #: User-defined identifier used in a deep-link URL for the Product.
    #: Must be unique across a Project, but can be the same for Products in different [Locales](ctp:api:type:Locale).
    #: Matches the pattern `[a-zA-Z0-9_\\-]{2,256}`.
    slug: "LocalizedString"
    #: Title of the Product displayed in search results.
    meta_title: typing.Optional["LocalizedString"]
    #: Description of the Product displayed in search results below the meta title.
    meta_description: typing.Optional["LocalizedString"]
    #: Keywords that give additional information about the Product to search engines.
    meta_keywords: typing.Optional["LocalizedString"]
    #: The Master Variant of the Product.
    master_variant: "ProductVariant"
    #: Additional Product Variants.
    variants: typing.List["ProductVariant"]
    #: Used by [Product Suggestions](ctp:api:type:ProductSuggestions), but is also considered for a full text search.
    search_keywords: "SearchKeywords"

    def __init__(
        self,
        *,
        name: "LocalizedString",
        categories: typing.List["CategoryReference"],
        category_order_hints: typing.Optional["CategoryOrderHints"] = None,
        description: typing.Optional["LocalizedString"] = None,
        slug: "LocalizedString",
        meta_title: typing.Optional["LocalizedString"] = None,
        meta_description: typing.Optional["LocalizedString"] = None,
        meta_keywords: typing.Optional["LocalizedString"] = None,
        master_variant: "ProductVariant",
        variants: typing.List["ProductVariant"],
        search_keywords: "SearchKeywords"
    ):
        self.name = name
        self.categories = categories
        self.category_order_hints = category_order_hints
        self.description = description
        self.slug = slug
        self.meta_title = meta_title
        self.meta_description = meta_description
        self.meta_keywords = meta_keywords
        self.master_variant = master_variant
        self.variants = variants
        self.search_keywords = search_keywords

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ProductData":
        from ._schemas.product import ProductDataSchema

        return ProductDataSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import ProductDataSchema

        return ProductDataSchema().dump(self)


class ProductDraft(_BaseType):
    #: The Product Type defining the Attributes for the Product. Cannot be changed later.
    product_type: "ProductTypeResourceIdentifier"
    #: Name of the Product.
    name: "LocalizedString"
    #: User-defined identifier used in a deep-link URL for the Product.
    #: It must be unique across a Project, but a Product can have the same slug in different [Locales](ctp:api:type:Locale).
    #: It must match the pattern `[a-zA-Z0-9_\\-]{2,256}`.
    slug: "LocalizedString"
    #: User-defined unique identifier for the Product.
    key: typing.Optional[str]
    #: Description of the Product.
    description: typing.Optional["LocalizedString"]
    #: Categories assigned to the Product.
    categories: typing.Optional[typing.List["CategoryResourceIdentifier"]]
    #: Numerical values to allow ordering of Products within a specified Category.
    category_order_hints: typing.Optional["CategoryOrderHints"]
    #: Title of the Product displayed in search results.
    meta_title: typing.Optional["LocalizedString"]
    #: Description of the Product displayed in search results.
    meta_description: typing.Optional["LocalizedString"]
    #: Keywords that give additional information about the Product to search engines.
    meta_keywords: typing.Optional["LocalizedString"]
    #: The Product Variant to be the Master Variant for the Product. Required if `variants` are provided also.
    master_variant: typing.Optional["ProductVariantDraft"]
    #: The additional Product Variants for the Product.
    variants: typing.Optional[typing.List["ProductVariantDraft"]]
    #: The Tax Category to be assigned to the Product.
    tax_category: typing.Optional["TaxCategoryResourceIdentifier"]
    #: Used by [Product Suggestions](ctp:api:type:ProductSuggestions), but is also considered for a [full text search](/projects/products-search#full-text-search).
    search_keywords: typing.Optional["SearchKeywords"]
    #: State to be assigned to the Product.
    state: typing.Optional["StateResourceIdentifier"]
    #: If `true`, the Product is published immediately to the current projection.
    publish: typing.Optional[bool]
    #: Specifies the type of prices used when looking up a price for the Product.
    price_mode: typing.Optional["ProductPriceModeEnum"]

    def __init__(
        self,
        *,
        product_type: "ProductTypeResourceIdentifier",
        name: "LocalizedString",
        slug: "LocalizedString",
        key: typing.Optional[str] = None,
        description: typing.Optional["LocalizedString"] = None,
        categories: typing.Optional[typing.List["CategoryResourceIdentifier"]] = None,
        category_order_hints: typing.Optional["CategoryOrderHints"] = None,
        meta_title: typing.Optional["LocalizedString"] = None,
        meta_description: typing.Optional["LocalizedString"] = None,
        meta_keywords: typing.Optional["LocalizedString"] = None,
        master_variant: typing.Optional["ProductVariantDraft"] = None,
        variants: typing.Optional[typing.List["ProductVariantDraft"]] = None,
        tax_category: typing.Optional["TaxCategoryResourceIdentifier"] = None,
        search_keywords: typing.Optional["SearchKeywords"] = None,
        state: typing.Optional["StateResourceIdentifier"] = None,
        publish: typing.Optional[bool] = None,
        price_mode: typing.Optional["ProductPriceModeEnum"] = None
    ):
        self.product_type = product_type
        self.name = name
        self.slug = slug
        self.key = key
        self.description = description
        self.categories = categories
        self.category_order_hints = category_order_hints
        self.meta_title = meta_title
        self.meta_description = meta_description
        self.meta_keywords = meta_keywords
        self.master_variant = master_variant
        self.variants = variants
        self.tax_category = tax_category
        self.search_keywords = search_keywords
        self.state = state
        self.publish = publish
        self.price_mode = price_mode

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ProductDraft":
        from ._schemas.product import ProductDraftSchema

        return ProductDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import ProductDraftSchema

        return ProductDraftSchema().dump(self)


class ProductPagedQueryResponse(_BaseType):
    """[PagedQueryResult](/../api/general-concepts#pagedqueryresult) with `results` containing an array of [Product](ctp:api:type:Product)."""

    #: Number of [results requested](/../api/general-concepts#limit).
    limit: int
    #: Number of [elements skipped](/../api/general-concepts#offset).
    offset: int
    #: Actual number of results returned.
    count: int
    #: Total number of results matching the query.
    #: This number is an estimation that is not [strongly consistent](/../api/general-concepts#strong-consistency).
    #: This field is returned by default.
    #: For improved performance, calculating this field can be deactivated by using the query parameter `withTotal=false`.
    #: When the results are filtered with a [Query Predicate](ctp:api:type:QueryPredicate), `total` is subject to a [limit](/../api/limits#queries).
    total: typing.Optional[int]
    #: [Products](ctp:api:type:Product) matching the query.
    results: typing.List["Product"]

    def __init__(
        self,
        *,
        limit: int,
        offset: int,
        count: int,
        total: typing.Optional[int] = None,
        results: typing.List["Product"]
    ):
        self.limit = limit
        self.offset = offset
        self.count = count
        self.total = total
        self.results = results

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductPagedQueryResponse":
        from ._schemas.product import ProductPagedQueryResponseSchema

        return ProductPagedQueryResponseSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import ProductPagedQueryResponseSchema

        return ProductPagedQueryResponseSchema().dump(self)


class ProductPriceModeEnum(enum.Enum):
    """This mode determines the type of Prices used for [Product Price Selection](ctp:api:type:ProductPriceSelection) and for [LineItem Price selection](ctp:api:type:LineItemPriceSelection)."""

    EMBEDDED = "Embedded"
    STANDALONE = "Standalone"


class ProductProjection(BaseResource):
    #: User-defined unique identifier of the [Product](ctp:api:type:Product).
    key: typing.Optional[str]
    #: The [ProductType](ctp:api:type:ProductType) defining the Attributes of the [Product](ctp:api:type:Product).
    product_type: "ProductTypeReference"
    #: Name of the [Product](ctp:api:type:Product).
    name: "LocalizedString"
    #: Description of the [Product](ctp:api:type:Product).
    description: typing.Optional["LocalizedString"]
    #: User-defined identifier used in a deep-link URL for the [Product](ctp:api:type:Product).
    #: Must be unique across a Project, but can be the same for Products in different locales.
    #: Matches the pattern `[a-zA-Z0-9_\-]{2,256}`.
    #: For [good performance](/../api/predicates/query#performance-considerations), indexes are provided for the first 15 `languages` set in the [Project](ctp:api:type:Project).
    slug: "LocalizedString"
    #: [Categories](ctp:api:type:Category) assigned to the [Product](ctp:api:type:Product).
    categories: typing.List["CategoryReference"]
    #: Order of [Product](ctp:api:type:Product) in [Categories](ctp:api:type:Category).
    category_order_hints: typing.Optional["CategoryOrderHints"]
    #: Title of the [Product](ctp:api:type:Product) displayed in search results.
    meta_title: typing.Optional["LocalizedString"]
    #: Description of the [Product](ctp:api:type:Product) displayed in search results below the meta title.
    meta_description: typing.Optional["LocalizedString"]
    #: Keywords that give additional information about the [Product](ctp:api:type:Product) to search engines.
    meta_keywords: typing.Optional["LocalizedString"]
    #: Used by [Product Suggestions](/../api/projects/products-suggestions), but is also considered for a [full text search](ctp:api:type:FullTextSearch).
    search_keywords: typing.Optional["SearchKeywords"]
    #: `true` if the staged data is different from the current data.
    has_staged_changes: typing.Optional[bool]
    #: `true` if the [Product](ctp:api:type:Product) is [published](ctp:api:type:CurrentStaged).
    published: typing.Optional[bool]
    #: The Master Variant of the [Product](ctp:api:type:Product).
    master_variant: "ProductVariant"
    #: Additional Product Variants.
    variants: typing.List["ProductVariant"]
    #: The [TaxCategory](ctp:api:type:TaxCategory) of the [Product](ctp:api:type:Product).
    tax_category: typing.Optional["TaxCategoryReference"]
    #: [State](ctp:api:type:State) of the [Product](ctp:api:type:Product).
    state: typing.Optional["StateReference"]
    #: Review statistics of the [Product](ctp:api:type:Product).
    review_rating_statistics: typing.Optional["ReviewRatingStatistics"]
    #: Indicates whether the Prices of the Product Projection are [embedded](ctp:api:type:Price) or [standalone](ctp:api:type:StandalonePrice). [Projecting Prices](#prices) only works with `Embedded`, there is currently no support for `Standalone`.
    price_mode: typing.Optional["ProductPriceModeEnum"]

    def __init__(
        self,
        *,
        id: str,
        version: int,
        created_at: datetime.datetime,
        last_modified_at: datetime.datetime,
        key: typing.Optional[str] = None,
        product_type: "ProductTypeReference",
        name: "LocalizedString",
        description: typing.Optional["LocalizedString"] = None,
        slug: "LocalizedString",
        categories: typing.List["CategoryReference"],
        category_order_hints: typing.Optional["CategoryOrderHints"] = None,
        meta_title: typing.Optional["LocalizedString"] = None,
        meta_description: typing.Optional["LocalizedString"] = None,
        meta_keywords: typing.Optional["LocalizedString"] = None,
        search_keywords: typing.Optional["SearchKeywords"] = None,
        has_staged_changes: typing.Optional[bool] = None,
        published: typing.Optional[bool] = None,
        master_variant: "ProductVariant",
        variants: typing.List["ProductVariant"],
        tax_category: typing.Optional["TaxCategoryReference"] = None,
        state: typing.Optional["StateReference"] = None,
        review_rating_statistics: typing.Optional["ReviewRatingStatistics"] = None,
        price_mode: typing.Optional["ProductPriceModeEnum"] = None
    ):
        self.key = key
        self.product_type = product_type
        self.name = name
        self.description = description
        self.slug = slug
        self.categories = categories
        self.category_order_hints = category_order_hints
        self.meta_title = meta_title
        self.meta_description = meta_description
        self.meta_keywords = meta_keywords
        self.search_keywords = search_keywords
        self.has_staged_changes = has_staged_changes
        self.published = published
        self.master_variant = master_variant
        self.variants = variants
        self.tax_category = tax_category
        self.state = state
        self.review_rating_statistics = review_rating_statistics
        self.price_mode = price_mode

        super().__init__(
            id=id,
            version=version,
            created_at=created_at,
            last_modified_at=last_modified_at,
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ProductProjection":
        from ._schemas.product import ProductProjectionSchema

        return ProductProjectionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import ProductProjectionSchema

        return ProductProjectionSchema().dump(self)


class ProductProjectionPagedQueryResponse(_BaseType):
    #: Number of [results requested](/../api/general-concepts#limit).
    limit: int
    #: Actual number of results returned.
    count: int
    #: Total number of results matching the query.
    #: This number is an estimation that is not [strongly consistent](/../api/general-concepts#strong-consistency).
    #: This field is returned by default.
    #: For improved performance, calculating this field can be deactivated by using the query parameter `withTotal=false`.
    #: When the results are filtered with a [Query Predicate](/../api/predicates/query), `total` is subject to a [limit](/../api/limits#queries).
    total: typing.Optional[int]
    #: Number of [elements skipped](/../api/general-concepts#offset).
    offset: int
    #: [ProductProjections](ctp:api:type:ProductProjection) matching the query.
    results: typing.List["ProductProjection"]

    def __init__(
        self,
        *,
        limit: int,
        count: int,
        total: typing.Optional[int] = None,
        offset: int,
        results: typing.List["ProductProjection"]
    ):
        self.limit = limit
        self.count = count
        self.total = total
        self.offset = offset
        self.results = results

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductProjectionPagedQueryResponse":
        from ._schemas.product import ProductProjectionPagedQueryResponseSchema

        return ProductProjectionPagedQueryResponseSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import ProductProjectionPagedQueryResponseSchema

        return ProductProjectionPagedQueryResponseSchema().dump(self)


class ProductProjectionPagedSearchResponse(_BaseType):
    #: Number of [results requested](/../api/general-concepts#limit).
    limit: int
    count: int
    total: typing.Optional[int]
    #: Number of [elements skipped](/../api/general-concepts#offset).
    offset: int
    results: typing.List["ProductProjection"]
    facets: "FacetResults"

    def __init__(
        self,
        *,
        limit: int,
        count: int,
        total: typing.Optional[int] = None,
        offset: int,
        results: typing.List["ProductProjection"],
        facets: "FacetResults"
    ):
        self.limit = limit
        self.count = count
        self.total = total
        self.offset = offset
        self.results = results
        self.facets = facets

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductProjectionPagedSearchResponse":
        from ._schemas.product import ProductProjectionPagedSearchResponseSchema

        return ProductProjectionPagedSearchResponseSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import ProductProjectionPagedSearchResponseSchema

        return ProductProjectionPagedSearchResponseSchema().dump(self)


class ProductReference(Reference):
    """[Reference](ctp:api:type:Reference) to a [Product](ctp:api:type:Product)."""

    #: Contains the representation of the expanded Product. Only present in responses to requests with [Reference Expansion](/../api/general-concepts#reference-expansion) for Products.
    obj: typing.Optional["Product"]

    def __init__(self, *, id: str, obj: typing.Optional["Product"] = None):
        self.obj = obj

        super().__init__(id=id, type_id=ReferenceTypeId.PRODUCT)

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ProductReference":
        from ._schemas.product import ProductReferenceSchema

        return ProductReferenceSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import ProductReferenceSchema

        return ProductReferenceSchema().dump(self)


class ProductResourceIdentifier(ResourceIdentifier):
    """[ResourceIdentifier](ctp:api:type:ResourceIdentifier) to a [Product](ctp:api:type:Product). Either `id` or `key` is required."""

    def __init__(
        self, *, id: typing.Optional[str] = None, key: typing.Optional[str] = None
    ):
        super().__init__(id=id, key=key, type_id=ReferenceTypeId.PRODUCT)

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductResourceIdentifier":
        from ._schemas.product import ProductResourceIdentifierSchema

        return ProductResourceIdentifierSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import ProductResourceIdentifierSchema

        return ProductResourceIdentifierSchema().dump(self)


class ProductUpdate(_BaseType):
    #: Expected version of the Product on which the changes should be applied. If the expected version does not match the actual version, a [409 Conflict](/../api/errors#409-conflict) will be returned.
    version: int
    #: Update actions to be performed on the Product.
    actions: typing.List["ProductUpdateAction"]

    def __init__(self, *, version: int, actions: typing.List["ProductUpdateAction"]):
        self.version = version
        self.actions = actions

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ProductUpdate":
        from ._schemas.product import ProductUpdateSchema

        return ProductUpdateSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import ProductUpdateSchema

        return ProductUpdateSchema().dump(self)


class ProductUpdateAction(_BaseType):
    action: str

    def __init__(self, *, action: str):
        self.action = action

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ProductUpdateAction":
        if data["action"] == "addAsset":
            from ._schemas.product import ProductAddAssetActionSchema

            return ProductAddAssetActionSchema().load(data)
        if data["action"] == "addExternalImage":
            from ._schemas.product import ProductAddExternalImageActionSchema

            return ProductAddExternalImageActionSchema().load(data)
        if data["action"] == "addPrice":
            from ._schemas.product import ProductAddPriceActionSchema

            return ProductAddPriceActionSchema().load(data)
        if data["action"] == "addToCategory":
            from ._schemas.product import ProductAddToCategoryActionSchema

            return ProductAddToCategoryActionSchema().load(data)
        if data["action"] == "addVariant":
            from ._schemas.product import ProductAddVariantActionSchema

            return ProductAddVariantActionSchema().load(data)
        if data["action"] == "changeAssetName":
            from ._schemas.product import ProductChangeAssetNameActionSchema

            return ProductChangeAssetNameActionSchema().load(data)
        if data["action"] == "changeAssetOrder":
            from ._schemas.product import ProductChangeAssetOrderActionSchema

            return ProductChangeAssetOrderActionSchema().load(data)
        if data["action"] == "changeMasterVariant":
            from ._schemas.product import ProductChangeMasterVariantActionSchema

            return ProductChangeMasterVariantActionSchema().load(data)
        if data["action"] == "changeName":
            from ._schemas.product import ProductChangeNameActionSchema

            return ProductChangeNameActionSchema().load(data)
        if data["action"] == "changePrice":
            from ._schemas.product import ProductChangePriceActionSchema

            return ProductChangePriceActionSchema().load(data)
        if data["action"] == "changeSlug":
            from ._schemas.product import ProductChangeSlugActionSchema

            return ProductChangeSlugActionSchema().load(data)
        if data["action"] == "legacySetSku":
            from ._schemas.product import ProductLegacySetSkuActionSchema

            return ProductLegacySetSkuActionSchema().load(data)
        if data["action"] == "moveImageToPosition":
            from ._schemas.product import ProductMoveImageToPositionActionSchema

            return ProductMoveImageToPositionActionSchema().load(data)
        if data["action"] == "publish":
            from ._schemas.product import ProductPublishActionSchema

            return ProductPublishActionSchema().load(data)
        if data["action"] == "removeAsset":
            from ._schemas.product import ProductRemoveAssetActionSchema

            return ProductRemoveAssetActionSchema().load(data)
        if data["action"] == "removeFromCategory":
            from ._schemas.product import ProductRemoveFromCategoryActionSchema

            return ProductRemoveFromCategoryActionSchema().load(data)
        if data["action"] == "removeImage":
            from ._schemas.product import ProductRemoveImageActionSchema

            return ProductRemoveImageActionSchema().load(data)
        if data["action"] == "removePrice":
            from ._schemas.product import ProductRemovePriceActionSchema

            return ProductRemovePriceActionSchema().load(data)
        if data["action"] == "removeVariant":
            from ._schemas.product import ProductRemoveVariantActionSchema

            return ProductRemoveVariantActionSchema().load(data)
        if data["action"] == "revertStagedChanges":
            from ._schemas.product import ProductRevertStagedChangesActionSchema

            return ProductRevertStagedChangesActionSchema().load(data)
        if data["action"] == "revertStagedVariantChanges":
            from ._schemas.product import ProductRevertStagedVariantChangesActionSchema

            return ProductRevertStagedVariantChangesActionSchema().load(data)
        if data["action"] == "setAssetCustomField":
            from ._schemas.product import ProductSetAssetCustomFieldActionSchema

            return ProductSetAssetCustomFieldActionSchema().load(data)
        if data["action"] == "setAssetCustomType":
            from ._schemas.product import ProductSetAssetCustomTypeActionSchema

            return ProductSetAssetCustomTypeActionSchema().load(data)
        if data["action"] == "setAssetDescription":
            from ._schemas.product import ProductSetAssetDescriptionActionSchema

            return ProductSetAssetDescriptionActionSchema().load(data)
        if data["action"] == "setAssetKey":
            from ._schemas.product import ProductSetAssetKeyActionSchema

            return ProductSetAssetKeyActionSchema().load(data)
        if data["action"] == "setAssetSources":
            from ._schemas.product import ProductSetAssetSourcesActionSchema

            return ProductSetAssetSourcesActionSchema().load(data)
        if data["action"] == "setAssetTags":
            from ._schemas.product import ProductSetAssetTagsActionSchema

            return ProductSetAssetTagsActionSchema().load(data)
        if data["action"] == "setAttribute":
            from ._schemas.product import ProductSetAttributeActionSchema

            return ProductSetAttributeActionSchema().load(data)
        if data["action"] == "setAttributeInAllVariants":
            from ._schemas.product import ProductSetAttributeInAllVariantsActionSchema

            return ProductSetAttributeInAllVariantsActionSchema().load(data)
        if data["action"] == "setCategoryOrderHint":
            from ._schemas.product import ProductSetCategoryOrderHintActionSchema

            return ProductSetCategoryOrderHintActionSchema().load(data)
        if data["action"] == "setDescription":
            from ._schemas.product import ProductSetDescriptionActionSchema

            return ProductSetDescriptionActionSchema().load(data)
        if data["action"] == "setDiscountedPrice":
            from ._schemas.product import ProductSetDiscountedPriceActionSchema

            return ProductSetDiscountedPriceActionSchema().load(data)
        if data["action"] == "setImageLabel":
            from ._schemas.product import ProductSetImageLabelActionSchema

            return ProductSetImageLabelActionSchema().load(data)
        if data["action"] == "setKey":
            from ._schemas.product import ProductSetKeyActionSchema

            return ProductSetKeyActionSchema().load(data)
        if data["action"] == "setMetaDescription":
            from ._schemas.product import ProductSetMetaDescriptionActionSchema

            return ProductSetMetaDescriptionActionSchema().load(data)
        if data["action"] == "setMetaKeywords":
            from ._schemas.product import ProductSetMetaKeywordsActionSchema

            return ProductSetMetaKeywordsActionSchema().load(data)
        if data["action"] == "setMetaTitle":
            from ._schemas.product import ProductSetMetaTitleActionSchema

            return ProductSetMetaTitleActionSchema().load(data)
        if data["action"] == "setPriceKey":
            from ._schemas.product import ProductSetPriceKeyActionSchema

            return ProductSetPriceKeyActionSchema().load(data)
        if data["action"] == "setPriceMode":
            from ._schemas.product import ProductSetPriceModeActionSchema

            return ProductSetPriceModeActionSchema().load(data)
        if data["action"] == "setPrices":
            from ._schemas.product import ProductSetPricesActionSchema

            return ProductSetPricesActionSchema().load(data)
        if data["action"] == "setProductPriceCustomField":
            from ._schemas.product import ProductSetProductPriceCustomFieldActionSchema

            return ProductSetProductPriceCustomFieldActionSchema().load(data)
        if data["action"] == "setProductPriceCustomType":
            from ._schemas.product import ProductSetProductPriceCustomTypeActionSchema

            return ProductSetProductPriceCustomTypeActionSchema().load(data)
        if data["action"] == "setProductVariantKey":
            from ._schemas.product import ProductSetProductVariantKeyActionSchema

            return ProductSetProductVariantKeyActionSchema().load(data)
        if data["action"] == "setSearchKeywords":
            from ._schemas.product import ProductSetSearchKeywordsActionSchema

            return ProductSetSearchKeywordsActionSchema().load(data)
        if data["action"] == "setSku":
            from ._schemas.product import ProductSetSkuActionSchema

            return ProductSetSkuActionSchema().load(data)
        if data["action"] == "setTaxCategory":
            from ._schemas.product import ProductSetTaxCategoryActionSchema

            return ProductSetTaxCategoryActionSchema().load(data)
        if data["action"] == "transitionState":
            from ._schemas.product import ProductTransitionStateActionSchema

            return ProductTransitionStateActionSchema().load(data)
        if data["action"] == "unpublish":
            from ._schemas.product import ProductUnpublishActionSchema

            return ProductUnpublishActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import ProductUpdateActionSchema

        return ProductUpdateActionSchema().dump(self)


class ProductVariant(_BaseType):
    """A concrete sellable good for which inventory can be tracked. Product Variants are generally mapped to specific SKUs."""

    #: A unique, sequential identifier of the Product Variant within the Product.
    id: int
    #: User-defined unique SKU of the Product Variant.
    sku: typing.Optional[str]
    #: User-defined unique identifier of the ProductVariant.
    #:
    #: This is different from [Product](ctp:api:type:Product) `key`.
    key: typing.Optional[str]
    #: The Embedded Prices of the Product Variant.
    #: Cannot contain two Prices of the same Price scope (with same currency, country, Customer Group, Channel, `validFrom` and `validUntil`).
    prices: typing.Optional[typing.List["Price"]]
    #: Attributes of the Product Variant.
    attributes: typing.Optional[typing.List["Attribute"]]
    #: Only available when [Price selection](#price-selection) is used.
    #: Cannot be used in a [Query Predicate](ctp:api:type:QueryPredicate).
    price: typing.Optional["Price"]
    #: Images of the Product Variant.
    images: typing.Optional[typing.List["Image"]]
    #: Media assets of the Product Variant.
    assets: typing.Optional[typing.List["Asset"]]
    #: Set if the Product Variant is tracked by [Inventory](ctp:api:type:InventoryEntry).
    #: Can be used as an optimization to reduce calls to the Inventory service.
    #: May not contain the latest Inventory State (it is [eventually consistent](/general-concepts#eventual-consistency)).
    availability: typing.Optional["ProductVariantAvailability"]
    #: `true` if the Product Variant matches the search query.
    #: Only available in response to a [Product Projection Search](ctp:api:type:ProductProjectionSearch) request.
    is_matching_variant: typing.Optional[bool]
    #: Only available in response to a [Product Projection Search](ctp:api:type:ProductProjectionSearch) request
    #: with [price selection](ctp:api:type:ProductPriceSelection).
    #: Can be used to sort, [filter](ctp:api:type:ProductProjectionSearchFilterScopedPrice), and facet.
    scoped_price: typing.Optional["ScopedPrice"]
    #: Only available in response to a [Product Projection Search](ctp:api:type:ProductProjectionSearchFilterScopedPrice) request
    #: with [price selection](ctp:api:type:ProductPriceSelection).
    scoped_price_discounted: typing.Optional[bool]

    def __init__(
        self,
        *,
        id: int,
        sku: typing.Optional[str] = None,
        key: typing.Optional[str] = None,
        prices: typing.Optional[typing.List["Price"]] = None,
        attributes: typing.Optional[typing.List["Attribute"]] = None,
        price: typing.Optional["Price"] = None,
        images: typing.Optional[typing.List["Image"]] = None,
        assets: typing.Optional[typing.List["Asset"]] = None,
        availability: typing.Optional["ProductVariantAvailability"] = None,
        is_matching_variant: typing.Optional[bool] = None,
        scoped_price: typing.Optional["ScopedPrice"] = None,
        scoped_price_discounted: typing.Optional[bool] = None
    ):
        self.id = id
        self.sku = sku
        self.key = key
        self.prices = prices
        self.attributes = attributes
        self.price = price
        self.images = images
        self.assets = assets
        self.availability = availability
        self.is_matching_variant = is_matching_variant
        self.scoped_price = scoped_price
        self.scoped_price_discounted = scoped_price_discounted

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ProductVariant":
        from ._schemas.product import ProductVariantSchema

        return ProductVariantSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import ProductVariantSchema

        return ProductVariantSchema().dump(self)


class ProductVariantAvailability(_BaseType):
    """The [InventoryEntry](ctp:api:type:InventoryEntry) information of the Product Variant. If there is a supply [Channel](ctp:api:type:Channel) for the InventoryEntry, then `channels` is returned. If not, then `isOnStock`, `restockableInDays`, and `quantityOnStock` are returned."""

    #: For each [InventoryEntry](ctp:api:type:InventoryEntry) with a supply Channel, an entry is added to `channels`.
    channels: typing.Optional["ProductVariantChannelAvailabilityMap"]
    #: Indicates whether a Product Variant is in stock.
    is_on_stock: typing.Optional[bool]
    #: Number of days to restock a Product Variant once it is out of stock.
    restockable_in_days: typing.Optional[int]
    #: Number of items of the Product Variant that are in stock.
    available_quantity: typing.Optional[int]

    def __init__(
        self,
        *,
        channels: typing.Optional["ProductVariantChannelAvailabilityMap"] = None,
        is_on_stock: typing.Optional[bool] = None,
        restockable_in_days: typing.Optional[int] = None,
        available_quantity: typing.Optional[int] = None
    ):
        self.channels = channels
        self.is_on_stock = is_on_stock
        self.restockable_in_days = restockable_in_days
        self.available_quantity = available_quantity

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductVariantAvailability":
        from ._schemas.product import ProductVariantAvailabilitySchema

        return ProductVariantAvailabilitySchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import ProductVariantAvailabilitySchema

        return ProductVariantAvailabilitySchema().dump(self)


class ProductVariantChannelAvailability(_BaseType):
    #: Indicates whether a Product Variant is in stock in a specified [Channel](ctp:api:type:Channel).
    is_on_stock: typing.Optional[bool]
    #: Number of days to restock a Product Variant once it is out of stock in a specified [Channel](ctp:api:type:Channel).
    restockable_in_days: typing.Optional[int]
    #: Number of items of this Product Variant that are in stock in a specified [Channel](ctp:api:type:Channel).
    available_quantity: typing.Optional[int]
    #: Unique identifier of the [InventoryEntry](ctp:api:type:InventoryEntry).
    id: str
    #: Current version of the [InventoryEntry](ctp:api:type:InventoryEntry).
    version: int

    def __init__(
        self,
        *,
        is_on_stock: typing.Optional[bool] = None,
        restockable_in_days: typing.Optional[int] = None,
        available_quantity: typing.Optional[int] = None,
        id: str,
        version: int
    ):
        self.is_on_stock = is_on_stock
        self.restockable_in_days = restockable_in_days
        self.available_quantity = available_quantity
        self.id = id
        self.version = version

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductVariantChannelAvailability":
        from ._schemas.product import ProductVariantChannelAvailabilitySchema

        return ProductVariantChannelAvailabilitySchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import ProductVariantChannelAvailabilitySchema

        return ProductVariantChannelAvailabilitySchema().dump(self)


class ProductVariantChannelAvailabilityMap(
    typing.Dict[str, "ProductVariantChannelAvailability"]
):
    pass


class ProductVariantDraft(_BaseType):
    """Creates a Product Variant when included in the `masterVariant` and `variants` fields of the [ProductDraft](ctp:api:type:ProductDraft)."""

    #: User-defined unique SKU of the Product Variant.
    sku: typing.Optional[str]
    #: User-defined unique identifier for the ProductVariant.
    key: typing.Optional[str]
    #: The Embedded Prices for the Product Variant.
    #: Each Price must have its unique Price scope (with same currency, country, Customer Group, Channel, `validFrom` and `validUntil`).
    prices: typing.Optional[typing.List["PriceDraft"]]
    #: Attributes according to the respective [AttributeDefinition](ctp:api:type:AttributeDefinition).
    attributes: typing.Optional[typing.List["Attribute"]]
    #: Images for the Product Variant.
    images: typing.Optional[typing.List["Image"]]
    #: Media assets for the Product Variant.
    assets: typing.Optional[typing.List["AssetDraft"]]

    def __init__(
        self,
        *,
        sku: typing.Optional[str] = None,
        key: typing.Optional[str] = None,
        prices: typing.Optional[typing.List["PriceDraft"]] = None,
        attributes: typing.Optional[typing.List["Attribute"]] = None,
        images: typing.Optional[typing.List["Image"]] = None,
        assets: typing.Optional[typing.List["AssetDraft"]] = None
    ):
        self.sku = sku
        self.key = key
        self.prices = prices
        self.attributes = attributes
        self.images = images
        self.assets = assets

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ProductVariantDraft":
        from ._schemas.product import ProductVariantDraftSchema

        return ProductVariantDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import ProductVariantDraftSchema

        return ProductVariantDraftSchema().dump(self)


class RangeFacetResult(FacetResult):
    ranges: typing.List["FacetRange"]

    def __init__(self, *, ranges: typing.List["FacetRange"]):
        self.ranges = ranges

        super().__init__(type=FacetTypes.RANGE)

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "RangeFacetResult":
        from ._schemas.product import RangeFacetResultSchema

        return RangeFacetResultSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import RangeFacetResultSchema

        return RangeFacetResultSchema().dump(self)


class SearchKeyword(_BaseType):
    #: Text to return in the result of a [suggest query](ctp:api:type:ProductSuggestionsSuggestQuery).
    text: str
    #: If no tokenizer is defined, the `text` is used as a single token.
    suggest_tokenizer: typing.Optional["SuggestTokenizer"]

    def __init__(
        self,
        *,
        text: str,
        suggest_tokenizer: typing.Optional["SuggestTokenizer"] = None
    ):
        self.text = text
        self.suggest_tokenizer = suggest_tokenizer

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "SearchKeyword":
        from ._schemas.product import SearchKeywordSchema

        return SearchKeywordSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import SearchKeywordSchema

        return SearchKeywordSchema().dump(self)


class SearchKeywords(typing.Dict[str, typing.List["SearchKeyword"]]):
    pass


class SuggestTokenizer(_BaseType):
    type: str

    def __init__(self, *, type: str):
        self.type = type

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "SuggestTokenizer":
        if data["type"] == "custom":
            from ._schemas.product import CustomTokenizerSchema

            return CustomTokenizerSchema().load(data)
        if data["type"] == "whitespace":
            from ._schemas.product import WhitespaceTokenizerSchema

            return WhitespaceTokenizerSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import SuggestTokenizerSchema

        return SuggestTokenizerSchema().dump(self)


class CustomTokenizer(SuggestTokenizer):
    """Define arbitrary tokens that are used to match the input."""

    #: Contains custom tokens.
    inputs: typing.List["str"]

    def __init__(self, *, inputs: typing.List["str"]):
        self.inputs = inputs

        super().__init__(type="custom")

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CustomTokenizer":
        from ._schemas.product import CustomTokenizerSchema

        return CustomTokenizerSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import CustomTokenizerSchema

        return CustomTokenizerSchema().dump(self)


class Suggestion(_BaseType):
    #: The suggested text.
    text: str

    def __init__(self, *, text: str):
        self.text = text

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "Suggestion":
        from ._schemas.product import SuggestionSchema

        return SuggestionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import SuggestionSchema

        return SuggestionSchema().dump(self)


class SuggestionResult(typing.Dict[str, typing.List["Suggestion"]]):
    pass


class TermFacetResult(FacetResult):
    data_type: "TermFacetResultType"
    missing: int
    total: int
    other: int
    terms: typing.List["FacetTerm"]

    def __init__(
        self,
        *,
        data_type: "TermFacetResultType",
        missing: int,
        total: int,
        other: int,
        terms: typing.List["FacetTerm"]
    ):
        self.data_type = data_type
        self.missing = missing
        self.total = total
        self.other = other
        self.terms = terms

        super().__init__(type=FacetTypes.TERMS)

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "TermFacetResult":
        from ._schemas.product import TermFacetResultSchema

        return TermFacetResultSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import TermFacetResultSchema

        return TermFacetResultSchema().dump(self)


class TermFacetResultType(enum.Enum):
    TEXT = "text"
    DATE = "date"
    TIME = "time"
    DATETIME = "datetime"
    BOOLEAN = "boolean"
    NUMBER = "number"


class WhitespaceTokenizer(SuggestTokenizer):
    """Creates tokens by splitting the `text` field in [SearchKeyword](ctp:api:type:SearchKeyword) by whitespaces."""

    def __init__(self):
        super().__init__(type="whitespace")

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "WhitespaceTokenizer":
        from ._schemas.product import WhitespaceTokenizerSchema

        return WhitespaceTokenizerSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import WhitespaceTokenizerSchema

        return WhitespaceTokenizerSchema().dump(self)


class ProductAddAssetAction(ProductUpdateAction):
    """Either `variantId` or `sku` is required."""

    #: The `id` of the ProductVariant to update.
    variant_id: typing.Optional[int]
    #: The `sku` of the ProductVariant to update.
    sku: typing.Optional[str]
    #: If `true`, only the staged `assets` are updated. If `false`, both the current and staged `assets` are updated.
    staged: typing.Optional[bool]
    #: Value to append.
    asset: "AssetDraft"
    #: Position in `assets` where the Asset should be put. When specified, the value must be between `0` and the total number of Assets minus `1`.
    position: typing.Optional[int]

    def __init__(
        self,
        *,
        variant_id: typing.Optional[int] = None,
        sku: typing.Optional[str] = None,
        staged: typing.Optional[bool] = None,
        asset: "AssetDraft",
        position: typing.Optional[int] = None
    ):
        self.variant_id = variant_id
        self.sku = sku
        self.staged = staged
        self.asset = asset
        self.position = position

        super().__init__(action="addAsset")

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ProductAddAssetAction":
        from ._schemas.product import ProductAddAssetActionSchema

        return ProductAddAssetActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import ProductAddAssetActionSchema

        return ProductAddAssetActionSchema().dump(self)


class ProductAddExternalImageAction(ProductUpdateAction):
    """Either `variantId` or `sku` is required. Produces the [ProductImageAdded](/projects/messages#product-image-added) Message."""

    #: The `id` of the ProductVariant to update.
    variant_id: typing.Optional[int]
    #: The `sku` of the ProductVariant to update.
    sku: typing.Optional[str]
    #: Value to add to `images`.
    image: "Image"
    #: If `true`, only the staged `images` is updated. If `false`, both the current and staged `images` is updated.
    staged: typing.Optional[bool]

    def __init__(
        self,
        *,
        variant_id: typing.Optional[int] = None,
        sku: typing.Optional[str] = None,
        image: "Image",
        staged: typing.Optional[bool] = None
    ):
        self.variant_id = variant_id
        self.sku = sku
        self.image = image
        self.staged = staged

        super().__init__(action="addExternalImage")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductAddExternalImageAction":
        from ._schemas.product import ProductAddExternalImageActionSchema

        return ProductAddExternalImageActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import ProductAddExternalImageActionSchema

        return ProductAddExternalImageActionSchema().dump(self)


class ProductAddPriceAction(ProductUpdateAction):
    """Adds the given Price to the `prices` array of the [ProductVariant](ctp:api:type:ProductVariant).
    Either `variantId` or `sku` is required.

    """

    #: The `id` of the ProductVariant to update.
    variant_id: typing.Optional[int]
    #: The `sku` of the ProductVariant to update.
    sku: typing.Optional[str]
    #: Embedded Price to add to the Product Variant.
    price: "PriceDraft"
    #: If `true`, only the staged `prices` is updated. If `false`, both the current and staged `prices` are updated.
    staged: typing.Optional[bool]

    def __init__(
        self,
        *,
        variant_id: typing.Optional[int] = None,
        sku: typing.Optional[str] = None,
        price: "PriceDraft",
        staged: typing.Optional[bool] = None
    ):
        self.variant_id = variant_id
        self.sku = sku
        self.price = price
        self.staged = staged

        super().__init__(action="addPrice")

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ProductAddPriceAction":
        from ._schemas.product import ProductAddPriceActionSchema

        return ProductAddPriceActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import ProductAddPriceActionSchema

        return ProductAddPriceActionSchema().dump(self)


class ProductAddToCategoryAction(ProductUpdateAction):
    """Produces the [ProductAddedToCategory](/projects/messages#product-added-to-category) Message."""

    #: The Category to add.
    category: "CategoryResourceIdentifier"
    #: A string representing a number between 0 and 1. Must start with `0.` and cannot end with `0`. If empty, any existing value will be removed.
    order_hint: typing.Optional[str]
    #: If `true`, only the staged `categories` and `categoryOrderHints` are updated. If `false`, both the current and staged `categories` and `categoryOrderHints` are updated.
    staged: typing.Optional[bool]

    def __init__(
        self,
        *,
        category: "CategoryResourceIdentifier",
        order_hint: typing.Optional[str] = None,
        staged: typing.Optional[bool] = None
    ):
        self.category = category
        self.order_hint = order_hint
        self.staged = staged

        super().__init__(action="addToCategory")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductAddToCategoryAction":
        from ._schemas.product import ProductAddToCategoryActionSchema

        return ProductAddToCategoryActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import ProductAddToCategoryActionSchema

        return ProductAddToCategoryActionSchema().dump(self)


class ProductAddVariantAction(ProductUpdateAction):
    #: Value to set. Must be unique.
    sku: typing.Optional[str]
    #: Value to set. Must be unique.
    key: typing.Optional[str]
    #: Embedded Prices for the Product Variant.
    prices: typing.Optional[typing.List["PriceDraft"]]
    #: Images for the Product Variant.
    images: typing.Optional[typing.List["Image"]]
    #: Attributes for the Product Variant.
    attributes: typing.Optional[typing.List["Attribute"]]
    #: If `true` the new Product Variant is only staged. If `false` the new Product Variant is both current and staged.
    staged: typing.Optional[bool]
    #: Media assets for the Product Variant.
    assets: typing.Optional[typing.List["AssetDraft"]]

    def __init__(
        self,
        *,
        sku: typing.Optional[str] = None,
        key: typing.Optional[str] = None,
        prices: typing.Optional[typing.List["PriceDraft"]] = None,
        images: typing.Optional[typing.List["Image"]] = None,
        attributes: typing.Optional[typing.List["Attribute"]] = None,
        staged: typing.Optional[bool] = None,
        assets: typing.Optional[typing.List["AssetDraft"]] = None
    ):
        self.sku = sku
        self.key = key
        self.prices = prices
        self.images = images
        self.attributes = attributes
        self.staged = staged
        self.assets = assets

        super().__init__(action="addVariant")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductAddVariantAction":
        from ._schemas.product import ProductAddVariantActionSchema

        return ProductAddVariantActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import ProductAddVariantActionSchema

        return ProductAddVariantActionSchema().dump(self)


class ProductChangeAssetNameAction(ProductUpdateAction):
    """Either `variantId` or `sku` is required. The Asset to update must be specified using either `assetId` or `assetKey`."""

    #: The `id` of the ProductVariant to update.
    variant_id: typing.Optional[int]
    #: The `sku` of the ProductVariant to update.
    sku: typing.Optional[str]
    #: If `true`, only the staged Asset is updated. If `false`, both the current and staged Asset is updated.
    staged: typing.Optional[bool]
    #: The `id` of the Asset to update.
    asset_id: typing.Optional[str]
    #: The `key` of the Asset to update.
    asset_key: typing.Optional[str]
    #: New value to set. Must not be empty.
    name: "LocalizedString"

    def __init__(
        self,
        *,
        variant_id: typing.Optional[int] = None,
        sku: typing.Optional[str] = None,
        staged: typing.Optional[bool] = None,
        asset_id: typing.Optional[str] = None,
        asset_key: typing.Optional[str] = None,
        name: "LocalizedString"
    ):
        self.variant_id = variant_id
        self.sku = sku
        self.staged = staged
        self.asset_id = asset_id
        self.asset_key = asset_key
        self.name = name

        super().__init__(action="changeAssetName")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductChangeAssetNameAction":
        from ._schemas.product import ProductChangeAssetNameActionSchema

        return ProductChangeAssetNameActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import ProductChangeAssetNameActionSchema

        return ProductChangeAssetNameActionSchema().dump(self)


class ProductChangeAssetOrderAction(ProductUpdateAction):
    """Either `variantId` or `sku` is required."""

    #: The `id` of the ProductVariant to update.
    variant_id: typing.Optional[int]
    #: The `sku` of the ProductVariant to update.
    sku: typing.Optional[str]
    #: If `true`, only the staged `assets` is updated. If `false`, both the current and staged `assets` are updated.
    staged: typing.Optional[bool]
    #: All existing Asset `id`s of the ProductVariant in the desired new order.
    asset_order: typing.List["str"]

    def __init__(
        self,
        *,
        variant_id: typing.Optional[int] = None,
        sku: typing.Optional[str] = None,
        staged: typing.Optional[bool] = None,
        asset_order: typing.List["str"]
    ):
        self.variant_id = variant_id
        self.sku = sku
        self.staged = staged
        self.asset_order = asset_order

        super().__init__(action="changeAssetOrder")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductChangeAssetOrderAction":
        from ._schemas.product import ProductChangeAssetOrderActionSchema

        return ProductChangeAssetOrderActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import ProductChangeAssetOrderActionSchema

        return ProductChangeAssetOrderActionSchema().dump(self)


class ProductChangeMasterVariantAction(ProductUpdateAction):
    """Assigns the specified Product Variant to the `masterVariant` and removes the same from `variants` at the same time. The current Master Variant becomes part of the `variants` array.
    Either `variantId` or `sku` is required.

    """

    #: The `id` of the ProductVariant to become the Master Variant.
    variant_id: typing.Optional[int]
    #: The `sku` of the ProductVariant to become the Master Variant.
    sku: typing.Optional[str]
    #: If `true`, only the staged Master Variant is changed. If `false`, both the current and staged Master Variant are changed.
    staged: typing.Optional[bool]

    def __init__(
        self,
        *,
        variant_id: typing.Optional[int] = None,
        sku: typing.Optional[str] = None,
        staged: typing.Optional[bool] = None
    ):
        self.variant_id = variant_id
        self.sku = sku
        self.staged = staged

        super().__init__(action="changeMasterVariant")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductChangeMasterVariantAction":
        from ._schemas.product import ProductChangeMasterVariantActionSchema

        return ProductChangeMasterVariantActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import ProductChangeMasterVariantActionSchema

        return ProductChangeMasterVariantActionSchema().dump(self)


class ProductChangeNameAction(ProductUpdateAction):
    #: Value to set. Must not be empty.
    name: "LocalizedString"
    #: If `true`, only the staged `name` is updated. If `false`, both the current and staged `name` are updated.
    staged: typing.Optional[bool]

    def __init__(
        self, *, name: "LocalizedString", staged: typing.Optional[bool] = None
    ):
        self.name = name
        self.staged = staged

        super().__init__(action="changeName")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductChangeNameAction":
        from ._schemas.product import ProductChangeNameActionSchema

        return ProductChangeNameActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import ProductChangeNameActionSchema

        return ProductChangeNameActionSchema().dump(self)


class ProductChangePriceAction(ProductUpdateAction):
    #: The `id` of the Embedded Price to update.
    price_id: str
    #: Value to set.
    price: "PriceDraft"
    #: If `true`, only the staged Embedded Price is updated. If `false`, both the current and staged Embedded Price are updated.
    staged: typing.Optional[bool]

    def __init__(
        self,
        *,
        price_id: str,
        price: "PriceDraft",
        staged: typing.Optional[bool] = None
    ):
        self.price_id = price_id
        self.price = price
        self.staged = staged

        super().__init__(action="changePrice")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductChangePriceAction":
        from ._schemas.product import ProductChangePriceActionSchema

        return ProductChangePriceActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import ProductChangePriceActionSchema

        return ProductChangePriceActionSchema().dump(self)


class ProductChangeSlugAction(ProductUpdateAction):
    """Produces the [ProductSlugChanged](ctp:api:type:ProductSlugChangedMessage) Message."""

    #: Value to set. Must not be empty. A Product can have the same slug for different [Locales](ctp:api:type:Locale), but it must be unique across the [Project](ctp:api:type:Project). Must match the pattern `^[A-Za-z0-9_-]{2,256}+$`.
    slug: "LocalizedString"
    #: If `true`, only the staged `slug` is updated. If `false`, both the current and staged `slug` are updated.
    staged: typing.Optional[bool]

    def __init__(
        self, *, slug: "LocalizedString", staged: typing.Optional[bool] = None
    ):
        self.slug = slug
        self.staged = staged

        super().__init__(action="changeSlug")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductChangeSlugAction":
        from ._schemas.product import ProductChangeSlugActionSchema

        return ProductChangeSlugActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import ProductChangeSlugActionSchema

        return ProductChangeSlugActionSchema().dump(self)


class ProductLegacySetSkuAction(ProductUpdateAction):
    sku: typing.Optional[str]
    variant_id: int

    def __init__(self, *, sku: typing.Optional[str] = None, variant_id: int):
        self.sku = sku
        self.variant_id = variant_id

        super().__init__(action="legacySetSku")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductLegacySetSkuAction":
        from ._schemas.product import ProductLegacySetSkuActionSchema

        return ProductLegacySetSkuActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import ProductLegacySetSkuActionSchema

        return ProductLegacySetSkuActionSchema().dump(self)


class ProductMoveImageToPositionAction(ProductUpdateAction):
    """Either `variantId` or `sku` is required."""

    #: The `id` of the ProductVariant to update.
    variant_id: typing.Optional[int]
    #: The `sku` of the ProductVariant to update.
    sku: typing.Optional[str]
    #: The URL of the image to update.
    image_url: str
    #: Position in `images` where the image should be moved. Must be between `0` and the total number of images minus `1`.
    position: int
    #: If `true`, only the staged `images` is updated. If `false`, both the current and staged `images` is updated.
    staged: typing.Optional[bool]

    def __init__(
        self,
        *,
        variant_id: typing.Optional[int] = None,
        sku: typing.Optional[str] = None,
        image_url: str,
        position: int,
        staged: typing.Optional[bool] = None
    ):
        self.variant_id = variant_id
        self.sku = sku
        self.image_url = image_url
        self.position = position
        self.staged = staged

        super().__init__(action="moveImageToPosition")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductMoveImageToPositionAction":
        from ._schemas.product import ProductMoveImageToPositionActionSchema

        return ProductMoveImageToPositionActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import ProductMoveImageToPositionActionSchema

        return ProductMoveImageToPositionActionSchema().dump(self)


class ProductPublishAction(ProductUpdateAction):
    """Publishes product data from the Product's staged projection to its current projection.
    Produces the [ProductPublished](ctp:api:type:ProductPublishedMessage) Message.
    """

    #: `All` or `Prices`
    scope: typing.Optional["ProductPublishScope"]

    def __init__(self, *, scope: typing.Optional["ProductPublishScope"] = None):
        self.scope = scope

        super().__init__(action="publish")

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ProductPublishAction":
        from ._schemas.product import ProductPublishActionSchema

        return ProductPublishActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import ProductPublishActionSchema

        return ProductPublishActionSchema().dump(self)


class ProductRemoveAssetAction(ProductUpdateAction):
    """Either `variantId` or `sku` is required. The Asset to remove must be specified using either `assetId` or `assetKey`."""

    #: The `id` of the ProductVariant to update.
    variant_id: typing.Optional[int]
    #: The `sku` of the ProductVariant to update.
    sku: typing.Optional[str]
    #: If `true`, only the staged Asset is removed. If `false`, both the current and staged Asset is removed.
    staged: typing.Optional[bool]
    #: The `id` of the Asset to remove.
    asset_id: typing.Optional[str]
    #: The `key` of the Asset to remove.
    asset_key: typing.Optional[str]

    def __init__(
        self,
        *,
        variant_id: typing.Optional[int] = None,
        sku: typing.Optional[str] = None,
        staged: typing.Optional[bool] = None,
        asset_id: typing.Optional[str] = None,
        asset_key: typing.Optional[str] = None
    ):
        self.variant_id = variant_id
        self.sku = sku
        self.staged = staged
        self.asset_id = asset_id
        self.asset_key = asset_key

        super().__init__(action="removeAsset")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductRemoveAssetAction":
        from ._schemas.product import ProductRemoveAssetActionSchema

        return ProductRemoveAssetActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import ProductRemoveAssetActionSchema

        return ProductRemoveAssetActionSchema().dump(self)


class ProductRemoveFromCategoryAction(ProductUpdateAction):
    """Produces the [ProductRemovedFromCategory](ctp:api:type:ProductRemovedFromCategoryMessage) Message."""

    #: The Category to remove.
    category: "CategoryResourceIdentifier"
    #: If `true`, only the staged `categories` and `categoryOrderHints` are removed. If `false`, both the current and staged `categories` and `categoryOrderHints` are removed.
    staged: typing.Optional[bool]

    def __init__(
        self,
        *,
        category: "CategoryResourceIdentifier",
        staged: typing.Optional[bool] = None
    ):
        self.category = category
        self.staged = staged

        super().__init__(action="removeFromCategory")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductRemoveFromCategoryAction":
        from ._schemas.product import ProductRemoveFromCategoryActionSchema

        return ProductRemoveFromCategoryActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import ProductRemoveFromCategoryActionSchema

        return ProductRemoveFromCategoryActionSchema().dump(self)


class ProductRemoveImageAction(ProductUpdateAction):
    """Removes a Product image and deletes it from the Content Delivery Network (external images are not deleted). Deletion from the CDN is not instant, which means the image file itself will stay available for some time after the deletion. Either `variantId` or `sku` is required."""

    #: The `id` of the ProductVariant to update.
    variant_id: typing.Optional[int]
    #: The `sku` of the ProductVariant to update.
    sku: typing.Optional[str]
    #: The URL of the image to remove.
    image_url: str
    #: If `true`, only the staged image is removed. If `false`, both the current and staged image is removed.
    staged: typing.Optional[bool]

    def __init__(
        self,
        *,
        variant_id: typing.Optional[int] = None,
        sku: typing.Optional[str] = None,
        image_url: str,
        staged: typing.Optional[bool] = None
    ):
        self.variant_id = variant_id
        self.sku = sku
        self.image_url = image_url
        self.staged = staged

        super().__init__(action="removeImage")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductRemoveImageAction":
        from ._schemas.product import ProductRemoveImageActionSchema

        return ProductRemoveImageActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import ProductRemoveImageActionSchema

        return ProductRemoveImageActionSchema().dump(self)


class ProductRemovePriceAction(ProductUpdateAction):
    #: The `id` of the Embedded Price to remove.
    price_id: str
    #: The `sku` of the ProductVariant the provided Price should be removed from.
    #: Either 'variantId' or 'sku' is required" when `priceId` is not provided.
    #: This field is now deprecated, use 'priceId' instead.
    sku: typing.Optional[str]
    #: The `id` of the ProductVariant the provided Price should be removed from.
    #: Either 'variantId' or 'sku' is required" when `priceId` is not provided.
    #: This field is now deprecated, use 'priceId' instead.
    variant_id: typing.Optional[int]
    #: The Price identical to the one to be removed from the ProductVariant.
    #: This field is now deprecated, use 'priceId' instead.
    price: typing.Optional["PriceDraft"]
    #: If `true`, only the staged Embedded Price is removed. If `false`, both the current and staged Embedded Price are removed.
    staged: typing.Optional[bool]

    def __init__(
        self,
        *,
        price_id: str,
        sku: typing.Optional[str] = None,
        variant_id: typing.Optional[int] = None,
        price: typing.Optional["PriceDraft"] = None,
        staged: typing.Optional[bool] = None
    ):
        self.price_id = price_id
        self.sku = sku
        self.variant_id = variant_id
        self.price = price
        self.staged = staged

        super().__init__(action="removePrice")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductRemovePriceAction":
        from ._schemas.product import ProductRemovePriceActionSchema

        return ProductRemovePriceActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import ProductRemovePriceActionSchema

        return ProductRemovePriceActionSchema().dump(self)


class ProductRemoveVariantAction(ProductUpdateAction):
    """Either `id` or `sku` is required.
    Produces the [ProductVariantDeleted](ctp:api:type:ProductVariantDeletedMessage) Message.
    If the Product Variant to remove is part of a [ProductSelectionAssignment](ctp:api:type:ProductSelectionAssignment)
    its SKU will be automatically removed from the respective [ProductVariantSelection](ctp:api:type:ProductVariantSelection).

    """

    #: The `id` of the ProductVariant to remove.
    id: typing.Optional[int]
    #: The `sku` of the ProductVariant to remove.
    sku: typing.Optional[str]
    #: If `true`, only the staged ProductVariant is removed. If `false`, both the current and staged ProductVariant is removed.
    staged: typing.Optional[bool]

    def __init__(
        self,
        *,
        id: typing.Optional[int] = None,
        sku: typing.Optional[str] = None,
        staged: typing.Optional[bool] = None
    ):
        self.id = id
        self.sku = sku
        self.staged = staged

        super().__init__(action="removeVariant")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductRemoveVariantAction":
        from ._schemas.product import ProductRemoveVariantActionSchema

        return ProductRemoveVariantActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import ProductRemoveVariantActionSchema

        return ProductRemoveVariantActionSchema().dump(self)


class ProductRevertStagedChangesAction(ProductUpdateAction):
    """Reverts the staged version of a Product to the current version. Produces the [ProductRevertedStagedChanges](ctp:api:type:ProductRevertedStagedChangesMessage) Message."""

    def __init__(self):
        super().__init__(action="revertStagedChanges")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductRevertStagedChangesAction":
        from ._schemas.product import ProductRevertStagedChangesActionSchema

        return ProductRevertStagedChangesActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import ProductRevertStagedChangesActionSchema

        return ProductRevertStagedChangesActionSchema().dump(self)


class ProductRevertStagedVariantChangesAction(ProductUpdateAction):
    """Reverts the staged version of a ProductVariant to the current version."""

    #: The `id` of the ProductVariant to revert.
    variant_id: int

    def __init__(self, *, variant_id: int):
        self.variant_id = variant_id

        super().__init__(action="revertStagedVariantChanges")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductRevertStagedVariantChangesAction":
        from ._schemas.product import ProductRevertStagedVariantChangesActionSchema

        return ProductRevertStagedVariantChangesActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import ProductRevertStagedVariantChangesActionSchema

        return ProductRevertStagedVariantChangesActionSchema().dump(self)


class ProductSetAssetCustomFieldAction(ProductUpdateAction):
    """Either `variantId` or `sku` is required. The [Asset](ctp:api:type:Asset) to update must be specified using either `assetId` or `assetKey`."""

    #: The `id` of the ProductVariant to update.
    variant_id: typing.Optional[int]
    #: The `sku` of the ProductVariant to update.
    sku: typing.Optional[str]
    #: If `true`, only the staged Asset is updated. If `false`, both the current and staged Asset is updated.
    staged: typing.Optional[bool]
    #: The `id` of the Asset to update.
    asset_id: typing.Optional[str]
    #: The `key` of the Asset to update.
    asset_key: typing.Optional[str]
    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: Removing a field that does not exist returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
    #: If `value` is provided, it is set for the field defined by `name`.
    value: typing.Optional[typing.Any]

    def __init__(
        self,
        *,
        variant_id: typing.Optional[int] = None,
        sku: typing.Optional[str] = None,
        staged: typing.Optional[bool] = None,
        asset_id: typing.Optional[str] = None,
        asset_key: typing.Optional[str] = None,
        name: str,
        value: typing.Optional[typing.Any] = None
    ):
        self.variant_id = variant_id
        self.sku = sku
        self.staged = staged
        self.asset_id = asset_id
        self.asset_key = asset_key
        self.name = name
        self.value = value

        super().__init__(action="setAssetCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductSetAssetCustomFieldAction":
        from ._schemas.product import ProductSetAssetCustomFieldActionSchema

        return ProductSetAssetCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import ProductSetAssetCustomFieldActionSchema

        return ProductSetAssetCustomFieldActionSchema().dump(self)


class ProductSetAssetCustomTypeAction(ProductUpdateAction):
    """Either `variantId` or `sku` is required. The [Asset](ctp:api:type:Asset) to update must be specified using either `assetId` or `assetKey`."""

    #: The `id` of the ProductVariant to update.
    variant_id: typing.Optional[int]
    #: The `sku` of the ProductVariant to update.
    sku: typing.Optional[str]
    #: If `true`, only the staged Asset is updated. If `false`, both the current and staged Asset is updated.
    staged: typing.Optional[bool]
    #: The `id` of the Asset to update.
    asset_id: typing.Optional[str]
    #: The `key` of the Asset to update.
    asset_key: typing.Optional[str]
    #: Defines the [Type](ctp:api:type:Type) that extends the Asset with [Custom Fields](/../api/projects/custom-fields).
    #: If absent, any existing Type and Custom Fields are removed from the Asset.
    type: typing.Optional["TypeResourceIdentifier"]
    #: Sets the [Custom Fields](/../api/projects/custom-fields) fields for the Asset.
    fields: typing.Optional["FieldContainer"]

    def __init__(
        self,
        *,
        variant_id: typing.Optional[int] = None,
        sku: typing.Optional[str] = None,
        staged: typing.Optional[bool] = None,
        asset_id: typing.Optional[str] = None,
        asset_key: typing.Optional[str] = None,
        type: typing.Optional["TypeResourceIdentifier"] = None,
        fields: typing.Optional["FieldContainer"] = None
    ):
        self.variant_id = variant_id
        self.sku = sku
        self.staged = staged
        self.asset_id = asset_id
        self.asset_key = asset_key
        self.type = type
        self.fields = fields

        super().__init__(action="setAssetCustomType")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductSetAssetCustomTypeAction":
        from ._schemas.product import ProductSetAssetCustomTypeActionSchema

        return ProductSetAssetCustomTypeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import ProductSetAssetCustomTypeActionSchema

        return ProductSetAssetCustomTypeActionSchema().dump(self)


class ProductSetAssetDescriptionAction(ProductUpdateAction):
    """Either `variantId` or `sku` is required. The [Asset](ctp:api:type:Asset) to update must be specified using either `assetId` or `assetKey`."""

    #: The `id` of the ProductVariant to update.
    variant_id: typing.Optional[int]
    #: The `sku` of the ProductVariant to update.
    sku: typing.Optional[str]
    #: If `true`, only the staged Asset is updated. If `false`, both the current and staged Asset is updated.
    staged: typing.Optional[bool]
    #: The `id` of the Asset to update.
    asset_id: typing.Optional[str]
    #: The `key` of the Asset to update.
    asset_key: typing.Optional[str]
    #: Value to set. If empty, any existing value will be removed.
    description: typing.Optional["LocalizedString"]

    def __init__(
        self,
        *,
        variant_id: typing.Optional[int] = None,
        sku: typing.Optional[str] = None,
        staged: typing.Optional[bool] = None,
        asset_id: typing.Optional[str] = None,
        asset_key: typing.Optional[str] = None,
        description: typing.Optional["LocalizedString"] = None
    ):
        self.variant_id = variant_id
        self.sku = sku
        self.staged = staged
        self.asset_id = asset_id
        self.asset_key = asset_key
        self.description = description

        super().__init__(action="setAssetDescription")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductSetAssetDescriptionAction":
        from ._schemas.product import ProductSetAssetDescriptionActionSchema

        return ProductSetAssetDescriptionActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import ProductSetAssetDescriptionActionSchema

        return ProductSetAssetDescriptionActionSchema().dump(self)


class ProductSetAssetKeyAction(ProductUpdateAction):
    """Either `variantId` or `sku` is required."""

    #: The `id` of the ProductVariant to update.
    variant_id: typing.Optional[int]
    #: The `sku` of the ProductVariant to update.
    sku: typing.Optional[str]
    #: If `true`, only the staged Asset is updated. If `false`, both the current and staged Asset is updated.
    staged: typing.Optional[bool]
    #: The `id` of the Asset to update.
    asset_id: str
    #: Value to set. If empty, any existing value will be removed.
    asset_key: typing.Optional[str]

    def __init__(
        self,
        *,
        variant_id: typing.Optional[int] = None,
        sku: typing.Optional[str] = None,
        staged: typing.Optional[bool] = None,
        asset_id: str,
        asset_key: typing.Optional[str] = None
    ):
        self.variant_id = variant_id
        self.sku = sku
        self.staged = staged
        self.asset_id = asset_id
        self.asset_key = asset_key

        super().__init__(action="setAssetKey")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductSetAssetKeyAction":
        from ._schemas.product import ProductSetAssetKeyActionSchema

        return ProductSetAssetKeyActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import ProductSetAssetKeyActionSchema

        return ProductSetAssetKeyActionSchema().dump(self)


class ProductSetAssetSourcesAction(ProductUpdateAction):
    """Either `variantId` or `sku` is required. The [Asset](ctp:api:type:Asset) to update must be specified using either `assetId` or `assetKey`."""

    #: The `id` of the ProductVariant to update.
    variant_id: typing.Optional[int]
    #: The `sku` of the ProductVariant to update.
    sku: typing.Optional[str]
    #: If `true`, only the staged Asset is updated. If `false` both the current and staged Asset is updated.
    staged: typing.Optional[bool]
    #: The `id` of the Asset to update.
    asset_id: typing.Optional[str]
    #: The `key` of the Asset to update.
    asset_key: typing.Optional[str]
    #: Value to set.
    sources: typing.List["AssetSource"]

    def __init__(
        self,
        *,
        variant_id: typing.Optional[int] = None,
        sku: typing.Optional[str] = None,
        staged: typing.Optional[bool] = None,
        asset_id: typing.Optional[str] = None,
        asset_key: typing.Optional[str] = None,
        sources: typing.List["AssetSource"]
    ):
        self.variant_id = variant_id
        self.sku = sku
        self.staged = staged
        self.asset_id = asset_id
        self.asset_key = asset_key
        self.sources = sources

        super().__init__(action="setAssetSources")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductSetAssetSourcesAction":
        from ._schemas.product import ProductSetAssetSourcesActionSchema

        return ProductSetAssetSourcesActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import ProductSetAssetSourcesActionSchema

        return ProductSetAssetSourcesActionSchema().dump(self)


class ProductSetAssetTagsAction(ProductUpdateAction):
    """Either `variantId` or `sku` is required. The Asset to update must be specified using either `assetId` or `assetKey`."""

    #: The `id` of the ProductVariant to update.
    variant_id: typing.Optional[int]
    #: The `sku` of the ProductVariant to update.
    sku: typing.Optional[str]
    #: If `true`, only the staged Asset is updated. If `false`, both the current and staged Asset is updated.
    staged: typing.Optional[bool]
    #: The `id` of the Asset to update.
    asset_id: typing.Optional[str]
    #: The `key` of the Asset to update.
    asset_key: typing.Optional[str]
    #: Keywords for categorizing and organizing Assets.
    tags: typing.Optional[typing.List["str"]]

    def __init__(
        self,
        *,
        variant_id: typing.Optional[int] = None,
        sku: typing.Optional[str] = None,
        staged: typing.Optional[bool] = None,
        asset_id: typing.Optional[str] = None,
        asset_key: typing.Optional[str] = None,
        tags: typing.Optional[typing.List["str"]] = None
    ):
        self.variant_id = variant_id
        self.sku = sku
        self.staged = staged
        self.asset_id = asset_id
        self.asset_key = asset_key
        self.tags = tags

        super().__init__(action="setAssetTags")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductSetAssetTagsAction":
        from ._schemas.product import ProductSetAssetTagsActionSchema

        return ProductSetAssetTagsActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import ProductSetAssetTagsActionSchema

        return ProductSetAssetTagsActionSchema().dump(self)


class ProductSetAttributeAction(ProductUpdateAction):
    """Either `variantId` or `sku` is required."""

    #: The `id` of the ProductVariant to update.
    variant_id: typing.Optional[int]
    #: The `sku` of the ProductVariant to update.
    sku: typing.Optional[str]
    #: The name of the Attribute to set.
    name: str
    #: Value to set for the Attribute. If empty, any existing value will be removed.
    #:
    #: The [AttributeType](ctp:api:type:AttributeType) determines the format of the Attribute `value` to be provided:
    #:
    #: - For [Enum Type](ctp:api:type:AttributeEnumType) and [Localized Enum Type](ctp:api:type:AttributeLocalizedEnumType),
    #:   use the `key` of the [Plain Enum Value](ctp:api:type:AttributePlainEnumValue) or [Localized Enum Value](ctp:api:type:AttributeLocalizedEnumValue) objects,
    #:   or the complete objects as `value`.
    #: - For [Localizable Text Type](ctp:api:type:AttributeLocalizableTextType), use the [LocalizedString](ctp:api:type:LocalizedString) object as `value`.
    #: - For [Money Type](ctp:api:type:AttributeMoneyType) Attributes, use the [Money](ctp:api:type:Money) object as `value`.
    #: - For [Set Type](ctp:api:type:AttributeSetType) Attributes, use the entire `set` object  as `value`.
    #: - For [Nested Type](ctp:api:type:AttributeNestedType) Attributes, use the list of values of all Attributes of the nested Product as `value`.
    #: - For [Reference Type](ctp:api:type:AttributeReferenceType) Attributes, use the [Reference](ctp:api:type:Reference) object as `value`.
    value: typing.Optional[typing.Any]
    #: If `true`, only the staged Attribute is set. If `false`, both current and staged Attribute is set.
    staged: typing.Optional[bool]

    def __init__(
        self,
        *,
        variant_id: typing.Optional[int] = None,
        sku: typing.Optional[str] = None,
        name: str,
        value: typing.Optional[typing.Any] = None,
        staged: typing.Optional[bool] = None
    ):
        self.variant_id = variant_id
        self.sku = sku
        self.name = name
        self.value = value
        self.staged = staged

        super().__init__(action="setAttribute")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductSetAttributeAction":
        from ._schemas.product import ProductSetAttributeActionSchema

        return ProductSetAttributeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import ProductSetAttributeActionSchema

        return ProductSetAttributeActionSchema().dump(self)


class ProductSetAttributeInAllVariantsAction(ProductUpdateAction):
    """Adds, removes, or changes a Product Attribute in all Product Variants at the same time.
    This action is useful for setting values for Attributes with the [Constraint](ctp:api:type:AttributeConstraintEnum) `SameForAll`.
    """

    #: The name of the Attribute to set.
    name: str
    #: Value to set for the Attributes. If empty, any existing value will be removed.
    #:
    #: The [AttributeType](ctp:api:type:AttributeType) determines the format of the Attribute `value` to be provided:
    #:
    #: - For [Enum Type](ctp:api:type:AttributeEnumType) and [Localized Enum Type](ctp:api:type:AttributeLocalizedEnumType),
    #:   use the `key` of the [Plain Enum Value](ctp:api:type:AttributePlainEnumValue) or [Localized Enum Value](ctp:api:type:AttributeLocalizedEnumValue) objects,
    #:   or the complete objects as `value`.
    #: - For [Localizable Text Type](ctp:api:type:AttributeLocalizableTextType), use the [LocalizedString](ctp:api:type:LocalizedString) object as `value`.
    #: - For [Money Type](ctp:api:type:AttributeMoneyType) Attributes, use the [Money](ctp:api:type:Money) object as `value`.
    #: - For [Set Type](ctp:api:type:AttributeSetType) Attributes, use the entire `set` object  as `value`.
    #: - For [Nested Type](ctp:api:type:AttributeNestedType) Attributes, use the list of values of all Attributes of the nested Product as `value`.
    #: - For [Reference Type](ctp:api:type:AttributeReferenceType) Attributes, use the [Reference](ctp:api:type:Reference) object as `value`.
    value: typing.Optional[typing.Any]
    #: If `true`, only the staged Attributes are set. If `false`, both the current and staged Attributes are set.
    staged: typing.Optional[bool]

    def __init__(
        self,
        *,
        name: str,
        value: typing.Optional[typing.Any] = None,
        staged: typing.Optional[bool] = None
    ):
        self.name = name
        self.value = value
        self.staged = staged

        super().__init__(action="setAttributeInAllVariants")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductSetAttributeInAllVariantsAction":
        from ._schemas.product import ProductSetAttributeInAllVariantsActionSchema

        return ProductSetAttributeInAllVariantsActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import ProductSetAttributeInAllVariantsActionSchema

        return ProductSetAttributeInAllVariantsActionSchema().dump(self)


class ProductSetCategoryOrderHintAction(ProductUpdateAction):
    #: The `id` of the Category to add the `orderHint`.
    category_id: str
    #: A string representing a number between 0 and 1. Must start with `0.` and cannot end with `0`. If empty, any existing value will be removed.
    order_hint: typing.Optional[str]
    #: If `true`, only the staged `categoryOrderHints` is updated. If `false`, both the current and staged `categoryOrderHints` are updated.
    staged: typing.Optional[bool]

    def __init__(
        self,
        *,
        category_id: str,
        order_hint: typing.Optional[str] = None,
        staged: typing.Optional[bool] = None
    ):
        self.category_id = category_id
        self.order_hint = order_hint
        self.staged = staged

        super().__init__(action="setCategoryOrderHint")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductSetCategoryOrderHintAction":
        from ._schemas.product import ProductSetCategoryOrderHintActionSchema

        return ProductSetCategoryOrderHintActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import ProductSetCategoryOrderHintActionSchema

        return ProductSetCategoryOrderHintActionSchema().dump(self)


class ProductSetDescriptionAction(ProductUpdateAction):
    #: Value to set. If empty, any existing value will be removed.
    description: typing.Optional["LocalizedString"]
    #: If `true`, only the staged `description` is updated. If `false`, both the current and staged `description` are updated.
    staged: typing.Optional[bool]

    def __init__(
        self,
        *,
        description: typing.Optional["LocalizedString"] = None,
        staged: typing.Optional[bool] = None
    ):
        self.description = description
        self.staged = staged

        super().__init__(action="setDescription")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductSetDescriptionAction":
        from ._schemas.product import ProductSetDescriptionActionSchema

        return ProductSetDescriptionActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import ProductSetDescriptionActionSchema

        return ProductSetDescriptionActionSchema().dump(self)


class ProductSetDiscountedPriceAction(ProductUpdateAction):
    """Produces the [ProductPriceExternalDiscountSet](ctp:api:type:ProductPriceExternalDiscountSetMessage) Message."""

    #: The `id` of the [Price](ctp:api:type:Price) to set the Discount.
    price_id: str
    #: If `true`, only the staged Embedded Price is updated. If `false`, both the current and staged Embedded Price are updated.
    staged: typing.Optional[bool]
    #: Value to set. If empty, any existing value will be removed.
    #: The referenced [ProductDiscount](ctp:api:type:ProductDiscount) must have the Type `external`, be active, and its predicate must match the referenced Price.
    discounted: typing.Optional["DiscountedPriceDraft"]

    def __init__(
        self,
        *,
        price_id: str,
        staged: typing.Optional[bool] = None,
        discounted: typing.Optional["DiscountedPriceDraft"] = None
    ):
        self.price_id = price_id
        self.staged = staged
        self.discounted = discounted

        super().__init__(action="setDiscountedPrice")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductSetDiscountedPriceAction":
        from ._schemas.product import ProductSetDiscountedPriceActionSchema

        return ProductSetDiscountedPriceActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import ProductSetDiscountedPriceActionSchema

        return ProductSetDiscountedPriceActionSchema().dump(self)


class ProductSetImageLabelAction(ProductUpdateAction):
    """Either `variantId` or `sku` is required."""

    #: The `sku` of the ProductVariant to update.
    sku: typing.Optional[str]
    #: The `id` of the ProductVariant to update.
    variant_id: typing.Optional[int]
    #: The URL of the image to set the label.
    image_url: str
    #: Value to set. If empty, any existing value will be removed.
    label: typing.Optional[str]
    #: If `true`, only the staged image is updated. If `false`, both the current and staged image is updated.
    staged: typing.Optional[bool]

    def __init__(
        self,
        *,
        sku: typing.Optional[str] = None,
        variant_id: typing.Optional[int] = None,
        image_url: str,
        label: typing.Optional[str] = None,
        staged: typing.Optional[bool] = None
    ):
        self.sku = sku
        self.variant_id = variant_id
        self.image_url = image_url
        self.label = label
        self.staged = staged

        super().__init__(action="setImageLabel")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductSetImageLabelAction":
        from ._schemas.product import ProductSetImageLabelActionSchema

        return ProductSetImageLabelActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import ProductSetImageLabelActionSchema

        return ProductSetImageLabelActionSchema().dump(self)


class ProductSetKeyAction(ProductUpdateAction):
    #: Value to set. If empty, any existing value will be removed.
    key: typing.Optional[str]

    def __init__(self, *, key: typing.Optional[str] = None):
        self.key = key

        super().__init__(action="setKey")

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ProductSetKeyAction":
        from ._schemas.product import ProductSetKeyActionSchema

        return ProductSetKeyActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import ProductSetKeyActionSchema

        return ProductSetKeyActionSchema().dump(self)


class ProductSetMetaDescriptionAction(ProductUpdateAction):
    #: Value to set. If empty, any existing value will be removed.
    meta_description: typing.Optional["LocalizedString"]
    #: If `true`, only the staged `metaDescription` is updated. If `false`, both the current and staged `metaDescription` are updated.
    staged: typing.Optional[bool]

    def __init__(
        self,
        *,
        meta_description: typing.Optional["LocalizedString"] = None,
        staged: typing.Optional[bool] = None
    ):
        self.meta_description = meta_description
        self.staged = staged

        super().__init__(action="setMetaDescription")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductSetMetaDescriptionAction":
        from ._schemas.product import ProductSetMetaDescriptionActionSchema

        return ProductSetMetaDescriptionActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import ProductSetMetaDescriptionActionSchema

        return ProductSetMetaDescriptionActionSchema().dump(self)


class ProductSetMetaKeywordsAction(ProductUpdateAction):
    #: Value to set. If empty, any existing value will be removed.
    meta_keywords: typing.Optional["LocalizedString"]
    #: If `true`, only the staged `metaKeywords` is updated. If `false`, both the current and staged `metaKeywords` are updated.
    staged: typing.Optional[bool]

    def __init__(
        self,
        *,
        meta_keywords: typing.Optional["LocalizedString"] = None,
        staged: typing.Optional[bool] = None
    ):
        self.meta_keywords = meta_keywords
        self.staged = staged

        super().__init__(action="setMetaKeywords")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductSetMetaKeywordsAction":
        from ._schemas.product import ProductSetMetaKeywordsActionSchema

        return ProductSetMetaKeywordsActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import ProductSetMetaKeywordsActionSchema

        return ProductSetMetaKeywordsActionSchema().dump(self)


class ProductSetMetaTitleAction(ProductUpdateAction):
    #: Value to set. If empty, any existing value will be removed.
    meta_title: typing.Optional["LocalizedString"]
    #: If `true`, only the staged `metaTitle` is updated. If `false`, both the current and staged `metaTitle` are updated.
    staged: typing.Optional[bool]

    def __init__(
        self,
        *,
        meta_title: typing.Optional["LocalizedString"] = None,
        staged: typing.Optional[bool] = None
    ):
        self.meta_title = meta_title
        self.staged = staged

        super().__init__(action="setMetaTitle")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductSetMetaTitleAction":
        from ._schemas.product import ProductSetMetaTitleActionSchema

        return ProductSetMetaTitleActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import ProductSetMetaTitleActionSchema

        return ProductSetMetaTitleActionSchema().dump(self)


class ProductSetPriceKeyAction(ProductUpdateAction):
    """Sets the key of an [Embedded Price](/projects/products#embedded-price). Produces the [ProductPriceKeySet](ctp:api:type:ProductPriceKeySetMessage) Message."""

    #: The `id` of the [Price](ctp:api:type:Price) to set the key.
    price_id: str
    #: If `true`, only the staged [Embedded Price](/projects/products#embedded-price) is updated. If `false`, both the current and staged Embedded Price are updated.
    staged: typing.Optional[bool]
    #: Value to set. If empty, any existing value will be removed.
    key: typing.Optional[str]

    def __init__(
        self,
        *,
        price_id: str,
        staged: typing.Optional[bool] = None,
        key: typing.Optional[str] = None
    ):
        self.price_id = price_id
        self.staged = staged
        self.key = key

        super().__init__(action="setPriceKey")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductSetPriceKeyAction":
        from ._schemas.product import ProductSetPriceKeyActionSchema

        return ProductSetPriceKeyActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import ProductSetPriceKeyActionSchema

        return ProductSetPriceKeyActionSchema().dump(self)


class ProductSetPriceModeAction(ProductUpdateAction):
    """Controls whether the Prices of a Product Variant are embedded into the Product or standalone."""

    #: Specifies which type of Prices should be used when looking up a price for the Product.
    price_mode: typing.Optional["ProductPriceModeEnum"]

    def __init__(self, *, price_mode: typing.Optional["ProductPriceModeEnum"] = None):
        self.price_mode = price_mode

        super().__init__(action="setPriceMode")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductSetPriceModeAction":
        from ._schemas.product import ProductSetPriceModeActionSchema

        return ProductSetPriceModeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import ProductSetPriceModeActionSchema

        return ProductSetPriceModeActionSchema().dump(self)


class ProductSetPricesAction(ProductUpdateAction):
    """Either `variantId` or `sku` is required."""

    #: The `id` of the ProductVariant to update.
    variant_id: typing.Optional[int]
    #: The `sku` of the ProductVariant to update.
    sku: typing.Optional[str]
    #: The Embedded Prices to set.
    #: Each Price must have its unique Price scope (with same currency, country, Customer Group, Channel, `validFrom` and `validUntil`).
    prices: typing.List["PriceDraft"]
    #: If `true`, only the staged ProductVariant is updated. If `false`, both the current and staged ProductVariant are updated.
    staged: typing.Optional[bool]

    def __init__(
        self,
        *,
        variant_id: typing.Optional[int] = None,
        sku: typing.Optional[str] = None,
        prices: typing.List["PriceDraft"],
        staged: typing.Optional[bool] = None
    ):
        self.variant_id = variant_id
        self.sku = sku
        self.prices = prices
        self.staged = staged

        super().__init__(action="setPrices")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductSetPricesAction":
        from ._schemas.product import ProductSetPricesActionSchema

        return ProductSetPricesActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import ProductSetPricesActionSchema

        return ProductSetPricesActionSchema().dump(self)


class ProductSetProductPriceCustomFieldAction(ProductUpdateAction):
    #: The `id` of the Embedded Price to update.
    price_id: str
    #: If `true`, only the staged Embedded Price Custom Field is updated. If `false`, both the current and staged Embedded Price Custom Field are updated.
    staged: typing.Optional[bool]
    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: Removing a field that does not exist returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
    #: If `value` is provided, it is set for the field defined by `name`.
    value: typing.Optional[typing.Any]

    def __init__(
        self,
        *,
        price_id: str,
        staged: typing.Optional[bool] = None,
        name: str,
        value: typing.Optional[typing.Any] = None
    ):
        self.price_id = price_id
        self.staged = staged
        self.name = name
        self.value = value

        super().__init__(action="setProductPriceCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductSetProductPriceCustomFieldAction":
        from ._schemas.product import ProductSetProductPriceCustomFieldActionSchema

        return ProductSetProductPriceCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import ProductSetProductPriceCustomFieldActionSchema

        return ProductSetProductPriceCustomFieldActionSchema().dump(self)


class ProductSetProductPriceCustomTypeAction(ProductUpdateAction):
    #: The `id` of the Embedded Price to update.
    price_id: str
    #: If `true`, only the staged Embedded Price is updated. If `false`, both the current and staged Embedded Price is updated.
    staged: typing.Optional[bool]
    #: Defines the [Type](ctp:api:type:Type) that extends the Price with [Custom Fields](/../api/projects/custom-fields).
    #: If absent, any existing Type and Custom Fields are removed from the Embedded Price.
    type: typing.Optional["TypeResourceIdentifier"]
    #: Sets the [Custom Fields](/../api/projects/custom-fields) fields for the Embedded Price.
    fields: typing.Optional["FieldContainer"]

    def __init__(
        self,
        *,
        price_id: str,
        staged: typing.Optional[bool] = None,
        type: typing.Optional["TypeResourceIdentifier"] = None,
        fields: typing.Optional["FieldContainer"] = None
    ):
        self.price_id = price_id
        self.staged = staged
        self.type = type
        self.fields = fields

        super().__init__(action="setProductPriceCustomType")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductSetProductPriceCustomTypeAction":
        from ._schemas.product import ProductSetProductPriceCustomTypeActionSchema

        return ProductSetProductPriceCustomTypeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import ProductSetProductPriceCustomTypeActionSchema

        return ProductSetProductPriceCustomTypeActionSchema().dump(self)


class ProductSetProductVariantKeyAction(ProductUpdateAction):
    """Either `variantId` or `sku` is required."""

    #: The `id` of the ProductVariant to update.
    variant_id: typing.Optional[int]
    #: The `sku` of the ProductVariant to update.
    sku: typing.Optional[str]
    #: Value to set. Must be unique. If empty, any existing value will be removed.
    key: typing.Optional[str]
    #: If `true`, only the staged `key` is set. If `false`, both the current and staged `key` are set.
    staged: typing.Optional[bool]

    def __init__(
        self,
        *,
        variant_id: typing.Optional[int] = None,
        sku: typing.Optional[str] = None,
        key: typing.Optional[str] = None,
        staged: typing.Optional[bool] = None
    ):
        self.variant_id = variant_id
        self.sku = sku
        self.key = key
        self.staged = staged

        super().__init__(action="setProductVariantKey")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductSetProductVariantKeyAction":
        from ._schemas.product import ProductSetProductVariantKeyActionSchema

        return ProductSetProductVariantKeyActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import ProductSetProductVariantKeyActionSchema

        return ProductSetProductVariantKeyActionSchema().dump(self)


class ProductSetSearchKeywordsAction(ProductUpdateAction):
    #: Value to set.
    search_keywords: "SearchKeywords"
    #: If `true`, only the staged `searchKeywords` is updated. If `false`, both the current and staged `searchKeywords` are updated.
    staged: typing.Optional[bool]

    def __init__(
        self, *, search_keywords: "SearchKeywords", staged: typing.Optional[bool] = None
    ):
        self.search_keywords = search_keywords
        self.staged = staged

        super().__init__(action="setSearchKeywords")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductSetSearchKeywordsAction":
        from ._schemas.product import ProductSetSearchKeywordsActionSchema

        return ProductSetSearchKeywordsActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import ProductSetSearchKeywordsActionSchema

        return ProductSetSearchKeywordsActionSchema().dump(self)


class ProductSetSkuAction(ProductUpdateAction):
    """SKU cannot be changed or removed if it is associated with an [InventoryEntry](ctp:api:type:InventoryEntry).
    If the SKU to set or unset is part of a [ProductSelectionAssignment](ctp:api:type:ProductSelectionAssignment)
    it will be automatically added or removed from the respective [ProductVariantSelection](ctp:api:type:ProductVariantSelection).

    """

    #: The `id` of the ProductVariant to update.
    variant_id: int
    #: Value to set. Must be unique. If empty, any existing value will be removed.
    sku: typing.Optional[str]
    #: If `true`, only the staged `sku` is updated. If `false`, both the current and staged `sku` are updated.
    staged: typing.Optional[bool]

    def __init__(
        self,
        *,
        variant_id: int,
        sku: typing.Optional[str] = None,
        staged: typing.Optional[bool] = None
    ):
        self.variant_id = variant_id
        self.sku = sku
        self.staged = staged

        super().__init__(action="setSku")

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ProductSetSkuAction":
        from ._schemas.product import ProductSetSkuActionSchema

        return ProductSetSkuActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import ProductSetSkuActionSchema

        return ProductSetSkuActionSchema().dump(self)


class ProductSetTaxCategoryAction(ProductUpdateAction):
    """Cannot be staged. Published Products are immediately updated."""

    #: The Tax Category to set. If empty, any existing value will be removed.
    tax_category: typing.Optional["TaxCategoryResourceIdentifier"]

    def __init__(
        self, *, tax_category: typing.Optional["TaxCategoryResourceIdentifier"] = None
    ):
        self.tax_category = tax_category

        super().__init__(action="setTaxCategory")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductSetTaxCategoryAction":
        from ._schemas.product import ProductSetTaxCategoryActionSchema

        return ProductSetTaxCategoryActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import ProductSetTaxCategoryActionSchema

        return ProductSetTaxCategoryActionSchema().dump(self)


class ProductTransitionStateAction(ProductUpdateAction):
    """If the existing [State](ctp:api:type:State) has set `transitions`, there must be a direct transition to the new State. If `transitions` is not set, no validation is performed. Produces the [ProductStateTransition](ctp:api:type:ProductStateTransitionMessage) Message."""

    #: The State to transition to. If there is no existing State, this must be an initial State.
    state: typing.Optional["StateResourceIdentifier"]
    #: If `true`, validations are disabled.
    force: typing.Optional[bool]

    def __init__(
        self,
        *,
        state: typing.Optional["StateResourceIdentifier"] = None,
        force: typing.Optional[bool] = None
    ):
        self.state = state
        self.force = force

        super().__init__(action="transitionState")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTransitionStateAction":
        from ._schemas.product import ProductTransitionStateActionSchema

        return ProductTransitionStateActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import ProductTransitionStateActionSchema

        return ProductTransitionStateActionSchema().dump(self)


class ProductUnpublishAction(ProductUpdateAction):
    """Removes the current [projection](/../api/projects/productProjections#current--staged) of the Product. The staged projection is unaffected. To retrieve unpublished Products, the `staged` parameter must be set to `false` when [querying](/projects/productProjections#query-productprojections)/[searching](/projects/products-search#product-projection-search) Product Projections. Produces the [ProductUnpublished](ctp:api:type:ProductUnpublishedMessage) Message.

    Unpublished Products cannot be added to a Cart. However, if a Cart contains Line Items for Products that were added before the Product was unpublished, the Cart is unaffected and can still be used to create an Order. To prevent this, in addition to unpublishing the Product you should remove the Prices from the Product using [Remove Price](ctp:api:type:ProductRemovePriceAction) for Embedded Prices or [Delete StandalonePrice](/projects/standalone-prices#delete-standaloneprice) for Standalone Prices.

    """

    def __init__(self):
        super().__init__(action="unpublish")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductUnpublishAction":
        from ._schemas.product import ProductUnpublishActionSchema

        return ProductUnpublishActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product import ProductUnpublishActionSchema

        return ProductUnpublishActionSchema().dump(self)
