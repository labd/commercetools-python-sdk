# This file is automatically generated by the rmf-codegen project.
#
# The Python code generator is maintained by Lab Digital. If you want to
# contribute to this project then please do not edit this file directly
# but send a pull request to the Lab Digital fork of rmf-codegen at
# https://github.com/labd/rmf-codegen

import datetime
import enum
import typing

from ._abstract import _BaseType
from .common import BaseResource, Reference, ReferenceTypeId, ResourceIdentifier

if typing.TYPE_CHECKING:
    from .common import (
        CentPrecisionMoney,
        CreatedBy,
        LastModifiedBy,
        LocalizedString,
        Money,
        QueryPrice,
        Reference,
        ReferenceTypeId,
    )

__all__ = [
    "ProductDiscount",
    "ProductDiscountChangeIsActiveAction",
    "ProductDiscountChangeNameAction",
    "ProductDiscountChangePredicateAction",
    "ProductDiscountChangeSortOrderAction",
    "ProductDiscountChangeValueAction",
    "ProductDiscountDraft",
    "ProductDiscountMatchQuery",
    "ProductDiscountPagedQueryResponse",
    "ProductDiscountReference",
    "ProductDiscountResourceIdentifier",
    "ProductDiscountSetDescriptionAction",
    "ProductDiscountSetKeyAction",
    "ProductDiscountSetValidFromAction",
    "ProductDiscountSetValidFromAndUntilAction",
    "ProductDiscountSetValidUntilAction",
    "ProductDiscountUpdate",
    "ProductDiscountUpdateAction",
    "ProductDiscountValue",
    "ProductDiscountValueAbsolute",
    "ProductDiscountValueAbsoluteDraft",
    "ProductDiscountValueDraft",
    "ProductDiscountValueExternal",
    "ProductDiscountValueExternalDraft",
    "ProductDiscountValueRelative",
    "ProductDiscountValueRelativeDraft",
]


class ProductDiscount(BaseResource):
    #: IDs and references that last modified the ProductDiscount.
    last_modified_by: typing.Optional["LastModifiedBy"]
    #: IDs and references that created the ProductDiscount.
    created_by: typing.Optional["CreatedBy"]
    #: Name of the ProductDiscount.
    name: "LocalizedString"
    #: User-defined unique identifier of the ProductDiscount.
    key: typing.Optional[str]
    #: Description of the ProductDiscount.
    description: typing.Optional["LocalizedString"]
    #: Type of Discount and its corresponding value.
    value: "ProductDiscountValue"
    #: Valid [ProductDiscount predicate](/../api/projects/predicates#productdiscount-predicates).
    predicate: str
    #: Unique decimal value between 0 and 1 (stored as String literal) defining the order of Product Discounts to apply in case more than one is applicable and active.
    #: A Product Discount with a higher value is prioritized.
    sort_order: str
    #: If `true` the Product Discount is applied to Products matching the `predicate`.
    is_active: bool
    #: References of all the resources that are addressed in the `predicate`.
    references: typing.List["Reference"]
    #: Date and time (UTC) from which the Discount is effective.
    #: Take [Eventual Consistency](/../api/general-concepts#eventual-consistency) into account for calculated discount values.
    valid_from: typing.Optional[datetime.datetime]
    #: Date and time (UTC) until which the Discount is effective.
    #: Take [Eventual Consistency](/../api/general-concepts#eventual-consistency) into account for calculated undiscounted values.
    valid_until: typing.Optional[datetime.datetime]

    def __init__(
        self,
        *,
        id: str,
        version: int,
        created_at: datetime.datetime,
        last_modified_at: datetime.datetime,
        last_modified_by: typing.Optional["LastModifiedBy"] = None,
        created_by: typing.Optional["CreatedBy"] = None,
        name: "LocalizedString",
        key: typing.Optional[str] = None,
        description: typing.Optional["LocalizedString"] = None,
        value: "ProductDiscountValue",
        predicate: str,
        sort_order: str,
        is_active: bool,
        references: typing.List["Reference"],
        valid_from: typing.Optional[datetime.datetime] = None,
        valid_until: typing.Optional[datetime.datetime] = None
    ):
        self.last_modified_by = last_modified_by
        self.created_by = created_by
        self.name = name
        self.key = key
        self.description = description
        self.value = value
        self.predicate = predicate
        self.sort_order = sort_order
        self.is_active = is_active
        self.references = references
        self.valid_from = valid_from
        self.valid_until = valid_until

        super().__init__(
            id=id,
            version=version,
            created_at=created_at,
            last_modified_at=last_modified_at,
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ProductDiscount":
        from ._schemas.product_discount import ProductDiscountSchema

        return ProductDiscountSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_discount import ProductDiscountSchema

        return ProductDiscountSchema().dump(self)


class ProductDiscountDraft(_BaseType):
    #: Name of the ProductDiscount.
    name: "LocalizedString"
    #: User-defined unique identifier for the ProductDiscount.
    key: typing.Optional[str]
    #: Description of the ProductDiscount.
    description: typing.Optional["LocalizedString"]
    #: Type of Discount and its corresponding value.
    value: "ProductDiscountValueDraft"
    #: Valid [ProductDiscount predicate](/../api/projects/predicates#productdiscount-predicates).
    predicate: str
    #: Decimal value between 0 and 1 (passed as String literal) that defines the order of ProductDiscounts to apply in case more than one is applicable and active. A ProductDiscount with a higher `sortOrder` is prioritized.
    #: The value must be **unique** among all ProductDiscounts in the [Project](ctp:api:type:Project).
    sort_order: str
    #: Set to `true` to activate the ProductDiscount, set to `false` to deactivate it (even though the `predicate` matches).
    is_active: bool
    #: Date and time (UTC) from which the Discount is effective.
    #: Take [Eventual Consistency](/../api/general-concepts#eventual-consistency) into account for calculated discount values.
    valid_from: typing.Optional[datetime.datetime]
    #: Date and time (UTC) until which the Discount is effective.
    #: Take [Eventual Consistency](/../api/general-concepts#eventual-consistency) into account for calculated undiscounted values.
    valid_until: typing.Optional[datetime.datetime]

    def __init__(
        self,
        *,
        name: "LocalizedString",
        key: typing.Optional[str] = None,
        description: typing.Optional["LocalizedString"] = None,
        value: "ProductDiscountValueDraft",
        predicate: str,
        sort_order: str,
        is_active: bool,
        valid_from: typing.Optional[datetime.datetime] = None,
        valid_until: typing.Optional[datetime.datetime] = None
    ):
        self.name = name
        self.key = key
        self.description = description
        self.value = value
        self.predicate = predicate
        self.sort_order = sort_order
        self.is_active = is_active
        self.valid_from = valid_from
        self.valid_until = valid_until

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ProductDiscountDraft":
        from ._schemas.product_discount import ProductDiscountDraftSchema

        return ProductDiscountDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_discount import ProductDiscountDraftSchema

        return ProductDiscountDraftSchema().dump(self)


class ProductDiscountMatchQuery(_BaseType):
    #: ID of the specified Product.
    product_id: str
    #: ID of the specified Product Variant.
    variant_id: int
    #: Controls which [projected representation](/../api/projects/productProjections#current--staged) is applied for the query.
    #: Set to `true` for the `staged` Product Projection of the specified Product Variant, set to `false` for the `current` one.
    staged: bool
    #: Specified Price of the specified Product Variant.
    price: "QueryPrice"

    def __init__(
        self, *, product_id: str, variant_id: int, staged: bool, price: "QueryPrice"
    ):
        self.product_id = product_id
        self.variant_id = variant_id
        self.staged = staged
        self.price = price

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductDiscountMatchQuery":
        from ._schemas.product_discount import ProductDiscountMatchQuerySchema

        return ProductDiscountMatchQuerySchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_discount import ProductDiscountMatchQuerySchema

        return ProductDiscountMatchQuerySchema().dump(self)


class ProductDiscountPagedQueryResponse(_BaseType):
    """[PagedQueryResult](/../api/general-concepts#pagedqueryresult) with results containing an array of [ProductDiscount](ctp:api:type:ProductDiscount)."""

    #: Number of [results requested](/../api/general-concepts#limit).
    limit: int
    #: Number of [elements skipped](/../api/general-concepts#offset).
    offset: int
    #: Actual number of results returned.
    count: int
    #: Total number of results matching the query.
    #: This number is an estimation that is not [strongly consistent](/../api/general-concepts#strong-consistency).
    #: This field is returned by default.
    #: For improved performance, calculating this field can be deactivated by using the query parameter `withTotal=false`.
    #: When the results are filtered with a [Query Predicate](/../api/predicates/query), `total` is subject to a [limit](/../api/limits#queries).
    total: typing.Optional[int]
    #: [ProductDiscounts](ctp:api:type:ProductDiscount) matching the query.
    results: typing.List["ProductDiscount"]

    def __init__(
        self,
        *,
        limit: int,
        offset: int,
        count: int,
        total: typing.Optional[int] = None,
        results: typing.List["ProductDiscount"]
    ):
        self.limit = limit
        self.offset = offset
        self.count = count
        self.total = total
        self.results = results

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductDiscountPagedQueryResponse":
        from ._schemas.product_discount import ProductDiscountPagedQueryResponseSchema

        return ProductDiscountPagedQueryResponseSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_discount import ProductDiscountPagedQueryResponseSchema

        return ProductDiscountPagedQueryResponseSchema().dump(self)


class ProductDiscountReference(Reference):
    """[Reference](ctp:api:type:Reference) to a [ProductDiscount](ctp:api:type:ProductDiscount)."""

    #: Contains the representation of the expanded ProductDiscount. Only present in responses to requests with [Reference Expansion](/../api/general-concepts#reference-expansion) for ProductDiscounts.
    obj: typing.Optional["ProductDiscount"]

    def __init__(self, *, id: str, obj: typing.Optional["ProductDiscount"] = None):
        self.obj = obj

        super().__init__(id=id, type_id=ReferenceTypeId.PRODUCT_DISCOUNT)

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductDiscountReference":
        from ._schemas.product_discount import ProductDiscountReferenceSchema

        return ProductDiscountReferenceSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_discount import ProductDiscountReferenceSchema

        return ProductDiscountReferenceSchema().dump(self)


class ProductDiscountResourceIdentifier(ResourceIdentifier):
    """[ResourceIdentifier](ctp:api:type:ResourceIdentifier) to a [ProductDiscount](ctp:api:type:ProductDiscount). Either `id` or `key` is required. If both are set, an [InvalidJsonInput](/../api/errors#invalidjsoninput) error is returned."""

    def __init__(
        self, *, id: typing.Optional[str] = None, key: typing.Optional[str] = None
    ):

        super().__init__(id=id, key=key, type_id=ReferenceTypeId.PRODUCT_DISCOUNT)

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductDiscountResourceIdentifier":
        from ._schemas.product_discount import ProductDiscountResourceIdentifierSchema

        return ProductDiscountResourceIdentifierSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_discount import ProductDiscountResourceIdentifierSchema

        return ProductDiscountResourceIdentifierSchema().dump(self)


class ProductDiscountUpdate(_BaseType):
    #: Expected version of the ProductDiscount on which the changes should be applied.
    #: If the expected version does not match the actual version, a [ConcurrentModification](ctp:api:type:ConcurrentModificationError) error will be returned.
    version: int
    #: Update actions to be performed on the ProductDiscount.
    actions: typing.List["ProductDiscountUpdateAction"]

    def __init__(
        self, *, version: int, actions: typing.List["ProductDiscountUpdateAction"]
    ):
        self.version = version
        self.actions = actions

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ProductDiscountUpdate":
        from ._schemas.product_discount import ProductDiscountUpdateSchema

        return ProductDiscountUpdateSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_discount import ProductDiscountUpdateSchema

        return ProductDiscountUpdateSchema().dump(self)


class ProductDiscountUpdateAction(_BaseType):
    action: str

    def __init__(self, *, action: str):
        self.action = action

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductDiscountUpdateAction":
        if data["action"] == "changeIsActive":
            from ._schemas.product_discount import (
                ProductDiscountChangeIsActiveActionSchema,
            )

            return ProductDiscountChangeIsActiveActionSchema().load(data)
        if data["action"] == "changeName":
            from ._schemas.product_discount import ProductDiscountChangeNameActionSchema

            return ProductDiscountChangeNameActionSchema().load(data)
        if data["action"] == "changePredicate":
            from ._schemas.product_discount import (
                ProductDiscountChangePredicateActionSchema,
            )

            return ProductDiscountChangePredicateActionSchema().load(data)
        if data["action"] == "changeSortOrder":
            from ._schemas.product_discount import (
                ProductDiscountChangeSortOrderActionSchema,
            )

            return ProductDiscountChangeSortOrderActionSchema().load(data)
        if data["action"] == "changeValue":
            from ._schemas.product_discount import (
                ProductDiscountChangeValueActionSchema,
            )

            return ProductDiscountChangeValueActionSchema().load(data)
        if data["action"] == "setDescription":
            from ._schemas.product_discount import (
                ProductDiscountSetDescriptionActionSchema,
            )

            return ProductDiscountSetDescriptionActionSchema().load(data)
        if data["action"] == "setKey":
            from ._schemas.product_discount import ProductDiscountSetKeyActionSchema

            return ProductDiscountSetKeyActionSchema().load(data)
        if data["action"] == "setValidFrom":
            from ._schemas.product_discount import (
                ProductDiscountSetValidFromActionSchema,
            )

            return ProductDiscountSetValidFromActionSchema().load(data)
        if data["action"] == "setValidFromAndUntil":
            from ._schemas.product_discount import (
                ProductDiscountSetValidFromAndUntilActionSchema,
            )

            return ProductDiscountSetValidFromAndUntilActionSchema().load(data)
        if data["action"] == "setValidUntil":
            from ._schemas.product_discount import (
                ProductDiscountSetValidUntilActionSchema,
            )

            return ProductDiscountSetValidUntilActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_discount import ProductDiscountUpdateActionSchema

        return ProductDiscountUpdateActionSchema().dump(self)


class ProductDiscountValue(_BaseType):
    type: str

    def __init__(self, *, type: str):
        self.type = type

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ProductDiscountValue":
        if data["type"] == "absolute":
            from ._schemas.product_discount import ProductDiscountValueAbsoluteSchema

            return ProductDiscountValueAbsoluteSchema().load(data)
        if data["type"] == "external":
            from ._schemas.product_discount import ProductDiscountValueExternalSchema

            return ProductDiscountValueExternalSchema().load(data)
        if data["type"] == "relative":
            from ._schemas.product_discount import ProductDiscountValueRelativeSchema

            return ProductDiscountValueRelativeSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_discount import ProductDiscountValueSchema

        return ProductDiscountValueSchema().dump(self)


class ProductDiscountValueAbsolute(ProductDiscountValue):
    """Discounts the Product's Price by a fixed amount, defined by the `money` field."""

    #: Money values in different currencies. An absolute [ProductDiscount](ctp:api:type:ProductDiscount) will only match a price if this array contains a value with the same currency. For example, if it contains 10€ and 15$, the matching € price will be decreased by 10€ and the matching $ price will be decreased by 15\$.
    money: typing.List["CentPrecisionMoney"]

    def __init__(self, *, money: typing.List["CentPrecisionMoney"]):
        self.money = money

        super().__init__(type="absolute")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductDiscountValueAbsolute":
        from ._schemas.product_discount import ProductDiscountValueAbsoluteSchema

        return ProductDiscountValueAbsoluteSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_discount import ProductDiscountValueAbsoluteSchema

        return ProductDiscountValueAbsoluteSchema().dump(self)


class ProductDiscountValueDraft(_BaseType):
    type: str

    def __init__(self, *, type: str):
        self.type = type

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductDiscountValueDraft":
        if data["type"] == "absolute":
            from ._schemas.product_discount import (
                ProductDiscountValueAbsoluteDraftSchema,
            )

            return ProductDiscountValueAbsoluteDraftSchema().load(data)
        if data["type"] == "external":
            from ._schemas.product_discount import (
                ProductDiscountValueExternalDraftSchema,
            )

            return ProductDiscountValueExternalDraftSchema().load(data)
        if data["type"] == "relative":
            from ._schemas.product_discount import (
                ProductDiscountValueRelativeDraftSchema,
            )

            return ProductDiscountValueRelativeDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_discount import ProductDiscountValueDraftSchema

        return ProductDiscountValueDraftSchema().dump(self)


class ProductDiscountValueAbsoluteDraft(ProductDiscountValueDraft):
    """Discounts the Product Price by a fixed amount, defined by the `money` field."""

    #: Money values in different currencies.
    #: An absolute Product Discount will match a price only if the array contains a value with the same currency. For example, if it contains 10€ and 15$, the matching € price will be decreased by 10€ and the matching $ price will be decreased by 15$. If the array has multiple values of the same currency, the API returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
    #:
    #: If the array is empty, the discount does not apply.
    money: typing.List["Money"]

    def __init__(self, *, money: typing.List["Money"]):
        self.money = money

        super().__init__(type="absolute")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductDiscountValueAbsoluteDraft":
        from ._schemas.product_discount import ProductDiscountValueAbsoluteDraftSchema

        return ProductDiscountValueAbsoluteDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_discount import ProductDiscountValueAbsoluteDraftSchema

        return ProductDiscountValueAbsoluteDraftSchema().dump(self)


class ProductDiscountValueExternal(ProductDiscountValue):
    """Discounts the Product Price by allowing the client to explicitly [set a discounted value](ctp:api:type:ProductSetDiscountedPriceAction).
    Used when setting discounts using an external service.

    """

    def __init__(self):

        super().__init__(type="external")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductDiscountValueExternal":
        from ._schemas.product_discount import ProductDiscountValueExternalSchema

        return ProductDiscountValueExternalSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_discount import ProductDiscountValueExternalSchema

        return ProductDiscountValueExternalSchema().dump(self)


class ProductDiscountValueExternalDraft(ProductDiscountValueDraft):
    """Discounts the Product Price by allowing the client to explicitly [set a discounted value](ctp:api:type:ProductSetDiscountedPriceAction).
    Use this when setting discounts using an external service.

    """

    def __init__(self):

        super().__init__(type="external")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductDiscountValueExternalDraft":
        from ._schemas.product_discount import ProductDiscountValueExternalDraftSchema

        return ProductDiscountValueExternalDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_discount import ProductDiscountValueExternalDraftSchema

        return ProductDiscountValueExternalDraftSchema().dump(self)


class ProductDiscountValueRelative(ProductDiscountValue):
    """Discounts the product price by a percentage, defined by the `permyriad` field."""

    #: Fraction (per ten thousand) the price is reduced by. For example, `1000` will result in a 10% price reduction.
    permyriad: int

    def __init__(self, *, permyriad: int):
        self.permyriad = permyriad

        super().__init__(type="relative")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductDiscountValueRelative":
        from ._schemas.product_discount import ProductDiscountValueRelativeSchema

        return ProductDiscountValueRelativeSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_discount import ProductDiscountValueRelativeSchema

        return ProductDiscountValueRelativeSchema().dump(self)


class ProductDiscountValueRelativeDraft(ProductDiscountValueDraft):
    """Discounts the Product Price by a percentage, defined by the `permyriad` field."""

    #: Fraction (per ten thousand) the price is reduced by. For example, `1000` will result in a 10% price reduction.
    permyriad: int

    def __init__(self, *, permyriad: int):
        self.permyriad = permyriad

        super().__init__(type="relative")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductDiscountValueRelativeDraft":
        from ._schemas.product_discount import ProductDiscountValueRelativeDraftSchema

        return ProductDiscountValueRelativeDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_discount import ProductDiscountValueRelativeDraftSchema

        return ProductDiscountValueRelativeDraftSchema().dump(self)


class ProductDiscountChangeIsActiveAction(ProductDiscountUpdateAction):
    #: New value to set.
    #: If set to `true`, the Discount will be applied to Product Prices.
    is_active: bool

    def __init__(self, *, is_active: bool):
        self.is_active = is_active

        super().__init__(action="changeIsActive")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductDiscountChangeIsActiveAction":
        from ._schemas.product_discount import ProductDiscountChangeIsActiveActionSchema

        return ProductDiscountChangeIsActiveActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_discount import ProductDiscountChangeIsActiveActionSchema

        return ProductDiscountChangeIsActiveActionSchema().dump(self)


class ProductDiscountChangeNameAction(ProductDiscountUpdateAction):
    #: New value to set. Must not be empty.
    name: "LocalizedString"

    def __init__(self, *, name: "LocalizedString"):
        self.name = name

        super().__init__(action="changeName")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductDiscountChangeNameAction":
        from ._schemas.product_discount import ProductDiscountChangeNameActionSchema

        return ProductDiscountChangeNameActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_discount import ProductDiscountChangeNameActionSchema

        return ProductDiscountChangeNameActionSchema().dump(self)


class ProductDiscountChangePredicateAction(ProductDiscountUpdateAction):
    #: New value to set. Must be a valid [ProductDiscount predicate](/../api/projects/predicates#productdiscount-predicates).
    predicate: str

    def __init__(self, *, predicate: str):
        self.predicate = predicate

        super().__init__(action="changePredicate")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductDiscountChangePredicateAction":
        from ._schemas.product_discount import (
            ProductDiscountChangePredicateActionSchema,
        )

        return ProductDiscountChangePredicateActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_discount import (
            ProductDiscountChangePredicateActionSchema,
        )

        return ProductDiscountChangePredicateActionSchema().dump(self)


class ProductDiscountChangeSortOrderAction(ProductDiscountUpdateAction):
    #: New value to set.
    #: Must not be empty.
    #: The string value must be a number between `0` and `1`.
    #: A Discount with a higher sortOrder is prioritized.
    sort_order: str

    def __init__(self, *, sort_order: str):
        self.sort_order = sort_order

        super().__init__(action="changeSortOrder")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductDiscountChangeSortOrderAction":
        from ._schemas.product_discount import (
            ProductDiscountChangeSortOrderActionSchema,
        )

        return ProductDiscountChangeSortOrderActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_discount import (
            ProductDiscountChangeSortOrderActionSchema,
        )

        return ProductDiscountChangeSortOrderActionSchema().dump(self)


class ProductDiscountChangeValueAction(ProductDiscountUpdateAction):
    #: New value to set. Must not be empty.
    value: "ProductDiscountValueDraft"

    def __init__(self, *, value: "ProductDiscountValueDraft"):
        self.value = value

        super().__init__(action="changeValue")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductDiscountChangeValueAction":
        from ._schemas.product_discount import ProductDiscountChangeValueActionSchema

        return ProductDiscountChangeValueActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_discount import ProductDiscountChangeValueActionSchema

        return ProductDiscountChangeValueActionSchema().dump(self)


class ProductDiscountSetDescriptionAction(ProductDiscountUpdateAction):
    #: Value to set. If empty, any existing value will be removed.
    description: typing.Optional["LocalizedString"]

    def __init__(self, *, description: typing.Optional["LocalizedString"] = None):
        self.description = description

        super().__init__(action="setDescription")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductDiscountSetDescriptionAction":
        from ._schemas.product_discount import ProductDiscountSetDescriptionActionSchema

        return ProductDiscountSetDescriptionActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_discount import ProductDiscountSetDescriptionActionSchema

        return ProductDiscountSetDescriptionActionSchema().dump(self)


class ProductDiscountSetKeyAction(ProductDiscountUpdateAction):
    #: Value to set. If empty, any existing value will be removed.
    key: typing.Optional[str]

    def __init__(self, *, key: typing.Optional[str] = None):
        self.key = key

        super().__init__(action="setKey")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductDiscountSetKeyAction":
        from ._schemas.product_discount import ProductDiscountSetKeyActionSchema

        return ProductDiscountSetKeyActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_discount import ProductDiscountSetKeyActionSchema

        return ProductDiscountSetKeyActionSchema().dump(self)


class ProductDiscountSetValidFromAction(ProductDiscountUpdateAction):
    #: Value to set.
    #: If empty, any existing value will be removed.
    #: Take [Eventual Consistency](/../api/general-concepts#eventual-consistency) into account for calculated discount values.
    valid_from: typing.Optional[datetime.datetime]

    def __init__(self, *, valid_from: typing.Optional[datetime.datetime] = None):
        self.valid_from = valid_from

        super().__init__(action="setValidFrom")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductDiscountSetValidFromAction":
        from ._schemas.product_discount import ProductDiscountSetValidFromActionSchema

        return ProductDiscountSetValidFromActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_discount import ProductDiscountSetValidFromActionSchema

        return ProductDiscountSetValidFromActionSchema().dump(self)


class ProductDiscountSetValidFromAndUntilAction(ProductDiscountUpdateAction):
    #: Value to set.
    #: Take [Eventual Consistency](/../api/general-concepts#eventual-consistency) into account for calculated undiscounted values.
    valid_from: typing.Optional[datetime.datetime]
    #: Value to set.
    #: Take [Eventual Consistency](/../api/general-concepts#eventual-consistency) into account for calculated undiscounted values.
    valid_until: typing.Optional[datetime.datetime]

    def __init__(
        self,
        *,
        valid_from: typing.Optional[datetime.datetime] = None,
        valid_until: typing.Optional[datetime.datetime] = None
    ):
        self.valid_from = valid_from
        self.valid_until = valid_until

        super().__init__(action="setValidFromAndUntil")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductDiscountSetValidFromAndUntilAction":
        from ._schemas.product_discount import (
            ProductDiscountSetValidFromAndUntilActionSchema,
        )

        return ProductDiscountSetValidFromAndUntilActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_discount import (
            ProductDiscountSetValidFromAndUntilActionSchema,
        )

        return ProductDiscountSetValidFromAndUntilActionSchema().dump(self)


class ProductDiscountSetValidUntilAction(ProductDiscountUpdateAction):
    #: Value to set.
    #: If empty, any existing value will be removed.
    #: Take [Eventual Consistency](/../api/general-concepts#eventual-consistency) into account for calculated undiscounted values.
    valid_until: typing.Optional[datetime.datetime]

    def __init__(self, *, valid_until: typing.Optional[datetime.datetime] = None):
        self.valid_until = valid_until

        super().__init__(action="setValidUntil")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductDiscountSetValidUntilAction":
        from ._schemas.product_discount import ProductDiscountSetValidUntilActionSchema

        return ProductDiscountSetValidUntilActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_discount import ProductDiscountSetValidUntilActionSchema

        return ProductDiscountSetValidUntilActionSchema().dump(self)
