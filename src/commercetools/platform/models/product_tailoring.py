# This file is automatically generated by the rmf-codegen project.
#
# The Python code generator is maintained by Lab Digital. If you want to
# contribute to this project then please do not edit this file directly
# but send a pull request to the Lab Digital fork of rmf-codegen at
# https://github.com/labd/rmf-codegen

import datetime
import enum
import typing

from ._abstract import _BaseType
from .common import BaseResource, Reference, ReferenceTypeId, ResourceIdentifier

if typing.TYPE_CHECKING:
    from .common import CreatedBy, LastModifiedBy, LocalizedString, ReferenceTypeId
    from .product import ProductReference, ProductResourceIdentifier
    from .store import StoreKeyReference, StoreResourceIdentifier

__all__ = [
    "ProductTailoring",
    "ProductTailoringData",
    "ProductTailoringDraft",
    "ProductTailoringInStoreDraft",
    "ProductTailoringPagedQueryResponse",
    "ProductTailoringPublishAction",
    "ProductTailoringReference",
    "ProductTailoringResourceIdentifier",
    "ProductTailoringSetDescriptionAction",
    "ProductTailoringSetMetaAttributesAction",
    "ProductTailoringSetMetaDescriptionAction",
    "ProductTailoringSetMetaKeywordsAction",
    "ProductTailoringSetMetaTitleAction",
    "ProductTailoringSetNameAction",
    "ProductTailoringSetSlugAction",
    "ProductTailoringUnpublishAction",
    "ProductTailoringUpdateAction",
]


class ProductTailoring(BaseResource):
    """A single ProductTailoring representation contains the _current_ and the _staged_ representation of its product data tailored per Store."""

    #: IDs and references that last modified the ProductTailoring.
    last_modified_by: typing.Optional["LastModifiedBy"]
    #: IDs and references that created the ProductTailoring.
    created_by: typing.Optional["CreatedBy"]
    #: User-defined unique identifier of the ProductTailoring.
    key: typing.Optional[str]
    #: The Store to which the ProductTailoring belongs.
    store: "StoreKeyReference"
    #: Reference to the Product the ProductTailoring belongs to.
    product: "ProductReference"
    #: `true` if the ProductTailoring is published.
    published: bool
    #: Current (published) data of the ProductTailoring.
    current: "ProductTailoringData"
    #: Staged (unpublished) data of the ProductTailoring.
    staged: "ProductTailoringData"
    #: `true` if the `staged` data is different from the `current` data.
    has_staged_changes: bool

    def __init__(
        self,
        *,
        id: str,
        version: int,
        created_at: datetime.datetime,
        last_modified_at: datetime.datetime,
        last_modified_by: typing.Optional["LastModifiedBy"] = None,
        created_by: typing.Optional["CreatedBy"] = None,
        key: typing.Optional[str] = None,
        store: "StoreKeyReference",
        product: "ProductReference",
        published: bool,
        current: "ProductTailoringData",
        staged: "ProductTailoringData",
        has_staged_changes: bool
    ):
        self.last_modified_by = last_modified_by
        self.created_by = created_by
        self.key = key
        self.store = store
        self.product = product
        self.published = published
        self.current = current
        self.staged = staged
        self.has_staged_changes = has_staged_changes

        super().__init__(
            id=id,
            version=version,
            created_at=created_at,
            last_modified_at=last_modified_at,
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ProductTailoring":
        from ._schemas.product_tailoring import ProductTailoringSchema

        return ProductTailoringSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_tailoring import ProductTailoringSchema

        return ProductTailoringSchema().dump(self)


class ProductTailoringData(_BaseType):
    """Contains all the tailored data of a Product."""

    #: Tailored name of the Product.
    name: typing.Optional["LocalizedString"]
    #: Tailored description of the Product.
    description: typing.Optional["LocalizedString"]
    #: Tailored title of the Product used by external search engines for improved search engine performance.
    meta_title: typing.Optional["LocalizedString"]
    #: Tailored description of the Product used by external search engines for improved search engine performance.
    meta_description: typing.Optional["LocalizedString"]
    #: Tailored keywords related to the Product used by external search engines for improved search engine performance.
    meta_keywords: typing.Optional["LocalizedString"]
    #: User-defined identifier used in a deep-link URL for the ProductTailoring.
    #: Matches the pattern `[a-zA-Z0-9_\\-]{2,256}`.
    slug: typing.Optional["LocalizedString"]

    def __init__(
        self,
        *,
        name: typing.Optional["LocalizedString"] = None,
        description: typing.Optional["LocalizedString"] = None,
        meta_title: typing.Optional["LocalizedString"] = None,
        meta_description: typing.Optional["LocalizedString"] = None,
        meta_keywords: typing.Optional["LocalizedString"] = None,
        slug: typing.Optional["LocalizedString"] = None
    ):
        self.name = name
        self.description = description
        self.meta_title = meta_title
        self.meta_description = meta_description
        self.meta_keywords = meta_keywords
        self.slug = slug

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ProductTailoringData":
        from ._schemas.product_tailoring import ProductTailoringDataSchema

        return ProductTailoringDataSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_tailoring import ProductTailoringDataSchema

        return ProductTailoringDataSchema().dump(self)


class ProductTailoringDraft(_BaseType):
    """Contains all the tailored data of a Product."""

    #: User-defined unique identifier of the ProductTailoring.
    key: typing.Optional[str]
    #: The Store to which the ProductTailoring belongs.
    store: "StoreResourceIdentifier"
    #: ResourceIdentifier of the Product the ProductTailoring belongs to.
    product: "ProductResourceIdentifier"
    #: Tailored name of the Product.
    name: typing.Optional["LocalizedString"]
    #: Tailored description of the Product.
    description: typing.Optional["LocalizedString"]
    #: Tailored title of the Product used by external search engines for improved search engine performance.
    meta_title: typing.Optional["LocalizedString"]
    #: Tailored description of the Product used by external search engines for improved search engine performance.
    meta_description: typing.Optional["LocalizedString"]
    #: Tailored keywords related to the Product used by external search engines for improved search engine performance.
    meta_keywords: typing.Optional["LocalizedString"]
    #: User-defined identifier used in a deep-link URL for the ProductTailoring.
    #: Matches the pattern `[a-zA-Z0-9_\\-]{2,256}`.
    slug: typing.Optional["LocalizedString"]
    #: If `true`, the ProductTailoring is published immediately.
    publish: typing.Optional[bool]

    def __init__(
        self,
        *,
        key: typing.Optional[str] = None,
        store: "StoreResourceIdentifier",
        product: "ProductResourceIdentifier",
        name: typing.Optional["LocalizedString"] = None,
        description: typing.Optional["LocalizedString"] = None,
        meta_title: typing.Optional["LocalizedString"] = None,
        meta_description: typing.Optional["LocalizedString"] = None,
        meta_keywords: typing.Optional["LocalizedString"] = None,
        slug: typing.Optional["LocalizedString"] = None,
        publish: typing.Optional[bool] = None
    ):
        self.key = key
        self.store = store
        self.product = product
        self.name = name
        self.description = description
        self.meta_title = meta_title
        self.meta_description = meta_description
        self.meta_keywords = meta_keywords
        self.slug = slug
        self.publish = publish

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ProductTailoringDraft":
        from ._schemas.product_tailoring import ProductTailoringDraftSchema

        return ProductTailoringDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_tailoring import ProductTailoringDraftSchema

        return ProductTailoringDraftSchema().dump(self)


class ProductTailoringInStoreDraft(_BaseType):
    """Contains all the tailored data of a Product for a specific Store."""

    #: User-defined unique identifier of the ProductTailoring.
    key: typing.Optional[str]
    #: ResourceIdentifier of the Product the ProductTailoring belongs to.
    product: "ProductResourceIdentifier"
    #: Tailored name of the Product.
    name: typing.Optional["LocalizedString"]
    #: Tailored description of the Product.
    description: typing.Optional["LocalizedString"]
    #: Tailored title of the Product used by external search engines for improved search engine performance.
    meta_title: typing.Optional["LocalizedString"]
    #: Tailored description of the Product used by external search engines for improved search engine performance.
    meta_description: typing.Optional["LocalizedString"]
    #: Tailored keywords related to the Product used by external search engines for improved search engine performance.
    meta_keywords: typing.Optional["LocalizedString"]
    #: User-defined identifier used in a deep-link URL for the ProductTailoring.
    #: Matches the pattern `[a-zA-Z0-9_\\-]{2,256}`.
    slug: typing.Optional["LocalizedString"]
    #: If `true`, the ProductTailoring is published immediately.
    publish: typing.Optional[bool]

    def __init__(
        self,
        *,
        key: typing.Optional[str] = None,
        product: "ProductResourceIdentifier",
        name: typing.Optional["LocalizedString"] = None,
        description: typing.Optional["LocalizedString"] = None,
        meta_title: typing.Optional["LocalizedString"] = None,
        meta_description: typing.Optional["LocalizedString"] = None,
        meta_keywords: typing.Optional["LocalizedString"] = None,
        slug: typing.Optional["LocalizedString"] = None,
        publish: typing.Optional[bool] = None
    ):
        self.key = key
        self.product = product
        self.name = name
        self.description = description
        self.meta_title = meta_title
        self.meta_description = meta_description
        self.meta_keywords = meta_keywords
        self.slug = slug
        self.publish = publish

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTailoringInStoreDraft":
        from ._schemas.product_tailoring import ProductTailoringInStoreDraftSchema

        return ProductTailoringInStoreDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_tailoring import ProductTailoringInStoreDraftSchema

        return ProductTailoringInStoreDraftSchema().dump(self)


class ProductTailoringPagedQueryResponse(_BaseType):
    """[PagedQueryResult](/../api/general-concepts#pagedqueryresult) with results containing an array of [ProductTailoring](ctp:api:type:ProductTailoring)."""

    #: Number of [results requested](/../api/general-concepts#limit).
    limit: int
    #: Number of [elements skipped](/../api/general-concepts#offset).
    offset: int
    #: Actual number of results returned.
    count: int
    #: Total number of results matching the query.
    #: This number is an estimation that is not [strongly consistent](/../api/general-concepts#strong-consistency).
    #: This field is returned by default.
    #: For improved performance, calculating this field can be deactivated by using the query parameter `withTotal=false`.
    #: When the results are filtered with a [Query Predicate](/../api/predicates/query), `total` is subject to a [limit](/../api/limits#queries).
    total: typing.Optional[int]
    #: [ProductTailoring](ctp:api:type:ProductTailoring) list matching the query.
    results: typing.List["ProductTailoring"]

    def __init__(
        self,
        *,
        limit: int,
        offset: int,
        count: int,
        total: typing.Optional[int] = None,
        results: typing.List["ProductTailoring"]
    ):
        self.limit = limit
        self.offset = offset
        self.count = count
        self.total = total
        self.results = results

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTailoringPagedQueryResponse":
        from ._schemas.product_tailoring import ProductTailoringPagedQueryResponseSchema

        return ProductTailoringPagedQueryResponseSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_tailoring import ProductTailoringPagedQueryResponseSchema

        return ProductTailoringPagedQueryResponseSchema().dump(self)


class ProductTailoringReference(Reference):
    """[Reference](ctp:api:type:Reference) to a [ProductTailoring](ctp:api:type:ProductTailoring)."""

    #: Contains the representation of the expanded ProductTailoring. Only present in responses to requests with [Reference Expansion](/../api/general-concepts#reference-expansion) for ProductTailoring.
    obj: typing.Optional["ProductTailoring"]

    def __init__(self, *, id: str, obj: typing.Optional["ProductTailoring"] = None):
        self.obj = obj

        super().__init__(id=id, type_id=ReferenceTypeId.PRODUCT_TAILORING)

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTailoringReference":
        from ._schemas.product_tailoring import ProductTailoringReferenceSchema

        return ProductTailoringReferenceSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_tailoring import ProductTailoringReferenceSchema

        return ProductTailoringReferenceSchema().dump(self)


class ProductTailoringResourceIdentifier(ResourceIdentifier):
    """[ResourceIdentifier](ctp:api:type:ResourceIdentifier) to a [ProductTailoring](ctp:api:type:ProductTailoring)."""

    def __init__(
        self, *, id: typing.Optional[str] = None, key: typing.Optional[str] = None
    ):

        super().__init__(id=id, key=key, type_id=ReferenceTypeId.PRODUCT_TAILORING)

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTailoringResourceIdentifier":
        from ._schemas.product_tailoring import ProductTailoringResourceIdentifierSchema

        return ProductTailoringResourceIdentifierSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_tailoring import ProductTailoringResourceIdentifierSchema

        return ProductTailoringResourceIdentifierSchema().dump(self)


class ProductTailoringUpdateAction(_BaseType):
    action: str

    def __init__(self, *, action: str):
        self.action = action

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTailoringUpdateAction":
        if data["action"] == "publish":
            from ._schemas.product_tailoring import ProductTailoringPublishActionSchema

            return ProductTailoringPublishActionSchema().load(data)
        if data["action"] == "setDescription":
            from ._schemas.product_tailoring import (
                ProductTailoringSetDescriptionActionSchema,
            )

            return ProductTailoringSetDescriptionActionSchema().load(data)
        if data["action"] == "setMetaAttributes":
            from ._schemas.product_tailoring import (
                ProductTailoringSetMetaAttributesActionSchema,
            )

            return ProductTailoringSetMetaAttributesActionSchema().load(data)
        if data["action"] == "setMetaDescription":
            from ._schemas.product_tailoring import (
                ProductTailoringSetMetaDescriptionActionSchema,
            )

            return ProductTailoringSetMetaDescriptionActionSchema().load(data)
        if data["action"] == "setMetaKeywords":
            from ._schemas.product_tailoring import (
                ProductTailoringSetMetaKeywordsActionSchema,
            )

            return ProductTailoringSetMetaKeywordsActionSchema().load(data)
        if data["action"] == "setMetaTitle":
            from ._schemas.product_tailoring import (
                ProductTailoringSetMetaTitleActionSchema,
            )

            return ProductTailoringSetMetaTitleActionSchema().load(data)
        if data["action"] == "setName":
            from ._schemas.product_tailoring import ProductTailoringSetNameActionSchema

            return ProductTailoringSetNameActionSchema().load(data)
        if data["action"] == "setSlug":
            from ._schemas.product_tailoring import ProductTailoringSetSlugActionSchema

            return ProductTailoringSetSlugActionSchema().load(data)
        if data["action"] == "unpublish":
            from ._schemas.product_tailoring import (
                ProductTailoringUnpublishActionSchema,
            )

            return ProductTailoringUnpublishActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_tailoring import ProductTailoringUpdateActionSchema

        return ProductTailoringUpdateActionSchema().dump(self)


class ProductTailoringPublishAction(ProductTailoringUpdateAction):
    """Publishes the `staged` data of the ProductTailoring to `current`. Sets `hasStagedChanges` to `false`.
    Generates the [ProductTailoringPublished](ctp:api:type:ProductTailoringPublishedMessage) Message.

    """

    def __init__(self):

        super().__init__(action="publish")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTailoringPublishAction":
        from ._schemas.product_tailoring import ProductTailoringPublishActionSchema

        return ProductTailoringPublishActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_tailoring import ProductTailoringPublishActionSchema

        return ProductTailoringPublishActionSchema().dump(self)


class ProductTailoringSetDescriptionAction(ProductTailoringUpdateAction):
    """Generates the [ProductTailoringDescriptionSet](ctp:api:type:ProductTailoringDescriptionSetMessage) Message."""

    #: Value to set. If empty, any existing value will be removed.
    description: typing.Optional["LocalizedString"]
    #: If `true`, only the staged `description` is updated. If `false`, both the current and staged `description` are updated.
    staged: typing.Optional[bool]

    def __init__(
        self,
        *,
        description: typing.Optional["LocalizedString"] = None,
        staged: typing.Optional[bool] = None
    ):
        self.description = description
        self.staged = staged

        super().__init__(action="setDescription")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTailoringSetDescriptionAction":
        from ._schemas.product_tailoring import (
            ProductTailoringSetDescriptionActionSchema,
        )

        return ProductTailoringSetDescriptionActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_tailoring import (
            ProductTailoringSetDescriptionActionSchema,
        )

        return ProductTailoringSetDescriptionActionSchema().dump(self)


class ProductTailoringSetMetaAttributesAction(ProductTailoringUpdateAction):
    """Updates all meta attributes at the same time."""

    #: Value to set. If empty, any existing value will be removed.
    meta_title: typing.Optional["LocalizedString"]
    #: Value to set. If empty, any existing value will be removed.
    meta_description: typing.Optional["LocalizedString"]
    #: Value to set. If empty, any existing value will be removed.
    meta_keywords: typing.Optional["LocalizedString"]
    #: If `true`, only the staged attributes are updated. If `false`, both the current and staged attributes are updated.
    staged: typing.Optional[bool]

    def __init__(
        self,
        *,
        meta_title: typing.Optional["LocalizedString"] = None,
        meta_description: typing.Optional["LocalizedString"] = None,
        meta_keywords: typing.Optional["LocalizedString"] = None,
        staged: typing.Optional[bool] = None
    ):
        self.meta_title = meta_title
        self.meta_description = meta_description
        self.meta_keywords = meta_keywords
        self.staged = staged

        super().__init__(action="setMetaAttributes")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTailoringSetMetaAttributesAction":
        from ._schemas.product_tailoring import (
            ProductTailoringSetMetaAttributesActionSchema,
        )

        return ProductTailoringSetMetaAttributesActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_tailoring import (
            ProductTailoringSetMetaAttributesActionSchema,
        )

        return ProductTailoringSetMetaAttributesActionSchema().dump(self)


class ProductTailoringSetMetaDescriptionAction(ProductTailoringUpdateAction):
    #: Value to set. If empty, any existing value will be removed.
    meta_description: typing.Optional["LocalizedString"]
    #: If `true`, only the staged `metaDescription` is updated. If `false`, both the current and staged `metaDescription` are updated.
    staged: typing.Optional[bool]

    def __init__(
        self,
        *,
        meta_description: typing.Optional["LocalizedString"] = None,
        staged: typing.Optional[bool] = None
    ):
        self.meta_description = meta_description
        self.staged = staged

        super().__init__(action="setMetaDescription")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTailoringSetMetaDescriptionAction":
        from ._schemas.product_tailoring import (
            ProductTailoringSetMetaDescriptionActionSchema,
        )

        return ProductTailoringSetMetaDescriptionActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_tailoring import (
            ProductTailoringSetMetaDescriptionActionSchema,
        )

        return ProductTailoringSetMetaDescriptionActionSchema().dump(self)


class ProductTailoringSetMetaKeywordsAction(ProductTailoringUpdateAction):
    #: Value to set. If empty, any existing value will be removed.
    meta_keywords: typing.Optional["LocalizedString"]
    #: If `true`, only the staged `metaKeywords` is updated. If `false`, both the current and staged `metaKeywords` are updated.
    staged: typing.Optional[bool]

    def __init__(
        self,
        *,
        meta_keywords: typing.Optional["LocalizedString"] = None,
        staged: typing.Optional[bool] = None
    ):
        self.meta_keywords = meta_keywords
        self.staged = staged

        super().__init__(action="setMetaKeywords")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTailoringSetMetaKeywordsAction":
        from ._schemas.product_tailoring import (
            ProductTailoringSetMetaKeywordsActionSchema,
        )

        return ProductTailoringSetMetaKeywordsActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_tailoring import (
            ProductTailoringSetMetaKeywordsActionSchema,
        )

        return ProductTailoringSetMetaKeywordsActionSchema().dump(self)


class ProductTailoringSetMetaTitleAction(ProductTailoringUpdateAction):
    #: Value to set. If empty, any existing value will be removed.
    meta_title: typing.Optional["LocalizedString"]
    #: If `true`, only the staged `metaTitle` is updated. If `false`, both the current and staged `metaTitle` are updated.
    staged: typing.Optional[bool]

    def __init__(
        self,
        *,
        meta_title: typing.Optional["LocalizedString"] = None,
        staged: typing.Optional[bool] = None
    ):
        self.meta_title = meta_title
        self.staged = staged

        super().__init__(action="setMetaTitle")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTailoringSetMetaTitleAction":
        from ._schemas.product_tailoring import ProductTailoringSetMetaTitleActionSchema

        return ProductTailoringSetMetaTitleActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_tailoring import ProductTailoringSetMetaTitleActionSchema

        return ProductTailoringSetMetaTitleActionSchema().dump(self)


class ProductTailoringSetNameAction(ProductTailoringUpdateAction):
    """Generates the [ProductTailoringNameSet](ctp:api:type:ProductTailoringNameSetMessage) Message."""

    #: Value to set. If empty, any existing value will be removed.
    name: typing.Optional["LocalizedString"]
    #: If `true`, only the staged `name` is updated. If `false`, both the current and staged `name` are updated.
    staged: typing.Optional[bool]

    def __init__(
        self,
        *,
        name: typing.Optional["LocalizedString"] = None,
        staged: typing.Optional[bool] = None
    ):
        self.name = name
        self.staged = staged

        super().__init__(action="setName")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTailoringSetNameAction":
        from ._schemas.product_tailoring import ProductTailoringSetNameActionSchema

        return ProductTailoringSetNameActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_tailoring import ProductTailoringSetNameActionSchema

        return ProductTailoringSetNameActionSchema().dump(self)


class ProductTailoringSetSlugAction(ProductTailoringUpdateAction):
    """Generates the [ProductTailoringSlugSet](ctp:api:type:ProductTailoringSlugSetMessage) Message."""

    #: Value to set. If empty, any existing value will be removed.
    slug: typing.Optional["LocalizedString"]
    #: If `true`, only the staged `slug` is updated. If `false`, both the current and staged `slug` are updated.
    staged: typing.Optional[bool]

    def __init__(
        self,
        *,
        slug: typing.Optional["LocalizedString"] = None,
        staged: typing.Optional[bool] = None
    ):
        self.slug = slug
        self.staged = staged

        super().__init__(action="setSlug")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTailoringSetSlugAction":
        from ._schemas.product_tailoring import ProductTailoringSetSlugActionSchema

        return ProductTailoringSetSlugActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_tailoring import ProductTailoringSetSlugActionSchema

        return ProductTailoringSetSlugActionSchema().dump(self)


class ProductTailoringUnpublishAction(ProductTailoringUpdateAction):
    """Unpublishes the `current` data of the ProductTailoring. Sets the `published` field to `false`.
    Generates the [ProductTailoringUnpublished](ctp:api:type:ProductTailoringUnpublishedMessage) Message.

    """

    def __init__(self):

        super().__init__(action="unpublish")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTailoringUnpublishAction":
        from ._schemas.product_tailoring import ProductTailoringUnpublishActionSchema

        return ProductTailoringUnpublishActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_tailoring import ProductTailoringUnpublishActionSchema

        return ProductTailoringUnpublishActionSchema().dump(self)
