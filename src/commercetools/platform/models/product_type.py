# This file is automatically generated by the rmf-codegen project.
#
# The Python code generator is maintained by Lab Digital. If you want to
# contribute to this project then please do not edit this file directly
# but send a pull request to the Lab Digital fork of rmf-codegen at
# https://github.com/labd/rmf-codegen

import datetime
import enum
import typing

from ._abstract import _BaseType
from .common import BaseResource, Reference, ReferenceTypeId, ResourceIdentifier

if typing.TYPE_CHECKING:
    from .common import CreatedBy, LastModifiedBy, LocalizedString, ReferenceTypeId

__all__ = [
    "AttributeBooleanType",
    "AttributeConstraintEnum",
    "AttributeConstraintEnumDraft",
    "AttributeDateTimeType",
    "AttributeDateType",
    "AttributeDefinition",
    "AttributeDefinitionDraft",
    "AttributeEnumType",
    "AttributeLocalizableTextType",
    "AttributeLocalizedEnumType",
    "AttributeLocalizedEnumValue",
    "AttributeMoneyType",
    "AttributeNestedType",
    "AttributeNumberType",
    "AttributePlainEnumValue",
    "AttributeReferenceType",
    "AttributeReferenceTypeId",
    "AttributeSetType",
    "AttributeTextType",
    "AttributeTimeType",
    "AttributeType",
    "ProductType",
    "ProductTypeAddAttributeDefinitionAction",
    "ProductTypeAddLocalizedEnumValueAction",
    "ProductTypeAddPlainEnumValueAction",
    "ProductTypeChangeAttributeConstraintAction",
    "ProductTypeChangeAttributeNameAction",
    "ProductTypeChangeAttributeOrderAction",
    "ProductTypeChangeAttributeOrderByNameAction",
    "ProductTypeChangeDescriptionAction",
    "ProductTypeChangeEnumKeyAction",
    "ProductTypeChangeInputHintAction",
    "ProductTypeChangeIsSearchableAction",
    "ProductTypeChangeLabelAction",
    "ProductTypeChangeLocalizedEnumValueLabelAction",
    "ProductTypeChangeLocalizedEnumValueOrderAction",
    "ProductTypeChangeNameAction",
    "ProductTypeChangePlainEnumValueLabelAction",
    "ProductTypeChangePlainEnumValueOrderAction",
    "ProductTypeDraft",
    "ProductTypePagedQueryResponse",
    "ProductTypeReference",
    "ProductTypeRemoveAttributeDefinitionAction",
    "ProductTypeRemoveEnumValuesAction",
    "ProductTypeResourceIdentifier",
    "ProductTypeSetInputTipAction",
    "ProductTypeSetKeyAction",
    "ProductTypeUpdate",
    "ProductTypeUpdateAction",
    "TextInputHint",
]


class AttributeConstraintEnum(enum.Enum):
    """Specifies how an Attribute (or a set of Attributes) should be validated across all variants of a Product:"""

    NONE = "None"
    UNIQUE = "Unique"
    COMBINATION_UNIQUE = "CombinationUnique"
    SAME_FOR_ALL = "SameForAll"


class AttributeConstraintEnumDraft(enum.Enum):
    NONE = "None"


class AttributeDefinition(_BaseType):
    """Describes a Product Attribute and allows you to define meta-information associated with the Attribute (like whether it should be searchable, or its constraints)."""

    #: Describes the Type of the Attribute.
    type: "AttributeType"
    #: User-defined name of the Attribute that is unique within the [Project](ctp:api:type:Project).
    name: str
    #: Human-readable label for the Attribute.
    label: "LocalizedString"
    #: If `true`, the Attribute must have a value on a [ProductVariant](ctp:api:type:ProductVariant).
    is_required: bool
    #: Specifies how Attributes are validated across all variants of a Product.
    attribute_constraint: "AttributeConstraintEnum"
    #: Provides additional Attribute information to aid content managers configure Product details.
    input_tip: typing.Optional["LocalizedString"]
    #: Provides a visual representation directive for values of this Attribute (only relevant for [AttributeTextType](ctp:api:type:AttributeTextType) and [AttributeLocalizableTextType](ctp:api:type:AttributeLocalizableTextType)).
    input_hint: "TextInputHint"
    #: If `true`, the Attribute's values are available for the [Product Projections Search API](/../api/projects/products-search) for use in full-text search queries, filters, and facets.
    #:
    #: Which exact features are available with this flag depends on the specific [AttributeType](ctp:api:type:AttributeType).
    #: The maximum size of a searchable field is **restricted** by the [Field content size limit](/../api/limits#field-content-size).
    #: This constraint is enforced at both [Product creation](/../api/projects/products#create-product) and [Product update](/../api/projects/products#update-product).
    #: If the length of the input exceeds the maximum size, an [InvalidField](ctp:api:type:InvalidFieldError) error is returned.
    is_searchable: bool

    def __init__(
        self,
        *,
        type: "AttributeType",
        name: str,
        label: "LocalizedString",
        is_required: bool,
        attribute_constraint: "AttributeConstraintEnum",
        input_tip: typing.Optional["LocalizedString"] = None,
        input_hint: "TextInputHint",
        is_searchable: bool
    ):
        self.type = type
        self.name = name
        self.label = label
        self.is_required = is_required
        self.attribute_constraint = attribute_constraint
        self.input_tip = input_tip
        self.input_hint = input_hint
        self.is_searchable = is_searchable

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "AttributeDefinition":
        from ._schemas.product_type import AttributeDefinitionSchema

        return AttributeDefinitionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_type import AttributeDefinitionSchema

        return AttributeDefinitionSchema().dump(self)


class AttributeDefinitionDraft(_BaseType):
    """Specify the Attribute to be created with the [ProductTypeDraft](ctp:api:type:ProductTypeDraft)."""

    #: Describes the Type of the Attribute.
    #:
    #: When the `type` is different for an AttributeDefinition using the same name in multiple ProductTypes, an [AttributeDefinitionTypeConflict](ctp:api:type:AttributeDefinitionTypeConflictError) error is returned.
    type: "AttributeType"
    #: User-defined name of the Attribute that is unique with the [Project](ctp:api:type:Project).
    #:
    #: When using the same `name` for an Attribute in multiple ProductTypes, all fields of the AttributeDefinition of this Attribute must be the same across the ProductTypes, else an [AttributeDefinitionAlreadyExists](ctp:api:type:AttributeDefinitionAlreadyExistsError) error is returned.
    #: An exception to this are the values of an `enum` or `lenum` Type and sets thereof.
    name: str
    #: Human-readable label for the Attribute.
    label: "LocalizedString"
    #: Set to `true` if the Attribute is required to have a value on a [ProductVariant](ctp:api:type:ProductVariant).
    is_required: bool
    #: Specifies how an Attribute or a combination of Attributes should be validated across all variants of a Product.
    attribute_constraint: typing.Optional["AttributeConstraintEnum"]
    #: Provides additional information about the Attribute that aids content managers when setting Product details.
    input_tip: typing.Optional["LocalizedString"]
    #: Provides a visual representation directive for values of this Attribute (only relevant for [AttributeTextType](ctp:api:type:AttributeTextType) and [AttributeLocalizableTextType](ctp:api:type:AttributeLocalizableTextType)).
    input_hint: typing.Optional["TextInputHint"]
    #: Set to `true` if the Attribute's values should be available in the [Product Projections Search API](/../api/projects/products-search) and can be used in full-text search queries, filters, and facets.
    #: Which exact features are available with this flag depends on the specific [AttributeType](ctp:api:type:AttributeType).
    #: The maximum size of a searchable field is **restricted** by the [Field content size limit](/../api/limits#field-content-size).
    #: This constraint is enforced at both Product creation and Product update.
    #: If the length of the input exceeds the maximum size, an InvalidField error is returned.
    is_searchable: typing.Optional[bool]

    def __init__(
        self,
        *,
        type: "AttributeType",
        name: str,
        label: "LocalizedString",
        is_required: bool,
        attribute_constraint: typing.Optional["AttributeConstraintEnum"] = None,
        input_tip: typing.Optional["LocalizedString"] = None,
        input_hint: typing.Optional["TextInputHint"] = None,
        is_searchable: typing.Optional[bool] = None
    ):
        self.type = type
        self.name = name
        self.label = label
        self.is_required = is_required
        self.attribute_constraint = attribute_constraint
        self.input_tip = input_tip
        self.input_hint = input_hint
        self.is_searchable = is_searchable

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "AttributeDefinitionDraft":
        from ._schemas.product_type import AttributeDefinitionDraftSchema

        return AttributeDefinitionDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_type import AttributeDefinitionDraftSchema

        return AttributeDefinitionDraftSchema().dump(self)


class AttributeLocalizedEnumValue(_BaseType):
    """A localized enum value must be unique within the enum, else a [DuplicateEnumValues](ctp:api:type:DuplicateEnumValuesError) error is returned."""

    #: Key of the value used as a programmatic identifier, for example in facets & filters.
    key: str
    #: Descriptive, localized label of the value.
    label: "LocalizedString"

    def __init__(self, *, key: str, label: "LocalizedString"):
        self.key = key
        self.label = label

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "AttributeLocalizedEnumValue":
        from ._schemas.product_type import AttributeLocalizedEnumValueSchema

        return AttributeLocalizedEnumValueSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_type import AttributeLocalizedEnumValueSchema

        return AttributeLocalizedEnumValueSchema().dump(self)


class AttributePlainEnumValue(_BaseType):
    """A plain enum value must be unique within the enum, else a [DuplicateEnumValues](ctp:api:types:DuplicateEnumValuesError) error is returned."""

    #: Key of the value used as a programmatic identifier, for example in facets & filters.
    key: str
    #: Descriptive label of the value.
    label: str

    def __init__(self, *, key: str, label: str):
        self.key = key
        self.label = label

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "AttributePlainEnumValue":
        from ._schemas.product_type import AttributePlainEnumValueSchema

        return AttributePlainEnumValueSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_type import AttributePlainEnumValueSchema

        return AttributePlainEnumValueSchema().dump(self)


class AttributeReferenceTypeId(enum.Enum):
    """Name of the resource type that the value should reference. Supported resource type identifiers:"""

    CART = "cart"
    CATEGORY = "category"
    CHANNEL = "channel"
    CUSTOMER = "customer"
    KEY_VALUE_DOCUMENT = "key-value-document"
    ORDER = "order"
    PRODUCT = "product"
    PRODUCT_TYPE = "product-type"
    REVIEW = "review"
    SHIPPING_METHOD = "shipping-method"
    STATE = "state"
    ZONE = "zone"


class AttributeType(_BaseType):
    """Umbrella type for specific attribute types discriminated by property `name`."""

    name: str

    def __init__(self, *, name: str):
        self.name = name

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "AttributeType":
        if data["name"] == "boolean":
            from ._schemas.product_type import AttributeBooleanTypeSchema

            return AttributeBooleanTypeSchema().load(data)
        if data["name"] == "datetime":
            from ._schemas.product_type import AttributeDateTimeTypeSchema

            return AttributeDateTimeTypeSchema().load(data)
        if data["name"] == "date":
            from ._schemas.product_type import AttributeDateTypeSchema

            return AttributeDateTypeSchema().load(data)
        if data["name"] == "enum":
            from ._schemas.product_type import AttributeEnumTypeSchema

            return AttributeEnumTypeSchema().load(data)
        if data["name"] == "ltext":
            from ._schemas.product_type import AttributeLocalizableTextTypeSchema

            return AttributeLocalizableTextTypeSchema().load(data)
        if data["name"] == "lenum":
            from ._schemas.product_type import AttributeLocalizedEnumTypeSchema

            return AttributeLocalizedEnumTypeSchema().load(data)
        if data["name"] == "money":
            from ._schemas.product_type import AttributeMoneyTypeSchema

            return AttributeMoneyTypeSchema().load(data)
        if data["name"] == "nested":
            from ._schemas.product_type import AttributeNestedTypeSchema

            return AttributeNestedTypeSchema().load(data)
        if data["name"] == "number":
            from ._schemas.product_type import AttributeNumberTypeSchema

            return AttributeNumberTypeSchema().load(data)
        if data["name"] == "reference":
            from ._schemas.product_type import AttributeReferenceTypeSchema

            return AttributeReferenceTypeSchema().load(data)
        if data["name"] == "set":
            from ._schemas.product_type import AttributeSetTypeSchema

            return AttributeSetTypeSchema().load(data)
        if data["name"] == "text":
            from ._schemas.product_type import AttributeTextTypeSchema

            return AttributeTextTypeSchema().load(data)
        if data["name"] == "time":
            from ._schemas.product_type import AttributeTimeTypeSchema

            return AttributeTimeTypeSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_type import AttributeTypeSchema

        return AttributeTypeSchema().dump(self)


class AttributeBooleanType(AttributeType):
    """Attribute type for Boolean values. Valid values for the Attribute are `true` and `false` (JSON Boolean)."""

    def __init__(self):
        super().__init__(name="boolean")

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "AttributeBooleanType":
        from ._schemas.product_type import AttributeBooleanTypeSchema

        return AttributeBooleanTypeSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_type import AttributeBooleanTypeSchema

        return AttributeBooleanTypeSchema().dump(self)


class AttributeDateTimeType(AttributeType):
    def __init__(self):
        super().__init__(name="datetime")

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "AttributeDateTimeType":
        from ._schemas.product_type import AttributeDateTimeTypeSchema

        return AttributeDateTimeTypeSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_type import AttributeDateTimeTypeSchema

        return AttributeDateTimeTypeSchema().dump(self)


class AttributeDateType(AttributeType):
    def __init__(self):
        super().__init__(name="date")

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "AttributeDateType":
        from ._schemas.product_type import AttributeDateTypeSchema

        return AttributeDateTypeSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_type import AttributeDateTypeSchema

        return AttributeDateTypeSchema().dump(self)


class AttributeEnumType(AttributeType):
    """Attribute type for plain enum values. Useful for predefined language-agnostic values selectable in drop downs when only one value should be selected. Use [AttributeSetType](ctp:api:type:AttributeSetType) of AttributeEnumType instead if multiple values can be selected from the list."""

    #: Available values that can be assigned to Products.
    values: typing.List["AttributePlainEnumValue"]

    def __init__(self, *, values: typing.List["AttributePlainEnumValue"]):
        self.values = values

        super().__init__(name="enum")

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "AttributeEnumType":
        from ._schemas.product_type import AttributeEnumTypeSchema

        return AttributeEnumTypeSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_type import AttributeEnumTypeSchema

        return AttributeEnumTypeSchema().dump(self)


class AttributeLocalizableTextType(AttributeType):
    """Attribute type for [LocalizedString](ctp:api:type:LocalizedString) values."""

    def __init__(self):
        super().__init__(name="ltext")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "AttributeLocalizableTextType":
        from ._schemas.product_type import AttributeLocalizableTextTypeSchema

        return AttributeLocalizableTextTypeSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_type import AttributeLocalizableTextTypeSchema

        return AttributeLocalizableTextTypeSchema().dump(self)


class AttributeLocalizedEnumType(AttributeType):
    """Attribute type for localized enum values. Useful for predefined language-specific values selectable in drop-down menus if only one value can be selected. Use [AttributeSetType](ctp:api:type:AttributeSetType) of AttributeLocalizedEnumValue instead if multiple values can be selected."""

    #: Available values that can be assigned to Products.
    values: typing.List["AttributeLocalizedEnumValue"]

    def __init__(self, *, values: typing.List["AttributeLocalizedEnumValue"]):
        self.values = values

        super().__init__(name="lenum")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "AttributeLocalizedEnumType":
        from ._schemas.product_type import AttributeLocalizedEnumTypeSchema

        return AttributeLocalizedEnumTypeSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_type import AttributeLocalizedEnumTypeSchema

        return AttributeLocalizedEnumTypeSchema().dump(self)


class AttributeMoneyType(AttributeType):
    def __init__(self):
        super().__init__(name="money")

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "AttributeMoneyType":
        from ._schemas.product_type import AttributeMoneyTypeSchema

        return AttributeMoneyTypeSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_type import AttributeMoneyTypeSchema

        return AttributeMoneyTypeSchema().dump(self)


class AttributeNestedType(AttributeType):
    """Attribute type for nesting Attributes based on some existing ProductType. It does not support `isSearchable` and is not supported in queries. The only supported AttributeConstraint is `None`."""

    #: Attributes that can be stored as nested Attributes of the current Attribute.
    type_reference: "ProductTypeReference"

    def __init__(self, *, type_reference: "ProductTypeReference"):
        self.type_reference = type_reference

        super().__init__(name="nested")

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "AttributeNestedType":
        from ._schemas.product_type import AttributeNestedTypeSchema

        return AttributeNestedTypeSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_type import AttributeNestedTypeSchema

        return AttributeNestedTypeSchema().dump(self)


class AttributeNumberType(AttributeType):
    def __init__(self):
        super().__init__(name="number")

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "AttributeNumberType":
        from ._schemas.product_type import AttributeNumberTypeSchema

        return AttributeNumberTypeSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_type import AttributeNumberTypeSchema

        return AttributeNumberTypeSchema().dump(self)


class AttributeReferenceType(AttributeType):
    #: Name of the resource type that the value should reference.
    reference_type_id: "AttributeReferenceTypeId"

    def __init__(self, *, reference_type_id: "AttributeReferenceTypeId"):
        self.reference_type_id = reference_type_id

        super().__init__(name="reference")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "AttributeReferenceType":
        from ._schemas.product_type import AttributeReferenceTypeSchema

        return AttributeReferenceTypeSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_type import AttributeReferenceTypeSchema

        return AttributeReferenceTypeSchema().dump(self)


class AttributeSetType(AttributeType):
    """AttributeType that defines a set (without duplicate elements) with values of the given `elementType`. It does not support `isRequired`. Since this type itself is an AttributeType, it is possible to construct an AttributeSetType of an AttributeSetType of any AttributeType, and to continue with this iteration until terminating with any non-AttributeSetType. In case the AttributeSetType iteration terminates with an [AttributeNestedType](ctp:api:type:AttributeNestedType), the iteration can have 5 steps at maximum."""

    #: Attribute type of the elements in the set.
    element_type: "AttributeType"

    def __init__(self, *, element_type: "AttributeType"):
        self.element_type = element_type

        super().__init__(name="set")

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "AttributeSetType":
        from ._schemas.product_type import AttributeSetTypeSchema

        return AttributeSetTypeSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_type import AttributeSetTypeSchema

        return AttributeSetTypeSchema().dump(self)


class AttributeTextType(AttributeType):
    """Attribute type for plain text values."""

    def __init__(self):
        super().__init__(name="text")

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "AttributeTextType":
        from ._schemas.product_type import AttributeTextTypeSchema

        return AttributeTextTypeSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_type import AttributeTextTypeSchema

        return AttributeTextTypeSchema().dump(self)


class AttributeTimeType(AttributeType):
    def __init__(self):
        super().__init__(name="time")

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "AttributeTimeType":
        from ._schemas.product_type import AttributeTimeTypeSchema

        return AttributeTimeTypeSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_type import AttributeTimeTypeSchema

        return AttributeTimeTypeSchema().dump(self)


class ProductType(BaseResource):
    #: Present on resources created after 1 February 2019 except for [events not tracked](/client-logging#events-tracked).
    last_modified_by: typing.Optional["LastModifiedBy"]
    #: Present on resources created after 1 February 2019 except for [events not tracked](/client-logging#events-tracked).
    created_by: typing.Optional["CreatedBy"]
    #: User-defined unique identifier of the ProductType.
    key: typing.Optional[str]
    #: Name of the ProductType.
    name: str
    #: Description of the ProductType.
    description: str
    #: Attributes specified for the ProductType.
    attributes: typing.Optional[typing.List["AttributeDefinition"]]

    def __init__(
        self,
        *,
        id: str,
        version: int,
        created_at: datetime.datetime,
        last_modified_at: datetime.datetime,
        last_modified_by: typing.Optional["LastModifiedBy"] = None,
        created_by: typing.Optional["CreatedBy"] = None,
        key: typing.Optional[str] = None,
        name: str,
        description: str,
        attributes: typing.Optional[typing.List["AttributeDefinition"]] = None
    ):
        self.last_modified_by = last_modified_by
        self.created_by = created_by
        self.key = key
        self.name = name
        self.description = description
        self.attributes = attributes

        super().__init__(
            id=id,
            version=version,
            created_at=created_at,
            last_modified_at=last_modified_at,
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ProductType":
        from ._schemas.product_type import ProductTypeSchema

        return ProductTypeSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_type import ProductTypeSchema

        return ProductTypeSchema().dump(self)


class ProductTypeDraft(_BaseType):
    #: User-defined unique identifier for the ProductType.
    key: typing.Optional[str]
    #: Name of the ProductType.
    name: str
    #: Description of the ProductType.
    description: str
    #: Attributes to specify for the ProductType. Products of this ProductType have these Attributes available on their [ProductVariants](ctp:api:type:ProductVariant).
    attributes: typing.Optional[typing.List["AttributeDefinitionDraft"]]

    def __init__(
        self,
        *,
        key: typing.Optional[str] = None,
        name: str,
        description: str,
        attributes: typing.Optional[typing.List["AttributeDefinitionDraft"]] = None
    ):
        self.key = key
        self.name = name
        self.description = description
        self.attributes = attributes

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ProductTypeDraft":
        from ._schemas.product_type import ProductTypeDraftSchema

        return ProductTypeDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_type import ProductTypeDraftSchema

        return ProductTypeDraftSchema().dump(self)


class ProductTypePagedQueryResponse(_BaseType):
    """[PagedQueryResult](/../api/general-concepts#pagedqueryresult) with results containing an array of [ProductType](ctp:api:type:ProductType)."""

    #: Number of [results requested](/../api/general-concepts#limit).
    limit: int
    #: Number of [elements skipped](/../api/general-concepts#offset).
    offset: int
    #: Actual number of results returned.
    count: int
    #: Total number of results matching the query.
    #: This number is an estimation that is not [strongly consistent](/../api/general-concepts#strong-consistency).
    #: This field is returned by default.
    #: For improved performance, calculating this field can be deactivated by using the query parameter `withTotal=false`.
    #: When the results are filtered with a [Query Predicate](/../api/predicates/query), `total` is subject to a [limit](/../api/limits#queries).
    total: typing.Optional[int]
    #: [ProductTypes](ctp:api:type:ProductType) matching the query.
    results: typing.List["ProductType"]

    def __init__(
        self,
        *,
        limit: int,
        offset: int,
        count: int,
        total: typing.Optional[int] = None,
        results: typing.List["ProductType"]
    ):
        self.limit = limit
        self.offset = offset
        self.count = count
        self.total = total
        self.results = results

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTypePagedQueryResponse":
        from ._schemas.product_type import ProductTypePagedQueryResponseSchema

        return ProductTypePagedQueryResponseSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_type import ProductTypePagedQueryResponseSchema

        return ProductTypePagedQueryResponseSchema().dump(self)


class ProductTypeReference(Reference):
    """[Reference](ctp:api:type:Reference) to a [ProductType](ctp:api:type:ProductType)."""

    #: Contains the representation of the expanded ProductType. Only present in responses to requests with [Reference Expansion](/../api/general-concepts#reference-expansion) for ProductTypes.
    obj: typing.Optional["ProductType"]

    def __init__(self, *, id: str, obj: typing.Optional["ProductType"] = None):
        self.obj = obj

        super().__init__(id=id, type_id=ReferenceTypeId.PRODUCT_TYPE)

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ProductTypeReference":
        from ._schemas.product_type import ProductTypeReferenceSchema

        return ProductTypeReferenceSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_type import ProductTypeReferenceSchema

        return ProductTypeReferenceSchema().dump(self)


class ProductTypeResourceIdentifier(ResourceIdentifier):
    """[ResourceIdentifier](ctp:api:type:ResourceIdentifier) to a [ProductType](ctp:api:type:ProductType)."""

    def __init__(
        self, *, id: typing.Optional[str] = None, key: typing.Optional[str] = None
    ):
        super().__init__(id=id, key=key, type_id=ReferenceTypeId.PRODUCT_TYPE)

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTypeResourceIdentifier":
        from ._schemas.product_type import ProductTypeResourceIdentifierSchema

        return ProductTypeResourceIdentifierSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_type import ProductTypeResourceIdentifierSchema

        return ProductTypeResourceIdentifierSchema().dump(self)


class ProductTypeUpdate(_BaseType):
    #: Expected version of the ProductType on which the changes should be applied. If the expected version does not match the actual version, a [ConcurrentModification](ctp:api:type:ConcurrentModificationError) error is returned.
    version: int
    #: Update actions to be performed on the ProductType.
    actions: typing.List["ProductTypeUpdateAction"]

    def __init__(
        self, *, version: int, actions: typing.List["ProductTypeUpdateAction"]
    ):
        self.version = version
        self.actions = actions

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ProductTypeUpdate":
        from ._schemas.product_type import ProductTypeUpdateSchema

        return ProductTypeUpdateSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_type import ProductTypeUpdateSchema

        return ProductTypeUpdateSchema().dump(self)


class ProductTypeUpdateAction(_BaseType):
    action: str

    def __init__(self, *, action: str):
        self.action = action

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTypeUpdateAction":
        if data["action"] == "addAttributeDefinition":
            from ._schemas.product_type import (
                ProductTypeAddAttributeDefinitionActionSchema,
            )

            return ProductTypeAddAttributeDefinitionActionSchema().load(data)
        if data["action"] == "addLocalizedEnumValue":
            from ._schemas.product_type import (
                ProductTypeAddLocalizedEnumValueActionSchema,
            )

            return ProductTypeAddLocalizedEnumValueActionSchema().load(data)
        if data["action"] == "addPlainEnumValue":
            from ._schemas.product_type import ProductTypeAddPlainEnumValueActionSchema

            return ProductTypeAddPlainEnumValueActionSchema().load(data)
        if data["action"] == "changeAttributeConstraint":
            from ._schemas.product_type import (
                ProductTypeChangeAttributeConstraintActionSchema,
            )

            return ProductTypeChangeAttributeConstraintActionSchema().load(data)
        if data["action"] == "changeAttributeName":
            from ._schemas.product_type import (
                ProductTypeChangeAttributeNameActionSchema,
            )

            return ProductTypeChangeAttributeNameActionSchema().load(data)
        if data["action"] == "changeAttributeOrder":
            from ._schemas.product_type import (
                ProductTypeChangeAttributeOrderActionSchema,
            )

            return ProductTypeChangeAttributeOrderActionSchema().load(data)
        if data["action"] == "changeAttributeOrderByName":
            from ._schemas.product_type import (
                ProductTypeChangeAttributeOrderByNameActionSchema,
            )

            return ProductTypeChangeAttributeOrderByNameActionSchema().load(data)
        if data["action"] == "changeDescription":
            from ._schemas.product_type import ProductTypeChangeDescriptionActionSchema

            return ProductTypeChangeDescriptionActionSchema().load(data)
        if data["action"] == "changeEnumKey":
            from ._schemas.product_type import ProductTypeChangeEnumKeyActionSchema

            return ProductTypeChangeEnumKeyActionSchema().load(data)
        if data["action"] == "changeInputHint":
            from ._schemas.product_type import ProductTypeChangeInputHintActionSchema

            return ProductTypeChangeInputHintActionSchema().load(data)
        if data["action"] == "changeIsSearchable":
            from ._schemas.product_type import ProductTypeChangeIsSearchableActionSchema

            return ProductTypeChangeIsSearchableActionSchema().load(data)
        if data["action"] == "changeLabel":
            from ._schemas.product_type import ProductTypeChangeLabelActionSchema

            return ProductTypeChangeLabelActionSchema().load(data)
        if data["action"] == "changeLocalizedEnumValueLabel":
            from ._schemas.product_type import (
                ProductTypeChangeLocalizedEnumValueLabelActionSchema,
            )

            return ProductTypeChangeLocalizedEnumValueLabelActionSchema().load(data)
        if data["action"] == "changeLocalizedEnumValueOrder":
            from ._schemas.product_type import (
                ProductTypeChangeLocalizedEnumValueOrderActionSchema,
            )

            return ProductTypeChangeLocalizedEnumValueOrderActionSchema().load(data)
        if data["action"] == "changeName":
            from ._schemas.product_type import ProductTypeChangeNameActionSchema

            return ProductTypeChangeNameActionSchema().load(data)
        if data["action"] == "changePlainEnumValueLabel":
            from ._schemas.product_type import (
                ProductTypeChangePlainEnumValueLabelActionSchema,
            )

            return ProductTypeChangePlainEnumValueLabelActionSchema().load(data)
        if data["action"] == "changePlainEnumValueOrder":
            from ._schemas.product_type import (
                ProductTypeChangePlainEnumValueOrderActionSchema,
            )

            return ProductTypeChangePlainEnumValueOrderActionSchema().load(data)
        if data["action"] == "removeAttributeDefinition":
            from ._schemas.product_type import (
                ProductTypeRemoveAttributeDefinitionActionSchema,
            )

            return ProductTypeRemoveAttributeDefinitionActionSchema().load(data)
        if data["action"] == "removeEnumValues":
            from ._schemas.product_type import ProductTypeRemoveEnumValuesActionSchema

            return ProductTypeRemoveEnumValuesActionSchema().load(data)
        if data["action"] == "setInputTip":
            from ._schemas.product_type import ProductTypeSetInputTipActionSchema

            return ProductTypeSetInputTipActionSchema().load(data)
        if data["action"] == "setKey":
            from ._schemas.product_type import ProductTypeSetKeyActionSchema

            return ProductTypeSetKeyActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_type import ProductTypeUpdateActionSchema

        return ProductTypeUpdateActionSchema().dump(self)


class TextInputHint(enum.Enum):
    """A text input hint is a string with one of the following values:"""

    SINGLE_LINE = "SingleLine"
    MULTI_LINE = "MultiLine"


class ProductTypeAddAttributeDefinitionAction(ProductTypeUpdateAction):
    #: Value to append to `attributes`.
    attribute: "AttributeDefinitionDraft"

    def __init__(self, *, attribute: "AttributeDefinitionDraft"):
        self.attribute = attribute

        super().__init__(action="addAttributeDefinition")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTypeAddAttributeDefinitionAction":
        from ._schemas.product_type import ProductTypeAddAttributeDefinitionActionSchema

        return ProductTypeAddAttributeDefinitionActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_type import ProductTypeAddAttributeDefinitionActionSchema

        return ProductTypeAddAttributeDefinitionActionSchema().dump(self)


class ProductTypeAddLocalizedEnumValueAction(ProductTypeUpdateAction):
    """Adds a localizable enum to the values of [AttributeLocalizedEnumType](ctp:api:type:AttributeLocalizedEnumType). It can update an AttributeLocalizedEnumType AttributeDefinition or an [AttributeSetType](ctp:api:type:AttributeSetType) of AttributeLocalizedEnumType AttributeDefinition."""

    #: Name of the AttributeDefinition to update.
    attribute_name: str
    #: Value to append to the array.
    value: "AttributeLocalizedEnumValue"

    def __init__(self, *, attribute_name: str, value: "AttributeLocalizedEnumValue"):
        self.attribute_name = attribute_name
        self.value = value

        super().__init__(action="addLocalizedEnumValue")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTypeAddLocalizedEnumValueAction":
        from ._schemas.product_type import ProductTypeAddLocalizedEnumValueActionSchema

        return ProductTypeAddLocalizedEnumValueActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_type import ProductTypeAddLocalizedEnumValueActionSchema

        return ProductTypeAddLocalizedEnumValueActionSchema().dump(self)


class ProductTypeAddPlainEnumValueAction(ProductTypeUpdateAction):
    """Adds an enum to the values of [AttributeEnumType](ctp:api:type:AttributeEnumType) AttributeDefinition, or [AttributeSetType](ctp:api:type:AttributeSetType) of AttributeEnumType AttributeDefinition."""

    #: Name of the AttributeDefinition to update.
    attribute_name: str
    #: Value to append to the array.
    value: "AttributePlainEnumValue"

    def __init__(self, *, attribute_name: str, value: "AttributePlainEnumValue"):
        self.attribute_name = attribute_name
        self.value = value

        super().__init__(action="addPlainEnumValue")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTypeAddPlainEnumValueAction":
        from ._schemas.product_type import ProductTypeAddPlainEnumValueActionSchema

        return ProductTypeAddPlainEnumValueActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_type import ProductTypeAddPlainEnumValueActionSchema

        return ProductTypeAddPlainEnumValueActionSchema().dump(self)


class ProductTypeChangeAttributeConstraintAction(ProductTypeUpdateAction):
    """Updates the `attributeConstraint` of an [AttributeDefinition](ctp:api:type:AttributeDefinition). For now only following changes are supported: `SameForAll` to `None` and `Unique` to `None`."""

    #: Name of the AttributeDefinition to update.
    attribute_name: str
    #: `None`
    new_value: "AttributeConstraintEnumDraft"

    def __init__(
        self, *, attribute_name: str, new_value: "AttributeConstraintEnumDraft"
    ):
        self.attribute_name = attribute_name
        self.new_value = new_value

        super().__init__(action="changeAttributeConstraint")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTypeChangeAttributeConstraintAction":
        from ._schemas.product_type import (
            ProductTypeChangeAttributeConstraintActionSchema,
        )

        return ProductTypeChangeAttributeConstraintActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_type import (
            ProductTypeChangeAttributeConstraintActionSchema,
        )

        return ProductTypeChangeAttributeConstraintActionSchema().dump(self)


class ProductTypeChangeAttributeNameAction(ProductTypeUpdateAction):
    """Renames an AttributeDefinition and also renames all corresponding Attributes on all [Products](/projects/products) with this ProductType. The renaming of the Attributes is [eventually consistent](/general-concepts#eventual-consistency).

    If the AttributeDefinition name to be changed does not exist, an [AttributeNameDoesNotExist](ctp:api:type:AttributeNameDoesNotExistError) error is returned.

    """

    #: Name of the AttributeDefinition to update.
    attribute_name: str
    #: New user-defined name of the Attribute that is unique with the [Project](ctp:api:type:Project).
    #:
    #: When using the same `name` for an Attribute in two or more ProductTypes, all fields of the AttributeDefinition of this Attribute must be the same across the ProductTypes. If not, an [AttributeDefinitionAlreadyExists](ctp:api:type:AttributeDefinitionAlreadyExistsError) error is returned.
    #: An exception to this are the values of an `enum` or `lenum` type and sets thereof.
    new_attribute_name: str

    def __init__(self, *, attribute_name: str, new_attribute_name: str):
        self.attribute_name = attribute_name
        self.new_attribute_name = new_attribute_name

        super().__init__(action="changeAttributeName")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTypeChangeAttributeNameAction":
        from ._schemas.product_type import ProductTypeChangeAttributeNameActionSchema

        return ProductTypeChangeAttributeNameActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_type import ProductTypeChangeAttributeNameActionSchema

        return ProductTypeChangeAttributeNameActionSchema().dump(self)


class ProductTypeChangeAttributeOrderAction(ProductTypeUpdateAction):
    attributes: typing.List["AttributeDefinition"]

    def __init__(self, *, attributes: typing.List["AttributeDefinition"]):
        self.attributes = attributes

        super().__init__(action="changeAttributeOrder")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTypeChangeAttributeOrderAction":
        from ._schemas.product_type import ProductTypeChangeAttributeOrderActionSchema

        return ProductTypeChangeAttributeOrderActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_type import ProductTypeChangeAttributeOrderActionSchema

        return ProductTypeChangeAttributeOrderActionSchema().dump(self)


class ProductTypeChangeAttributeOrderByNameAction(ProductTypeUpdateAction):
    #: Names of Attributes to reorder. This array must include all Attributes currently present on a ProductType in a different order.
    attribute_names: typing.List["str"]

    def __init__(self, *, attribute_names: typing.List["str"]):
        self.attribute_names = attribute_names

        super().__init__(action="changeAttributeOrderByName")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTypeChangeAttributeOrderByNameAction":
        from ._schemas.product_type import (
            ProductTypeChangeAttributeOrderByNameActionSchema,
        )

        return ProductTypeChangeAttributeOrderByNameActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_type import (
            ProductTypeChangeAttributeOrderByNameActionSchema,
        )

        return ProductTypeChangeAttributeOrderByNameActionSchema().dump(self)


class ProductTypeChangeDescriptionAction(ProductTypeUpdateAction):
    #: New value to set.
    description: str

    def __init__(self, *, description: str):
        self.description = description

        super().__init__(action="changeDescription")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTypeChangeDescriptionAction":
        from ._schemas.product_type import ProductTypeChangeDescriptionActionSchema

        return ProductTypeChangeDescriptionActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_type import ProductTypeChangeDescriptionActionSchema

        return ProductTypeChangeDescriptionActionSchema().dump(self)


class ProductTypeChangeEnumKeyAction(ProductTypeUpdateAction):
    """Updates the key of a single enum `value` in an [AttributeEnumType](ctp:api:type:AttributeEnumType) AttributeDefinition, [AttributeLocalizedEnumType](ctp:api:type:AttributeLocalizedEnumType) AttributeDefinition, [AttributeSetType](ctp:api:type:AttributeSetType) of AttributeEnumType AttributeDefinition, or AttributeSetType of AttributeLocalizedEnumType AttributeDefinition.

    If the AttributeDefinition does not contain an enum with the referenced key, a [EnumKeyDoesNotExist](ctp:api:type:EnumKeyDoesNotExistError) error is returned.

    All Products will be updated to the new key in an [eventually consistent](/general-concepts#eventual-consistency) way.

    """

    #: Name of the AttributeDefinition to update.
    attribute_name: str
    #: Existing key to be changed.
    key: str
    #: New key to be set.
    new_key: str

    def __init__(self, *, attribute_name: str, key: str, new_key: str):
        self.attribute_name = attribute_name
        self.key = key
        self.new_key = new_key

        super().__init__(action="changeEnumKey")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTypeChangeEnumKeyAction":
        from ._schemas.product_type import ProductTypeChangeEnumKeyActionSchema

        return ProductTypeChangeEnumKeyActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_type import ProductTypeChangeEnumKeyActionSchema

        return ProductTypeChangeEnumKeyActionSchema().dump(self)


class ProductTypeChangeInputHintAction(ProductTypeUpdateAction):
    """Updates the `inputHint` of an [AttributeDefinition](ctp:api:type:AttributeDefinition)."""

    #: Name of the AttributeDefinition to update.
    attribute_name: str
    #: `SingleLine` or `MultiLine`
    new_value: "TextInputHint"

    def __init__(self, *, attribute_name: str, new_value: "TextInputHint"):
        self.attribute_name = attribute_name
        self.new_value = new_value

        super().__init__(action="changeInputHint")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTypeChangeInputHintAction":
        from ._schemas.product_type import ProductTypeChangeInputHintActionSchema

        return ProductTypeChangeInputHintActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_type import ProductTypeChangeInputHintActionSchema

        return ProductTypeChangeInputHintActionSchema().dump(self)


class ProductTypeChangeIsSearchableAction(ProductTypeUpdateAction):
    """Following this update the Products are reindexed asynchronously to reflect this change on the search endpoint. When enabling search on an existing Attribute type definition, the constraint regarding the maximum size of a searchable Attribute will not be enforced. Instead, Product AttributeDefinitions exceeding this limit will be treated as not searchable and will not be available for full-text search."""

    #: Name of the AttributeDefinition to update.
    attribute_name: str
    #: Determines whether the Attribute's values can be used in full-text search queries, filters, and facets. See [AttributeDefinition](ctp:api:type:AttributeDefinition) for details.
    is_searchable: bool

    def __init__(self, *, attribute_name: str, is_searchable: bool):
        self.attribute_name = attribute_name
        self.is_searchable = is_searchable

        super().__init__(action="changeIsSearchable")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTypeChangeIsSearchableAction":
        from ._schemas.product_type import ProductTypeChangeIsSearchableActionSchema

        return ProductTypeChangeIsSearchableActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_type import ProductTypeChangeIsSearchableActionSchema

        return ProductTypeChangeIsSearchableActionSchema().dump(self)


class ProductTypeChangeLabelAction(ProductTypeUpdateAction):
    #: Name of the AttributeDefinition to update.
    attribute_name: str
    #: New value to set. Must not be empty.
    label: "LocalizedString"

    def __init__(self, *, attribute_name: str, label: "LocalizedString"):
        self.attribute_name = attribute_name
        self.label = label

        super().__init__(action="changeLabel")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTypeChangeLabelAction":
        from ._schemas.product_type import ProductTypeChangeLabelActionSchema

        return ProductTypeChangeLabelActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_type import ProductTypeChangeLabelActionSchema

        return ProductTypeChangeLabelActionSchema().dump(self)


class ProductTypeChangeLocalizedEnumValueLabelAction(ProductTypeUpdateAction):
    """Updates the label of a single enum `value` in an [AttributeLocalizedEnumType](ctp:api:type:AttributeLocalizedEnumType) AttributeDefinition, or [AttributeSetType](ctp:api:type:AttributeSetType) of AttributeLocalizedEnumType AttributeDefinition.

    All Products will be updated to the new label in an [eventually consistent](/general-concepts#eventual-consistency) way.

    """

    #: Name of the AttributeDefinition to update.
    attribute_name: str
    #: New value to set. Must be different from the existing value.
    new_value: "AttributeLocalizedEnumValue"

    def __init__(
        self, *, attribute_name: str, new_value: "AttributeLocalizedEnumValue"
    ):
        self.attribute_name = attribute_name
        self.new_value = new_value

        super().__init__(action="changeLocalizedEnumValueLabel")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTypeChangeLocalizedEnumValueLabelAction":
        from ._schemas.product_type import (
            ProductTypeChangeLocalizedEnumValueLabelActionSchema,
        )

        return ProductTypeChangeLocalizedEnumValueLabelActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_type import (
            ProductTypeChangeLocalizedEnumValueLabelActionSchema,
        )

        return ProductTypeChangeLocalizedEnumValueLabelActionSchema().dump(self)


class ProductTypeChangeLocalizedEnumValueOrderAction(ProductTypeUpdateAction):
    """Updates the order of localized enum `values` in an [AttributeLocalizedEnumType](ctp:api:type:AttributeLocalizedEnumType) AttributeDefinition. It can update an AttributeLocalizedEnumType AttributeDefinition or an [AttributeSetType](ctp:api:type:AttributeSetType) of AttributeLocalizedEnumType AttributeDefinition."""

    #: Name of the AttributeDefinition to update.
    attribute_name: str
    #: Values must be equal to the values of the Attribute enum values (except for the order). If not, an [EnumValuesMustMatch](ctp:api:type:EnumValuesMustMatchError) error is returned.
    values: typing.List["AttributeLocalizedEnumValue"]

    def __init__(
        self, *, attribute_name: str, values: typing.List["AttributeLocalizedEnumValue"]
    ):
        self.attribute_name = attribute_name
        self.values = values

        super().__init__(action="changeLocalizedEnumValueOrder")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTypeChangeLocalizedEnumValueOrderAction":
        from ._schemas.product_type import (
            ProductTypeChangeLocalizedEnumValueOrderActionSchema,
        )

        return ProductTypeChangeLocalizedEnumValueOrderActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_type import (
            ProductTypeChangeLocalizedEnumValueOrderActionSchema,
        )

        return ProductTypeChangeLocalizedEnumValueOrderActionSchema().dump(self)


class ProductTypeChangeNameAction(ProductTypeUpdateAction):
    #: New value to set.
    name: str

    def __init__(self, *, name: str):
        self.name = name

        super().__init__(action="changeName")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTypeChangeNameAction":
        from ._schemas.product_type import ProductTypeChangeNameActionSchema

        return ProductTypeChangeNameActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_type import ProductTypeChangeNameActionSchema

        return ProductTypeChangeNameActionSchema().dump(self)


class ProductTypeChangePlainEnumValueLabelAction(ProductTypeUpdateAction):
    """Updates the label of a single enum `value` in an [AttributeEnumType](ctp:api:type:AttributeEnumType) AttributeDefinition, or [AttributeSetType](ctp:api:type:AttributeSetType) of AttributeEnumType AttributeDefinition.

    All Products will be updated to the new label in an [eventually consistent](/general-concepts#eventual-consistency) way.

    """

    #: Name of the AttributeDefinition to update.
    attribute_name: str
    #: New value to set. Must be different from the existing value.
    new_value: "AttributePlainEnumValue"

    def __init__(self, *, attribute_name: str, new_value: "AttributePlainEnumValue"):
        self.attribute_name = attribute_name
        self.new_value = new_value

        super().__init__(action="changePlainEnumValueLabel")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTypeChangePlainEnumValueLabelAction":
        from ._schemas.product_type import (
            ProductTypeChangePlainEnumValueLabelActionSchema,
        )

        return ProductTypeChangePlainEnumValueLabelActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_type import (
            ProductTypeChangePlainEnumValueLabelActionSchema,
        )

        return ProductTypeChangePlainEnumValueLabelActionSchema().dump(self)


class ProductTypeChangePlainEnumValueOrderAction(ProductTypeUpdateAction):
    """Updates the order of enum `values` in an [AttributeEnumType](ctp:api:type:AttributeEnumType) AttributeDefinition. It can update an AttributeEnumType AttributeDefinition or an [AttributeSetType](ctp:api:type:AttributeSetType) of AttributeEnumType AttributeDefinition."""

    #: Name of the AttributeDefinition to update.
    attribute_name: str
    #: Values must be equal to the values of the Attribute enum values (except for the order). If not, an [EnumValuesMustMatch](ctp:api:type:EnumValuesMustMatchError) error is returned.
    values: typing.List["AttributePlainEnumValue"]

    def __init__(
        self, *, attribute_name: str, values: typing.List["AttributePlainEnumValue"]
    ):
        self.attribute_name = attribute_name
        self.values = values

        super().__init__(action="changePlainEnumValueOrder")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTypeChangePlainEnumValueOrderAction":
        from ._schemas.product_type import (
            ProductTypeChangePlainEnumValueOrderActionSchema,
        )

        return ProductTypeChangePlainEnumValueOrderActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_type import (
            ProductTypeChangePlainEnumValueOrderActionSchema,
        )

        return ProductTypeChangePlainEnumValueOrderActionSchema().dump(self)


class ProductTypeRemoveAttributeDefinitionAction(ProductTypeUpdateAction):
    """Removes an AttributeDefinition and also deletes all corresponding Attributes on all [Products](/projects/products) with this ProductType. The removal of the Attributes is [eventually consistent](/general-concepts#eventual-consistency).

    The `CombinationUnique` constraint is not checked when an Attribute is removed, and uniqueness violations may occur when you remove an Attribute with a `CombinationUnique` constraint.

    """

    #: Name of the Attribute to remove.
    name: str

    def __init__(self, *, name: str):
        self.name = name

        super().__init__(action="removeAttributeDefinition")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTypeRemoveAttributeDefinitionAction":
        from ._schemas.product_type import (
            ProductTypeRemoveAttributeDefinitionActionSchema,
        )

        return ProductTypeRemoveAttributeDefinitionActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_type import (
            ProductTypeRemoveAttributeDefinitionActionSchema,
        )

        return ProductTypeRemoveAttributeDefinitionActionSchema().dump(self)


class ProductTypeRemoveEnumValuesAction(ProductTypeUpdateAction):
    """Removes enum values from an AttributeDefinition of [AttributeEnumType](ctp:api:type:AttributeEnumType), [AttributeLocalizedEnumType](ctp:api:type:AttributeLocalizedEnumType), [AttributeSetType](ctp:api:type:AttributeSetType) of AttributeEnumType, or AttributeSetType of AttributeLocalizedEnumType.

    If the Attribute is **not** required, the Attributes of all Products using those enum keys will also be removed in an [eventually consistent](/general-concepts#eventual-consistency) way. If the Attribute is required, the operation returns an [EnumValueIsUsed](ctp:api:type:EnumValueIsUsedError) error.

    """

    #: Name of the AttributeDefinition to update.
    attribute_name: str
    #: Keys of [AttributeEnumType](ctp:api:type:AttributeEnumType) or [AttributeLocalizedEnumType](ctp:api:type:AttributeLocalizedEnumType) to remove.
    keys: typing.List["str"]

    def __init__(self, *, attribute_name: str, keys: typing.List["str"]):
        self.attribute_name = attribute_name
        self.keys = keys

        super().__init__(action="removeEnumValues")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTypeRemoveEnumValuesAction":
        from ._schemas.product_type import ProductTypeRemoveEnumValuesActionSchema

        return ProductTypeRemoveEnumValuesActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_type import ProductTypeRemoveEnumValuesActionSchema

        return ProductTypeRemoveEnumValuesActionSchema().dump(self)


class ProductTypeSetInputTipAction(ProductTypeUpdateAction):
    #: Name of the AttributeDefinition to update.
    attribute_name: str
    #: Value to set. If empty, any existing value will be removed.
    input_tip: typing.Optional["LocalizedString"]

    def __init__(
        self,
        *,
        attribute_name: str,
        input_tip: typing.Optional["LocalizedString"] = None
    ):
        self.attribute_name = attribute_name
        self.input_tip = input_tip

        super().__init__(action="setInputTip")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTypeSetInputTipAction":
        from ._schemas.product_type import ProductTypeSetInputTipActionSchema

        return ProductTypeSetInputTipActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_type import ProductTypeSetInputTipActionSchema

        return ProductTypeSetInputTipActionSchema().dump(self)


class ProductTypeSetKeyAction(ProductTypeUpdateAction):
    #: Value to set. If empty, any existing value will be removed.
    key: typing.Optional[str]

    def __init__(self, *, key: typing.Optional[str] = None):
        self.key = key

        super().__init__(action="setKey")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ProductTypeSetKeyAction":
        from ._schemas.product_type import ProductTypeSetKeyActionSchema

        return ProductTypeSetKeyActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.product_type import ProductTypeSetKeyActionSchema

        return ProductTypeSetKeyActionSchema().dump(self)
