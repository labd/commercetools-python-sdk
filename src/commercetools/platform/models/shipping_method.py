# This file is automatically generated by the rmf-codegen project.
#
# The Python code generator is maintained by Lab Digital. If you want to
# contribute to this project then please do not edit this file directly
# but send a pull request to the Lab Digital fork of rmf-codegen at
# https://github.com/labd/rmf-codegen

import datetime
import enum
import typing

from ._abstract import _BaseType
from .common import BaseResource, Reference, ReferenceTypeId, ResourceIdentifier

if typing.TYPE_CHECKING:
    from .common import (
        CreatedBy,
        LastModifiedBy,
        LocalizedString,
        Money,
        ReferenceTypeId,
        TypedMoney,
    )
    from .tax_category import TaxCategoryReference, TaxCategoryResourceIdentifier
    from .type import (
        CustomFields,
        CustomFieldsDraft,
        FieldContainer,
        TypeResourceIdentifier,
    )
    from .zone import ZoneReference, ZoneResourceIdentifier

__all__ = [
    "CartClassificationTier",
    "CartScoreTier",
    "CartValueTier",
    "PriceFunction",
    "ShippingMethod",
    "ShippingMethodAddShippingRateAction",
    "ShippingMethodAddZoneAction",
    "ShippingMethodChangeIsDefaultAction",
    "ShippingMethodChangeNameAction",
    "ShippingMethodChangeTaxCategoryAction",
    "ShippingMethodDraft",
    "ShippingMethodPagedQueryResponse",
    "ShippingMethodReference",
    "ShippingMethodRemoveShippingRateAction",
    "ShippingMethodRemoveZoneAction",
    "ShippingMethodResourceIdentifier",
    "ShippingMethodSetCustomFieldAction",
    "ShippingMethodSetCustomTypeAction",
    "ShippingMethodSetDescriptionAction",
    "ShippingMethodSetKeyAction",
    "ShippingMethodSetLocalizedDescriptionAction",
    "ShippingMethodSetLocalizedNameAction",
    "ShippingMethodSetPredicateAction",
    "ShippingMethodUpdate",
    "ShippingMethodUpdateAction",
    "ShippingRate",
    "ShippingRateDraft",
    "ShippingRatePriceTier",
    "ShippingRateTierType",
    "ZoneRate",
    "ZoneRateDraft",
]


class PriceFunction(_BaseType):
    #: Currency code compliant to [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217).
    currency_code: str
    #: To calculate a Price based on the score, use `+`, `-`, `*` and parentheses. The score is inserted with `x`. The function returns the cent amount.
    #:
    #: For example, to charge $1.99 for a score of `1`, $3.99 for a score of `2`, \$5.99 for a score of `3` and onwards, the function is: `(200 * x) - 1)`. To charge $4.50, $6.00, and \$7.50 for express shipping, the function is: `(150 * x) + 300`.
    function: str

    def __init__(self, *, currency_code: str, function: str):
        self.currency_code = currency_code
        self.function = function

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "PriceFunction":
        from ._schemas.shipping_method import PriceFunctionSchema

        return PriceFunctionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shipping_method import PriceFunctionSchema

        return PriceFunctionSchema().dump(self)


class ShippingMethod(BaseResource):
    #: Present on resources created after 1 February 2019 except for [events not tracked](/client-logging#events-tracked).
    last_modified_by: typing.Optional["LastModifiedBy"]
    #: Present on resources created after 1 February 2019 except for [events not tracked](/client-logging#events-tracked).
    created_by: typing.Optional["CreatedBy"]
    #: User-defined unique identifier of the ShippingMethod.
    key: typing.Optional[str]
    #: Name of the ShippingMethod.
    name: str
    #: Localized name of the ShippingMethod.
    localized_name: typing.Optional["LocalizedString"]
    #: Description of the ShippingMethod.
    description: typing.Optional[str]
    #: Localized description of the ShippingMethod.
    localized_description: typing.Optional["LocalizedString"]
    #: [TaxCategory](ctp:api:type:TaxCategory) of all ZoneRates of the ShippingMethod.
    tax_category: "TaxCategoryReference"
    #: Defines [ShippingRates](ctp:api:type:ShippingRate) (prices) for specific Zones.
    zone_rates: typing.List["ZoneRate"]
    #: If `true` this ShippingMethod is the [Project](ctp:api:type:Project)'s default ShippingMethod.
    is_default: bool
    #: Valid [Cart predicate](/projects/predicates#cart-predicates) to select a ShippingMethod for a Cart.
    predicate: typing.Optional[str]
    #: Custom Fields of the ShippingMethod.
    custom: typing.Optional["CustomFields"]

    def __init__(
        self,
        *,
        id: str,
        version: int,
        created_at: datetime.datetime,
        last_modified_at: datetime.datetime,
        last_modified_by: typing.Optional["LastModifiedBy"] = None,
        created_by: typing.Optional["CreatedBy"] = None,
        key: typing.Optional[str] = None,
        name: str,
        localized_name: typing.Optional["LocalizedString"] = None,
        description: typing.Optional[str] = None,
        localized_description: typing.Optional["LocalizedString"] = None,
        tax_category: "TaxCategoryReference",
        zone_rates: typing.List["ZoneRate"],
        is_default: bool,
        predicate: typing.Optional[str] = None,
        custom: typing.Optional["CustomFields"] = None
    ):
        self.last_modified_by = last_modified_by
        self.created_by = created_by
        self.key = key
        self.name = name
        self.localized_name = localized_name
        self.description = description
        self.localized_description = localized_description
        self.tax_category = tax_category
        self.zone_rates = zone_rates
        self.is_default = is_default
        self.predicate = predicate
        self.custom = custom

        super().__init__(
            id=id,
            version=version,
            created_at=created_at,
            last_modified_at=last_modified_at,
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ShippingMethod":
        from ._schemas.shipping_method import ShippingMethodSchema

        return ShippingMethodSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shipping_method import ShippingMethodSchema

        return ShippingMethodSchema().dump(self)


class ShippingMethodDraft(_BaseType):
    #: User-defined unique identifier for the ShippingMethod.
    key: typing.Optional[str]
    #: Name of the ShippingMethod.
    name: str
    #: Localized name of the ShippingMethod.
    localized_name: typing.Optional["LocalizedString"]
    #: Description of the ShippingMethod.
    description: typing.Optional[str]
    #: Localized description of the ShippingMethod.
    localized_description: typing.Optional["LocalizedString"]
    #: [TaxCategory](ctp:api:type:TaxCategory) for all ZoneRates of the ShippingMethod.
    tax_category: "TaxCategoryResourceIdentifier"
    #: Defines [ShippingRates](ctp:api:type:ShippingRate) (prices) for specific zones.
    zone_rates: typing.List["ZoneRateDraft"]
    #: If `true` the ShippingMethod will be the [Project](ctp:api:type:Project)'s default ShippingMethod.
    is_default: bool
    #: Valid [Cart predicate](/projects/predicates#cart-predicates) to select a ShippingMethod for a Cart.
    predicate: typing.Optional[str]
    #: Custom Fields for the ShippingMethod.
    custom: typing.Optional["CustomFieldsDraft"]

    def __init__(
        self,
        *,
        key: typing.Optional[str] = None,
        name: str,
        localized_name: typing.Optional["LocalizedString"] = None,
        description: typing.Optional[str] = None,
        localized_description: typing.Optional["LocalizedString"] = None,
        tax_category: "TaxCategoryResourceIdentifier",
        zone_rates: typing.List["ZoneRateDraft"],
        is_default: bool,
        predicate: typing.Optional[str] = None,
        custom: typing.Optional["CustomFieldsDraft"] = None
    ):
        self.key = key
        self.name = name
        self.localized_name = localized_name
        self.description = description
        self.localized_description = localized_description
        self.tax_category = tax_category
        self.zone_rates = zone_rates
        self.is_default = is_default
        self.predicate = predicate
        self.custom = custom

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ShippingMethodDraft":
        from ._schemas.shipping_method import ShippingMethodDraftSchema

        return ShippingMethodDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shipping_method import ShippingMethodDraftSchema

        return ShippingMethodDraftSchema().dump(self)


class ShippingMethodPagedQueryResponse(_BaseType):
    """[PagedQueryResult](/general-concepts#pagedqueryresult) with `results` containing an array of [ShippingMethod](ctp:api:type:ShippingMethod)."""

    #: Number of [results requested](/../api/general-concepts#limit).
    limit: typing.Optional[int]
    #: Actual number of results returned.
    count: int
    #: Total number of results matching the query.
    #: This number is an estimation that is not [strongly consistent](/../api/general-concepts#strong-consistency).
    #: This field is returned by default.
    #: For improved performance, calculating this field can be deactivated by using the query parameter `withTotal=false`.
    #: When the results are filtered with a [Query Predicate](/../api/predicates/query), `total` is subject to a [limit](/../api/limits#queries).
    total: typing.Optional[int]
    #: Number of [elements skipped](/../api/general-concepts#offset).
    offset: typing.Optional[int]
    #: [Shipping Methods](ctp:api:type:ShippingMethod) matching the query.
    results: typing.List["ShippingMethod"]

    def __init__(
        self,
        *,
        limit: typing.Optional[int] = None,
        count: int,
        total: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        results: typing.List["ShippingMethod"]
    ):
        self.limit = limit
        self.count = count
        self.total = total
        self.offset = offset
        self.results = results

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ShippingMethodPagedQueryResponse":
        from ._schemas.shipping_method import ShippingMethodPagedQueryResponseSchema

        return ShippingMethodPagedQueryResponseSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shipping_method import ShippingMethodPagedQueryResponseSchema

        return ShippingMethodPagedQueryResponseSchema().dump(self)


class ShippingMethodReference(Reference):
    """[Reference](ctp:api:type:Reference) to a [ShippingMethod](ctp:api:type:ShippingMethod)."""

    #: Contains the representation of the expanded ShippingMethod. Only present in responses to requests with [Reference Expansion](/../api/general-concepts#reference-expansion) for ShippingMethods.
    obj: typing.Optional["ShippingMethod"]

    def __init__(self, *, id: str, obj: typing.Optional["ShippingMethod"] = None):
        self.obj = obj

        super().__init__(id=id, type_id=ReferenceTypeId.SHIPPING_METHOD)

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ShippingMethodReference":
        from ._schemas.shipping_method import ShippingMethodReferenceSchema

        return ShippingMethodReferenceSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shipping_method import ShippingMethodReferenceSchema

        return ShippingMethodReferenceSchema().dump(self)


class ShippingMethodResourceIdentifier(ResourceIdentifier):
    """[ResourceIdentifier](ctp:api:type:ResourceIdentifier) to a [ShippingMethod](ctp:api:type:ShippingMethod)."""

    def __init__(
        self, *, id: typing.Optional[str] = None, key: typing.Optional[str] = None
    ):
        super().__init__(id=id, key=key, type_id=ReferenceTypeId.SHIPPING_METHOD)

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ShippingMethodResourceIdentifier":
        from ._schemas.shipping_method import ShippingMethodResourceIdentifierSchema

        return ShippingMethodResourceIdentifierSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shipping_method import ShippingMethodResourceIdentifierSchema

        return ShippingMethodResourceIdentifierSchema().dump(self)


class ShippingMethodUpdate(_BaseType):
    #: Expected version of the ShippingMethod on which the changes should be applied. If the expected version does not match the actual version, a 409 Conflict will be returned.
    version: int
    #: Update actions to be performed on the [ShippingMethod](/projects/shippingMethods#shippingmethod).
    actions: typing.List["ShippingMethodUpdateAction"]

    def __init__(
        self, *, version: int, actions: typing.List["ShippingMethodUpdateAction"]
    ):
        self.version = version
        self.actions = actions

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ShippingMethodUpdate":
        from ._schemas.shipping_method import ShippingMethodUpdateSchema

        return ShippingMethodUpdateSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shipping_method import ShippingMethodUpdateSchema

        return ShippingMethodUpdateSchema().dump(self)


class ShippingMethodUpdateAction(_BaseType):
    action: str

    def __init__(self, *, action: str):
        self.action = action

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ShippingMethodUpdateAction":
        if data["action"] == "addShippingRate":
            from ._schemas.shipping_method import (
                ShippingMethodAddShippingRateActionSchema,
            )

            return ShippingMethodAddShippingRateActionSchema().load(data)
        if data["action"] == "addZone":
            from ._schemas.shipping_method import ShippingMethodAddZoneActionSchema

            return ShippingMethodAddZoneActionSchema().load(data)
        if data["action"] == "changeIsDefault":
            from ._schemas.shipping_method import (
                ShippingMethodChangeIsDefaultActionSchema,
            )

            return ShippingMethodChangeIsDefaultActionSchema().load(data)
        if data["action"] == "changeName":
            from ._schemas.shipping_method import ShippingMethodChangeNameActionSchema

            return ShippingMethodChangeNameActionSchema().load(data)
        if data["action"] == "changeTaxCategory":
            from ._schemas.shipping_method import (
                ShippingMethodChangeTaxCategoryActionSchema,
            )

            return ShippingMethodChangeTaxCategoryActionSchema().load(data)
        if data["action"] == "removeShippingRate":
            from ._schemas.shipping_method import (
                ShippingMethodRemoveShippingRateActionSchema,
            )

            return ShippingMethodRemoveShippingRateActionSchema().load(data)
        if data["action"] == "removeZone":
            from ._schemas.shipping_method import ShippingMethodRemoveZoneActionSchema

            return ShippingMethodRemoveZoneActionSchema().load(data)
        if data["action"] == "setCustomField":
            from ._schemas.shipping_method import (
                ShippingMethodSetCustomFieldActionSchema,
            )

            return ShippingMethodSetCustomFieldActionSchema().load(data)
        if data["action"] == "setCustomType":
            from ._schemas.shipping_method import (
                ShippingMethodSetCustomTypeActionSchema,
            )

            return ShippingMethodSetCustomTypeActionSchema().load(data)
        if data["action"] == "setDescription":
            from ._schemas.shipping_method import (
                ShippingMethodSetDescriptionActionSchema,
            )

            return ShippingMethodSetDescriptionActionSchema().load(data)
        if data["action"] == "setKey":
            from ._schemas.shipping_method import ShippingMethodSetKeyActionSchema

            return ShippingMethodSetKeyActionSchema().load(data)
        if data["action"] == "setLocalizedDescription":
            from ._schemas.shipping_method import (
                ShippingMethodSetLocalizedDescriptionActionSchema,
            )

            return ShippingMethodSetLocalizedDescriptionActionSchema().load(data)
        if data["action"] == "setLocalizedName":
            from ._schemas.shipping_method import (
                ShippingMethodSetLocalizedNameActionSchema,
            )

            return ShippingMethodSetLocalizedNameActionSchema().load(data)
        if data["action"] == "setPredicate":
            from ._schemas.shipping_method import ShippingMethodSetPredicateActionSchema

            return ShippingMethodSetPredicateActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shipping_method import ShippingMethodUpdateActionSchema

        return ShippingMethodUpdateActionSchema().dump(self)


class ShippingRate(_BaseType):
    #: Currency amount of the ShippingRate.
    price: "TypedMoney"
    #: Shipping is free if the sum of the (Custom) Line Item Prices reaches the specified value.
    free_above: typing.Optional["TypedMoney"]
    #: `true` if the ShippingRate matches given [Cart](ctp:api:type:Cart) or [Location](ctp:api:type:Location).
    #: Only appears in response to requests for [Get ShippingMethods for a Cart](ctp:api:endpoint:/{projectKey}/shipping-methods/matching-cart:GET) or
    #: [Get ShippingMethods for a Location](ctp:api:endpoint:/{projectKey}/shipping-methods/matching-location:GET).
    is_matching: typing.Optional[bool]
    #: Price tiers for the ShippingRate.
    tiers: typing.List["ShippingRatePriceTier"]

    def __init__(
        self,
        *,
        price: "TypedMoney",
        free_above: typing.Optional["TypedMoney"] = None,
        is_matching: typing.Optional[bool] = None,
        tiers: typing.List["ShippingRatePriceTier"]
    ):
        self.price = price
        self.free_above = free_above
        self.is_matching = is_matching
        self.tiers = tiers

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ShippingRate":
        from ._schemas.shipping_method import ShippingRateSchema

        return ShippingRateSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shipping_method import ShippingRateSchema

        return ShippingRateSchema().dump(self)


class ShippingRateDraft(_BaseType):
    #: Money value of the ShippingRate.
    price: "Money"
    #: Shipping is free if the sum of the (Custom) Line Item Prices reaches the specified value.
    free_above: typing.Optional["Money"]
    #: Price tiers for the ShippingRate.
    tiers: typing.Optional[typing.List["ShippingRatePriceTier"]]

    def __init__(
        self,
        *,
        price: "Money",
        free_above: typing.Optional["Money"] = None,
        tiers: typing.Optional[typing.List["ShippingRatePriceTier"]] = None
    ):
        self.price = price
        self.free_above = free_above
        self.tiers = tiers

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ShippingRateDraft":
        from ._schemas.shipping_method import ShippingRateDraftSchema

        return ShippingRateDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shipping_method import ShippingRateDraftSchema

        return ShippingRateDraftSchema().dump(self)


class ShippingRatePriceTier(_BaseType):
    type: "ShippingRateTierType"

    def __init__(self, *, type: "ShippingRateTierType"):
        self.type = type

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ShippingRatePriceTier":
        if data["type"] == "CartClassification":
            from ._schemas.shipping_method import CartClassificationTierSchema

            return CartClassificationTierSchema().load(data)
        if data["type"] == "CartScore":
            from ._schemas.shipping_method import CartScoreTierSchema

            return CartScoreTierSchema().load(data)
        if data["type"] == "CartValue":
            from ._schemas.shipping_method import CartValueTierSchema

            return CartValueTierSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shipping_method import ShippingRatePriceTierSchema

        return ShippingRatePriceTierSchema().dump(self)


class CartClassificationTier(ShippingRatePriceTier):
    """Used when the ShippingRate maps to an abstract Cart categorization expressed by strings (for example, `Light`, `Medium`, or `Heavy`)."""

    #: `key` selected from the `values` of the [CartClassificationType](/projects/project#cartclassificationtype) configured in the Project.
    value: str
    #: Fixed shipping rate for the selected classification.
    price: "Money"
    #: Appears in response to [Get ShippingMethods for a Cart](ctp:api:endpoint:/{projectKey}/shipping-methods/matching-cart:GET) if the shipping rate matches the search query.
    is_matching: typing.Optional[bool]

    def __init__(
        self, *, value: str, price: "Money", is_matching: typing.Optional[bool] = None
    ):
        self.value = value
        self.price = price
        self.is_matching = is_matching

        super().__init__(type=ShippingRateTierType.CART_CLASSIFICATION)

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CartClassificationTier":
        from ._schemas.shipping_method import CartClassificationTierSchema

        return CartClassificationTierSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shipping_method import CartClassificationTierSchema

        return CartClassificationTierSchema().dump(self)


class CartScoreTier(ShippingRatePriceTier):
    """Used when the ShippingRate maps to an abstract Cart categorization expressed by integers (such as shipping scores or weight ranges).
    Either `price` or `priceFunction` is required.

    """

    #: Abstract value for categorizing a Cart. The range starts at `0`. The default price covers `0`, tiers start at `1`. See [Using Tiered Shipping Rates](/../tutorials/shipping-rate) for details and examples.
    score: int
    #: Defines a fixed price for the `score`.
    price: typing.Optional["Money"]
    #: Dynamically calculates a Price for a range of scores.
    price_function: typing.Optional["PriceFunction"]
    #: Appears in response to [Get ShippingMethods for a Cart](ctp:api:endpoint:/{projectKey}/shipping-methods/matching-cart:GET) if the shipping rate matches the search query.
    is_matching: typing.Optional[bool]

    def __init__(
        self,
        *,
        score: int,
        price: typing.Optional["Money"] = None,
        price_function: typing.Optional["PriceFunction"] = None,
        is_matching: typing.Optional[bool] = None
    ):
        self.score = score
        self.price = price
        self.price_function = price_function
        self.is_matching = is_matching

        super().__init__(type=ShippingRateTierType.CART_SCORE)

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CartScoreTier":
        from ._schemas.shipping_method import CartScoreTierSchema

        return CartScoreTierSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shipping_method import CartScoreTierSchema

        return CartScoreTierSchema().dump(self)


class CartValueTier(ShippingRatePriceTier):
    """Used when the ShippingRate maps to the sum of [LineItem](ctp:api:type:LineItem) Prices.
    The value of the Cart is used to select a tier.
    If chosen, it is not possible to set a value for the `shippingRateInput` on the [Cart](ctp:api:type:Cart).
    Tiers contain the `centAmount` (a value of `100` in the currency `USD` corresponds to `$ 1.00`), and start at `1`.'

    """

    #: Minimum total price of a Cart for which a shipping rate applies.
    minimum_cent_amount: int
    #: Fixed shipping rate Price for a CartValue.
    price: "Money"
    #: Appears in response to [Get ShippingMethods for a Cart](ctp:api:endpoint:/{projectKey}/shipping-methods/matching-cart:GET) if the shipping rate matches the search query.
    is_matching: typing.Optional[bool]

    def __init__(
        self,
        *,
        minimum_cent_amount: int,
        price: "Money",
        is_matching: typing.Optional[bool] = None
    ):
        self.minimum_cent_amount = minimum_cent_amount
        self.price = price
        self.is_matching = is_matching

        super().__init__(type=ShippingRateTierType.CART_VALUE)

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CartValueTier":
        from ._schemas.shipping_method import CartValueTierSchema

        return CartValueTierSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shipping_method import CartValueTierSchema

        return CartValueTierSchema().dump(self)


class ShippingRateTierType(enum.Enum):
    CART_VALUE = "CartValue"
    CART_CLASSIFICATION = "CartClassification"
    CART_SCORE = "CartScore"


class ZoneRate(_BaseType):
    """Defines shipping rates in different currencies for a specific [Zone](ctp:api:type:Zone)."""

    #: [Zone](ctp:api:type:Zone) for which the shipping rates are valid.
    zone: "ZoneReference"
    #: Shipping rates defined per currency.
    shipping_rates: typing.List["ShippingRate"]

    def __init__(
        self, *, zone: "ZoneReference", shipping_rates: typing.List["ShippingRate"]
    ):
        self.zone = zone
        self.shipping_rates = shipping_rates

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ZoneRate":
        from ._schemas.shipping_method import ZoneRateSchema

        return ZoneRateSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shipping_method import ZoneRateSchema

        return ZoneRateSchema().dump(self)


class ZoneRateDraft(_BaseType):
    #: Sets the [Zone](ctp:api:type:Zone) for which the shippng rates are valid.
    zone: "ZoneResourceIdentifier"
    #: Shipping rates for the `currencies` configured in the [Project](ctp:api:type:Project). The array must not contain two ShippingRates with the same [CurrencyCode](ctp:api:type:CurrencyCode).
    shipping_rates: typing.List["ShippingRateDraft"]

    def __init__(
        self,
        *,
        zone: "ZoneResourceIdentifier",
        shipping_rates: typing.List["ShippingRateDraft"]
    ):
        self.zone = zone
        self.shipping_rates = shipping_rates

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ZoneRateDraft":
        from ._schemas.shipping_method import ZoneRateDraftSchema

        return ZoneRateDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shipping_method import ZoneRateDraftSchema

        return ZoneRateDraftSchema().dump(self)


class ShippingMethodAddShippingRateAction(ShippingMethodUpdateAction):
    #: [Zone](ctp:api:type:Zone) to which the ShippingRate should be added.
    zone: "ZoneResourceIdentifier"
    #: Value to add to `shippingRates`.
    shipping_rate: "ShippingRateDraft"

    def __init__(
        self, *, zone: "ZoneResourceIdentifier", shipping_rate: "ShippingRateDraft"
    ):
        self.zone = zone
        self.shipping_rate = shipping_rate

        super().__init__(action="addShippingRate")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ShippingMethodAddShippingRateAction":
        from ._schemas.shipping_method import ShippingMethodAddShippingRateActionSchema

        return ShippingMethodAddShippingRateActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shipping_method import ShippingMethodAddShippingRateActionSchema

        return ShippingMethodAddShippingRateActionSchema().dump(self)


class ShippingMethodAddZoneAction(ShippingMethodUpdateAction):
    #: Value to add to `zoneRates`.
    zone: "ZoneResourceIdentifier"

    def __init__(self, *, zone: "ZoneResourceIdentifier"):
        self.zone = zone

        super().__init__(action="addZone")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ShippingMethodAddZoneAction":
        from ._schemas.shipping_method import ShippingMethodAddZoneActionSchema

        return ShippingMethodAddZoneActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shipping_method import ShippingMethodAddZoneActionSchema

        return ShippingMethodAddZoneActionSchema().dump(self)


class ShippingMethodChangeIsDefaultAction(ShippingMethodUpdateAction):
    #: Value to set. Only one ShippingMethod can be default in a [Project](ctp:api:type:Project).
    is_default: bool

    def __init__(self, *, is_default: bool):
        self.is_default = is_default

        super().__init__(action="changeIsDefault")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ShippingMethodChangeIsDefaultAction":
        from ._schemas.shipping_method import ShippingMethodChangeIsDefaultActionSchema

        return ShippingMethodChangeIsDefaultActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shipping_method import ShippingMethodChangeIsDefaultActionSchema

        return ShippingMethodChangeIsDefaultActionSchema().dump(self)


class ShippingMethodChangeNameAction(ShippingMethodUpdateAction):
    #: Value to set. Must not be empty.
    name: str

    def __init__(self, *, name: str):
        self.name = name

        super().__init__(action="changeName")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ShippingMethodChangeNameAction":
        from ._schemas.shipping_method import ShippingMethodChangeNameActionSchema

        return ShippingMethodChangeNameActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shipping_method import ShippingMethodChangeNameActionSchema

        return ShippingMethodChangeNameActionSchema().dump(self)


class ShippingMethodChangeTaxCategoryAction(ShippingMethodUpdateAction):
    #: Value to set.
    tax_category: "TaxCategoryResourceIdentifier"

    def __init__(self, *, tax_category: "TaxCategoryResourceIdentifier"):
        self.tax_category = tax_category

        super().__init__(action="changeTaxCategory")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ShippingMethodChangeTaxCategoryAction":
        from ._schemas.shipping_method import (
            ShippingMethodChangeTaxCategoryActionSchema,
        )

        return ShippingMethodChangeTaxCategoryActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shipping_method import (
            ShippingMethodChangeTaxCategoryActionSchema,
        )

        return ShippingMethodChangeTaxCategoryActionSchema().dump(self)


class ShippingMethodRemoveShippingRateAction(ShippingMethodUpdateAction):
    #: [Zone](ctp:api:type:Zone) from which the ShippingRate should be removed.
    zone: "ZoneResourceIdentifier"
    #: Value to remove from `shippingRates`.
    shipping_rate: "ShippingRateDraft"

    def __init__(
        self, *, zone: "ZoneResourceIdentifier", shipping_rate: "ShippingRateDraft"
    ):
        self.zone = zone
        self.shipping_rate = shipping_rate

        super().__init__(action="removeShippingRate")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ShippingMethodRemoveShippingRateAction":
        from ._schemas.shipping_method import (
            ShippingMethodRemoveShippingRateActionSchema,
        )

        return ShippingMethodRemoveShippingRateActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shipping_method import (
            ShippingMethodRemoveShippingRateActionSchema,
        )

        return ShippingMethodRemoveShippingRateActionSchema().dump(self)


class ShippingMethodRemoveZoneAction(ShippingMethodUpdateAction):
    #: Value to remove from `zoneRates`.
    zone: "ZoneResourceIdentifier"

    def __init__(self, *, zone: "ZoneResourceIdentifier"):
        self.zone = zone

        super().__init__(action="removeZone")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ShippingMethodRemoveZoneAction":
        from ._schemas.shipping_method import ShippingMethodRemoveZoneActionSchema

        return ShippingMethodRemoveZoneActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shipping_method import ShippingMethodRemoveZoneActionSchema

        return ShippingMethodRemoveZoneActionSchema().dump(self)


class ShippingMethodSetCustomFieldAction(ShippingMethodUpdateAction):
    """This action sets, overwrites, or removes any existing [Custom Field](/projects/custom-fields) for an existing ShippingMethod."""

    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: Removing a field that does not exist returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
    #: If `value` is provided, it is set for the field defined by `name`.
    value: typing.Optional[typing.Any]

    def __init__(self, *, name: str, value: typing.Optional[typing.Any] = None):
        self.name = name
        self.value = value

        super().__init__(action="setCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ShippingMethodSetCustomFieldAction":
        from ._schemas.shipping_method import ShippingMethodSetCustomFieldActionSchema

        return ShippingMethodSetCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shipping_method import ShippingMethodSetCustomFieldActionSchema

        return ShippingMethodSetCustomFieldActionSchema().dump(self)


class ShippingMethodSetCustomTypeAction(ShippingMethodUpdateAction):
    #: Defines the [Type](ctp:api:type:Type) that extends the ShippingMethod with [Custom Fields](/../api/projects/custom-fields).
    #: If absent, any existing Type and Custom Fields are removed from the ShippingMethod.
    type: typing.Optional["TypeResourceIdentifier"]
    #: Sets the [Custom Fields](/../api/projects/custom-fields) fields for the ShippingMethod.
    fields: typing.Optional["FieldContainer"]

    def __init__(
        self,
        *,
        type: typing.Optional["TypeResourceIdentifier"] = None,
        fields: typing.Optional["FieldContainer"] = None
    ):
        self.type = type
        self.fields = fields

        super().__init__(action="setCustomType")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ShippingMethodSetCustomTypeAction":
        from ._schemas.shipping_method import ShippingMethodSetCustomTypeActionSchema

        return ShippingMethodSetCustomTypeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shipping_method import ShippingMethodSetCustomTypeActionSchema

        return ShippingMethodSetCustomTypeActionSchema().dump(self)


class ShippingMethodSetDescriptionAction(ShippingMethodUpdateAction):
    #: Value to set. If empty, any existing value will be removed.
    description: typing.Optional[str]

    def __init__(self, *, description: typing.Optional[str] = None):
        self.description = description

        super().__init__(action="setDescription")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ShippingMethodSetDescriptionAction":
        from ._schemas.shipping_method import ShippingMethodSetDescriptionActionSchema

        return ShippingMethodSetDescriptionActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shipping_method import ShippingMethodSetDescriptionActionSchema

        return ShippingMethodSetDescriptionActionSchema().dump(self)


class ShippingMethodSetKeyAction(ShippingMethodUpdateAction):
    #: If `key` is absent or `null`, the existing key, if any, will be removed.
    key: typing.Optional[str]

    def __init__(self, *, key: typing.Optional[str] = None):
        self.key = key

        super().__init__(action="setKey")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ShippingMethodSetKeyAction":
        from ._schemas.shipping_method import ShippingMethodSetKeyActionSchema

        return ShippingMethodSetKeyActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shipping_method import ShippingMethodSetKeyActionSchema

        return ShippingMethodSetKeyActionSchema().dump(self)


class ShippingMethodSetLocalizedDescriptionAction(ShippingMethodUpdateAction):
    #: Value to set. If empty, any existing value will be removed.
    localized_description: typing.Optional["LocalizedString"]

    def __init__(
        self, *, localized_description: typing.Optional["LocalizedString"] = None
    ):
        self.localized_description = localized_description

        super().__init__(action="setLocalizedDescription")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ShippingMethodSetLocalizedDescriptionAction":
        from ._schemas.shipping_method import (
            ShippingMethodSetLocalizedDescriptionActionSchema,
        )

        return ShippingMethodSetLocalizedDescriptionActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shipping_method import (
            ShippingMethodSetLocalizedDescriptionActionSchema,
        )

        return ShippingMethodSetLocalizedDescriptionActionSchema().dump(self)


class ShippingMethodSetLocalizedNameAction(ShippingMethodUpdateAction):
    #: Value to set. If empty, any existing value will be removed.
    localized_name: typing.Optional["LocalizedString"]

    def __init__(self, *, localized_name: typing.Optional["LocalizedString"] = None):
        self.localized_name = localized_name

        super().__init__(action="setLocalizedName")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ShippingMethodSetLocalizedNameAction":
        from ._schemas.shipping_method import ShippingMethodSetLocalizedNameActionSchema

        return ShippingMethodSetLocalizedNameActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shipping_method import ShippingMethodSetLocalizedNameActionSchema

        return ShippingMethodSetLocalizedNameActionSchema().dump(self)


class ShippingMethodSetPredicateAction(ShippingMethodUpdateAction):
    #: A valid [Cart predicate](/projects/predicates#cart-predicates). If `predicate` is absent or `null`, it is removed if it exists.
    predicate: typing.Optional[str]

    def __init__(self, *, predicate: typing.Optional[str] = None):
        self.predicate = predicate

        super().__init__(action="setPredicate")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ShippingMethodSetPredicateAction":
        from ._schemas.shipping_method import ShippingMethodSetPredicateActionSchema

        return ShippingMethodSetPredicateActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shipping_method import ShippingMethodSetPredicateActionSchema

        return ShippingMethodSetPredicateActionSchema().dump(self)
