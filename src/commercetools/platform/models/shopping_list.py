# This file is automatically generated by the rmf-codegen project.
#
# The Python code generator is maintained by Lab Digital. If you want to
# contribute to this project then please do not edit this file directly
# but send a pull request to the Lab Digital fork of rmf-codegen at
# https://github.com/labd/rmf-codegen

import datetime
import enum
import typing

from ._abstract import _BaseType
from .common import BaseResource, Reference, ReferenceTypeId, ResourceIdentifier

if typing.TYPE_CHECKING:
    from .common import CreatedBy, LastModifiedBy, LocalizedString, ReferenceTypeId
    from .customer import CustomerReference, CustomerResourceIdentifier
    from .product import ProductVariant
    from .product_type import ProductTypeReference
    from .store import StoreKeyReference, StoreResourceIdentifier
    from .type import (
        CustomFields,
        CustomFieldsDraft,
        FieldContainer,
        TypeResourceIdentifier,
    )

__all__ = [
    "ShoppingList",
    "ShoppingListAddLineItemAction",
    "ShoppingListAddTextLineItemAction",
    "ShoppingListChangeLineItemQuantityAction",
    "ShoppingListChangeLineItemsOrderAction",
    "ShoppingListChangeNameAction",
    "ShoppingListChangeTextLineItemNameAction",
    "ShoppingListChangeTextLineItemQuantityAction",
    "ShoppingListChangeTextLineItemsOrderAction",
    "ShoppingListDraft",
    "ShoppingListLineItem",
    "ShoppingListLineItemDraft",
    "ShoppingListPagedQueryResponse",
    "ShoppingListReference",
    "ShoppingListRemoveLineItemAction",
    "ShoppingListRemoveTextLineItemAction",
    "ShoppingListResourceIdentifier",
    "ShoppingListSetAnonymousIdAction",
    "ShoppingListSetCustomFieldAction",
    "ShoppingListSetCustomTypeAction",
    "ShoppingListSetCustomerAction",
    "ShoppingListSetDeleteDaysAfterLastModificationAction",
    "ShoppingListSetDescriptionAction",
    "ShoppingListSetKeyAction",
    "ShoppingListSetLineItemCustomFieldAction",
    "ShoppingListSetLineItemCustomTypeAction",
    "ShoppingListSetSlugAction",
    "ShoppingListSetStoreAction",
    "ShoppingListSetTextLineItemCustomFieldAction",
    "ShoppingListSetTextLineItemCustomTypeAction",
    "ShoppingListSetTextLineItemDescriptionAction",
    "ShoppingListUpdate",
    "ShoppingListUpdateAction",
    "TextLineItem",
    "TextLineItemDraft",
]


class ShoppingList(BaseResource):
    #: Name of the ShoppingList.
    name: "LocalizedString"
    #: User-defined unique identifier of the ShoppingList.
    key: typing.Optional[str]
    #: Reference to a [Customer](ctp:api:type:Customer) associated with the ShoppingList.
    customer: typing.Optional["CustomerReference"]
    #: Human-readable identifiers usually used as deep-link URL to the related ShoppingList.
    #: Each slug is unique across a Project, but a ShoppingList can have the same slug for different languages.
    #: The slug must match the pattern `[a-zA-Z0-9_-]{2,256}`. For [good performance](/predicates/query#performance-considerations), indexes are provided for the first 15 `languages` set on the [Project](ctp:api:type:Project).
    slug: typing.Optional["LocalizedString"]
    #: Description of the ShoppingList.
    description: typing.Optional["LocalizedString"]
    #: Line Items (containing Products) of the ShoppingList.
    line_items: typing.List["ShoppingListLineItem"]
    #: Line Items (containing text values) of the ShoppingList.
    text_line_items: typing.List["TextLineItem"]
    #: Number of days after which the ShoppingList will be automatically deleted if it has not been modified.
    delete_days_after_last_modification: typing.Optional[int]
    #: Identifies ShoppingLists belonging to an [anonymous session](ctp:api:type:AnonymousSession).
    anonymous_id: typing.Optional[str]
    #: Store to which the ShoppingList is assigned.
    store: typing.Optional["StoreKeyReference"]
    #: Custom Fields defined for the ShoppingList.
    custom: typing.Optional["CustomFields"]
    #: IDs and references that last modified the ShoppingList.
    last_modified_by: typing.Optional["LastModifiedBy"]
    #: IDs and references that created the ShoppingList.
    created_by: typing.Optional["CreatedBy"]

    def __init__(
        self,
        *,
        id: str,
        version: int,
        created_at: datetime.datetime,
        last_modified_at: datetime.datetime,
        name: "LocalizedString",
        key: typing.Optional[str] = None,
        customer: typing.Optional["CustomerReference"] = None,
        slug: typing.Optional["LocalizedString"] = None,
        description: typing.Optional["LocalizedString"] = None,
        line_items: typing.List["ShoppingListLineItem"],
        text_line_items: typing.List["TextLineItem"],
        delete_days_after_last_modification: typing.Optional[int] = None,
        anonymous_id: typing.Optional[str] = None,
        store: typing.Optional["StoreKeyReference"] = None,
        custom: typing.Optional["CustomFields"] = None,
        last_modified_by: typing.Optional["LastModifiedBy"] = None,
        created_by: typing.Optional["CreatedBy"] = None
    ):
        self.name = name
        self.key = key
        self.customer = customer
        self.slug = slug
        self.description = description
        self.line_items = line_items
        self.text_line_items = text_line_items
        self.delete_days_after_last_modification = delete_days_after_last_modification
        self.anonymous_id = anonymous_id
        self.store = store
        self.custom = custom
        self.last_modified_by = last_modified_by
        self.created_by = created_by

        super().__init__(
            id=id,
            version=version,
            created_at=created_at,
            last_modified_at=last_modified_at,
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ShoppingList":
        from ._schemas.shopping_list import ShoppingListSchema

        return ShoppingListSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shopping_list import ShoppingListSchema

        return ShoppingListSchema().dump(self)


class ShoppingListDraft(_BaseType):
    #: Name of the ShoppingList.
    name: "LocalizedString"
    #: Human-readable identifiers usually used as deep-link URL to the related ShoppingList.
    #: Each slug is unique across a Project, but a ShoppingList can have the same slug for different languages.
    #: The slug must match the pattern `[a-zA-Z0-9_-]{2,256}`.
    slug: typing.Optional["LocalizedString"]
    #: The [Customer](ctp:api:type:Customer) the ShoppingList should be associated to.
    customer: typing.Optional["CustomerResourceIdentifier"]
    #: User-defined unique identifier for the ShoppingList.
    key: typing.Optional[str]
    #: Description of the ShoppingList.
    description: typing.Optional["LocalizedString"]
    #: Identifies ShoppingLists belonging to an [anonymous session](ctp:api:type:AnonymousSession).
    anonymous_id: typing.Optional[str]
    #: Number of days after which the ShoppingList will be automatically deleted if it has not been modified. If not set, the [default value](ctp:api:type:ShoppingListsConfiguration) configured in the [Project](ctp:api:type:Project) is used.
    delete_days_after_last_modification: typing.Optional[int]
    #: Line Items (containing Products) to add to the ShoppingList.
    line_items: typing.Optional[typing.List["ShoppingListLineItemDraft"]]
    #: Line Items (containing text values) to add to the ShoppingList.
    text_line_items: typing.Optional[typing.List["TextLineItemDraft"]]
    #: Assigns the new ShoppingList to the [Store](ctp:api:type:Store).
    store: typing.Optional["StoreResourceIdentifier"]
    #: Custom Fields defined for the ShoppingList.
    custom: typing.Optional["CustomFieldsDraft"]

    def __init__(
        self,
        *,
        name: "LocalizedString",
        slug: typing.Optional["LocalizedString"] = None,
        customer: typing.Optional["CustomerResourceIdentifier"] = None,
        key: typing.Optional[str] = None,
        description: typing.Optional["LocalizedString"] = None,
        anonymous_id: typing.Optional[str] = None,
        delete_days_after_last_modification: typing.Optional[int] = None,
        line_items: typing.Optional[typing.List["ShoppingListLineItemDraft"]] = None,
        text_line_items: typing.Optional[typing.List["TextLineItemDraft"]] = None,
        store: typing.Optional["StoreResourceIdentifier"] = None,
        custom: typing.Optional["CustomFieldsDraft"] = None
    ):
        self.name = name
        self.slug = slug
        self.customer = customer
        self.key = key
        self.description = description
        self.anonymous_id = anonymous_id
        self.delete_days_after_last_modification = delete_days_after_last_modification
        self.line_items = line_items
        self.text_line_items = text_line_items
        self.store = store
        self.custom = custom

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ShoppingListDraft":
        from ._schemas.shopping_list import ShoppingListDraftSchema

        return ShoppingListDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shopping_list import ShoppingListDraftSchema

        return ShoppingListDraftSchema().dump(self)


class ShoppingListLineItem(_BaseType):
    """ShoppingListLineItems are Line Items that contain references to [ProductVariants](ctp:api:type:ProductVariant) in a [Product](ctp:api:type:Product).

    In addition to standard [Reference Expansion](/general-concepts#reference-expansion), a ShoppingListLineItem offers expansion on `productSlug` and `variant`, defined with the query parameter `expand`.

    """

    #: Date and time (UTC) the ShoppingListLineItem was added to the ShoppingList.
    added_at: datetime.datetime
    #: Custom Fields of the ShoppingListLineItem.
    custom: typing.Optional["CustomFields"]
    #: If the Product or Product Variant is deleted, `deactivatedAt` is the date and time (UTC) of deletion.
    #:
    #: This data is updated in an [eventual consistent manner](/general-concepts#eventual-consistency) when the Product Variant cannot be ordered anymore.
    deactivated_at: typing.Optional[datetime.datetime]
    #: Unique identifier of the ShoppingListLineItem.
    id: str
    #: User-defined identifier of the ShoppingListLineItem. It is unique per [ShoppingList](ctp:api:type:ShoppingList).
    key: typing.Optional[str]
    #: Name of the Product.
    #:
    #: This data is updated in an [eventual consistent manner](/general-concepts#eventual-consistency) when the Product's name changes.
    name: "LocalizedString"
    #: Unique identifier of a [Product](ctp:api:type:Product).
    product_id: str
    #: The Product Type defining the Attributes of the [Product](ctp:api:type:Product).
    product_type: "ProductTypeReference"
    #: Number of Products in the ShoppingListLineItem.
    quantity: int
    #: `id` of the [ProductVariant](ctp:api:type:ProductVariant) the ShoppingListLineItem refers to. If not set, the ShoppingListLineItem refers to the Master Variant.
    variant_id: typing.Optional[int]
    #: Data of the [ProductVariant](ctp:api:type:ProductVariant).
    #:
    #: Returned when expanded using `expand=lineItems[*].variant`. You cannot expand only a single element of the array.
    variant: typing.Optional["ProductVariant"]
    #: Slug of the current [ProductData](ctp:api:type:ProductData).
    #:
    #: Returned when expanded using `expand=lineItems[*].productSlug`. You cannot expand only a single element of the array.
    product_slug: typing.Optional["LocalizedString"]

    def __init__(
        self,
        *,
        added_at: datetime.datetime,
        custom: typing.Optional["CustomFields"] = None,
        deactivated_at: typing.Optional[datetime.datetime] = None,
        id: str,
        key: typing.Optional[str] = None,
        name: "LocalizedString",
        product_id: str,
        product_type: "ProductTypeReference",
        quantity: int,
        variant_id: typing.Optional[int] = None,
        variant: typing.Optional["ProductVariant"] = None,
        product_slug: typing.Optional["LocalizedString"] = None
    ):
        self.added_at = added_at
        self.custom = custom
        self.deactivated_at = deactivated_at
        self.id = id
        self.key = key
        self.name = name
        self.product_id = product_id
        self.product_type = product_type
        self.quantity = quantity
        self.variant_id = variant_id
        self.variant = variant
        self.product_slug = product_slug

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ShoppingListLineItem":
        from ._schemas.shopping_list import ShoppingListLineItemSchema

        return ShoppingListLineItemSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shopping_list import ShoppingListLineItemSchema

        return ShoppingListLineItemSchema().dump(self)


class ShoppingListLineItemDraft(_BaseType):
    """The [ProductVariant](ctp:api:type:ProductVariant) to be included in the ShoppingListLineItem must be specified using the `productID` and `variantID`, or by the `sku`."""

    #: User-defined identifier of the ShoppingListLineItem. Must be unique per [ShoppingList](ctp:api:type:ShoppingList).
    key: typing.Optional[str]
    #: Unique identifier of a [Product](ctp:api:type:Product).
    product_id: typing.Optional[str]
    #: `id` of the [ProductVariant](ctp:api:type:ProductVariant). If not set, the ShoppingListLineItem refers to the Master Variant.
    variant_id: typing.Optional[int]
    #: `sku` of the [ProductVariant](ctp:api:type:ProductVariant).
    sku: typing.Optional[str]
    #: Date and time the ShoppingListLineItem is added to the [ShoppingList](ctp:api:type:ShoppingList). If not set, the current date and time (UTC) is used.
    added_at: typing.Optional[datetime.datetime]
    #: Custom Fields of the ShoppingListLineItem.
    custom: typing.Optional["CustomFieldsDraft"]
    #: Number of Products in the ShoppingListLineItem.
    quantity: typing.Optional[int]

    def __init__(
        self,
        *,
        key: typing.Optional[str] = None,
        product_id: typing.Optional[str] = None,
        variant_id: typing.Optional[int] = None,
        sku: typing.Optional[str] = None,
        added_at: typing.Optional[datetime.datetime] = None,
        custom: typing.Optional["CustomFieldsDraft"] = None,
        quantity: typing.Optional[int] = None
    ):
        self.key = key
        self.product_id = product_id
        self.variant_id = variant_id
        self.sku = sku
        self.added_at = added_at
        self.custom = custom
        self.quantity = quantity

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ShoppingListLineItemDraft":
        from ._schemas.shopping_list import ShoppingListLineItemDraftSchema

        return ShoppingListLineItemDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shopping_list import ShoppingListLineItemDraftSchema

        return ShoppingListLineItemDraftSchema().dump(self)


class ShoppingListPagedQueryResponse(_BaseType):
    #: Number of [results requested](/../api/general-concepts#limit).
    limit: int
    #: Actual number of results returned.
    count: int
    #: Total number of results matching the query.
    #: This number is an estimation that is not [strongly consistent](/../api/general-concepts#strong-consistency).
    #: This field is returned by default.
    #: For improved performance, calculating this field can be deactivated by using the query parameter `withTotal=false`.
    #: When the results are filtered with a [Query Predicate](/../api/predicates/query), `total` is subject to a [limit](/../api/limits#queries).
    total: typing.Optional[int]
    #: Number of [elements skipped](/../api/general-concepts#offset).
    offset: int
    #: [ShoppingLists](ctp:api:type:ShoppingList) matching the query.
    results: typing.List["ShoppingList"]

    def __init__(
        self,
        *,
        limit: int,
        count: int,
        total: typing.Optional[int] = None,
        offset: int,
        results: typing.List["ShoppingList"]
    ):
        self.limit = limit
        self.count = count
        self.total = total
        self.offset = offset
        self.results = results

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ShoppingListPagedQueryResponse":
        from ._schemas.shopping_list import ShoppingListPagedQueryResponseSchema

        return ShoppingListPagedQueryResponseSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shopping_list import ShoppingListPagedQueryResponseSchema

        return ShoppingListPagedQueryResponseSchema().dump(self)


class ShoppingListReference(Reference):
    """[Reference](ctp:api:type:Reference) to a [ShoppingList](ctp:api:type:ShoppingList)."""

    #: Contains the representation of the expanded ShoppingList. Only present in responses to requests with [Reference Expansion](/../api/general-concepts#reference-expansion) for ShoppingLists.
    obj: typing.Optional["ShoppingList"]

    def __init__(self, *, id: str, obj: typing.Optional["ShoppingList"] = None):
        self.obj = obj

        super().__init__(id=id, type_id=ReferenceTypeId.SHOPPING_LIST)

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ShoppingListReference":
        from ._schemas.shopping_list import ShoppingListReferenceSchema

        return ShoppingListReferenceSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shopping_list import ShoppingListReferenceSchema

        return ShoppingListReferenceSchema().dump(self)


class ShoppingListResourceIdentifier(ResourceIdentifier):
    """[ResourceIdentifier](ctp:api:type:ResourceIdentifier) to a [ShoppingList](ctp:api:type:ShoppingList). Either `id` or `key` is required. If both are set, an [InvalidJsonInput](/../api/errors#invalidjsoninput) error is returned."""

    def __init__(
        self, *, id: typing.Optional[str] = None, key: typing.Optional[str] = None
    ):

        super().__init__(id=id, key=key, type_id=ReferenceTypeId.SHOPPING_LIST)

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ShoppingListResourceIdentifier":
        from ._schemas.shopping_list import ShoppingListResourceIdentifierSchema

        return ShoppingListResourceIdentifierSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shopping_list import ShoppingListResourceIdentifierSchema

        return ShoppingListResourceIdentifierSchema().dump(self)


class ShoppingListUpdate(_BaseType):
    #: Expected version of the ShoppingList on which the changes should be applied.
    #: If the expected version does not match the actual version, a [ConcurrentModification](ctp:api:type:ConcurrentModificationError) error will be returned.
    version: int
    #: List of update actions to be performed on the ShoppingList.
    actions: typing.List["ShoppingListUpdateAction"]

    def __init__(
        self, *, version: int, actions: typing.List["ShoppingListUpdateAction"]
    ):
        self.version = version
        self.actions = actions

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "ShoppingListUpdate":
        from ._schemas.shopping_list import ShoppingListUpdateSchema

        return ShoppingListUpdateSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shopping_list import ShoppingListUpdateSchema

        return ShoppingListUpdateSchema().dump(self)


class ShoppingListUpdateAction(_BaseType):
    action: str

    def __init__(self, *, action: str):
        self.action = action

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ShoppingListUpdateAction":
        if data["action"] == "addLineItem":
            from ._schemas.shopping_list import ShoppingListAddLineItemActionSchema

            return ShoppingListAddLineItemActionSchema().load(data)
        if data["action"] == "addTextLineItem":
            from ._schemas.shopping_list import ShoppingListAddTextLineItemActionSchema

            return ShoppingListAddTextLineItemActionSchema().load(data)
        if data["action"] == "changeLineItemQuantity":
            from ._schemas.shopping_list import (
                ShoppingListChangeLineItemQuantityActionSchema,
            )

            return ShoppingListChangeLineItemQuantityActionSchema().load(data)
        if data["action"] == "changeLineItemsOrder":
            from ._schemas.shopping_list import (
                ShoppingListChangeLineItemsOrderActionSchema,
            )

            return ShoppingListChangeLineItemsOrderActionSchema().load(data)
        if data["action"] == "changeName":
            from ._schemas.shopping_list import ShoppingListChangeNameActionSchema

            return ShoppingListChangeNameActionSchema().load(data)
        if data["action"] == "changeTextLineItemName":
            from ._schemas.shopping_list import (
                ShoppingListChangeTextLineItemNameActionSchema,
            )

            return ShoppingListChangeTextLineItemNameActionSchema().load(data)
        if data["action"] == "changeTextLineItemQuantity":
            from ._schemas.shopping_list import (
                ShoppingListChangeTextLineItemQuantityActionSchema,
            )

            return ShoppingListChangeTextLineItemQuantityActionSchema().load(data)
        if data["action"] == "changeTextLineItemsOrder":
            from ._schemas.shopping_list import (
                ShoppingListChangeTextLineItemsOrderActionSchema,
            )

            return ShoppingListChangeTextLineItemsOrderActionSchema().load(data)
        if data["action"] == "removeLineItem":
            from ._schemas.shopping_list import ShoppingListRemoveLineItemActionSchema

            return ShoppingListRemoveLineItemActionSchema().load(data)
        if data["action"] == "removeTextLineItem":
            from ._schemas.shopping_list import (
                ShoppingListRemoveTextLineItemActionSchema,
            )

            return ShoppingListRemoveTextLineItemActionSchema().load(data)
        if data["action"] == "setAnonymousId":
            from ._schemas.shopping_list import ShoppingListSetAnonymousIdActionSchema

            return ShoppingListSetAnonymousIdActionSchema().load(data)
        if data["action"] == "setCustomField":
            from ._schemas.shopping_list import ShoppingListSetCustomFieldActionSchema

            return ShoppingListSetCustomFieldActionSchema().load(data)
        if data["action"] == "setCustomType":
            from ._schemas.shopping_list import ShoppingListSetCustomTypeActionSchema

            return ShoppingListSetCustomTypeActionSchema().load(data)
        if data["action"] == "setCustomer":
            from ._schemas.shopping_list import ShoppingListSetCustomerActionSchema

            return ShoppingListSetCustomerActionSchema().load(data)
        if data["action"] == "setDeleteDaysAfterLastModification":
            from ._schemas.shopping_list import (
                ShoppingListSetDeleteDaysAfterLastModificationActionSchema,
            )

            return ShoppingListSetDeleteDaysAfterLastModificationActionSchema().load(
                data
            )
        if data["action"] == "setDescription":
            from ._schemas.shopping_list import ShoppingListSetDescriptionActionSchema

            return ShoppingListSetDescriptionActionSchema().load(data)
        if data["action"] == "setKey":
            from ._schemas.shopping_list import ShoppingListSetKeyActionSchema

            return ShoppingListSetKeyActionSchema().load(data)
        if data["action"] == "setLineItemCustomField":
            from ._schemas.shopping_list import (
                ShoppingListSetLineItemCustomFieldActionSchema,
            )

            return ShoppingListSetLineItemCustomFieldActionSchema().load(data)
        if data["action"] == "setLineItemCustomType":
            from ._schemas.shopping_list import (
                ShoppingListSetLineItemCustomTypeActionSchema,
            )

            return ShoppingListSetLineItemCustomTypeActionSchema().load(data)
        if data["action"] == "setSlug":
            from ._schemas.shopping_list import ShoppingListSetSlugActionSchema

            return ShoppingListSetSlugActionSchema().load(data)
        if data["action"] == "setStore":
            from ._schemas.shopping_list import ShoppingListSetStoreActionSchema

            return ShoppingListSetStoreActionSchema().load(data)
        if data["action"] == "setTextLineItemCustomField":
            from ._schemas.shopping_list import (
                ShoppingListSetTextLineItemCustomFieldActionSchema,
            )

            return ShoppingListSetTextLineItemCustomFieldActionSchema().load(data)
        if data["action"] == "setTextLineItemCustomType":
            from ._schemas.shopping_list import (
                ShoppingListSetTextLineItemCustomTypeActionSchema,
            )

            return ShoppingListSetTextLineItemCustomTypeActionSchema().load(data)
        if data["action"] == "setTextLineItemDescription":
            from ._schemas.shopping_list import (
                ShoppingListSetTextLineItemDescriptionActionSchema,
            )

            return ShoppingListSetTextLineItemDescriptionActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shopping_list import ShoppingListUpdateActionSchema

        return ShoppingListUpdateActionSchema().dump(self)


class TextLineItem(_BaseType):
    """TextLineItems are Line Items that use text values instead of references to Products."""

    #: Date and time (UTC) the TextLineItem was added to the [ShoppingList](ctp:api:type:ShoppingList).
    added_at: datetime.datetime
    #: Custom Fields of the TextLineItem.
    custom: typing.Optional["CustomFields"]
    #: Description of the TextLineItem.
    description: typing.Optional["LocalizedString"]
    #: Unique identifier of the TextLineItem.
    id: str
    #: User-defined identifier of the TextLineItem. It is unique per [ShoppingList](ctp:api:type:ShoppingList).
    key: typing.Optional[str]
    #: Name of the TextLineItem.
    name: "LocalizedString"
    #: Number of entries in the TextLineItem.
    quantity: int

    def __init__(
        self,
        *,
        added_at: datetime.datetime,
        custom: typing.Optional["CustomFields"] = None,
        description: typing.Optional["LocalizedString"] = None,
        id: str,
        key: typing.Optional[str] = None,
        name: "LocalizedString",
        quantity: int
    ):
        self.added_at = added_at
        self.custom = custom
        self.description = description
        self.id = id
        self.key = key
        self.name = name
        self.quantity = quantity

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "TextLineItem":
        from ._schemas.shopping_list import TextLineItemSchema

        return TextLineItemSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shopping_list import TextLineItemSchema

        return TextLineItemSchema().dump(self)


class TextLineItemDraft(_BaseType):
    #: User-defined unique identifier of the TextLineItem. Must be unique per [ShoppingList](ctp:api:type:ShoppingList).
    key: typing.Optional[str]
    #: Date and time the TextLineItem is added to the [ShoppingList](ctp:api:type:ShoppingList). If not set, the current date and time (UTC) is used.
    added_at: typing.Optional[datetime.datetime]
    #: Custom Fields for the TextLineItem.
    custom: typing.Optional["CustomFieldsDraft"]
    #: Description of the TextLineItem.
    description: typing.Optional["LocalizedString"]
    #: Name of the TextLineItem.
    name: "LocalizedString"
    #: Number of entries in the TextLineItem.
    quantity: typing.Optional[int]

    def __init__(
        self,
        *,
        key: typing.Optional[str] = None,
        added_at: typing.Optional[datetime.datetime] = None,
        custom: typing.Optional["CustomFieldsDraft"] = None,
        description: typing.Optional["LocalizedString"] = None,
        name: "LocalizedString",
        quantity: typing.Optional[int] = None
    ):
        self.key = key
        self.added_at = added_at
        self.custom = custom
        self.description = description
        self.name = name
        self.quantity = quantity

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "TextLineItemDraft":
        from ._schemas.shopping_list import TextLineItemDraftSchema

        return TextLineItemDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shopping_list import TextLineItemDraftSchema

        return TextLineItemDraftSchema().dump(self)


class ShoppingListAddLineItemAction(ShoppingListUpdateAction):
    """The [ProductVariant](ctp:api:type:ProductVariant) to be included in the ShoppingListLineItem must be specified using the `productID` and `variantID`, or by the `sku`.
    If the ShoppingList already contains a ShoppingListLineItem for the same Product Variant with the same Custom Fields, then only the quantity of the existing ShoppingListLineItem is increased.
    A ShoppingListLineItem with an empty `variantId` is not considered the same as a ShoppingListLineItem with a `variantId` currently referring to the Master Variant.

    """

    #: User-defined identifier of the ShoppingListLineItem. Must be unique per [ShoppingList](ctp:api:type:ShoppingList).
    key: typing.Optional[str]
    #: `sku` of the [ProductVariant](ctp:api:type:ProductVariant).
    sku: typing.Optional[str]
    #: Unique identifier of a [Product](ctp:api:type:Product).
    product_id: typing.Optional[str]
    #: `id` of the [ProductVariant](ctp:api:type:ProductVariant). If not set, the ShoppingListLineItem refers to the Master Variant.
    variant_id: typing.Optional[int]
    #: Number of Products in the ShoppingListLineItem.
    quantity: typing.Optional[int]
    #: Date and time the TextLineItem is added to the [ShoppingList](ctp:api:type:ShoppingList). If not set, the current date and time (UTC) is used.
    added_at: typing.Optional[datetime.datetime]
    #: Custom Fields defined for the ShoppingListLineItem.
    custom: typing.Optional["CustomFieldsDraft"]

    def __init__(
        self,
        *,
        key: typing.Optional[str] = None,
        sku: typing.Optional[str] = None,
        product_id: typing.Optional[str] = None,
        variant_id: typing.Optional[int] = None,
        quantity: typing.Optional[int] = None,
        added_at: typing.Optional[datetime.datetime] = None,
        custom: typing.Optional["CustomFieldsDraft"] = None
    ):
        self.key = key
        self.sku = sku
        self.product_id = product_id
        self.variant_id = variant_id
        self.quantity = quantity
        self.added_at = added_at
        self.custom = custom

        super().__init__(action="addLineItem")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ShoppingListAddLineItemAction":
        from ._schemas.shopping_list import ShoppingListAddLineItemActionSchema

        return ShoppingListAddLineItemActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shopping_list import ShoppingListAddLineItemActionSchema

        return ShoppingListAddLineItemActionSchema().dump(self)


class ShoppingListAddTextLineItemAction(ShoppingListUpdateAction):
    #: Name of the TextLineItem.
    name: "LocalizedString"
    #: User-defined identifier of the TextLineItem. Must be unique per [ShoppingList](ctp:api:type:ShoppingList).
    key: typing.Optional[str]
    #: Description of the TextLineItem.
    description: typing.Optional["LocalizedString"]
    #: Number of entries in the TextLineItem.
    quantity: typing.Optional[int]
    #: Date and time the TextLineItem is added to the [ShoppingList](ctp:api:type:ShoppingList). If not set, the current date and time (UTC) is used.
    added_at: typing.Optional[datetime.datetime]
    #: Custom Fields defined for the TextLineItem.
    custom: typing.Optional["CustomFieldsDraft"]

    def __init__(
        self,
        *,
        name: "LocalizedString",
        key: typing.Optional[str] = None,
        description: typing.Optional["LocalizedString"] = None,
        quantity: typing.Optional[int] = None,
        added_at: typing.Optional[datetime.datetime] = None,
        custom: typing.Optional["CustomFieldsDraft"] = None
    ):
        self.name = name
        self.key = key
        self.description = description
        self.quantity = quantity
        self.added_at = added_at
        self.custom = custom

        super().__init__(action="addTextLineItem")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ShoppingListAddTextLineItemAction":
        from ._schemas.shopping_list import ShoppingListAddTextLineItemActionSchema

        return ShoppingListAddTextLineItemActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shopping_list import ShoppingListAddTextLineItemActionSchema

        return ShoppingListAddTextLineItemActionSchema().dump(self)


class ShoppingListChangeLineItemQuantityAction(ShoppingListUpdateAction):
    #: The `id` of the [ShoppingListLineItem](ctp:api:type:ShoppingListLineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    line_item_id: typing.Optional[str]
    #: The `key` of the [ShoppingListLineItem](ctp:api:type:ShoppingListLineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    line_item_key: typing.Optional[str]
    #: New value to set. If `0`, the ShoppingListLineItem is removed from the ShoppingList.
    quantity: int

    def __init__(
        self,
        *,
        line_item_id: typing.Optional[str] = None,
        line_item_key: typing.Optional[str] = None,
        quantity: int
    ):
        self.line_item_id = line_item_id
        self.line_item_key = line_item_key
        self.quantity = quantity

        super().__init__(action="changeLineItemQuantity")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ShoppingListChangeLineItemQuantityAction":
        from ._schemas.shopping_list import (
            ShoppingListChangeLineItemQuantityActionSchema,
        )

        return ShoppingListChangeLineItemQuantityActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shopping_list import (
            ShoppingListChangeLineItemQuantityActionSchema,
        )

        return ShoppingListChangeLineItemQuantityActionSchema().dump(self)


class ShoppingListChangeLineItemsOrderAction(ShoppingListUpdateAction):
    #: All existing ShoppingListLineItem `id`s in the desired new order.
    line_item_order: typing.List["str"]

    def __init__(self, *, line_item_order: typing.List["str"]):
        self.line_item_order = line_item_order

        super().__init__(action="changeLineItemsOrder")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ShoppingListChangeLineItemsOrderAction":
        from ._schemas.shopping_list import ShoppingListChangeLineItemsOrderActionSchema

        return ShoppingListChangeLineItemsOrderActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shopping_list import ShoppingListChangeLineItemsOrderActionSchema

        return ShoppingListChangeLineItemsOrderActionSchema().dump(self)


class ShoppingListChangeNameAction(ShoppingListUpdateAction):
    #: New value to set. Must not be empty.
    name: "LocalizedString"

    def __init__(self, *, name: "LocalizedString"):
        self.name = name

        super().__init__(action="changeName")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ShoppingListChangeNameAction":
        from ._schemas.shopping_list import ShoppingListChangeNameActionSchema

        return ShoppingListChangeNameActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shopping_list import ShoppingListChangeNameActionSchema

        return ShoppingListChangeNameActionSchema().dump(self)


class ShoppingListChangeTextLineItemNameAction(ShoppingListUpdateAction):
    #: The `id` of the [TextLineItem](ctp:api:type:TextLineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    text_line_item_id: typing.Optional[str]
    #: The `key` of the [TextLineItem](ctp:api:type:TextLineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    text_line_item_key: typing.Optional[str]
    #: New value to set. Must not be empty.
    name: "LocalizedString"

    def __init__(
        self,
        *,
        text_line_item_id: typing.Optional[str] = None,
        text_line_item_key: typing.Optional[str] = None,
        name: "LocalizedString"
    ):
        self.text_line_item_id = text_line_item_id
        self.text_line_item_key = text_line_item_key
        self.name = name

        super().__init__(action="changeTextLineItemName")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ShoppingListChangeTextLineItemNameAction":
        from ._schemas.shopping_list import (
            ShoppingListChangeTextLineItemNameActionSchema,
        )

        return ShoppingListChangeTextLineItemNameActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shopping_list import (
            ShoppingListChangeTextLineItemNameActionSchema,
        )

        return ShoppingListChangeTextLineItemNameActionSchema().dump(self)


class ShoppingListChangeTextLineItemQuantityAction(ShoppingListUpdateAction):
    #: The `id` of the [TextLineItem](ctp:api:type:TextLineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    text_line_item_id: typing.Optional[str]
    #: The `key` of the [TextLineItem](ctp:api:type:TextLineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    text_line_item_key: typing.Optional[str]
    #: New value to set. If `0`, the TextLineItem is removed from the ShoppingList.
    quantity: int

    def __init__(
        self,
        *,
        text_line_item_id: typing.Optional[str] = None,
        text_line_item_key: typing.Optional[str] = None,
        quantity: int
    ):
        self.text_line_item_id = text_line_item_id
        self.text_line_item_key = text_line_item_key
        self.quantity = quantity

        super().__init__(action="changeTextLineItemQuantity")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ShoppingListChangeTextLineItemQuantityAction":
        from ._schemas.shopping_list import (
            ShoppingListChangeTextLineItemQuantityActionSchema,
        )

        return ShoppingListChangeTextLineItemQuantityActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shopping_list import (
            ShoppingListChangeTextLineItemQuantityActionSchema,
        )

        return ShoppingListChangeTextLineItemQuantityActionSchema().dump(self)


class ShoppingListChangeTextLineItemsOrderAction(ShoppingListUpdateAction):
    #: Must contain all existing [TextLineItem](ctp:api:type:TextLineItem) `id`s in the desired new order.
    text_line_item_order: typing.List["str"]

    def __init__(self, *, text_line_item_order: typing.List["str"]):
        self.text_line_item_order = text_line_item_order

        super().__init__(action="changeTextLineItemsOrder")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ShoppingListChangeTextLineItemsOrderAction":
        from ._schemas.shopping_list import (
            ShoppingListChangeTextLineItemsOrderActionSchema,
        )

        return ShoppingListChangeTextLineItemsOrderActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shopping_list import (
            ShoppingListChangeTextLineItemsOrderActionSchema,
        )

        return ShoppingListChangeTextLineItemsOrderActionSchema().dump(self)


class ShoppingListRemoveLineItemAction(ShoppingListUpdateAction):
    #: The `id` of the [ShoppingListLineItem](ctp:api:type:ShoppingListLineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    line_item_id: typing.Optional[str]
    #: The `key` of the [ShoppingListLineItem](ctp:api:type:ShoppingListLineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    line_item_key: typing.Optional[str]
    #: Amount to remove from the `quantity` of the ShoppingListLineItem. If not set, the ShoppingListLineItem is removed from the ShoppingList. If this value matches or exceeds the current `quantity` of the ShoppingListLineItem, the ShoppingListLineItem is removed from the ShoppingList.
    quantity: typing.Optional[int]

    def __init__(
        self,
        *,
        line_item_id: typing.Optional[str] = None,
        line_item_key: typing.Optional[str] = None,
        quantity: typing.Optional[int] = None
    ):
        self.line_item_id = line_item_id
        self.line_item_key = line_item_key
        self.quantity = quantity

        super().__init__(action="removeLineItem")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ShoppingListRemoveLineItemAction":
        from ._schemas.shopping_list import ShoppingListRemoveLineItemActionSchema

        return ShoppingListRemoveLineItemActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shopping_list import ShoppingListRemoveLineItemActionSchema

        return ShoppingListRemoveLineItemActionSchema().dump(self)


class ShoppingListRemoveTextLineItemAction(ShoppingListUpdateAction):
    #: The `id` of the [TextLineItem](ctp:api:type:TextLineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    text_line_item_id: typing.Optional[str]
    #: The `key` of the [TextLineItem](ctp:api:type:TextLineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    text_line_item_key: typing.Optional[str]
    #: Amount to remove from the `quantity` of the TextLineItem. If not set, the TextLineItem is removed from the ShoppingList. If this value matches or exceeds the current `quantity` of the TextLineItem, the TextLineItem is removed from the ShoppingList.
    quantity: typing.Optional[int]

    def __init__(
        self,
        *,
        text_line_item_id: typing.Optional[str] = None,
        text_line_item_key: typing.Optional[str] = None,
        quantity: typing.Optional[int] = None
    ):
        self.text_line_item_id = text_line_item_id
        self.text_line_item_key = text_line_item_key
        self.quantity = quantity

        super().__init__(action="removeTextLineItem")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ShoppingListRemoveTextLineItemAction":
        from ._schemas.shopping_list import ShoppingListRemoveTextLineItemActionSchema

        return ShoppingListRemoveTextLineItemActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shopping_list import ShoppingListRemoveTextLineItemActionSchema

        return ShoppingListRemoveTextLineItemActionSchema().dump(self)


class ShoppingListSetAnonymousIdAction(ShoppingListUpdateAction):
    #: Value to set. If empty, any existing value will be removed.
    anonymous_id: typing.Optional[str]

    def __init__(self, *, anonymous_id: typing.Optional[str] = None):
        self.anonymous_id = anonymous_id

        super().__init__(action="setAnonymousId")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ShoppingListSetAnonymousIdAction":
        from ._schemas.shopping_list import ShoppingListSetAnonymousIdActionSchema

        return ShoppingListSetAnonymousIdActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shopping_list import ShoppingListSetAnonymousIdActionSchema

        return ShoppingListSetAnonymousIdActionSchema().dump(self)


class ShoppingListSetCustomFieldAction(ShoppingListUpdateAction):
    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: Removing a field that does not exist returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
    #: If `value` is provided, it is set for the field defined by `name`.
    value: typing.Optional[typing.Any]

    def __init__(self, *, name: str, value: typing.Optional[typing.Any] = None):
        self.name = name
        self.value = value

        super().__init__(action="setCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ShoppingListSetCustomFieldAction":
        from ._schemas.shopping_list import ShoppingListSetCustomFieldActionSchema

        return ShoppingListSetCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shopping_list import ShoppingListSetCustomFieldActionSchema

        return ShoppingListSetCustomFieldActionSchema().dump(self)


class ShoppingListSetCustomTypeAction(ShoppingListUpdateAction):
    #: Defines the [Type](ctp:api:type:Type) that extends the ShoppingList with [Custom Fields](/../api/projects/custom-fields).
    #: If absent, any existing Type and Custom Fields are removed from the ShoppingList.
    type: typing.Optional["TypeResourceIdentifier"]
    #: Sets the [Custom Fields](/../api/projects/custom-fields) fields for the ShoppingList.
    fields: typing.Optional["FieldContainer"]

    def __init__(
        self,
        *,
        type: typing.Optional["TypeResourceIdentifier"] = None,
        fields: typing.Optional["FieldContainer"] = None
    ):
        self.type = type
        self.fields = fields

        super().__init__(action="setCustomType")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ShoppingListSetCustomTypeAction":
        from ._schemas.shopping_list import ShoppingListSetCustomTypeActionSchema

        return ShoppingListSetCustomTypeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shopping_list import ShoppingListSetCustomTypeActionSchema

        return ShoppingListSetCustomTypeActionSchema().dump(self)


class ShoppingListSetCustomerAction(ShoppingListUpdateAction):
    #: The [Customer](ctp:api:type:Customer) the ShoppingList should be associated to. If empty, any existing value will be removed.
    customer: typing.Optional["CustomerResourceIdentifier"]

    def __init__(
        self, *, customer: typing.Optional["CustomerResourceIdentifier"] = None
    ):
        self.customer = customer

        super().__init__(action="setCustomer")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ShoppingListSetCustomerAction":
        from ._schemas.shopping_list import ShoppingListSetCustomerActionSchema

        return ShoppingListSetCustomerActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shopping_list import ShoppingListSetCustomerActionSchema

        return ShoppingListSetCustomerActionSchema().dump(self)


class ShoppingListSetDeleteDaysAfterLastModificationAction(ShoppingListUpdateAction):
    #: Value to set. If empty, any existing value will be removed.
    delete_days_after_last_modification: typing.Optional[int]

    def __init__(
        self, *, delete_days_after_last_modification: typing.Optional[int] = None
    ):
        self.delete_days_after_last_modification = delete_days_after_last_modification

        super().__init__(action="setDeleteDaysAfterLastModification")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ShoppingListSetDeleteDaysAfterLastModificationAction":
        from ._schemas.shopping_list import (
            ShoppingListSetDeleteDaysAfterLastModificationActionSchema,
        )

        return ShoppingListSetDeleteDaysAfterLastModificationActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shopping_list import (
            ShoppingListSetDeleteDaysAfterLastModificationActionSchema,
        )

        return ShoppingListSetDeleteDaysAfterLastModificationActionSchema().dump(self)


class ShoppingListSetDescriptionAction(ShoppingListUpdateAction):
    #: Value to set. If empty, any existing value will be removed.
    description: typing.Optional["LocalizedString"]

    def __init__(self, *, description: typing.Optional["LocalizedString"] = None):
        self.description = description

        super().__init__(action="setDescription")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ShoppingListSetDescriptionAction":
        from ._schemas.shopping_list import ShoppingListSetDescriptionActionSchema

        return ShoppingListSetDescriptionActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shopping_list import ShoppingListSetDescriptionActionSchema

        return ShoppingListSetDescriptionActionSchema().dump(self)


class ShoppingListSetKeyAction(ShoppingListUpdateAction):
    #: Value to set. If empty, any existing value will be removed.
    key: typing.Optional[str]

    def __init__(self, *, key: typing.Optional[str] = None):
        self.key = key

        super().__init__(action="setKey")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ShoppingListSetKeyAction":
        from ._schemas.shopping_list import ShoppingListSetKeyActionSchema

        return ShoppingListSetKeyActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shopping_list import ShoppingListSetKeyActionSchema

        return ShoppingListSetKeyActionSchema().dump(self)


class ShoppingListSetLineItemCustomFieldAction(ShoppingListUpdateAction):
    #: The `id` of the [ShoppingListLineItem](ctp:api:type:ShoppingListLineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    line_item_id: typing.Optional[str]
    #: The `key` of the [ShoppingListLineItem](ctp:api:type:ShoppingListLineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    line_item_key: typing.Optional[str]
    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: Removing a field that does not exist returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
    #: If `value` is provided, it is set for the field defined by `name`.
    value: typing.Optional[typing.Any]

    def __init__(
        self,
        *,
        line_item_id: typing.Optional[str] = None,
        line_item_key: typing.Optional[str] = None,
        name: str,
        value: typing.Optional[typing.Any] = None
    ):
        self.line_item_id = line_item_id
        self.line_item_key = line_item_key
        self.name = name
        self.value = value

        super().__init__(action="setLineItemCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ShoppingListSetLineItemCustomFieldAction":
        from ._schemas.shopping_list import (
            ShoppingListSetLineItemCustomFieldActionSchema,
        )

        return ShoppingListSetLineItemCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shopping_list import (
            ShoppingListSetLineItemCustomFieldActionSchema,
        )

        return ShoppingListSetLineItemCustomFieldActionSchema().dump(self)


class ShoppingListSetLineItemCustomTypeAction(ShoppingListUpdateAction):
    #: The `id` of the [ShoppingListLineItem](ctp:api:type:ShoppingListLineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    line_item_id: typing.Optional[str]
    #: The `key` of the [ShoppingListLineItem](ctp:api:type:ShoppingListLineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    line_item_key: typing.Optional[str]
    #: Defines the [Type](ctp:api:type:Type) that extends the ShoppingListLineItem with [Custom Fields](/../api/projects/custom-fields).
    #: If absent, any existing Type and Custom Fields are removed from the ShoppingListLineItem.
    type: typing.Optional["TypeResourceIdentifier"]
    #: Sets the [Custom Fields](/../api/projects/custom-fields) fields for the ShoppingListLineItem.
    fields: typing.Optional["FieldContainer"]

    def __init__(
        self,
        *,
        line_item_id: typing.Optional[str] = None,
        line_item_key: typing.Optional[str] = None,
        type: typing.Optional["TypeResourceIdentifier"] = None,
        fields: typing.Optional["FieldContainer"] = None
    ):
        self.line_item_id = line_item_id
        self.line_item_key = line_item_key
        self.type = type
        self.fields = fields

        super().__init__(action="setLineItemCustomType")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ShoppingListSetLineItemCustomTypeAction":
        from ._schemas.shopping_list import (
            ShoppingListSetLineItemCustomTypeActionSchema,
        )

        return ShoppingListSetLineItemCustomTypeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shopping_list import (
            ShoppingListSetLineItemCustomTypeActionSchema,
        )

        return ShoppingListSetLineItemCustomTypeActionSchema().dump(self)


class ShoppingListSetSlugAction(ShoppingListUpdateAction):
    #: Value to set. If empty, any existing value will be removed. Each slug is unique across a Project, but a ShoppingList can have the same slug for different languages. Must match the pattern `^[A-Za-z0-9_-]{2,256}+$`
    slug: typing.Optional["LocalizedString"]

    def __init__(self, *, slug: typing.Optional["LocalizedString"] = None):
        self.slug = slug

        super().__init__(action="setSlug")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ShoppingListSetSlugAction":
        from ._schemas.shopping_list import ShoppingListSetSlugActionSchema

        return ShoppingListSetSlugActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shopping_list import ShoppingListSetSlugActionSchema

        return ShoppingListSetSlugActionSchema().dump(self)


class ShoppingListSetStoreAction(ShoppingListUpdateAction):
    #: The [Store](ctp:api:type:Store) the ShoppingList should be assigned to. If empty, any existing value will be removed.
    store: typing.Optional["StoreResourceIdentifier"]

    def __init__(self, *, store: typing.Optional["StoreResourceIdentifier"] = None):
        self.store = store

        super().__init__(action="setStore")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ShoppingListSetStoreAction":
        from ._schemas.shopping_list import ShoppingListSetStoreActionSchema

        return ShoppingListSetStoreActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shopping_list import ShoppingListSetStoreActionSchema

        return ShoppingListSetStoreActionSchema().dump(self)


class ShoppingListSetTextLineItemCustomFieldAction(ShoppingListUpdateAction):
    #: The `id` of the [TextLineItem](ctp:api:type:TextLineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    text_line_item_id: typing.Optional[str]
    #: The `key` of the [TextLineItem](ctp:api:type:TextLineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    text_line_item_key: typing.Optional[str]
    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: Removing a field that does not exist returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
    #: If `value` is provided, it is set for the field defined by `name`.
    value: typing.Optional[typing.Any]

    def __init__(
        self,
        *,
        text_line_item_id: typing.Optional[str] = None,
        text_line_item_key: typing.Optional[str] = None,
        name: str,
        value: typing.Optional[typing.Any] = None
    ):
        self.text_line_item_id = text_line_item_id
        self.text_line_item_key = text_line_item_key
        self.name = name
        self.value = value

        super().__init__(action="setTextLineItemCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ShoppingListSetTextLineItemCustomFieldAction":
        from ._schemas.shopping_list import (
            ShoppingListSetTextLineItemCustomFieldActionSchema,
        )

        return ShoppingListSetTextLineItemCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shopping_list import (
            ShoppingListSetTextLineItemCustomFieldActionSchema,
        )

        return ShoppingListSetTextLineItemCustomFieldActionSchema().dump(self)


class ShoppingListSetTextLineItemCustomTypeAction(ShoppingListUpdateAction):
    #: The `id` of the [TextLineItem](ctp:api:type:TextLineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    text_line_item_id: typing.Optional[str]
    #: The `key` of the [TextLineItem](ctp:api:type:TextLineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    text_line_item_key: typing.Optional[str]
    #: Defines the [Type](ctp:api:type:Type) that extends the TextLineItem with [Custom Fields](/../api/projects/custom-fields).
    #: If absent, any existing Type and Custom Fields are removed from the TextLineItem.
    type: typing.Optional["TypeResourceIdentifier"]
    #: Sets the [Custom Fields](/../api/projects/custom-fields) fields for the TextLineItem.
    fields: typing.Optional["FieldContainer"]

    def __init__(
        self,
        *,
        text_line_item_id: typing.Optional[str] = None,
        text_line_item_key: typing.Optional[str] = None,
        type: typing.Optional["TypeResourceIdentifier"] = None,
        fields: typing.Optional["FieldContainer"] = None
    ):
        self.text_line_item_id = text_line_item_id
        self.text_line_item_key = text_line_item_key
        self.type = type
        self.fields = fields

        super().__init__(action="setTextLineItemCustomType")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ShoppingListSetTextLineItemCustomTypeAction":
        from ._schemas.shopping_list import (
            ShoppingListSetTextLineItemCustomTypeActionSchema,
        )

        return ShoppingListSetTextLineItemCustomTypeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shopping_list import (
            ShoppingListSetTextLineItemCustomTypeActionSchema,
        )

        return ShoppingListSetTextLineItemCustomTypeActionSchema().dump(self)


class ShoppingListSetTextLineItemDescriptionAction(ShoppingListUpdateAction):
    #: The `id` of the [TextLineItem](ctp:api:type:TextLineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    text_line_item_id: typing.Optional[str]
    #: The `key` of the [TextLineItem](ctp:api:type:TextLineItem) to update. Either `lineItemId` or `lineItemKey` is required.
    text_line_item_key: typing.Optional[str]
    #: Value to set. If empty, any existing value will be removed.
    description: typing.Optional["LocalizedString"]

    def __init__(
        self,
        *,
        text_line_item_id: typing.Optional[str] = None,
        text_line_item_key: typing.Optional[str] = None,
        description: typing.Optional["LocalizedString"] = None
    ):
        self.text_line_item_id = text_line_item_id
        self.text_line_item_key = text_line_item_key
        self.description = description

        super().__init__(action="setTextLineItemDescription")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "ShoppingListSetTextLineItemDescriptionAction":
        from ._schemas.shopping_list import (
            ShoppingListSetTextLineItemDescriptionActionSchema,
        )

        return ShoppingListSetTextLineItemDescriptionActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.shopping_list import (
            ShoppingListSetTextLineItemDescriptionActionSchema,
        )

        return ShoppingListSetTextLineItemDescriptionActionSchema().dump(self)
