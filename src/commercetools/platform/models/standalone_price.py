# This file is automatically generated by the rmf-codegen project.
#
# The Python code generator is maintained by Lab Digital. If you want to
# contribute to this project then please do not edit this file directly
# but send a pull request to the Lab Digital fork of rmf-codegen at
# https://github.com/labd/rmf-codegen

import datetime
import enum
import typing

from ._abstract import _BaseType
from .common import BaseResource, Reference, ReferenceTypeId, ResourceIdentifier

if typing.TYPE_CHECKING:
    from .channel import ChannelReference, ChannelResourceIdentifier
    from .common import (
        CreatedBy,
        DiscountedPrice,
        DiscountedPriceDraft,
        LastModifiedBy,
        Money,
        PriceTier,
        PriceTierDraft,
        ReferenceTypeId,
        TypedMoney,
        TypedMoneyDraft,
    )
    from .customer_group import CustomerGroupReference, CustomerGroupResourceIdentifier
    from .type import (
        CustomFields,
        CustomFieldsDraft,
        FieldContainer,
        TypeResourceIdentifier,
    )

__all__ = [
    "StagedPriceDraft",
    "StagedStandalonePrice",
    "StandalonePrice",
    "StandalonePriceAddPriceTierAction",
    "StandalonePriceApplyStagedChangesAction",
    "StandalonePriceChangeActiveAction",
    "StandalonePriceChangeValueAction",
    "StandalonePriceDraft",
    "StandalonePricePagedQueryResponse",
    "StandalonePriceReference",
    "StandalonePriceRemovePriceTierAction",
    "StandalonePriceRemoveStagedChangesAction",
    "StandalonePriceResourceIdentifier",
    "StandalonePriceSetCustomFieldAction",
    "StandalonePriceSetCustomTypeAction",
    "StandalonePriceSetDiscountedPriceAction",
    "StandalonePriceSetKeyAction",
    "StandalonePriceSetPriceTiersAction",
    "StandalonePriceSetValidFromAction",
    "StandalonePriceSetValidFromAndUntilAction",
    "StandalonePriceSetValidUntilAction",
    "StandalonePriceUpdate",
    "StandalonePriceUpdateAction",
]


class StagedPriceDraft(_BaseType):
    #: Money value for the StagedPriceDraft.
    value: "TypedMoneyDraft"

    def __init__(self, *, value: "TypedMoneyDraft"):
        self.value = value

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "StagedPriceDraft":
        from ._schemas.standalone_price import StagedPriceDraftSchema

        return StagedPriceDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.standalone_price import StagedPriceDraftSchema

        return StagedPriceDraftSchema().dump(self)


class StagedStandalonePrice(_BaseType):
    """Staged changes on a Standalone Price.
    To update the `value` property of a Staged Standalone Price, use the [Change Value](ctp:api:type:StandalonePriceChangeValueAction) update action.
    To apply all staged changes to the Standalone Price, use the [Apply Staged Changes](ctp:api:type:StandalonePriceApplyStagedChangesAction) update action.

    """

    #: Money value of the StagedStandalonePrice.
    value: "TypedMoney"
    #: Discounted price for the StagedStandalonePrice.
    discounted: typing.Optional["DiscountedPrice"]

    def __init__(
        self,
        *,
        value: "TypedMoney",
        discounted: typing.Optional["DiscountedPrice"] = None
    ):
        self.value = value
        self.discounted = discounted

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "StagedStandalonePrice":
        from ._schemas.standalone_price import StagedStandalonePriceSchema

        return StagedStandalonePriceSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.standalone_price import StagedStandalonePriceSchema

        return StagedStandalonePriceSchema().dump(self)


class StandalonePrice(BaseResource):
    #: Present on resources created after 1 February 2019 except for [events not tracked](/../api/general-concepts#events-tracked).
    last_modified_by: typing.Optional["LastModifiedBy"]
    #: Present on resources created after 1 February 2019 except for [events not tracked](/../api/general-concepts#events-tracked).
    created_by: typing.Optional["CreatedBy"]
    #: User-defined unique identifier of the StandalonePrice.
    key: typing.Optional[str]
    #: SKU of the [ProductVariant](ctp:api:type:ProductVariant) to which this Price is associated.
    sku: str
    #: Money value of this Price.
    value: "TypedMoney"
    #: Country for which this Price is valid.
    country: typing.Optional[str]
    #: [CustomerGroup](ctp:api:type:CustomerGroup) for which this Price is valid.
    customer_group: typing.Optional["CustomerGroupReference"]
    #: Product distribution [Channel](ctp:api:type:Channel) for which this Price is valid.
    channel: typing.Optional["ChannelReference"]
    #: Date from which the Price is valid.
    valid_from: typing.Optional[datetime.datetime]
    #: Date until the Price is valid. Standalone Prices that are no longer valid are not automatically deleted, but they can be [deleted](/../api/projects/standalone-prices#delete-standaloneprice) if necessary.
    valid_until: typing.Optional[datetime.datetime]
    #: Price tiers if any are defined.
    #:
    #: If `discounted` is present, the tiered Price is ignored for a Product Variant.
    tiers: typing.Optional[typing.List["PriceTier"]]
    #: Set if a matching [ProductDiscount](ctp:api:type:ProductDiscount) exists. If set, the API uses the `discounted` value for the [LineItem Price selection](ctp:api:type:LineItemPriceSelection).
    #: When a [relative discount](/../api/projects/productDiscounts#productdiscountvaluerelative) is applied and the fraction part of the `discounted` price is 0.5, the discounted price is rounded in favor of the customer with the [half down rounding](https://en.wikipedia.org/wiki/Rounding#Round_half_down).
    discounted: typing.Optional["DiscountedPrice"]
    #: Custom Fields for the StandalonePrice.
    custom: typing.Optional["CustomFields"]
    #: Staged changes of the StandalonePrice. Only present if the StandalonePrice has some changes staged.
    staged: typing.Optional["StagedStandalonePrice"]
    #: If set to `true`, the StandalonePrice is considered during [price selection](ctp:api:type:ProductPriceSelection).
    #: If set to `false`, the StandalonePrice is not considered during [price selection](ctp:api:type:ProductPriceSelection).
    active: bool

    def __init__(
        self,
        *,
        id: str,
        version: int,
        created_at: datetime.datetime,
        last_modified_at: datetime.datetime,
        last_modified_by: typing.Optional["LastModifiedBy"] = None,
        created_by: typing.Optional["CreatedBy"] = None,
        key: typing.Optional[str] = None,
        sku: str,
        value: "TypedMoney",
        country: typing.Optional[str] = None,
        customer_group: typing.Optional["CustomerGroupReference"] = None,
        channel: typing.Optional["ChannelReference"] = None,
        valid_from: typing.Optional[datetime.datetime] = None,
        valid_until: typing.Optional[datetime.datetime] = None,
        tiers: typing.Optional[typing.List["PriceTier"]] = None,
        discounted: typing.Optional["DiscountedPrice"] = None,
        custom: typing.Optional["CustomFields"] = None,
        staged: typing.Optional["StagedStandalonePrice"] = None,
        active: bool
    ):
        self.last_modified_by = last_modified_by
        self.created_by = created_by
        self.key = key
        self.sku = sku
        self.value = value
        self.country = country
        self.customer_group = customer_group
        self.channel = channel
        self.valid_from = valid_from
        self.valid_until = valid_until
        self.tiers = tiers
        self.discounted = discounted
        self.custom = custom
        self.staged = staged
        self.active = active

        super().__init__(
            id=id,
            version=version,
            created_at=created_at,
            last_modified_at=last_modified_at,
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "StandalonePrice":
        from ._schemas.standalone_price import StandalonePriceSchema

        return StandalonePriceSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.standalone_price import StandalonePriceSchema

        return StandalonePriceSchema().dump(self)


class StandalonePriceDraft(_BaseType):
    """Standalone Prices are defined with a scope consisting of `currency` and optionally `country`, `customerGroup`, and `channel` and/or a validity period (`validFrom` and/or `validTo`). For more information see [price selection](/../api/projects/products#price-selection).

    Creating a Standalone Price for an SKU which has a Standalone Price with exactly the same price scope, or with overlapping validity periods within the same price scope returns the [DuplicateStandalonePriceScope](ctp:api:type:DuplicateStandalonePriceScopeError) and [OverlappingStandalonePriceValidity](ctp:api:type:OverlappingStandalonePriceValidityError) errors, respectively. A Price without validity period does not conflict with a Price defined for a time period.
    """

    #: User-defined unique identifier for the StandalonePrice.
    key: typing.Optional[str]
    #: Specifies to which [ProductVariant](ctp:api:type:ProductVariant) the API associates this Price.
    #: It is not validated to exist in product variants.
    sku: str
    #: Sets the money value of this Price.
    value: "Money"
    #: Sets the country for which this Price is valid.
    country: typing.Optional[str]
    #: Sets the [CustomerGroup](ctp:api:type:CustomerGroup) for which this Price is valid.
    customer_group: typing.Optional["CustomerGroupResourceIdentifier"]
    #: Sets the product distribution [Channel](ctp:api:type:Channel) for which this Price is valid.
    channel: typing.Optional["ChannelResourceIdentifier"]
    #: Sets the date from which the Price is valid. Must be at least 1 ms earlier than `validUntil`.
    valid_from: typing.Optional[datetime.datetime]
    #: Sets the date until the Price is valid. Must be at least 1 ms later than `validFrom`. Standalone Prices that are no longer valid are not automatically deleted, but they can be [deleted](/../api/projects/standalone-prices#delete-standaloneprice) if necessary.
    valid_until: typing.Optional[datetime.datetime]
    #: Sets price tiers.
    #:
    #: If `discounted` is set, the tiered Price is ignored for a Product Variant.
    tiers: typing.Optional[typing.List["PriceTierDraft"]]
    #: Sets a discounted price for this Price that is different from the base price with `value`.
    discounted: typing.Optional["DiscountedPriceDraft"]
    #: Custom Fields for the StandalonePrice.
    custom: typing.Optional["CustomFieldsDraft"]
    #: Staged changes for the StandalonePrice.
    staged: typing.Optional["StagedPriceDraft"]
    #: Set to `false`, if the StandalonePrice should not be considered during [price selection](ctp:api:type:ProductPriceSelection).
    active: typing.Optional[bool]

    def __init__(
        self,
        *,
        key: typing.Optional[str] = None,
        sku: str,
        value: "Money",
        country: typing.Optional[str] = None,
        customer_group: typing.Optional["CustomerGroupResourceIdentifier"] = None,
        channel: typing.Optional["ChannelResourceIdentifier"] = None,
        valid_from: typing.Optional[datetime.datetime] = None,
        valid_until: typing.Optional[datetime.datetime] = None,
        tiers: typing.Optional[typing.List["PriceTierDraft"]] = None,
        discounted: typing.Optional["DiscountedPriceDraft"] = None,
        custom: typing.Optional["CustomFieldsDraft"] = None,
        staged: typing.Optional["StagedPriceDraft"] = None,
        active: typing.Optional[bool] = None
    ):
        self.key = key
        self.sku = sku
        self.value = value
        self.country = country
        self.customer_group = customer_group
        self.channel = channel
        self.valid_from = valid_from
        self.valid_until = valid_until
        self.tiers = tiers
        self.discounted = discounted
        self.custom = custom
        self.staged = staged
        self.active = active

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "StandalonePriceDraft":
        from ._schemas.standalone_price import StandalonePriceDraftSchema

        return StandalonePriceDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.standalone_price import StandalonePriceDraftSchema

        return StandalonePriceDraftSchema().dump(self)


class StandalonePricePagedQueryResponse(_BaseType):
    #: Number of requested results.
    limit: int
    #: Offset supplied by the client or server default. It is the number of elements skipped, not a page number.
    offset: int
    #: Actual number of results returned.
    count: int
    #: Total number of results matching the query.
    #: This number is an estimation that is not [strongly consistent](/../api/general-concepts#strong-consistency).
    #: This field is returned by default.
    #: For improved performance, calculating this field can be deactivated by using the query parameter `withTotal=false`.
    #: When the results are filtered with a [Query Predicate](/../api/predicates/query), `total` is subject to a [limit](/../api/limits#queries).
    total: typing.Optional[int]
    #: [StandalonePrices](ctp:api:type:StandalonePrice) matching the query.
    results: typing.List["StandalonePrice"]

    def __init__(
        self,
        *,
        limit: int,
        offset: int,
        count: int,
        total: typing.Optional[int] = None,
        results: typing.List["StandalonePrice"]
    ):
        self.limit = limit
        self.offset = offset
        self.count = count
        self.total = total
        self.results = results

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StandalonePricePagedQueryResponse":
        from ._schemas.standalone_price import StandalonePricePagedQueryResponseSchema

        return StandalonePricePagedQueryResponseSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.standalone_price import StandalonePricePagedQueryResponseSchema

        return StandalonePricePagedQueryResponseSchema().dump(self)


class StandalonePriceReference(Reference):
    """[Reference](ctp:api:type:Reference) to a [StandalonePrice](ctp:api:type:StandalonePrice)."""

    #: Contains the representation of the expanded StandalonePrice. Only present in responses to requests with [Reference Expansion](/../api/general-concepts#reference-expansion) for StandalonePrice.
    obj: typing.Optional["StandalonePrice"]

    def __init__(self, *, id: str, obj: typing.Optional["StandalonePrice"] = None):
        self.obj = obj

        super().__init__(id=id, type_id=ReferenceTypeId.STANDALONE_PRICE)

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StandalonePriceReference":
        from ._schemas.standalone_price import StandalonePriceReferenceSchema

        return StandalonePriceReferenceSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.standalone_price import StandalonePriceReferenceSchema

        return StandalonePriceReferenceSchema().dump(self)


class StandalonePriceResourceIdentifier(ResourceIdentifier):
    """[ResourceIdentifier](ctp:api:type:ResourceIdentifier) to a [StandalonePrice](ctp:api:type:StandalonePrice)."""

    def __init__(
        self, *, id: typing.Optional[str] = None, key: typing.Optional[str] = None
    ):

        super().__init__(id=id, key=key, type_id=ReferenceTypeId.STANDALONE_PRICE)

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StandalonePriceResourceIdentifier":
        from ._schemas.standalone_price import StandalonePriceResourceIdentifierSchema

        return StandalonePriceResourceIdentifierSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.standalone_price import StandalonePriceResourceIdentifierSchema

        return StandalonePriceResourceIdentifierSchema().dump(self)


class StandalonePriceUpdate(_BaseType):
    #: Expected version of the StandalonePrice on which the changes should be applied.
    #: If the expected version does not match the actual version, a [ConcurrentModification](ctp:api:type:ConcurrentModificationError) error will be returned.
    version: int
    #: Update actions to be performed on the StandalonePrice.
    actions: typing.List["StandalonePriceUpdateAction"]

    def __init__(
        self, *, version: int, actions: typing.List["StandalonePriceUpdateAction"]
    ):
        self.version = version
        self.actions = actions

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "StandalonePriceUpdate":
        from ._schemas.standalone_price import StandalonePriceUpdateSchema

        return StandalonePriceUpdateSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.standalone_price import StandalonePriceUpdateSchema

        return StandalonePriceUpdateSchema().dump(self)


class StandalonePriceUpdateAction(_BaseType):
    action: str

    def __init__(self, *, action: str):
        self.action = action

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StandalonePriceUpdateAction":
        if data["action"] == "addPriceTier":
            from ._schemas.standalone_price import (
                StandalonePriceAddPriceTierActionSchema,
            )

            return StandalonePriceAddPriceTierActionSchema().load(data)
        if data["action"] == "applyStagedChanges":
            from ._schemas.standalone_price import (
                StandalonePriceApplyStagedChangesActionSchema,
            )

            return StandalonePriceApplyStagedChangesActionSchema().load(data)
        if data["action"] == "changeActive":
            from ._schemas.standalone_price import (
                StandalonePriceChangeActiveActionSchema,
            )

            return StandalonePriceChangeActiveActionSchema().load(data)
        if data["action"] == "changeValue":
            from ._schemas.standalone_price import (
                StandalonePriceChangeValueActionSchema,
            )

            return StandalonePriceChangeValueActionSchema().load(data)
        if data["action"] == "removePriceTier":
            from ._schemas.standalone_price import (
                StandalonePriceRemovePriceTierActionSchema,
            )

            return StandalonePriceRemovePriceTierActionSchema().load(data)
        if data["action"] == "removeStagedChanges":
            from ._schemas.standalone_price import (
                StandalonePriceRemoveStagedChangesActionSchema,
            )

            return StandalonePriceRemoveStagedChangesActionSchema().load(data)
        if data["action"] == "setCustomField":
            from ._schemas.standalone_price import (
                StandalonePriceSetCustomFieldActionSchema,
            )

            return StandalonePriceSetCustomFieldActionSchema().load(data)
        if data["action"] == "setCustomType":
            from ._schemas.standalone_price import (
                StandalonePriceSetCustomTypeActionSchema,
            )

            return StandalonePriceSetCustomTypeActionSchema().load(data)
        if data["action"] == "setDiscountedPrice":
            from ._schemas.standalone_price import (
                StandalonePriceSetDiscountedPriceActionSchema,
            )

            return StandalonePriceSetDiscountedPriceActionSchema().load(data)
        if data["action"] == "setKey":
            from ._schemas.standalone_price import StandalonePriceSetKeyActionSchema

            return StandalonePriceSetKeyActionSchema().load(data)
        if data["action"] == "setPriceTiers":
            from ._schemas.standalone_price import (
                StandalonePriceSetPriceTiersActionSchema,
            )

            return StandalonePriceSetPriceTiersActionSchema().load(data)
        if data["action"] == "setValidFrom":
            from ._schemas.standalone_price import (
                StandalonePriceSetValidFromActionSchema,
            )

            return StandalonePriceSetValidFromActionSchema().load(data)
        if data["action"] == "setValidFromAndUntil":
            from ._schemas.standalone_price import (
                StandalonePriceSetValidFromAndUntilActionSchema,
            )

            return StandalonePriceSetValidFromAndUntilActionSchema().load(data)
        if data["action"] == "setValidUntil":
            from ._schemas.standalone_price import (
                StandalonePriceSetValidUntilActionSchema,
            )

            return StandalonePriceSetValidUntilActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.standalone_price import StandalonePriceUpdateActionSchema

        return StandalonePriceUpdateActionSchema().dump(self)


class StandalonePriceAddPriceTierAction(StandalonePriceUpdateAction):
    """Adding a [PriceTier](ctp:api:type:PriceTier) to a [StandalonePrice](ctp:api:type:StandalonePrice) produces the [Standalone Price Tier Added](ctp:api:type:StandalonePriceTierAddedMessage) Message."""

    #: The [PriceTier](ctp:api:type:PriceTier) to be added to the `tiers` field of the [StandalonePrice](ctp:api:type:StandalonePrice).
    #: The action returns an [InvalidField](ctp:api:type:InvalidFieldError) error in the following cases:
    #:
    #: * Trying to add a PriceTier with `minimumQuantity` < `2`.
    #: * Trying to add a PriceTier with `minimumQuantity` that already exists for the StandalonePrice.
    tier: "PriceTierDraft"

    def __init__(self, *, tier: "PriceTierDraft"):
        self.tier = tier

        super().__init__(action="addPriceTier")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StandalonePriceAddPriceTierAction":
        from ._schemas.standalone_price import StandalonePriceAddPriceTierActionSchema

        return StandalonePriceAddPriceTierActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.standalone_price import StandalonePriceAddPriceTierActionSchema

        return StandalonePriceAddPriceTierActionSchema().dump(self)


class StandalonePriceApplyStagedChangesAction(StandalonePriceUpdateAction):
    """Applies all staged changes to the StandalonePrice by overwriting all current values with the values in the [StagedStandalonePrice](ctp:api:type:StagedStandalonePrice). After successfully applied, the [StagedStandalonePrice](ctp:api:type:StagedStandalonePrice) will be removed from the StandalonePrice. An `applyStagedChanges` update action on a StandalonePrice that does not contain any staged changes will return a `400 Bad Request` error. Applying staged changes successfully will produce the [StandalonePriceStagedChangesApplied](ctp:api:type:StandalonePriceStagedChangesAppliedMessage) Message."""

    def __init__(self):

        super().__init__(action="applyStagedChanges")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StandalonePriceApplyStagedChangesAction":
        from ._schemas.standalone_price import (
            StandalonePriceApplyStagedChangesActionSchema,
        )

        return StandalonePriceApplyStagedChangesActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.standalone_price import (
            StandalonePriceApplyStagedChangesActionSchema,
        )

        return StandalonePriceApplyStagedChangesActionSchema().dump(self)


class StandalonePriceChangeActiveAction(StandalonePriceUpdateAction):
    """Updating the value of a [StandalonePrice](ctp:api:type:StandalonePrice) produces the [StandalonePriceActiveChanged](ctp:api:type:StandalonePriceActiveChangedMessage) Message."""

    #: New value to set for the `active` field of the [StandalonePrice](ctp:api:type:StandalonePrice).
    active: bool

    def __init__(self, *, active: bool):
        self.active = active

        super().__init__(action="changeActive")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StandalonePriceChangeActiveAction":
        from ._schemas.standalone_price import StandalonePriceChangeActiveActionSchema

        return StandalonePriceChangeActiveActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.standalone_price import StandalonePriceChangeActiveActionSchema

        return StandalonePriceChangeActiveActionSchema().dump(self)


class StandalonePriceChangeValueAction(StandalonePriceUpdateAction):
    """Updating the value of a [StandalonePrice](ctp:api:type:StandalonePrice) produces the [StandalonePriceValueChangedMessage](ctp:api:type:StandalonePriceValueChangedMessage)."""

    #: New value to set. Must not be empty.
    value: "Money"
    #: If set to `true` the update action applies to the [StagedStandalonePrice](ctp:api:type:StagedStandalonePrice). If set to `false`, the update action applies to the current [StandalonePrice](ctp:api:type:StandalonePrice).
    staged: typing.Optional[bool]

    def __init__(self, *, value: "Money", staged: typing.Optional[bool] = None):
        self.value = value
        self.staged = staged

        super().__init__(action="changeValue")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StandalonePriceChangeValueAction":
        from ._schemas.standalone_price import StandalonePriceChangeValueActionSchema

        return StandalonePriceChangeValueActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.standalone_price import StandalonePriceChangeValueActionSchema

        return StandalonePriceChangeValueActionSchema().dump(self)


class StandalonePriceRemovePriceTierAction(StandalonePriceUpdateAction):
    """Removing a [PriceTier](ctp:api:type:PriceTier) from a [StandalonePrice](ctp:api:type:StandalonePrice) produces the [Standalone Price Tier Removed](ctp:api:type:StandalonePriceTierRemovedMessage) Message."""

    #: The `minimumQuantity` of the [PriceTier](ctp:api:type:PriceTier) to be removed from the `tiers` field of the [StandalonePrice](ctp:api:type:StandalonePrice).
    tier_minimum_quantity: int

    def __init__(self, *, tier_minimum_quantity: int):
        self.tier_minimum_quantity = tier_minimum_quantity

        super().__init__(action="removePriceTier")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StandalonePriceRemovePriceTierAction":
        from ._schemas.standalone_price import (
            StandalonePriceRemovePriceTierActionSchema,
        )

        return StandalonePriceRemovePriceTierActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.standalone_price import (
            StandalonePriceRemovePriceTierActionSchema,
        )

        return StandalonePriceRemovePriceTierActionSchema().dump(self)


class StandalonePriceRemoveStagedChangesAction(StandalonePriceUpdateAction):
    """Removes all staged changes from the StandalonePrice.
    Removing staged changes successfully produces the [StandalonePriceStagedChangesRemoved](ctp:api:type:StandalonePriceStagedChangesRemovedMessage) Message.

    """

    def __init__(self):

        super().__init__(action="removeStagedChanges")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StandalonePriceRemoveStagedChangesAction":
        from ._schemas.standalone_price import (
            StandalonePriceRemoveStagedChangesActionSchema,
        )

        return StandalonePriceRemoveStagedChangesActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.standalone_price import (
            StandalonePriceRemoveStagedChangesActionSchema,
        )

        return StandalonePriceRemoveStagedChangesActionSchema().dump(self)


class StandalonePriceSetCustomFieldAction(StandalonePriceUpdateAction):
    #: Name of the [Custom Field](/../api/projects/custom-fields).
    name: str
    #: If `value` is absent or `null`, this field will be removed if it exists.
    #: Removing a field that does not exist returns an [InvalidOperation](ctp:api:type:InvalidOperationError) error.
    #: If `value` is provided, it is set for the field defined by `name`.
    value: typing.Optional[typing.Any]

    def __init__(self, *, name: str, value: typing.Optional[typing.Any] = None):
        self.name = name
        self.value = value

        super().__init__(action="setCustomField")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StandalonePriceSetCustomFieldAction":
        from ._schemas.standalone_price import StandalonePriceSetCustomFieldActionSchema

        return StandalonePriceSetCustomFieldActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.standalone_price import StandalonePriceSetCustomFieldActionSchema

        return StandalonePriceSetCustomFieldActionSchema().dump(self)


class StandalonePriceSetCustomTypeAction(StandalonePriceUpdateAction):
    #: Defines the [Type](ctp:api:type:Type) that extends the StandalonePrice with [Custom Fields](/../api/projects/custom-fields).
    #: If absent, any existing Type and Custom Fields are removed from the StandalonePrice.
    type: typing.Optional["TypeResourceIdentifier"]
    #: Sets the [Custom Fields](/../api/projects/custom-fields) fields for the StandalonePrice.
    fields: typing.Optional["FieldContainer"]

    def __init__(
        self,
        *,
        type: typing.Optional["TypeResourceIdentifier"] = None,
        fields: typing.Optional["FieldContainer"] = None
    ):
        self.type = type
        self.fields = fields

        super().__init__(action="setCustomType")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StandalonePriceSetCustomTypeAction":
        from ._schemas.standalone_price import StandalonePriceSetCustomTypeActionSchema

        return StandalonePriceSetCustomTypeActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.standalone_price import StandalonePriceSetCustomTypeActionSchema

        return StandalonePriceSetCustomTypeActionSchema().dump(self)


class StandalonePriceSetDiscountedPriceAction(StandalonePriceUpdateAction):
    """Discounts a Standalone Price. The referenced [ProductDiscount](ctp:api:type:ProductDiscount) in the discounted field must be of type external, active, and its predicate must match the referenced Price. Produces the [StandalonePriceExternalDiscountSet](ctp:api:type:StandalonePriceExternalDiscountSetMessage) Message."""

    #: Value to set. If empty, any existing value will be removed.
    discounted: typing.Optional["DiscountedPriceDraft"]

    def __init__(self, *, discounted: typing.Optional["DiscountedPriceDraft"] = None):
        self.discounted = discounted

        super().__init__(action="setDiscountedPrice")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StandalonePriceSetDiscountedPriceAction":
        from ._schemas.standalone_price import (
            StandalonePriceSetDiscountedPriceActionSchema,
        )

        return StandalonePriceSetDiscountedPriceActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.standalone_price import (
            StandalonePriceSetDiscountedPriceActionSchema,
        )

        return StandalonePriceSetDiscountedPriceActionSchema().dump(self)


class StandalonePriceSetKeyAction(StandalonePriceUpdateAction):
    """Sets the key on a Standalone Price. Produces the [StandalonePriceKeySet](ctp:api:type:StandalonePriceKeySetMessage) Message."""

    #: Value to set. Must be unique. If empty, any existing value will be removed.
    key: typing.Optional[str]

    def __init__(self, *, key: typing.Optional[str] = None):
        self.key = key

        super().__init__(action="setKey")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StandalonePriceSetKeyAction":
        from ._schemas.standalone_price import StandalonePriceSetKeyActionSchema

        return StandalonePriceSetKeyActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.standalone_price import StandalonePriceSetKeyActionSchema

        return StandalonePriceSetKeyActionSchema().dump(self)


class StandalonePriceSetPriceTiersAction(StandalonePriceUpdateAction):
    """Sets all [PriceTiers](ctp:api:type:PriceTier) for a [StandalonePrice](ctp:api:type:StandalonePrice) in one action, produces the [Standalone Price Tiers Set](ctp:api:type:StandalonePriceTiersSetMessage) Message."""

    #: Value to set. If empty, any existing value will be removed.
    #: The `minimumQuantity` of the PriceTiers must be unique and greater than `1`, otherwise an [InvalidField](ctp:api:type:InvalidFieldError) error is returned.
    tiers: typing.List["PriceTierDraft"]

    def __init__(self, *, tiers: typing.List["PriceTierDraft"]):
        self.tiers = tiers

        super().__init__(action="setPriceTiers")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StandalonePriceSetPriceTiersAction":
        from ._schemas.standalone_price import StandalonePriceSetPriceTiersActionSchema

        return StandalonePriceSetPriceTiersActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.standalone_price import StandalonePriceSetPriceTiersActionSchema

        return StandalonePriceSetPriceTiersActionSchema().dump(self)


class StandalonePriceSetValidFromAction(StandalonePriceUpdateAction):
    """Updating the `validFrom` value generates the [StandalonePriceValidFromSet](ctp:api:type:StandalonePriceValidFromSetMessage) Message.

    As the validity dates are part of the price scope and are not allowed to overlap, this update might return the [DuplicateStandalonePriceScope](ctp:api:type:DuplicateStandalonePriceScopeError) and [OverlappingStandalonePriceValidity](ctp:api:type:OverlappingStandalonePriceValidityError) errors, respectively. A Price without validity period does not conflict with a Price defined for a time period.

    """

    #: Value to set.
    #: If empty, any existing value is removed.
    valid_from: typing.Optional[datetime.datetime]

    def __init__(self, *, valid_from: typing.Optional[datetime.datetime] = None):
        self.valid_from = valid_from

        super().__init__(action="setValidFrom")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StandalonePriceSetValidFromAction":
        from ._schemas.standalone_price import StandalonePriceSetValidFromActionSchema

        return StandalonePriceSetValidFromActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.standalone_price import StandalonePriceSetValidFromActionSchema

        return StandalonePriceSetValidFromActionSchema().dump(self)


class StandalonePriceSetValidFromAndUntilAction(StandalonePriceUpdateAction):
    """Updating the `validFrom` and `validUntil` values generates the [StandalonePriceValidFromAndUntilSet](ctp:api:type:StandalonePriceValidFromAndUntilSetMessage) Message.

    As the validity dates are part of the price scope and are not allowed to overlap, this update might return the [DuplicateStandalonePriceScope](ctp:api:type:DuplicateStandalonePriceScopeError) and [OverlappingStandalonePriceValidity](ctp:api:type:OverlappingStandalonePriceValidityError) errors, respectively. A Price without validity period does not conflict with a Price defined for a time period.

    """

    #: Value to set.
    #: If empty, any existing value is removed.
    valid_from: typing.Optional[datetime.datetime]
    #: Value to set.
    #: If empty, any existing value is removed.
    valid_until: typing.Optional[datetime.datetime]

    def __init__(
        self,
        *,
        valid_from: typing.Optional[datetime.datetime] = None,
        valid_until: typing.Optional[datetime.datetime] = None
    ):
        self.valid_from = valid_from
        self.valid_until = valid_until

        super().__init__(action="setValidFromAndUntil")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StandalonePriceSetValidFromAndUntilAction":
        from ._schemas.standalone_price import (
            StandalonePriceSetValidFromAndUntilActionSchema,
        )

        return StandalonePriceSetValidFromAndUntilActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.standalone_price import (
            StandalonePriceSetValidFromAndUntilActionSchema,
        )

        return StandalonePriceSetValidFromAndUntilActionSchema().dump(self)


class StandalonePriceSetValidUntilAction(StandalonePriceUpdateAction):
    """Updating the `validUntil` value generates the [StandalonePriceValidUntilSet](ctp:api:type:StandalonePriceValidUntilSetMessage) Message.

    As the validity dates are part of the price scope and are not allowed to overlap, this update might return the [DuplicateStandalonePriceScope](ctp:api:type:DuplicateStandalonePriceScopeError) and [OverlappingStandalonePriceValidity](ctp:api:type:OverlappingStandalonePriceValidityError) errors, respectively. A Price without validity period does not conflict with a Price defined for a time period.

    """

    #: Value to set.
    #: If empty, any existing value is removed.
    valid_until: typing.Optional[datetime.datetime]

    def __init__(self, *, valid_until: typing.Optional[datetime.datetime] = None):
        self.valid_until = valid_until

        super().__init__(action="setValidUntil")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "StandalonePriceSetValidUntilAction":
        from ._schemas.standalone_price import StandalonePriceSetValidUntilActionSchema

        return StandalonePriceSetValidUntilActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.standalone_price import StandalonePriceSetValidUntilActionSchema

        return StandalonePriceSetValidUntilActionSchema().dump(self)
