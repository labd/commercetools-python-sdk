# This file is automatically generated by the rmf-codegen project.
#
# The Python code generator is maintained by Lab Digital. If you want to
# contribute to this project then please do not edit this file directly
# but send a pull request to the Lab Digital fork of rmf-codegen at
# https://github.com/labd/rmf-codegen

import datetime
import enum
import typing

from ._abstract import _BaseType
from .common import BaseResource, Reference, ReferenceTypeId, ResourceIdentifier

if typing.TYPE_CHECKING:
    from .common import CreatedBy, LastModifiedBy, LocalizedString, ReferenceTypeId

__all__ = [
    "CustomFieldBooleanType",
    "CustomFieldDateTimeType",
    "CustomFieldDateType",
    "CustomFieldEnumType",
    "CustomFieldEnumValue",
    "CustomFieldLocalizedEnumType",
    "CustomFieldLocalizedEnumValue",
    "CustomFieldLocalizedStringType",
    "CustomFieldMoneyType",
    "CustomFieldNumberType",
    "CustomFieldReferenceType",
    "CustomFieldReferenceValue",
    "CustomFieldSetType",
    "CustomFieldStringType",
    "CustomFieldTimeType",
    "CustomFields",
    "CustomFieldsDraft",
    "FieldContainer",
    "FieldDefinition",
    "FieldType",
    "ResourceTypeId",
    "Type",
    "TypeAddEnumValueAction",
    "TypeAddFieldDefinitionAction",
    "TypeAddLocalizedEnumValueAction",
    "TypeChangeEnumValueLabelAction",
    "TypeChangeEnumValueOrderAction",
    "TypeChangeFieldDefinitionLabelAction",
    "TypeChangeFieldDefinitionOrderAction",
    "TypeChangeInputHintAction",
    "TypeChangeKeyAction",
    "TypeChangeLabelAction",
    "TypeChangeLocalizedEnumValueLabelAction",
    "TypeChangeLocalizedEnumValueOrderAction",
    "TypeChangeNameAction",
    "TypeDraft",
    "TypePagedQueryResponse",
    "TypeReference",
    "TypeRemoveFieldDefinitionAction",
    "TypeResourceIdentifier",
    "TypeSetDescriptionAction",
    "TypeTextInputHint",
    "TypeUpdate",
    "TypeUpdateAction",
]


class CustomFieldEnumValue(_BaseType):
    """Defines an allowed value of a [CustomFieldEnumType](ctp:api:type:CustomFieldEnumType) field."""

    #: Key of the value used as a programmatic identifier.
    key: str
    #: Descriptive label of the value.
    label: str

    def __init__(self, *, key: str, label: str):
        self.key = key
        self.label = label

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CustomFieldEnumValue":
        from ._schemas.type import CustomFieldEnumValueSchema

        return CustomFieldEnumValueSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.type import CustomFieldEnumValueSchema

        return CustomFieldEnumValueSchema().dump(self)


class CustomFieldLocalizedEnumValue(_BaseType):
    """Defines an allowed value of a [CustomFieldLocalizedEnumType](ctp:api:type:CustomFieldLocalizedEnumType) field."""

    #: Key of the value used as a programmatic identifier.
    key: str
    #: Descriptive localized label of the value.
    label: "LocalizedString"

    def __init__(self, *, key: str, label: "LocalizedString"):
        self.key = key
        self.label = label

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CustomFieldLocalizedEnumValue":
        from ._schemas.type import CustomFieldLocalizedEnumValueSchema

        return CustomFieldLocalizedEnumValueSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.type import CustomFieldLocalizedEnumValueSchema

        return CustomFieldLocalizedEnumValueSchema().dump(self)


class CustomFieldReferenceValue(enum.Enum):
    """Defines which resource type a [CustomFieldReferenceType](ctp:api:type:CustomFieldReferenceType) can reference."""

    APPROVAL_FLOW = "approval-flow"
    ASSOCIATE_ROLE = "associate-role"
    BUSINESS_UNIT = "business-unit"
    CART = "cart"
    CATEGORY = "category"
    CHANNEL = "channel"
    CUSTOMER = "customer"
    KEY_VALUE_DOCUMENT = "key-value-document"
    ORDER = "order"
    PRODUCT = "product"
    PRODUCT_TYPE = "product-type"
    REVIEW = "review"
    STATE = "state"
    SHIPPING_METHOD = "shipping-method"
    ZONE = "zone"


class CustomFields(_BaseType):
    """Serves as value of the `custom` field on a resource or data type customized with a [Type](ctp:api:type:Type)."""

    #: Reference to the [Type](ctp:api:type:Type) that holds the [FieldDefinitions](ctp:api:type:FieldDefinition) for the Custom Fields.
    type: "TypeReference"
    #: Object containing the Custom Fields for the [customized resource or data type](/../api/projects/types#list-of-customizable-data-types).
    fields: "FieldContainer"

    def __init__(self, *, type: "TypeReference", fields: "FieldContainer"):
        self.type = type
        self.fields = fields

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CustomFields":
        from ._schemas.type import CustomFieldsSchema

        return CustomFieldsSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.type import CustomFieldsSchema

        return CustomFieldsSchema().dump(self)


class CustomFieldsDraft(_BaseType):
    """The representation used when creating or updating a [customizable data type](/../api/projects/types#list-of-customizable-data-types) with Custom Fields."""

    #: `id` or `key` of the [Type](ctp:api:type:Type).
    type: "TypeResourceIdentifier"
    #: Object containing the Custom Fields for the [customized resource or data type](/../api/projects/types#list-of-customizable-data-types).
    fields: typing.Optional["FieldContainer"]

    def __init__(
        self,
        *,
        type: "TypeResourceIdentifier",
        fields: typing.Optional["FieldContainer"] = None
    ):
        self.type = type
        self.fields = fields

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CustomFieldsDraft":
        from ._schemas.type import CustomFieldsDraftSchema

        return CustomFieldsDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.type import CustomFieldsDraftSchema

        return CustomFieldsDraftSchema().dump(self)


class FieldContainer(typing.Dict[str, typing.Any]):
    pass


class FieldDefinition(_BaseType):
    """Defines a [Custom Field](/../api/projects/custom-fields) and its meta-information.
    This FieldDefinition is similar to an [AttributeDefinition](ctp:api:type:AttributeDefinition) of [Product Types](/../api/projects/productTypes).

    """

    #: Data type of the Custom Field to define.
    type: "FieldType"
    #: Name of the Custom Field to define.
    #: Must be unique for a given [ResourceTypeId](ctp:api:type:ResourceTypeId).
    #: In case there is a FieldDefinition with the same `name` in another [Type](ctp:api:type:Type), both FieldDefinitions must have the same `type`.
    name: str
    #: A human-readable label for the field.
    label: "LocalizedString"
    #: Defines whether the field is required to have a value.
    required: bool
    #: Defines the visual representation of the field in user interfaces like the Merchant Center.
    #: It is only relevant for string-based [FieldTypes](ctp:api:type:FieldType) like [CustomFieldStringType](ctp:api:type:CustomFieldStringType) and [CustomFieldLocalizedStringType](ctp:api:type:CustomFieldLocalizedStringType).
    input_hint: typing.Optional["TypeTextInputHint"]

    def __init__(
        self,
        *,
        type: "FieldType",
        name: str,
        label: "LocalizedString",
        required: bool,
        input_hint: typing.Optional["TypeTextInputHint"] = None
    ):
        self.type = type
        self.name = name
        self.label = label
        self.required = required
        self.input_hint = input_hint

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "FieldDefinition":
        from ._schemas.type import FieldDefinitionSchema

        return FieldDefinitionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.type import FieldDefinitionSchema

        return FieldDefinitionSchema().dump(self)


class FieldType(_BaseType):
    name: str

    def __init__(self, *, name: str):
        self.name = name

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "FieldType":
        if data["name"] == "Boolean":
            from ._schemas.type import CustomFieldBooleanTypeSchema

            return CustomFieldBooleanTypeSchema().load(data)
        if data["name"] == "DateTime":
            from ._schemas.type import CustomFieldDateTimeTypeSchema

            return CustomFieldDateTimeTypeSchema().load(data)
        if data["name"] == "Date":
            from ._schemas.type import CustomFieldDateTypeSchema

            return CustomFieldDateTypeSchema().load(data)
        if data["name"] == "Enum":
            from ._schemas.type import CustomFieldEnumTypeSchema

            return CustomFieldEnumTypeSchema().load(data)
        if data["name"] == "LocalizedEnum":
            from ._schemas.type import CustomFieldLocalizedEnumTypeSchema

            return CustomFieldLocalizedEnumTypeSchema().load(data)
        if data["name"] == "LocalizedString":
            from ._schemas.type import CustomFieldLocalizedStringTypeSchema

            return CustomFieldLocalizedStringTypeSchema().load(data)
        if data["name"] == "Money":
            from ._schemas.type import CustomFieldMoneyTypeSchema

            return CustomFieldMoneyTypeSchema().load(data)
        if data["name"] == "Number":
            from ._schemas.type import CustomFieldNumberTypeSchema

            return CustomFieldNumberTypeSchema().load(data)
        if data["name"] == "Reference":
            from ._schemas.type import CustomFieldReferenceTypeSchema

            return CustomFieldReferenceTypeSchema().load(data)
        if data["name"] == "Set":
            from ._schemas.type import CustomFieldSetTypeSchema

            return CustomFieldSetTypeSchema().load(data)
        if data["name"] == "String":
            from ._schemas.type import CustomFieldStringTypeSchema

            return CustomFieldStringTypeSchema().load(data)
        if data["name"] == "Time":
            from ._schemas.type import CustomFieldTimeTypeSchema

            return CustomFieldTimeTypeSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.type import FieldTypeSchema

        return FieldTypeSchema().dump(self)


class CustomFieldBooleanType(FieldType):
    """Field type for Boolean values."""

    def __init__(self):

        super().__init__(name="Boolean")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CustomFieldBooleanType":
        from ._schemas.type import CustomFieldBooleanTypeSchema

        return CustomFieldBooleanTypeSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.type import CustomFieldBooleanTypeSchema

        return CustomFieldBooleanTypeSchema().dump(self)


class CustomFieldDateTimeType(FieldType):
    """Field type for [DateTime](ctp:api:type:DateTime) values."""

    def __init__(self):

        super().__init__(name="DateTime")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CustomFieldDateTimeType":
        from ._schemas.type import CustomFieldDateTimeTypeSchema

        return CustomFieldDateTimeTypeSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.type import CustomFieldDateTimeTypeSchema

        return CustomFieldDateTimeTypeSchema().dump(self)


class CustomFieldDateType(FieldType):
    """Field type for [Date](ctp:api:type:Date) values."""

    def __init__(self):

        super().__init__(name="Date")

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CustomFieldDateType":
        from ._schemas.type import CustomFieldDateTypeSchema

        return CustomFieldDateTypeSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.type import CustomFieldDateTypeSchema

        return CustomFieldDateTypeSchema().dump(self)


class CustomFieldEnumType(FieldType):
    """Field type for enum values."""

    #: Allowed values.
    values: typing.List["CustomFieldEnumValue"]

    def __init__(self, *, values: typing.List["CustomFieldEnumValue"]):
        self.values = values

        super().__init__(name="Enum")

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CustomFieldEnumType":
        from ._schemas.type import CustomFieldEnumTypeSchema

        return CustomFieldEnumTypeSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.type import CustomFieldEnumTypeSchema

        return CustomFieldEnumTypeSchema().dump(self)


class CustomFieldLocalizedEnumType(FieldType):
    """Field type for localized enum values."""

    #: Allowed values.
    values: typing.List["CustomFieldLocalizedEnumValue"]

    def __init__(self, *, values: typing.List["CustomFieldLocalizedEnumValue"]):
        self.values = values

        super().__init__(name="LocalizedEnum")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CustomFieldLocalizedEnumType":
        from ._schemas.type import CustomFieldLocalizedEnumTypeSchema

        return CustomFieldLocalizedEnumTypeSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.type import CustomFieldLocalizedEnumTypeSchema

        return CustomFieldLocalizedEnumTypeSchema().dump(self)


class CustomFieldLocalizedStringType(FieldType):
    """Field type for [LocalizedString](ctp:api:type:LocalizedString) values."""

    def __init__(self):

        super().__init__(name="LocalizedString")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CustomFieldLocalizedStringType":
        from ._schemas.type import CustomFieldLocalizedStringTypeSchema

        return CustomFieldLocalizedStringTypeSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.type import CustomFieldLocalizedStringTypeSchema

        return CustomFieldLocalizedStringTypeSchema().dump(self)


class CustomFieldMoneyType(FieldType):
    """Field type for [CentPrecisionMoney](ctp:api:type:CentPrecisionMoney) values."""

    def __init__(self):

        super().__init__(name="Money")

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CustomFieldMoneyType":
        from ._schemas.type import CustomFieldMoneyTypeSchema

        return CustomFieldMoneyTypeSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.type import CustomFieldMoneyTypeSchema

        return CustomFieldMoneyTypeSchema().dump(self)


class CustomFieldNumberType(FieldType):
    """Field type for number values."""

    def __init__(self):

        super().__init__(name="Number")

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CustomFieldNumberType":
        from ._schemas.type import CustomFieldNumberTypeSchema

        return CustomFieldNumberTypeSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.type import CustomFieldNumberTypeSchema

        return CustomFieldNumberTypeSchema().dump(self)


class CustomFieldReferenceType(FieldType):
    """Field type for [Reference](ctp:api:type:Reference) values."""

    #: Resource type the Custom Field can reference.
    reference_type_id: "CustomFieldReferenceValue"

    def __init__(self, *, reference_type_id: "CustomFieldReferenceValue"):
        self.reference_type_id = reference_type_id

        super().__init__(name="Reference")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "CustomFieldReferenceType":
        from ._schemas.type import CustomFieldReferenceTypeSchema

        return CustomFieldReferenceTypeSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.type import CustomFieldReferenceTypeSchema

        return CustomFieldReferenceTypeSchema().dump(self)


class CustomFieldSetType(FieldType):
    """Values of a SetType Custom Field are sets of values of the specified `elementType` (without duplicate elements)."""

    #: Field type of the elements in the set.
    element_type: "FieldType"

    def __init__(self, *, element_type: "FieldType"):
        self.element_type = element_type

        super().__init__(name="Set")

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CustomFieldSetType":
        from ._schemas.type import CustomFieldSetTypeSchema

        return CustomFieldSetTypeSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.type import CustomFieldSetTypeSchema

        return CustomFieldSetTypeSchema().dump(self)


class CustomFieldStringType(FieldType):
    """Field type for string values."""

    def __init__(self):

        super().__init__(name="String")

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CustomFieldStringType":
        from ._schemas.type import CustomFieldStringTypeSchema

        return CustomFieldStringTypeSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.type import CustomFieldStringTypeSchema

        return CustomFieldStringTypeSchema().dump(self)


class CustomFieldTimeType(FieldType):
    """Field type for [Time](ctp:api:type:Time) values."""

    def __init__(self):

        super().__init__(name="Time")

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "CustomFieldTimeType":
        from ._schemas.type import CustomFieldTimeTypeSchema

        return CustomFieldTimeTypeSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.type import CustomFieldTimeTypeSchema

        return CustomFieldTimeTypeSchema().dump(self)


class ResourceTypeId(enum.Enum):
    """IDs indicating the [customizable resources and data types](/../api/projects/types#list-of-customizable-data-types)."""

    ADDRESS = "address"
    ASSET = "asset"
    APPROVAL_FLOW = "approval-flow"
    ASSOCIATE_ROLE = "associate-role"
    BUSINESS_UNIT = "business-unit"
    CART_DISCOUNT = "cart-discount"
    CATEGORY = "category"
    CHANNEL = "channel"
    CUSTOMER = "customer"
    CUSTOMER_GROUP = "customer-group"
    CUSTOM_LINE_ITEM = "custom-line-item"
    DISCOUNT_CODE = "discount-code"
    INVENTORY_ENTRY = "inventory-entry"
    LINE_ITEM = "line-item"
    ORDER = "order"
    ORDER_EDIT = "order-edit"
    ORDER_DELIVERY = "order-delivery"
    ORDER_PARCEL = "order-parcel"
    ORDER_RETURN_ITEM = "order-return-item"
    PAYMENT = "payment"
    PAYMENT_INTERFACE_INTERACTION = "payment-interface-interaction"
    PRODUCT_PRICE = "product-price"
    PRODUCT_SELECTION = "product-selection"
    QUOTE = "quote"
    REVIEW = "review"
    SHIPPING = "shipping"
    SHIPPING_METHOD = "shipping-method"
    SHOPPING_LIST = "shopping-list"
    SHOPPING_LIST_TEXT_LINE_ITEM = "shopping-list-text-line-item"
    STANDALONE_PRICE = "standalone-price"
    STORE = "store"
    TRANSACTION = "transaction"


class Type(BaseResource):
    #: Present on resources created after 1 February 2019 except for [events not tracked](/../api/general-concepts#events-tracked).
    last_modified_by: typing.Optional["LastModifiedBy"]
    #: Present on resources created after 1 February 2019 except for [events not tracked](/../api/general-concepts#events-tracked).
    created_by: typing.Optional["CreatedBy"]
    #: User-defined unique identifier of the Type.
    key: str
    #: Name of the Type.
    name: "LocalizedString"
    #: Description of the Type.
    description: typing.Optional["LocalizedString"]
    #: Resources and/or data types for which the Type is defined.
    resource_type_ids: typing.List["ResourceTypeId"]
    #: Defines Custom Fields.
    field_definitions: typing.List["FieldDefinition"]

    def __init__(
        self,
        *,
        id: str,
        version: int,
        created_at: datetime.datetime,
        last_modified_at: datetime.datetime,
        last_modified_by: typing.Optional["LastModifiedBy"] = None,
        created_by: typing.Optional["CreatedBy"] = None,
        key: str,
        name: "LocalizedString",
        description: typing.Optional["LocalizedString"] = None,
        resource_type_ids: typing.List["ResourceTypeId"],
        field_definitions: typing.List["FieldDefinition"]
    ):
        self.last_modified_by = last_modified_by
        self.created_by = created_by
        self.key = key
        self.name = name
        self.description = description
        self.resource_type_ids = resource_type_ids
        self.field_definitions = field_definitions

        super().__init__(
            id=id,
            version=version,
            created_at=created_at,
            last_modified_at=last_modified_at,
        )

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "Type":
        from ._schemas.type import TypeSchema

        return TypeSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.type import TypeSchema

        return TypeSchema().dump(self)


class TypeDraft(_BaseType):
    #: User-defined unique identifier for the Type.
    key: str
    #: Name of the Type.
    name: "LocalizedString"
    #: Description of the Type.
    description: typing.Optional["LocalizedString"]
    #: Resources and/or data types for which the Type is defined.
    resource_type_ids: typing.List["ResourceTypeId"]
    #: Defines Custom Fields.
    field_definitions: typing.Optional[typing.List["FieldDefinition"]]

    def __init__(
        self,
        *,
        key: str,
        name: "LocalizedString",
        description: typing.Optional["LocalizedString"] = None,
        resource_type_ids: typing.List["ResourceTypeId"],
        field_definitions: typing.Optional[typing.List["FieldDefinition"]] = None
    ):
        self.key = key
        self.name = name
        self.description = description
        self.resource_type_ids = resource_type_ids
        self.field_definitions = field_definitions

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "TypeDraft":
        from ._schemas.type import TypeDraftSchema

        return TypeDraftSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.type import TypeDraftSchema

        return TypeDraftSchema().dump(self)


class TypePagedQueryResponse(_BaseType):
    """[PagedQueryResult](/../api/general-concepts#pagedqueryresult) with `results` containing an array of [Types](ctp:api:type:Type)."""

    #: Number of [results requested](/../api/general-concepts#limit).
    limit: int
    #: Number of [elements skipped](/../api/general-concepts#offset).
    offset: int
    #: Actual number of results returned.
    count: int
    #: Total number of results matching the query.
    #: This number is an estimation that is not [strongly consistent](/../api/general-concepts#strong-consistency).
    #: This field is returned by default.
    #: For improved performance, calculating this field can be deactivated by using the query parameter `withTotal=false`.
    #: When the results are filtered with a [Query Predicate](ctp:api:type:QueryPredicate), `total` is subject to a [limit](/../api/limits#queries).
    total: typing.Optional[int]
    #: [Types](ctp:api:type:Type) matching the query.
    results: typing.List["Type"]

    def __init__(
        self,
        *,
        limit: int,
        offset: int,
        count: int,
        total: typing.Optional[int] = None,
        results: typing.List["Type"]
    ):
        self.limit = limit
        self.offset = offset
        self.count = count
        self.total = total
        self.results = results

        super().__init__()

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "TypePagedQueryResponse":
        from ._schemas.type import TypePagedQueryResponseSchema

        return TypePagedQueryResponseSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.type import TypePagedQueryResponseSchema

        return TypePagedQueryResponseSchema().dump(self)


class TypeReference(Reference):
    """[Reference](ctp:api:type:Reference) to a [Type](ctp:api:type:Type)."""

    #: Contains the representation of the expanded Type.
    #: Only present in responses to requests with [Reference Expansion](ctp:api:type:Expansion) for Types.
    obj: typing.Optional["Type"]

    def __init__(self, *, id: str, obj: typing.Optional["Type"] = None):
        self.obj = obj

        super().__init__(id=id, type_id=ReferenceTypeId.TYPE)

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "TypeReference":
        from ._schemas.type import TypeReferenceSchema

        return TypeReferenceSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.type import TypeReferenceSchema

        return TypeReferenceSchema().dump(self)


class TypeResourceIdentifier(ResourceIdentifier):
    """[ResourceIdentifier](ctp:api:type:ResourceIdentifier) of a [Type](ctp:api:type:Type). Either `id` or `key` is required. If both are set, an [InvalidJsonInput](/../api/errors#invalidjsoninput) error is returned."""

    def __init__(
        self, *, id: typing.Optional[str] = None, key: typing.Optional[str] = None
    ):

        super().__init__(id=id, key=key, type_id=ReferenceTypeId.TYPE)

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "TypeResourceIdentifier":
        from ._schemas.type import TypeResourceIdentifierSchema

        return TypeResourceIdentifierSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.type import TypeResourceIdentifierSchema

        return TypeResourceIdentifierSchema().dump(self)


class TypeTextInputHint(enum.Enum):
    """Provides a visual representation type for this field. It is only relevant for string-based field types like [CustomFieldStringType](ctp:api:type:CustomFieldStringType) and [CustomFieldLocalizedStringType](ctp:api:type:CustomFieldLocalizedStringType). Following values are supported:"""

    SINGLE_LINE = "SingleLine"
    MULTI_LINE = "MultiLine"


class TypeUpdate(_BaseType):
    #: Expected version of the type on which the changes should be applied.
    #: If the expected version does not match the actual version, a [ConcurrentModification](ctp:api:type:ConcurrentModificationError) error will be returned.
    version: int
    #: Update actions to be performed on the Type.
    actions: typing.List["TypeUpdateAction"]

    def __init__(self, *, version: int, actions: typing.List["TypeUpdateAction"]):
        self.version = version
        self.actions = actions

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "TypeUpdate":
        from ._schemas.type import TypeUpdateSchema

        return TypeUpdateSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.type import TypeUpdateSchema

        return TypeUpdateSchema().dump(self)


class TypeUpdateAction(_BaseType):
    action: str

    def __init__(self, *, action: str):
        self.action = action

        super().__init__()

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "TypeUpdateAction":
        if data["action"] == "addEnumValue":
            from ._schemas.type import TypeAddEnumValueActionSchema

            return TypeAddEnumValueActionSchema().load(data)
        if data["action"] == "addFieldDefinition":
            from ._schemas.type import TypeAddFieldDefinitionActionSchema

            return TypeAddFieldDefinitionActionSchema().load(data)
        if data["action"] == "addLocalizedEnumValue":
            from ._schemas.type import TypeAddLocalizedEnumValueActionSchema

            return TypeAddLocalizedEnumValueActionSchema().load(data)
        if data["action"] == "changeEnumValueLabel":
            from ._schemas.type import TypeChangeEnumValueLabelActionSchema

            return TypeChangeEnumValueLabelActionSchema().load(data)
        if data["action"] == "changeEnumValueOrder":
            from ._schemas.type import TypeChangeEnumValueOrderActionSchema

            return TypeChangeEnumValueOrderActionSchema().load(data)
        if data["action"] == "changeFieldDefinitionLabel":
            from ._schemas.type import TypeChangeFieldDefinitionLabelActionSchema

            return TypeChangeFieldDefinitionLabelActionSchema().load(data)
        if data["action"] == "changeFieldDefinitionOrder":
            from ._schemas.type import TypeChangeFieldDefinitionOrderActionSchema

            return TypeChangeFieldDefinitionOrderActionSchema().load(data)
        if data["action"] == "changeInputHint":
            from ._schemas.type import TypeChangeInputHintActionSchema

            return TypeChangeInputHintActionSchema().load(data)
        if data["action"] == "changeKey":
            from ._schemas.type import TypeChangeKeyActionSchema

            return TypeChangeKeyActionSchema().load(data)
        if data["action"] == "changeLabel":
            from ._schemas.type import TypeChangeLabelActionSchema

            return TypeChangeLabelActionSchema().load(data)
        if data["action"] == "changeLocalizedEnumValueLabel":
            from ._schemas.type import TypeChangeLocalizedEnumValueLabelActionSchema

            return TypeChangeLocalizedEnumValueLabelActionSchema().load(data)
        if data["action"] == "changeLocalizedEnumValueOrder":
            from ._schemas.type import TypeChangeLocalizedEnumValueOrderActionSchema

            return TypeChangeLocalizedEnumValueOrderActionSchema().load(data)
        if data["action"] == "changeName":
            from ._schemas.type import TypeChangeNameActionSchema

            return TypeChangeNameActionSchema().load(data)
        if data["action"] == "removeFieldDefinition":
            from ._schemas.type import TypeRemoveFieldDefinitionActionSchema

            return TypeRemoveFieldDefinitionActionSchema().load(data)
        if data["action"] == "setDescription":
            from ._schemas.type import TypeSetDescriptionActionSchema

            return TypeSetDescriptionActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.type import TypeUpdateActionSchema

        return TypeUpdateActionSchema().dump(self)


class TypeAddEnumValueAction(TypeUpdateAction):
    """Adds a value to an [EnumType](ctp:api:type:CustomFieldEnumType).
    This update action can be used to update an [EnumType](ctp:api:type:CustomFieldEnumType) FieldDefinition and a [SetType](ctp:api:type:CustomFieldSetType) FieldDefinition of [EnumType](ctp:api:type:CustomFieldEnumType).

    """

    #: `name` of the [Field Definition](ctp:api:type:FieldDefinition) to update.
    field_name: str
    #: Value to append to the array.
    value: "CustomFieldEnumValue"

    def __init__(self, *, field_name: str, value: "CustomFieldEnumValue"):
        self.field_name = field_name
        self.value = value

        super().__init__(action="addEnumValue")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "TypeAddEnumValueAction":
        from ._schemas.type import TypeAddEnumValueActionSchema

        return TypeAddEnumValueActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.type import TypeAddEnumValueActionSchema

        return TypeAddEnumValueActionSchema().dump(self)


class TypeAddFieldDefinitionAction(TypeUpdateAction):
    """Defines a new field for a Type. Adding new required fields to a Type that is already referenced by existing entities can put those entities in a temporarily inconsistent state.

    If a Type that is already in use requires new fields, we recommend making them optional (`required` set to `false`) whenever possible. Alternatively, any new required fields should be added one at a time followed by an update to all the resources using the Type. This prevents validation errors caused by an entity missing more than one required custom field.

    """

    #: Value to append to the array.
    field_definition: "FieldDefinition"

    def __init__(self, *, field_definition: "FieldDefinition"):
        self.field_definition = field_definition

        super().__init__(action="addFieldDefinition")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "TypeAddFieldDefinitionAction":
        from ._schemas.type import TypeAddFieldDefinitionActionSchema

        return TypeAddFieldDefinitionActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.type import TypeAddFieldDefinitionActionSchema

        return TypeAddFieldDefinitionActionSchema().dump(self)


class TypeAddLocalizedEnumValueAction(TypeUpdateAction):
    """Adds a value to a [LocalizedEnumType](ctp:api:type:CustomFieldLocalizedEnumType).
    This update action can be used to update a [LocalizedEnumType](ctp:api:type:CustomFieldLocalizedEnumType) FieldDefinition and a [SetType](ctp:api:type:CustomFieldSetType) FieldDefinition of [CustomFieldLocalizedEnumType](ctp:api:type:CustomFieldLocalizedEnumType).

    """

    #: `name` of the [FieldDefinition](ctp:api:type:FieldDefinition) to update.
    field_name: str
    #: Value to append to the array.
    value: "CustomFieldLocalizedEnumValue"

    def __init__(self, *, field_name: str, value: "CustomFieldLocalizedEnumValue"):
        self.field_name = field_name
        self.value = value

        super().__init__(action="addLocalizedEnumValue")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "TypeAddLocalizedEnumValueAction":
        from ._schemas.type import TypeAddLocalizedEnumValueActionSchema

        return TypeAddLocalizedEnumValueActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.type import TypeAddLocalizedEnumValueActionSchema

        return TypeAddLocalizedEnumValueActionSchema().dump(self)


class TypeChangeEnumValueLabelAction(TypeUpdateAction):
    """Changes the `label` of an [EnumValue](ctp:api:type:CustomFieldEnumValue) of an [EnumType](ctp:api:type:CustomFieldEnumType) FieldDefinition."""

    #: `name` of the [FieldDefinition](ctp:api:type:FieldDefinition) to update.
    field_name: str
    #: New value to set.
    #: Must not be empty.
    value: "CustomFieldEnumValue"

    def __init__(self, *, field_name: str, value: "CustomFieldEnumValue"):
        self.field_name = field_name
        self.value = value

        super().__init__(action="changeEnumValueLabel")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "TypeChangeEnumValueLabelAction":
        from ._schemas.type import TypeChangeEnumValueLabelActionSchema

        return TypeChangeEnumValueLabelActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.type import TypeChangeEnumValueLabelActionSchema

        return TypeChangeEnumValueLabelActionSchema().dump(self)


class TypeChangeEnumValueOrderAction(TypeUpdateAction):
    """Changes the order of [EnumValues](ctp:api:type:CustomFieldEnumValue) in an [EnumType](ctp:api:type:CustomFieldEnumType) FieldDefinition.
    This update action can be used to update an [EnumType](ctp:api:type:CustomFieldEnumType) FieldDefinition and a [SetType](ctp:api:type:CustomFieldSetType) FieldDefinition of [EnumType](ctp:api:type:CustomFieldEnumType).

    """

    #: `name` of the [FieldDefinition](ctp:api:type:FieldDefinition) to update.
    field_name: str
    #: Must match the set of `key`s of the EnumValues in the FieldDefinition (apart from their order).
    keys: typing.List["str"]

    def __init__(self, *, field_name: str, keys: typing.List["str"]):
        self.field_name = field_name
        self.keys = keys

        super().__init__(action="changeEnumValueOrder")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "TypeChangeEnumValueOrderAction":
        from ._schemas.type import TypeChangeEnumValueOrderActionSchema

        return TypeChangeEnumValueOrderActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.type import TypeChangeEnumValueOrderActionSchema

        return TypeChangeEnumValueOrderActionSchema().dump(self)


class TypeChangeFieldDefinitionLabelAction(TypeUpdateAction):
    #: `name` of the [FieldDefinition](ctp:api:type:FieldDefinition) to update.
    field_name: str
    #: New value to set.
    #: Must not be empty.
    label: "LocalizedString"

    def __init__(self, *, field_name: str, label: "LocalizedString"):
        self.field_name = field_name
        self.label = label

        super().__init__(action="changeFieldDefinitionLabel")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "TypeChangeFieldDefinitionLabelAction":
        from ._schemas.type import TypeChangeFieldDefinitionLabelActionSchema

        return TypeChangeFieldDefinitionLabelActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.type import TypeChangeFieldDefinitionLabelActionSchema

        return TypeChangeFieldDefinitionLabelActionSchema().dump(self)


class TypeChangeFieldDefinitionOrderAction(TypeUpdateAction):
    #: Must match the set of `name`s of FieldDefinitions (up to order).
    field_names: typing.List["str"]

    def __init__(self, *, field_names: typing.List["str"]):
        self.field_names = field_names

        super().__init__(action="changeFieldDefinitionOrder")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "TypeChangeFieldDefinitionOrderAction":
        from ._schemas.type import TypeChangeFieldDefinitionOrderActionSchema

        return TypeChangeFieldDefinitionOrderActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.type import TypeChangeFieldDefinitionOrderActionSchema

        return TypeChangeFieldDefinitionOrderActionSchema().dump(self)


class TypeChangeInputHintAction(TypeUpdateAction):
    """Changes the `inputHint` of [CustomFieldStringType](ctp:api:type:CustomFieldStringType) [FieldDefinition](ctp:api:type:FieldDefinition), a [CustomFieldLocalizedStringType](ctp:api:type:CustomFieldLocalizedStringType) [FieldDefinition](ctp:api:type:FieldDefinition), and [CustomFieldSetType](ctp:api:type:CustomFieldSetType) [FieldDefinition](ctp:api:type:FieldDefinition) of these string-based FieldTypes."""

    #: `name` of the [Field Definition](ctp:api:type:FieldDefinition) to update.
    field_name: str
    #: New value to set.
    #: Must not be empty.
    input_hint: "TypeTextInputHint"

    def __init__(self, *, field_name: str, input_hint: "TypeTextInputHint"):
        self.field_name = field_name
        self.input_hint = input_hint

        super().__init__(action="changeInputHint")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "TypeChangeInputHintAction":
        from ._schemas.type import TypeChangeInputHintActionSchema

        return TypeChangeInputHintActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.type import TypeChangeInputHintActionSchema

        return TypeChangeInputHintActionSchema().dump(self)


class TypeChangeKeyAction(TypeUpdateAction):
    #: New value to set.
    #: Must not be empty.
    key: str

    def __init__(self, *, key: str):
        self.key = key

        super().__init__(action="changeKey")

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "TypeChangeKeyAction":
        from ._schemas.type import TypeChangeKeyActionSchema

        return TypeChangeKeyActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.type import TypeChangeKeyActionSchema

        return TypeChangeKeyActionSchema().dump(self)


class TypeChangeLabelAction(TypeUpdateAction):
    #: Name of the [Field Definition](ctp:api:type:FieldDefinition) to update.
    field_name: str
    #: JSON object where the keys are of type [Locale](ctp:api:type:Locale), and the values are the strings used for the corresponding language.
    label: "LocalizedString"

    def __init__(self, *, field_name: str, label: "LocalizedString"):
        self.field_name = field_name
        self.label = label

        super().__init__(action="changeLabel")

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "TypeChangeLabelAction":
        from ._schemas.type import TypeChangeLabelActionSchema

        return TypeChangeLabelActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.type import TypeChangeLabelActionSchema

        return TypeChangeLabelActionSchema().dump(self)


class TypeChangeLocalizedEnumValueLabelAction(TypeUpdateAction):
    """Changes the `label` of a [LocalizedEnumValue](ctp:api:type:CustomFieldLocalizedEnumValue) of a [LocalizedEnumType](ctp:api:type:CustomFieldLocalizedEnumType) FieldDefinition."""

    #: `name` of the [FieldDefinition](ctp:api:type:FieldDefinition) to update.
    field_name: str
    #: New value to set.
    #: Must not be empty.
    value: "CustomFieldLocalizedEnumValue"

    def __init__(self, *, field_name: str, value: "CustomFieldLocalizedEnumValue"):
        self.field_name = field_name
        self.value = value

        super().__init__(action="changeLocalizedEnumValueLabel")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "TypeChangeLocalizedEnumValueLabelAction":
        from ._schemas.type import TypeChangeLocalizedEnumValueLabelActionSchema

        return TypeChangeLocalizedEnumValueLabelActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.type import TypeChangeLocalizedEnumValueLabelActionSchema

        return TypeChangeLocalizedEnumValueLabelActionSchema().dump(self)


class TypeChangeLocalizedEnumValueOrderAction(TypeUpdateAction):
    """Changes the order of [LocalizedEnumValues](ctp:api:type:CustomFieldLocalizedEnumValue) in a [LocalizedEnumType](ctp:api:type:CustomFieldLocalizedEnumType) FieldDefinition.
    This update action can be used to update a [LocalizedEnumType](ctp:api:type:CustomFieldLocalizedEnumType) FieldDefinition and a [SetType](ctp:api:type:CustomFieldSetType) of [LocalizedEnumType](ctp:api:type:CustomFieldLocalizedEnumType) FieldDefinitions.

    """

    #: `name` of the [Field Definition](ctp:api:type:FieldDefinition) to update.
    field_name: str
    #: Must match the set of `key`s of the LocalizedEnumValues in the FieldDefinition (up to order).
    keys: typing.List["str"]

    def __init__(self, *, field_name: str, keys: typing.List["str"]):
        self.field_name = field_name
        self.keys = keys

        super().__init__(action="changeLocalizedEnumValueOrder")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "TypeChangeLocalizedEnumValueOrderAction":
        from ._schemas.type import TypeChangeLocalizedEnumValueOrderActionSchema

        return TypeChangeLocalizedEnumValueOrderActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.type import TypeChangeLocalizedEnumValueOrderActionSchema

        return TypeChangeLocalizedEnumValueOrderActionSchema().dump(self)


class TypeChangeNameAction(TypeUpdateAction):
    #: New value to set.
    #: Must not be empty.
    name: "LocalizedString"

    def __init__(self, *, name: "LocalizedString"):
        self.name = name

        super().__init__(action="changeName")

    @classmethod
    def deserialize(cls, data: typing.Dict[str, typing.Any]) -> "TypeChangeNameAction":
        from ._schemas.type import TypeChangeNameActionSchema

        return TypeChangeNameActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.type import TypeChangeNameActionSchema

        return TypeChangeNameActionSchema().dump(self)


class TypeRemoveFieldDefinitionAction(TypeUpdateAction):
    #: `name` of the [FieldDefinition](ctp:api:type:FieldDefinition) to remove.
    #: The removal of a FieldDefinition deletes [asynchronously](/../api/general-concepts#eventual-consistency) all Custom Fields using the FieldDefinition as well.
    field_name: str

    def __init__(self, *, field_name: str):
        self.field_name = field_name

        super().__init__(action="removeFieldDefinition")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "TypeRemoveFieldDefinitionAction":
        from ._schemas.type import TypeRemoveFieldDefinitionActionSchema

        return TypeRemoveFieldDefinitionActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.type import TypeRemoveFieldDefinitionActionSchema

        return TypeRemoveFieldDefinitionActionSchema().dump(self)


class TypeSetDescriptionAction(TypeUpdateAction):
    #: Value to set. If empty, any existing value will be removed.
    description: typing.Optional["LocalizedString"]

    def __init__(self, *, description: typing.Optional["LocalizedString"] = None):
        self.description = description

        super().__init__(action="setDescription")

    @classmethod
    def deserialize(
        cls, data: typing.Dict[str, typing.Any]
    ) -> "TypeSetDescriptionAction":
        from ._schemas.type import TypeSetDescriptionActionSchema

        return TypeSetDescriptionActionSchema().load(data)

    def serialize(self) -> typing.Dict[str, typing.Any]:
        from ._schemas.type import TypeSetDescriptionActionSchema

        return TypeSetDescriptionActionSchema().dump(self)
